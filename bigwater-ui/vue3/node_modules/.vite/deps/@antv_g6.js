import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@antv/util/esm/is-array-like.js
var isArrayLike, is_array_like_default;
var init_is_array_like = __esm({
  "node_modules/@antv/util/esm/is-array-like.js"() {
    isArrayLike = function(value) {
      return value !== null && typeof value !== "function" && isFinite(value.length);
    };
    is_array_like_default = isArrayLike;
  }
});

// node_modules/@antv/util/esm/contains.js
var contains, contains_default;
var init_contains = __esm({
  "node_modules/@antv/util/esm/contains.js"() {
    init_is_array_like();
    contains = function(arr, value) {
      if (!is_array_like_default(arr)) {
        return false;
      }
      return arr.indexOf(value) > -1;
    };
    contains_default = contains;
  }
});

// node_modules/@antv/util/esm/filter.js
var filter, filter_default;
var init_filter = __esm({
  "node_modules/@antv/util/esm/filter.js"() {
    init_is_array_like();
    filter = function(arr, func) {
      if (!is_array_like_default(arr)) {
        return arr;
      }
      var result = [];
      for (var index2 = 0; index2 < arr.length; index2++) {
        var value = arr[index2];
        if (func(value, index2)) {
          result.push(value);
        }
      }
      return result;
    };
    filter_default = filter;
  }
});

// node_modules/@antv/util/esm/difference.js
var difference, difference_default;
var init_difference = __esm({
  "node_modules/@antv/util/esm/difference.js"() {
    init_filter();
    init_contains();
    difference = function(arr, values3) {
      if (values3 === void 0) {
        values3 = [];
      }
      return filter_default(arr, function(value) {
        return !contains_default(values3, value);
      });
    };
    difference_default = difference;
  }
});

// node_modules/@antv/util/esm/is-type.js
var toString, isType, is_type_default;
var init_is_type = __esm({
  "node_modules/@antv/util/esm/is-type.js"() {
    toString = {}.toString;
    isType = function(value, type) {
      return toString.call(value) === "[object " + type + "]";
    };
    is_type_default = isType;
  }
});

// node_modules/@antv/util/esm/is-function.js
var is_function_default;
var init_is_function = __esm({
  "node_modules/@antv/util/esm/is-function.js"() {
    init_is_type();
    is_function_default = function(value) {
      return is_type_default(value, "Function");
    };
  }
});

// node_modules/@antv/util/esm/is-nil.js
var isNil, is_nil_default;
var init_is_nil = __esm({
  "node_modules/@antv/util/esm/is-nil.js"() {
    isNil = function(value) {
      return value === null || value === void 0;
    };
    is_nil_default = isNil;
  }
});

// node_modules/@antv/util/esm/is-array.js
var is_array_default;
var init_is_array = __esm({
  "node_modules/@antv/util/esm/is-array.js"() {
    init_is_type();
    is_array_default = function(value) {
      return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
    };
  }
});

// node_modules/@antv/util/esm/is-object.js
var is_object_default;
var init_is_object = __esm({
  "node_modules/@antv/util/esm/is-object.js"() {
    is_object_default = function(value) {
      var type = typeof value;
      return value !== null && type === "object" || type === "function";
    };
  }
});

// node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i2 = 0, len6 = elements.length; i2 < len6; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default;
var init_each = __esm({
  "node_modules/@antv/util/esm/each.js"() {
    init_is_array();
    init_is_object();
    each_default = each;
  }
});

// node_modules/@antv/util/esm/keys.js
var keys, keys_default;
var init_keys = __esm({
  "node_modules/@antv/util/esm/keys.js"() {
    init_each();
    init_is_function();
    keys = Object.keys ? function(obj) {
      return Object.keys(obj);
    } : function(obj) {
      var result = [];
      each_default(obj, function(value, key) {
        if (!(is_function_default(obj) && key === "prototype")) {
          result.push(key);
        }
      });
      return result;
    };
    keys_default = keys;
  }
});

// node_modules/@antv/util/esm/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length6 = _keys.length;
  if (is_nil_default(obj))
    return !length6;
  for (var i2 = 0; i2 < length6; i2 += 1) {
    var key = _keys[i2];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default;
var init_is_match = __esm({
  "node_modules/@antv/util/esm/is-match.js"() {
    init_is_nil();
    init_keys();
    is_match_default = isMatch;
  }
});

// node_modules/@antv/util/esm/is-object-like.js
var isObjectLike, is_object_like_default;
var init_is_object_like = __esm({
  "node_modules/@antv/util/esm/is-object-like.js"() {
    isObjectLike = function(value) {
      return typeof value === "object" && value !== null;
    };
    is_object_like_default = isObjectLike;
  }
});

// node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject, is_plain_object_default;
var init_is_plain_object = __esm({
  "node_modules/@antv/util/esm/is-plain-object.js"() {
    init_is_object_like();
    init_is_type();
    isPlainObject = function(value) {
      if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
        return false;
      }
      if (Object.getPrototypeOf(value) === null) {
        return true;
      }
      var proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    };
    is_plain_object_default = isPlainObject;
  }
});

// node_modules/@antv/util/esm/find.js
function find(arr, predicate) {
  if (!is_array_default(arr))
    return null;
  var _predicate;
  if (is_function_default(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default(predicate)) {
    _predicate = function(a3) {
      return is_match_default(a3, predicate);
    };
  }
  if (_predicate) {
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      if (_predicate(arr[i2])) {
        return arr[i2];
      }
    }
  }
  return null;
}
var find_default;
var init_find = __esm({
  "node_modules/@antv/util/esm/find.js"() {
    init_is_function();
    init_is_match();
    init_is_array();
    init_is_plain_object();
    find_default = find;
  }
});

// node_modules/@antv/util/esm/find-index.js
function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i2 = fromIndex; i2 < arr.length; i2++) {
    if (predicate(arr[i2], i2)) {
      return i2;
    }
  }
  return -1;
}
var find_index_default;
var init_find_index = __esm({
  "node_modules/@antv/util/esm/find-index.js"() {
    find_index_default = findIndex;
  }
});

// node_modules/@antv/util/esm/first-value.js
var firstValue, first_value_default;
var init_first_value = __esm({
  "node_modules/@antv/util/esm/first-value.js"() {
    init_is_nil();
    init_is_array();
    firstValue = function(data, name) {
      var rst = null;
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!is_nil_default(value)) {
          if (is_array_default(value)) {
            rst = value[0];
          } else {
            rst = value;
          }
          break;
        }
      }
      return rst;
    };
    first_value_default = firstValue;
  }
});

// node_modules/@antv/util/esm/flatten.js
var flatten, flatten_default;
var init_flatten = __esm({
  "node_modules/@antv/util/esm/flatten.js"() {
    init_is_array();
    flatten = function(arr) {
      if (!is_array_default(arr)) {
        return [];
      }
      var rst = [];
      for (var i2 = 0; i2 < arr.length; i2++) {
        rst = rst.concat(arr[i2]);
      }
      return rst;
    };
    flatten_default = flatten;
  }
});

// node_modules/@antv/util/esm/flatten-deep.js
var flattenDeep, flatten_deep_default;
var init_flatten_deep = __esm({
  "node_modules/@antv/util/esm/flatten-deep.js"() {
    init_is_array();
    flattenDeep = function(arr, result) {
      if (result === void 0) {
        result = [];
      }
      if (!is_array_default(arr)) {
        result.push(arr);
      } else {
        for (var i2 = 0; i2 < arr.length; i2 += 1) {
          flattenDeep(arr[i2], result);
        }
      }
      return result;
    };
    flatten_deep_default = flattenDeep;
  }
});

// node_modules/@antv/util/esm/max.js
var max_default;
var init_max = __esm({
  "node_modules/@antv/util/esm/max.js"() {
    init_is_array();
    max_default = function(arr) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      return arr.reduce(function(prev, curr) {
        return Math.max(prev, curr);
      }, arr[0]);
    };
  }
});

// node_modules/@antv/util/esm/min.js
var min_default;
var init_min = __esm({
  "node_modules/@antv/util/esm/min.js"() {
    init_is_array();
    min_default = function(arr) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      return arr.reduce(function(prev, curr) {
        return Math.min(prev, curr);
      }, arr[0]);
    };
  }
});

// node_modules/@antv/util/esm/get-range.js
var getRange, get_range_default;
var init_get_range = __esm({
  "node_modules/@antv/util/esm/get-range.js"() {
    init_is_array();
    init_max();
    init_min();
    getRange = function(values3) {
      var filterValues = values3.filter(function(v2) {
        return !isNaN(v2);
      });
      if (!filterValues.length) {
        return {
          min: 0,
          max: 0
        };
      }
      if (is_array_default(values3[0])) {
        var tmp = [];
        for (var i2 = 0; i2 < values3.length; i2++) {
          tmp = tmp.concat(values3[i2]);
        }
        filterValues = tmp;
      }
      var max8 = max_default(filterValues);
      var min6 = min_default(filterValues);
      return {
        min: min6,
        max: max8
      };
    };
    get_range_default = getRange;
  }
});

// node_modules/@antv/util/esm/pull.js
var arrPrototype, splice, indexOf, pull, pull_default;
var init_pull = __esm({
  "node_modules/@antv/util/esm/pull.js"() {
    arrPrototype = Array.prototype;
    splice = arrPrototype.splice;
    indexOf = arrPrototype.indexOf;
    pull = function(arr) {
      var values3 = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        values3[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < values3.length; i2++) {
        var value = values3[i2];
        var fromIndex = -1;
        while ((fromIndex = indexOf.call(arr, value)) > -1) {
          splice.call(arr, fromIndex, 1);
        }
      }
      return arr;
    };
    pull_default = pull;
  }
});

// node_modules/@antv/util/esm/pull-at.js
var splice2, pullAt, pull_at_default;
var init_pull_at = __esm({
  "node_modules/@antv/util/esm/pull-at.js"() {
    init_is_array_like();
    splice2 = Array.prototype.splice;
    pullAt = function pullAt2(arr, indexes) {
      if (!is_array_like_default(arr)) {
        return [];
      }
      var length6 = arr ? indexes.length : 0;
      var last3 = length6 - 1;
      while (length6--) {
        var previous = void 0;
        var index2 = indexes[length6];
        if (length6 === last3 || index2 !== previous) {
          previous = index2;
          splice2.call(arr, index2, 1);
        }
      }
      return arr;
    };
    pull_at_default = pullAt;
  }
});

// node_modules/@antv/util/esm/reduce.js
var reduce, reduce_default;
var init_reduce = __esm({
  "node_modules/@antv/util/esm/reduce.js"() {
    init_each();
    init_is_array();
    init_is_plain_object();
    reduce = function(arr, fn2, init) {
      if (!is_array_default(arr) && !is_plain_object_default(arr)) {
        return arr;
      }
      var result = init;
      each_default(arr, function(data, i2) {
        result = fn2(result, data, i2);
      });
      return result;
    };
    reduce_default = reduce;
  }
});

// node_modules/@antv/util/esm/remove.js
var remove, remove_default;
var init_remove = __esm({
  "node_modules/@antv/util/esm/remove.js"() {
    init_is_array_like();
    init_pull_at();
    remove = function(arr, predicate) {
      var result = [];
      if (!is_array_like_default(arr)) {
        return result;
      }
      var i2 = -1;
      var indexes = [];
      var length6 = arr.length;
      while (++i2 < length6) {
        var value = arr[i2];
        if (predicate(value, i2, arr)) {
          result.push(value);
          indexes.push(i2);
        }
      }
      pull_at_default(arr, indexes);
      return result;
    };
    remove_default = remove;
  }
});

// node_modules/@antv/util/esm/is-string.js
var is_string_default;
var init_is_string = __esm({
  "node_modules/@antv/util/esm/is-string.js"() {
    init_is_type();
    is_string_default = function(str10) {
      return is_type_default(str10, "String");
    };
  }
});

// node_modules/@antv/util/esm/sort-by.js
function sortBy(arr, key) {
  var comparer;
  if (is_function_default(key)) {
    comparer = function(a3, b10) {
      return key(a3) - key(b10);
    };
  } else {
    var keys_1 = [];
    if (is_string_default(key)) {
      keys_1.push(key);
    } else if (is_array_default(key)) {
      keys_1 = key;
    }
    comparer = function(a3, b10) {
      for (var i2 = 0; i2 < keys_1.length; i2 += 1) {
        var prop = keys_1[i2];
        if (a3[prop] > b10[prop]) {
          return 1;
        }
        if (a3[prop] < b10[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
var sort_by_default;
var init_sort_by = __esm({
  "node_modules/@antv/util/esm/sort-by.js"() {
    init_is_array();
    init_is_string();
    init_is_function();
    sort_by_default = sortBy;
  }
});

// node_modules/@antv/util/esm/uniq.js
function uniq(arr, cache3) {
  if (cache3 === void 0) {
    cache3 = /* @__PURE__ */ new Map();
  }
  var r2 = [];
  if (Array.isArray(arr)) {
    for (var i2 = 0, len6 = arr.length; i2 < len6; i2++) {
      var item = arr[i2];
      if (!cache3.has(item)) {
        r2.push(item);
        cache3.set(item, true);
      }
    }
  }
  return r2;
}
var init_uniq = __esm({
  "node_modules/@antv/util/esm/uniq.js"() {
  }
});

// node_modules/@antv/util/esm/union.js
var union, union_default;
var init_union = __esm({
  "node_modules/@antv/util/esm/union.js"() {
    init_uniq();
    union = function() {
      var sources = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        sources[_i2] = arguments[_i2];
      }
      return uniq([].concat.apply([], sources));
    };
    union_default = union;
  }
});

// node_modules/@antv/util/esm/values-of-key.js
var values_of_key_default;
var init_values_of_key = __esm({
  "node_modules/@antv/util/esm/values-of-key.js"() {
    init_is_array();
    init_is_nil();
    values_of_key_default = function(data, name) {
      var rst = [];
      var tmpMap = {};
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!is_nil_default(value)) {
          if (!is_array_default(value)) {
            value = [value];
          }
          for (var j2 = 0; j2 < value.length; j2++) {
            var val = value[j2];
            if (!tmpMap[val]) {
              rst.push(val);
              tmpMap[val] = true;
            }
          }
        }
      }
      return rst;
    };
  }
});

// node_modules/@antv/util/esm/head.js
function head(o2) {
  if (is_array_like_default(o2)) {
    return o2[0];
  }
  return void 0;
}
var init_head = __esm({
  "node_modules/@antv/util/esm/head.js"() {
    init_is_array_like();
  }
});

// node_modules/@antv/util/esm/last.js
function last(o2) {
  if (is_array_like_default(o2)) {
    var arr = o2;
    return arr[arr.length - 1];
  }
  return void 0;
}
var init_last = __esm({
  "node_modules/@antv/util/esm/last.js"() {
    init_is_array_like();
  }
});

// node_modules/@antv/util/esm/starts-with.js
function startsWith(arr, e8) {
  return is_array_default(arr) || is_string_default(arr) ? arr[0] === e8 : false;
}
var starts_with_default;
var init_starts_with = __esm({
  "node_modules/@antv/util/esm/starts-with.js"() {
    init_is_array();
    init_is_string();
    starts_with_default = startsWith;
  }
});

// node_modules/@antv/util/esm/ends-with.js
function endsWith(arr, e8) {
  return is_array_default(arr) || is_string_default(arr) ? arr[arr.length - 1] === e8 : false;
}
var ends_with_default;
var init_ends_with = __esm({
  "node_modules/@antv/util/esm/ends-with.js"() {
    init_is_array();
    init_is_string();
    ends_with_default = endsWith;
  }
});

// node_modules/@antv/util/esm/every.js
var every, every_default;
var init_every = __esm({
  "node_modules/@antv/util/esm/every.js"() {
    every = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (!func(arr[i2], i2))
          return false;
      }
      return true;
    };
    every_default = every;
  }
});

// node_modules/@antv/util/esm/some.js
var some, some_default;
var init_some = __esm({
  "node_modules/@antv/util/esm/some.js"() {
    some = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (func(arr[i2], i2))
          return true;
      }
      return false;
    };
    some_default = some;
  }
});

// node_modules/@antv/util/esm/group-by.js
function groupBy(data, condition) {
  if (!condition || !is_array_default(data)) {
    return {};
  }
  var result = {};
  var predicate = is_function_default(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i2 = 0; i2 < data.length; i2++) {
    var item = data[i2];
    key = predicate(item);
    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var hasOwnProperty, group_by_default;
var init_group_by = __esm({
  "node_modules/@antv/util/esm/group-by.js"() {
    init_is_array();
    init_is_function();
    hasOwnProperty = Object.prototype.hasOwnProperty;
    group_by_default = groupBy;
  }
});

// node_modules/@antv/util/esm/group-to-map.js
function groupToMap(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }
  if (!is_function_default(condition)) {
    var paramscondition_1 = is_array_default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i2 = 0, l2 = paramscondition_1.length; i2 < l2; i2++) {
        unique += row[paramscondition_1[i2]] && row[paramscondition_1[i2]].toString();
      }
      return unique;
    };
  }
  return group_by_default(data, condition);
}
var init_group_to_map = __esm({
  "node_modules/@antv/util/esm/group-to-map.js"() {
    init_is_array();
    init_is_function();
    init_group_by();
  }
});

// node_modules/@antv/util/esm/group.js
var group_default;
var init_group = __esm({
  "node_modules/@antv/util/esm/group.js"() {
    init_group_to_map();
    group_default = function(data, condition) {
      if (!condition) {
        return [data];
      }
      var groups = groupToMap(data, condition);
      var array = [];
      for (var i2 in groups) {
        array.push(groups[i2]);
      }
      return array;
    };
  }
});

// node_modules/@antv/util/esm/get-wrap-behavior.js
function getWrapBehavior(obj, action) {
  return obj["_wrap_" + action];
}
var get_wrap_behavior_default;
var init_get_wrap_behavior = __esm({
  "node_modules/@antv/util/esm/get-wrap-behavior.js"() {
    get_wrap_behavior_default = getWrapBehavior;
  }
});

// node_modules/@antv/util/esm/wrap-behavior.js
function wrapBehavior(obj, action) {
  if (obj["_wrap_" + action]) {
    return obj["_wrap_" + action];
  }
  var method = function(e8) {
    obj[action](e8);
  };
  obj["_wrap_" + action] = method;
  return method;
}
var wrap_behavior_default;
var init_wrap_behavior = __esm({
  "node_modules/@antv/util/esm/wrap-behavior.js"() {
    wrap_behavior_default = wrapBehavior;
  }
});

// node_modules/@antv/util/esm/number2color.js
function numberToColor(num) {
  var color3 = numColorCache[num];
  if (!color3) {
    var str10 = num.toString(16);
    for (var i2 = str10.length; i2 < 6; i2++) {
      str10 = "0" + str10;
    }
    color3 = "#" + str10;
    numColorCache[num] = color3;
  }
  return color3;
}
var numColorCache, number2color_default;
var init_number2color = __esm({
  "node_modules/@antv/util/esm/number2color.js"() {
    numColorCache = {};
    number2color_default = numberToColor;
  }
});

// node_modules/@antv/util/esm/parse-radius.js
function parseRadius(radius) {
  var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}
var parse_radius_default;
var init_parse_radius = __esm({
  "node_modules/@antv/util/esm/parse-radius.js"() {
    init_is_array();
    parse_radius_default = parseRadius;
  }
});

// node_modules/@antv/util/esm/clamp.js
var clamp, clamp_default;
var init_clamp = __esm({
  "node_modules/@antv/util/esm/clamp.js"() {
    clamp = function(a3, min6, max8) {
      if (a3 < min6) {
        return min6;
      } else if (a3 > max8) {
        return max8;
      }
      return a3;
    };
    clamp_default = clamp;
  }
});

// node_modules/@antv/util/esm/fixed-base.js
var fixedBase, fixed_base_default;
var init_fixed_base = __esm({
  "node_modules/@antv/util/esm/fixed-base.js"() {
    fixedBase = function(v2, base) {
      var str10 = base.toString();
      var index2 = str10.indexOf(".");
      if (index2 === -1) {
        return Math.round(v2);
      }
      var length6 = str10.substr(index2 + 1).length;
      if (length6 > 20) {
        length6 = 20;
      }
      return parseFloat(v2.toFixed(length6));
    };
    fixed_base_default = fixedBase;
  }
});

// node_modules/@antv/util/esm/is-number.js
var isNumber, is_number_default;
var init_is_number = __esm({
  "node_modules/@antv/util/esm/is-number.js"() {
    init_is_type();
    isNumber = function(value) {
      return is_type_default(value, "Number");
    };
    is_number_default = isNumber;
  }
});

// node_modules/@antv/util/esm/is-decimal.js
var isDecimal, is_decimal_default;
var init_is_decimal = __esm({
  "node_modules/@antv/util/esm/is-decimal.js"() {
    init_is_number();
    isDecimal = function(num) {
      return is_number_default(num) && num % 1 !== 0;
    };
    is_decimal_default = isDecimal;
  }
});

// node_modules/@antv/util/esm/is-even.js
var isEven, is_even_default;
var init_is_even = __esm({
  "node_modules/@antv/util/esm/is-even.js"() {
    init_is_number();
    isEven = function(num) {
      return is_number_default(num) && num % 2 === 0;
    };
    is_even_default = isEven;
  }
});

// node_modules/@antv/util/esm/is-integer.js
var isInteger, is_integer_default;
var init_is_integer = __esm({
  "node_modules/@antv/util/esm/is-integer.js"() {
    init_is_number();
    isInteger = Number.isInteger ? Number.isInteger : function(num) {
      return is_number_default(num) && num % 1 === 0;
    };
    is_integer_default = isInteger;
  }
});

// node_modules/@antv/util/esm/is-negative.js
var isNegative, is_negative_default;
var init_is_negative = __esm({
  "node_modules/@antv/util/esm/is-negative.js"() {
    init_is_number();
    isNegative = function(num) {
      return is_number_default(num) && num < 0;
    };
    is_negative_default = isNegative;
  }
});

// node_modules/@antv/util/esm/is-number-equal.js
function isNumberEqual(a3, b10, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a3 - b10) < precision;
}
var PRECISION;
var init_is_number_equal = __esm({
  "node_modules/@antv/util/esm/is-number-equal.js"() {
    PRECISION = 1e-5;
  }
});

// node_modules/@antv/util/esm/is-odd.js
var isOdd, is_odd_default;
var init_is_odd = __esm({
  "node_modules/@antv/util/esm/is-odd.js"() {
    init_is_number();
    isOdd = function(num) {
      return is_number_default(num) && num % 2 !== 0;
    };
    is_odd_default = isOdd;
  }
});

// node_modules/@antv/util/esm/is-positive.js
var isPositive, is_positive_default;
var init_is_positive = __esm({
  "node_modules/@antv/util/esm/is-positive.js"() {
    init_is_number();
    isPositive = function(num) {
      return is_number_default(num) && num > 0;
    };
    is_positive_default = isPositive;
  }
});

// node_modules/@antv/util/esm/max-by.js
var max_by_default;
var init_max_by = __esm({
  "node_modules/@antv/util/esm/max-by.js"() {
    init_is_array();
    init_is_function();
    max_by_default = function(arr, fn2) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      var maxItem;
      var max8 = -Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = is_function_default(fn2) ? fn2(item) : item[fn2];
        if (v2 > max8) {
          maxItem = item;
          max8 = v2;
        }
      }
      return maxItem;
    };
  }
});

// node_modules/@antv/util/esm/min-by.js
var min_by_default;
var init_min_by = __esm({
  "node_modules/@antv/util/esm/min-by.js"() {
    init_is_array();
    init_is_function();
    min_by_default = function(arr, fn2) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      var minItem;
      var min6 = Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = is_function_default(fn2) ? fn2(item) : item[fn2];
        if (v2 < min6) {
          minItem = item;
          min6 = v2;
        }
      }
      return minItem;
    };
  }
});

// node_modules/@antv/util/esm/mod.js
var mod, mod_default;
var init_mod = __esm({
  "node_modules/@antv/util/esm/mod.js"() {
    mod = function(n2, m3) {
      return (n2 % m3 + m3) % m3;
    };
    mod_default = mod;
  }
});

// node_modules/@antv/util/esm/to-degree.js
var DEGREE, toDegree, to_degree_default;
var init_to_degree = __esm({
  "node_modules/@antv/util/esm/to-degree.js"() {
    DEGREE = 180 / Math.PI;
    toDegree = function(radian2) {
      return DEGREE * radian2;
    };
    to_degree_default = toDegree;
  }
});

// node_modules/@antv/util/esm/to-integer.js
var to_integer_default;
var init_to_integer = __esm({
  "node_modules/@antv/util/esm/to-integer.js"() {
    to_integer_default = parseInt;
  }
});

// node_modules/@antv/util/esm/to-radian.js
var RADIAN, toRadian, to_radian_default;
var init_to_radian = __esm({
  "node_modules/@antv/util/esm/to-radian.js"() {
    RADIAN = Math.PI / 180;
    toRadian = function(degree4) {
      return RADIAN * degree4;
    };
    to_radian_default = toRadian;
  }
});

// node_modules/@antv/util/esm/for-in.js
var for_in_default;
var init_for_in = __esm({
  "node_modules/@antv/util/esm/for-in.js"() {
    init_each();
    for_in_default = each_default;
  }
});

// node_modules/@antv/util/esm/has.js
var has_default;
var init_has = __esm({
  "node_modules/@antv/util/esm/has.js"() {
    has_default = function(obj, key) {
      return obj.hasOwnProperty(key);
    };
  }
});

// node_modules/@antv/util/esm/has-key.js
var has_key_default;
var init_has_key = __esm({
  "node_modules/@antv/util/esm/has-key.js"() {
    init_has();
    has_key_default = has_default;
  }
});

// node_modules/@antv/util/esm/values.js
var values, values_default;
var init_values = __esm({
  "node_modules/@antv/util/esm/values.js"() {
    init_each();
    init_is_function();
    values = Object.values ? function(obj) {
      return Object.values(obj);
    } : function(obj) {
      var result = [];
      each_default(obj, function(value, key) {
        if (!(is_function_default(obj) && key === "prototype")) {
          result.push(value);
        }
      });
      return result;
    };
    values_default = values;
  }
});

// node_modules/@antv/util/esm/has-value.js
var has_value_default;
var init_has_value = __esm({
  "node_modules/@antv/util/esm/has-value.js"() {
    init_contains();
    init_values();
    has_value_default = function(obj, value) {
      return contains_default(values_default(obj), value);
    };
  }
});

// node_modules/@antv/util/esm/to-string.js
var to_string_default;
var init_to_string = __esm({
  "node_modules/@antv/util/esm/to-string.js"() {
    init_is_nil();
    to_string_default = function(value) {
      if (is_nil_default(value))
        return "";
      return value.toString();
    };
  }
});

// node_modules/@antv/util/esm/lower-case.js
var lowerCase, lower_case_default;
var init_lower_case = __esm({
  "node_modules/@antv/util/esm/lower-case.js"() {
    init_to_string();
    lowerCase = function(str10) {
      return to_string_default(str10).toLowerCase();
    };
    lower_case_default = lowerCase;
  }
});

// node_modules/@antv/util/esm/lower-first.js
var lowerFirst, lower_first_default;
var init_lower_first = __esm({
  "node_modules/@antv/util/esm/lower-first.js"() {
    init_to_string();
    lowerFirst = function(value) {
      var str10 = to_string_default(value);
      return str10.charAt(0).toLowerCase() + str10.substring(1);
    };
    lower_first_default = lowerFirst;
  }
});

// node_modules/@antv/util/esm/substitute.js
function substitute(str10, o2) {
  if (!str10 || !o2) {
    return str10;
  }
  return str10.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o2[name] === void 0 ? "" : o2[name];
  });
}
var substitute_default;
var init_substitute = __esm({
  "node_modules/@antv/util/esm/substitute.js"() {
    substitute_default = substitute;
  }
});

// node_modules/@antv/util/esm/upper-case.js
var upperCase, upper_case_default;
var init_upper_case = __esm({
  "node_modules/@antv/util/esm/upper-case.js"() {
    init_to_string();
    upperCase = function(str10) {
      return to_string_default(str10).toUpperCase();
    };
    upper_case_default = upperCase;
  }
});

// node_modules/@antv/util/esm/upper-first.js
var upperFirst, upper_first_default;
var init_upper_first = __esm({
  "node_modules/@antv/util/esm/upper-first.js"() {
    init_to_string();
    upperFirst = function(value) {
      var str10 = to_string_default(value);
      return str10.charAt(0).toUpperCase() + str10.substring(1);
    };
    upper_first_default = upperFirst;
  }
});

// node_modules/@antv/util/esm/get-type.js
var toString2, getType, get_type_default;
var init_get_type = __esm({
  "node_modules/@antv/util/esm/get-type.js"() {
    toString2 = {}.toString;
    getType = function(value) {
      return toString2.call(value).replace(/^\[object /, "").replace(/]$/, "");
    };
    get_type_default = getType;
  }
});

// node_modules/@antv/util/esm/is-arguments.js
var isArguments, is_arguments_default;
var init_is_arguments = __esm({
  "node_modules/@antv/util/esm/is-arguments.js"() {
    init_is_type();
    isArguments = function(value) {
      return is_type_default(value, "Arguments");
    };
    is_arguments_default = isArguments;
  }
});

// node_modules/@antv/util/esm/is-boolean.js
var isBoolean, is_boolean_default;
var init_is_boolean = __esm({
  "node_modules/@antv/util/esm/is-boolean.js"() {
    init_is_type();
    isBoolean = function(value) {
      return is_type_default(value, "Boolean");
    };
    is_boolean_default = isBoolean;
  }
});

// node_modules/@antv/util/esm/is-date.js
var isDate, is_date_default;
var init_is_date = __esm({
  "node_modules/@antv/util/esm/is-date.js"() {
    init_is_type();
    isDate = function(value) {
      return is_type_default(value, "Date");
    };
    is_date_default = isDate;
  }
});

// node_modules/@antv/util/esm/is-error.js
var isError, is_error_default;
var init_is_error = __esm({
  "node_modules/@antv/util/esm/is-error.js"() {
    init_is_type();
    isError = function(value) {
      return is_type_default(value, "Error");
    };
    is_error_default = isError;
  }
});

// node_modules/@antv/util/esm/is-finite.js
function is_finite_default(value) {
  return is_number_default(value) && isFinite(value);
}
var init_is_finite = __esm({
  "node_modules/@antv/util/esm/is-finite.js"() {
    init_is_number();
  }
});

// node_modules/@antv/util/esm/is-null.js
var isNull, is_null_default;
var init_is_null = __esm({
  "node_modules/@antv/util/esm/is-null.js"() {
    isNull = function(value) {
      return value === null;
    };
    is_null_default = isNull;
  }
});

// node_modules/@antv/util/esm/is-prototype.js
var objectProto, isPrototype, is_prototype_default;
var init_is_prototype = __esm({
  "node_modules/@antv/util/esm/is-prototype.js"() {
    objectProto = Object.prototype;
    isPrototype = function(value) {
      var Ctor = value && value.constructor;
      var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
      return value === proto;
    };
    is_prototype_default = isPrototype;
  }
});

// node_modules/@antv/util/esm/is-reg-exp.js
var isRegExp, is_reg_exp_default;
var init_is_reg_exp = __esm({
  "node_modules/@antv/util/esm/is-reg-exp.js"() {
    init_is_type();
    isRegExp = function(str10) {
      return is_type_default(str10, "RegExp");
    };
    is_reg_exp_default = isRegExp;
  }
});

// node_modules/@antv/util/esm/is-undefined.js
var isUndefined, is_undefined_default;
var init_is_undefined = __esm({
  "node_modules/@antv/util/esm/is-undefined.js"() {
    isUndefined = function(value) {
      return value === void 0;
    };
    is_undefined_default = isUndefined;
  }
});

// node_modules/@antv/util/esm/is-element.js
var isElement, is_element_default;
var init_is_element = __esm({
  "node_modules/@antv/util/esm/is-element.js"() {
    isElement = function(o2) {
      return o2 instanceof Element || o2 instanceof HTMLDocument;
    };
    is_element_default = isElement;
  }
});

// node_modules/@antv/util/esm/request-animation-frame.js
function requestAnimationFrame2(fn2) {
  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || // @ts-ignore
  window.mozRequestAnimationFrame || // @ts-ignore
  window.msRequestAnimationFrame || function(f2) {
    return setTimeout(f2, 16);
  };
  return method(fn2);
}
var init_request_animation_frame = __esm({
  "node_modules/@antv/util/esm/request-animation-frame.js"() {
  }
});

// node_modules/@antv/util/esm/clear-animation-frame.js
function cancelAnimationFrame2(handler) {
  var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || // @ts-ignore
  window.mozCancelAnimationFrame || // @ts-ignore
  window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}
var init_clear_animation_frame = __esm({
  "node_modules/@antv/util/esm/clear-animation-frame.js"() {
  }
});

// node_modules/@antv/util/esm/mix.js
function _mix(dist4, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist4[key] = obj[key];
    }
  }
}
function mix(dist4, src1, src2, src3) {
  if (src1)
    _mix(dist4, src1);
  if (src2)
    _mix(dist4, src2);
  if (src3)
    _mix(dist4, src3);
  return dist4;
}
var init_mix = __esm({
  "node_modules/@antv/util/esm/mix.js"() {
  }
});

// node_modules/@antv/util/esm/augment.js
var augment, augment_default;
var init_augment = __esm({
  "node_modules/@antv/util/esm/augment.js"() {
    init_mix();
    init_is_function();
    augment = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var c3 = args[0];
      for (var i2 = 1; i2 < args.length; i2++) {
        var obj = args[i2];
        if (is_function_default(obj)) {
          obj = obj.prototype;
        }
        mix(c3.prototype, obj);
      }
    };
    augment_default = augment;
  }
});

// node_modules/@antv/util/esm/clone.js
var clone, clone_default;
var init_clone = __esm({
  "node_modules/@antv/util/esm/clone.js"() {
    init_is_array();
    clone = function(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var rst;
      if (is_array_default(obj)) {
        rst = [];
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          if (typeof obj[i2] === "object" && obj[i2] != null) {
            rst[i2] = clone(obj[i2]);
          } else {
            rst[i2] = obj[i2];
          }
        }
      } else {
        rst = {};
        for (var k2 in obj) {
          if (typeof obj[k2] === "object" && obj[k2] != null) {
            rst[k2] = clone(obj[k2]);
          } else {
            rst[k2] = obj[k2];
          }
        }
      }
      return rst;
    };
    clone_default = clone;
  }
});

// node_modules/@antv/util/esm/debounce.js
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default;
var init_debounce = __esm({
  "node_modules/@antv/util/esm/debounce.js"() {
    debounce_default = debounce;
  }
});

// node_modules/@antv/util/esm/memoize.js
var memoize_default;
var init_memoize = __esm({
  "node_modules/@antv/util/esm/memoize.js"() {
    init_is_function();
    memoize_default = function(f2, resolver) {
      if (!is_function_default(f2)) {
        throw new TypeError("Expected a function");
      }
      var memoized = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        var key = resolver ? resolver.apply(this, args) : args[0];
        var cache3 = memoized.cache;
        if (cache3.has(key)) {
          return cache3.get(key);
        }
        var result = f2.apply(this, args);
        cache3.set(key, result);
        return result;
      };
      memoized.cache = /* @__PURE__ */ new Map();
      return memoized;
    };
  }
});

// node_modules/@antv/util/esm/deep-mix.js
function _deepMix(dist4, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value = src[key];
      if (value !== null && is_plain_object_default(value)) {
        if (!is_plain_object_default(dist4[key])) {
          dist4[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist4[key], value, level + 1, maxLevel);
        } else {
          dist4[key] = src[key];
        }
      } else if (is_array_default(value)) {
        dist4[key] = [];
        dist4[key] = dist4[key].concat(value);
      } else if (value !== void 0) {
        dist4[key] = value;
      }
    }
  }
}
var MAX_MIX_LEVEL, deepMix, deep_mix_default;
var init_deep_mix = __esm({
  "node_modules/@antv/util/esm/deep-mix.js"() {
    init_is_array();
    init_is_plain_object();
    MAX_MIX_LEVEL = 5;
    deepMix = function(rst) {
      var args = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        args[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < args.length; i2 += 1) {
        _deepMix(rst, args[i2]);
      }
      return rst;
    };
    deep_mix_default = deepMix;
  }
});

// node_modules/@antv/util/esm/extend.js
var extend, extend_default;
var init_extend = __esm({
  "node_modules/@antv/util/esm/extend.js"() {
    init_mix();
    init_is_function();
    extend = function(subclass, superclass, overrides, staticOverrides) {
      if (!is_function_default(superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = function() {
        };
      }
      var create10 = Object.create ? function(proto, c3) {
        return Object.create(proto, {
          constructor: {
            value: c3
          }
        });
      } : function(proto, c3) {
        function Tmp() {
        }
        Tmp.prototype = proto;
        var o2 = new Tmp();
        o2.constructor = c3;
        return o2;
      };
      var superObj = create10(superclass.prototype, subclass);
      subclass.prototype = mix(superObj, subclass.prototype);
      subclass.superclass = create10(superclass.prototype, superclass);
      mix(superObj, overrides);
      mix(subclass, staticOverrides);
      return subclass;
    };
    extend_default = extend;
  }
});

// node_modules/@antv/util/esm/index-of.js
var indexOf2, index_of_default;
var init_index_of = __esm({
  "node_modules/@antv/util/esm/index-of.js"() {
    init_is_array_like();
    indexOf2 = function(arr, obj) {
      if (!is_array_like_default(arr)) {
        return -1;
      }
      var m3 = Array.prototype.indexOf;
      if (m3) {
        return m3.call(arr, obj);
      }
      var index2 = -1;
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2] === obj) {
          index2 = i2;
          break;
        }
      }
      return index2;
    };
    index_of_default = indexOf2;
  }
});

// node_modules/@antv/util/esm/is-empty.js
function isEmpty(value) {
  if (is_nil_default(value)) {
    return true;
  }
  if (is_array_like_default(value)) {
    return !value.length;
  }
  var type = get_type_default(value);
  if (type === "Map" || type === "Set") {
    return !value.size;
  }
  if (is_prototype_default(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty2, is_empty_default;
var init_is_empty = __esm({
  "node_modules/@antv/util/esm/is-empty.js"() {
    init_is_nil();
    init_is_array_like();
    init_get_type();
    init_is_prototype();
    hasOwnProperty2 = Object.prototype.hasOwnProperty;
    is_empty_default = isEmpty;
  }
});

// node_modules/@antv/util/esm/is-equal.js
var isEqual, is_equal_default;
var init_is_equal = __esm({
  "node_modules/@antv/util/esm/is-equal.js"() {
    init_is_object_like();
    init_is_array_like();
    init_is_string();
    isEqual = function(value, other) {
      if (value === other) {
        return true;
      }
      if (!value || !other) {
        return false;
      }
      if (is_string_default(value) || is_string_default(other)) {
        return false;
      }
      if (is_array_like_default(value) || is_array_like_default(other)) {
        if (value.length !== other.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < value.length; i2++) {
          rst = isEqual(value[i2], other[i2]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      if (is_object_like_default(value) || is_object_like_default(other)) {
        var valueKeys = Object.keys(value);
        var otherKeys = Object.keys(other);
        if (valueKeys.length !== otherKeys.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < valueKeys.length; i2++) {
          rst = isEqual(value[valueKeys[i2]], other[valueKeys[i2]]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      return false;
    };
    is_equal_default = isEqual;
  }
});

// node_modules/@antv/util/esm/is-equal-with.js
var is_equal_with_default;
var init_is_equal_with = __esm({
  "node_modules/@antv/util/esm/is-equal-with.js"() {
    init_is_function();
    init_is_equal();
    is_equal_with_default = function(value, other, fn2) {
      if (!is_function_default(fn2)) {
        return is_equal_default(value, other);
      }
      return !!fn2(value, other);
    };
  }
});

// node_modules/@antv/util/esm/map.js
var map, map_default;
var init_map = __esm({
  "node_modules/@antv/util/esm/map.js"() {
    init_is_array_like();
    map = function(arr, func) {
      if (!is_array_like_default(arr)) {
        return arr;
      }
      var result = [];
      for (var index2 = 0; index2 < arr.length; index2++) {
        var value = arr[index2];
        result.push(func(value, index2));
      }
      return result;
    };
    map_default = map;
  }
});

// node_modules/@antv/util/esm/map-values.js
var identity, map_values_default;
var init_map_values = __esm({
  "node_modules/@antv/util/esm/map-values.js"() {
    init_is_nil();
    init_is_object();
    identity = function(v2) {
      return v2;
    };
    map_values_default = function(object, func) {
      if (func === void 0) {
        func = identity;
      }
      var r2 = {};
      if (is_object_default(object) && !is_nil_default(object)) {
        Object.keys(object).forEach(function(key) {
          r2[key] = func(object[key], key);
        });
      }
      return r2;
    };
  }
});

// node_modules/@antv/util/esm/get.js
var get_default;
var init_get = __esm({
  "node_modules/@antv/util/esm/get.js"() {
    init_is_string();
    get_default = function(obj, key, defaultValue) {
      var p2 = 0;
      var keyArr = is_string_default(key) ? key.split(".") : key;
      while (obj && p2 < keyArr.length) {
        obj = obj[keyArr[p2++]];
      }
      return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
    };
  }
});

// node_modules/@antv/util/esm/set.js
var set_default;
var init_set = __esm({
  "node_modules/@antv/util/esm/set.js"() {
    init_is_object();
    init_is_string();
    init_is_number();
    set_default = function(obj, path, value) {
      var o2 = obj;
      var keyArr = is_string_default(path) ? path.split(".") : path;
      keyArr.forEach(function(key, idx) {
        if (idx < keyArr.length - 1) {
          if (!is_object_default(o2[key])) {
            o2[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
          }
          o2 = o2[key];
        } else {
          o2[key] = value;
        }
      });
      return obj;
    };
  }
});

// node_modules/@antv/util/esm/pick.js
var hasOwnProperty3, pick_default;
var init_pick = __esm({
  "node_modules/@antv/util/esm/pick.js"() {
    init_each();
    init_is_plain_object();
    hasOwnProperty3 = Object.prototype.hasOwnProperty;
    pick_default = function(object, keys3) {
      if (object === null || !is_plain_object_default(object)) {
        return {};
      }
      var result = {};
      each_default(keys3, function(key) {
        if (hasOwnProperty3.call(object, key)) {
          result[key] = object[key];
        }
      });
      return result;
    };
  }
});

// node_modules/@antv/util/esm/omit.js
var omit_default;
var init_omit = __esm({
  "node_modules/@antv/util/esm/omit.js"() {
    init_reduce();
    omit_default = function(obj, keys3) {
      return reduce_default(obj, function(r2, curr, key) {
        if (!keys3.includes(key)) {
          r2[key] = curr;
        }
        return r2;
      }, {});
    };
  }
});

// node_modules/@antv/util/esm/throttle.js
var throttle_default;
var init_throttle = __esm({
  "node_modules/@antv/util/esm/throttle.js"() {
    throttle_default = function(func, wait, options) {
      var timeout2, context, args, result;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : Date.now();
        timeout2 = null;
        result = func.apply(context, args);
        if (!timeout2)
          context = args = null;
      };
      var throttled = function() {
        var now2 = Date.now();
        if (!previous && options.leading === false)
          previous = now2;
        var remaining = wait - (now2 - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout2) {
            clearTimeout(timeout2);
            timeout2 = null;
          }
          previous = now2;
          result = func.apply(context, args);
          if (!timeout2)
            context = args = null;
        } else if (!timeout2 && options.trailing !== false) {
          timeout2 = setTimeout(later, remaining);
        }
        return result;
      };
      throttled.cancel = function() {
        clearTimeout(timeout2);
        previous = 0;
        timeout2 = context = args = null;
      };
      return throttled;
    };
  }
});

// node_modules/@antv/util/esm/to-array.js
var to_array_default;
var init_to_array = __esm({
  "node_modules/@antv/util/esm/to-array.js"() {
    init_is_array_like();
    to_array_default = function(value) {
      return is_array_like_default(value) ? Array.prototype.slice.call(value) : [];
    };
  }
});

// node_modules/@antv/util/esm/unique-id.js
var map2, unique_id_default;
var init_unique_id = __esm({
  "node_modules/@antv/util/esm/unique-id.js"() {
    map2 = {};
    unique_id_default = function(prefix) {
      prefix = prefix || "g";
      if (!map2[prefix]) {
        map2[prefix] = 1;
      } else {
        map2[prefix] += 1;
      }
      return prefix + map2[prefix];
    };
  }
});

// node_modules/@antv/util/esm/noop.js
var noop_default;
var init_noop = __esm({
  "node_modules/@antv/util/esm/noop.js"() {
    noop_default = function() {
    };
  }
});

// node_modules/@antv/util/esm/identity.js
var identity_default;
var init_identity = __esm({
  "node_modules/@antv/util/esm/identity.js"() {
    identity_default = function(v2) {
      return v2;
    };
  }
});

// node_modules/@antv/util/esm/size.js
function size(o2) {
  if (is_nil_default(o2)) {
    return 0;
  }
  if (is_array_like_default(o2)) {
    return o2.length;
  }
  return Object.keys(o2).length;
}
var init_size = __esm({
  "node_modules/@antv/util/esm/size.js"() {
    init_is_nil();
    init_is_array_like();
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter2,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest2,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends2(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics2(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
function __rest2(s2, e8) {
  var t4 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
    t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
}
function __decorate(decorators, target, key, desc) {
  var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t4[0] & 1) throw t4[1];
    return t4[1];
  }, trys: [], ops: [] }, f2, y4, t4, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done) return t4;
      if (y4 = 0, t4) op = [op[0] & 2, t4.value];
      switch (op[0]) {
        case 0:
        case 1:
          t4 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t4[1]) {
            _2.label = t4[1];
            t4 = op;
            break;
          }
          if (t4 && _2.label < t4[2]) {
            _2.label = t4[2];
            _2.ops.push(op);
            break;
          }
          if (t4[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e8) {
      op = [6, e8];
      y4 = 0;
    } finally {
      f2 = t4 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m3, o2) {
  for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2)) __createBinding(o2, m3, p2);
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i2 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e8;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar2.push(r2.value);
  } catch (error) {
    e8 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e8) throw e8.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read(arguments[i2]));
  return ar2;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a3 = arguments[i2], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
      r2[k2] = a3[j2];
  return r2;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
    if (ar2 || !(i2 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
      ar2[i2] = from[i2];
    }
  }
  return to2.concat(ar2 || from);
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2]) i2[n2] = function(v2) {
      return new Promise(function(a3, b10) {
        q2.push([n2, v2, a3, b10]) > 1 || resume(n2, v2);
      });
    };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e8) {
      settle(q2[0][3], e8);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e8) {
    throw e8;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o2[Symbol.asyncIterator], i2;
  return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod4) {
  if (mod4 && mod4.__esModule) return mod4;
  var result = {};
  if (mod4 != null) {
    for (var k2 in mod4) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod4, k2)) __createBinding(result, mod4, k2);
  }
  __setModuleDefault(result, mod4);
  return result;
}
function __importDefault(mod4) {
  return mod4 && mod4.__esModule ? mod4 : { default: mod4 };
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
var extendStatics2, __assign2, __createBinding, __setModuleDefault;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics2 = function(d2, b10) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
        d3.__proto__ = b11;
      } || function(d3, b11) {
        for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
      };
      return extendStatics2(d2, b10);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign18(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign2.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k2];
      } });
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    };
    __setModuleDefault = Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    };
  }
});

// node_modules/@antv/util/esm/measure-text-width.js
var ctx, measure_text_width_default;
var init_measure_text_width = __esm({
  "node_modules/@antv/util/esm/measure-text-width.js"() {
    init_tslib_es6();
    init_values();
    init_memoize();
    init_is_string();
    measure_text_width_default = memoize_default(function(text, font) {
      if (font === void 0) {
        font = {};
      }
      var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
      if (!ctx) {
        ctx = document.createElement("canvas").getContext("2d");
      }
      ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
      return ctx.measureText(is_string_default(text) ? text : "").width;
    }, function(text, font) {
      if (font === void 0) {
        font = {};
      }
      return __spreadArrays([text], values_default(font)).join("");
    });
  }
});

// node_modules/@antv/util/esm/get-ellipsis-text.js
var get_ellipsis_text_default;
var init_get_ellipsis_text = __esm({
  "node_modules/@antv/util/esm/get-ellipsis-text.js"() {
    init_is_string();
    init_to_string();
    init_measure_text_width();
    get_ellipsis_text_default = function(text, maxWidth, font, str10) {
      if (str10 === void 0) {
        str10 = "...";
      }
      var STEP = 16;
      var PLACEHOLDER_WIDTH = measure_text_width_default(str10, font);
      var leftText = !is_string_default(text) ? to_string_default(text) : text;
      var leftWidth = maxWidth;
      var r2 = [];
      var currentText;
      var currentWidth;
      if (measure_text_width_default(text, font) <= maxWidth) {
        return text;
      }
      while (true) {
        currentText = leftText.substr(0, STEP);
        currentWidth = measure_text_width_default(currentText, font);
        if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
          if (currentWidth > leftWidth) {
            break;
          }
        }
        r2.push(currentText);
        leftWidth -= currentWidth;
        leftText = leftText.substr(STEP);
        if (!leftText) {
          return r2.join("");
        }
      }
      while (true) {
        currentText = leftText.substr(0, 1);
        currentWidth = measure_text_width_default(currentText, font);
        if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
          break;
        }
        r2.push(currentText);
        leftWidth -= currentWidth;
        leftText = leftText.substr(1);
        if (!leftText) {
          return r2.join("");
        }
      }
      return "" + r2.join("") + str10;
    };
  }
});

// node_modules/@antv/util/esm/cache.js
var default_1, cache_default;
var init_cache = __esm({
  "node_modules/@antv/util/esm/cache.js"() {
    default_1 = /** @class */
    function() {
      function default_13() {
        this.map = {};
      }
      default_13.prototype.has = function(key) {
        return this.map[key] !== void 0;
      };
      default_13.prototype.get = function(key, def) {
        var v2 = this.map[key];
        return v2 === void 0 ? def : v2;
      };
      default_13.prototype.set = function(key, value) {
        this.map[key] = value;
      };
      default_13.prototype.clear = function() {
        this.map = {};
      };
      default_13.prototype.delete = function(key) {
        delete this.map[key];
      };
      default_13.prototype.size = function() {
        return Object.keys(this.map).length;
      };
      return default_13;
    }();
    cache_default = default_1;
  }
});

// node_modules/@antv/util/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Cache: () => cache_default,
  assign: () => mix,
  augment: () => augment_default,
  clamp: () => clamp_default,
  clearAnimationFrame: () => cancelAnimationFrame2,
  clone: () => clone_default,
  contains: () => contains_default,
  debounce: () => debounce_default,
  deepMix: () => deep_mix_default,
  difference: () => difference_default,
  each: () => each_default,
  endsWith: () => ends_with_default,
  every: () => every_default,
  extend: () => extend_default,
  filter: () => filter_default,
  find: () => find_default,
  findIndex: () => find_index_default,
  firstValue: () => first_value_default,
  fixedBase: () => fixed_base_default,
  flatten: () => flatten_default,
  flattenDeep: () => flatten_deep_default,
  forIn: () => for_in_default,
  get: () => get_default,
  getEllipsisText: () => get_ellipsis_text_default,
  getRange: () => get_range_default,
  getType: () => get_type_default,
  getWrapBehavior: () => get_wrap_behavior_default,
  group: () => group_default,
  groupBy: () => group_by_default,
  groupToMap: () => groupToMap,
  has: () => has_default,
  hasKey: () => has_key_default,
  hasValue: () => has_value_default,
  head: () => head,
  identity: () => identity_default,
  includes: () => contains_default,
  indexOf: () => index_of_default,
  isArguments: () => is_arguments_default,
  isArray: () => is_array_default,
  isArrayLike: () => is_array_like_default,
  isBoolean: () => is_boolean_default,
  isDate: () => is_date_default,
  isDecimal: () => is_decimal_default,
  isElement: () => is_element_default,
  isEmpty: () => is_empty_default,
  isEqual: () => is_equal_default,
  isEqualWith: () => is_equal_with_default,
  isError: () => is_error_default,
  isEven: () => is_even_default,
  isFinite: () => is_finite_default,
  isFunction: () => is_function_default,
  isInteger: () => is_integer_default,
  isMatch: () => is_match_default,
  isNegative: () => is_negative_default,
  isNil: () => is_nil_default,
  isNull: () => is_null_default,
  isNumber: () => is_number_default,
  isNumberEqual: () => isNumberEqual,
  isObject: () => is_object_default,
  isObjectLike: () => is_object_like_default,
  isOdd: () => is_odd_default,
  isPlainObject: () => is_plain_object_default,
  isPositive: () => is_positive_default,
  isPrototype: () => is_prototype_default,
  isRegExp: () => is_reg_exp_default,
  isString: () => is_string_default,
  isType: () => is_type_default,
  isUndefined: () => is_undefined_default,
  keys: () => keys_default,
  last: () => last,
  lowerCase: () => lower_case_default,
  lowerFirst: () => lower_first_default,
  map: () => map_default,
  mapValues: () => map_values_default,
  max: () => max_default,
  maxBy: () => max_by_default,
  measureTextWidth: () => measure_text_width_default,
  memoize: () => memoize_default,
  min: () => min_default,
  minBy: () => min_by_default,
  mix: () => mix,
  mod: () => mod_default,
  noop: () => noop_default,
  number2color: () => number2color_default,
  omit: () => omit_default,
  parseRadius: () => parse_radius_default,
  pick: () => pick_default,
  pull: () => pull_default,
  pullAt: () => pull_at_default,
  reduce: () => reduce_default,
  remove: () => remove_default,
  requestAnimationFrame: () => requestAnimationFrame2,
  set: () => set_default,
  size: () => size,
  some: () => some_default,
  sortBy: () => sort_by_default,
  startsWith: () => starts_with_default,
  substitute: () => substitute_default,
  throttle: () => throttle_default,
  toArray: () => to_array_default,
  toDegree: () => to_degree_default,
  toInteger: () => to_integer_default,
  toRadian: () => to_radian_default,
  toString: () => to_string_default,
  union: () => union_default,
  uniq: () => uniq,
  uniqueId: () => unique_id_default,
  upperCase: () => upper_case_default,
  upperFirst: () => upper_first_default,
  values: () => values_default,
  valuesOfKey: () => values_of_key_default,
  wrapBehavior: () => wrap_behavior_default
});
var init_esm = __esm({
  "node_modules/@antv/util/esm/index.js"() {
    init_contains();
    init_difference();
    init_find();
    init_find_index();
    init_first_value();
    init_flatten();
    init_flatten_deep();
    init_get_range();
    init_pull();
    init_pull_at();
    init_reduce();
    init_remove();
    init_sort_by();
    init_union();
    init_uniq();
    init_values_of_key();
    init_head();
    init_last();
    init_starts_with();
    init_ends_with();
    init_filter();
    init_every();
    init_some();
    init_group();
    init_group_by();
    init_group_to_map();
    init_get_wrap_behavior();
    init_wrap_behavior();
    init_number2color();
    init_parse_radius();
    init_clamp();
    init_fixed_base();
    init_is_decimal();
    init_is_even();
    init_is_integer();
    init_is_negative();
    init_is_number_equal();
    init_is_odd();
    init_is_positive();
    init_max();
    init_max_by();
    init_min();
    init_min_by();
    init_mod();
    init_to_degree();
    init_to_integer();
    init_to_radian();
    init_for_in();
    init_has();
    init_has_key();
    init_has_value();
    init_keys();
    init_is_match();
    init_values();
    init_lower_case();
    init_lower_first();
    init_substitute();
    init_upper_case();
    init_upper_first();
    init_get_type();
    init_is_arguments();
    init_is_array();
    init_is_array_like();
    init_is_boolean();
    init_is_date();
    init_is_error();
    init_is_function();
    init_is_finite();
    init_is_nil();
    init_is_null();
    init_is_number();
    init_is_object();
    init_is_object_like();
    init_is_plain_object();
    init_is_prototype();
    init_is_reg_exp();
    init_is_string();
    init_is_type();
    init_is_undefined();
    init_is_element();
    init_request_animation_frame();
    init_clear_animation_frame();
    init_augment();
    init_clone();
    init_debounce();
    init_memoize();
    init_deep_mix();
    init_each();
    init_extend();
    init_index_of();
    init_is_empty();
    init_is_equal();
    init_is_equal_with();
    init_map();
    init_map_values();
    init_mix();
    init_get();
    init_set();
    init_pick();
    init_omit();
    init_throttle();
    init_to_array();
    init_to_string();
    init_unique_id();
    init_noop();
    init_identity();
    init_size();
    init_measure_text_width();
    init_get_ellipsis_text();
    init_cache();
  }
});

// node_modules/gl-matrix/esm/common.js
var common_exports = {};
__export(common_exports, {
  ANGLE_ORDER: () => ANGLE_ORDER,
  ARRAY_TYPE: () => ARRAY_TYPE,
  EPSILON: () => EPSILON,
  RANDOM: () => RANDOM,
  equals: () => equals,
  round: () => round,
  setMatrixArrayType: () => setMatrixArrayType,
  toDegree: () => toDegree2,
  toRadian: () => toRadian2
});
function round(a3) {
  if (a3 >= 0) return Math.round(a3);
  return a3 % 0.5 === 0 ? Math.floor(a3) : Math.round(a3);
}
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
function toRadian2(a3) {
  return a3 * degree;
}
function toDegree2(a3) {
  return a3 * radian;
}
function equals(a3, b10) {
  var tolerance3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EPSILON;
  return Math.abs(a3 - b10) <= tolerance3 * Math.max(1, Math.abs(a3), Math.abs(b10));
}
var EPSILON, ARRAY_TYPE, RANDOM, ANGLE_ORDER, degree, radian;
var init_common = __esm({
  "node_modules/gl-matrix/esm/common.js"() {
    EPSILON = 1e-6;
    ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
    RANDOM = Math.random;
    ANGLE_ORDER = "zyx";
    degree = Math.PI / 180;
    radian = 180 / Math.PI;
  }
});

// node_modules/gl-matrix/esm/mat2.js
var mat2_exports = {};
__export(mat2_exports, {
  LDU: () => LDU,
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromValues: () => fromValues,
  identity: () => identity2,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set2,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
function clone2(a3) {
  var out = new ARRAY_TYPE(4);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  return out;
}
function copy(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function set2(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function transpose(out, a3) {
  if (out === a3) {
    var a1 = a3[1];
    out[1] = a3[2];
    out[2] = a1;
  } else {
    out[0] = a3[0];
    out[1] = a3[2];
    out[2] = a3[1];
    out[3] = a3[3];
  }
  return out;
}
function invert(out, a3) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var det = a0 * a32 - a22 * a1;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = a32 * det;
  out[1] = -a1 * det;
  out[2] = -a22 * det;
  out[3] = a0 * det;
  return out;
}
function adjoint(out, a3) {
  var a0 = a3[0];
  out[0] = a3[3];
  out[1] = -a3[1];
  out[2] = -a3[2];
  out[3] = a0;
  return out;
}
function determinant(a3) {
  return a3[0] * a3[3] - a3[2] * a3[1];
}
function multiply(out, a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  out[0] = a0 * b02 + a22 * b12;
  out[1] = a1 * b02 + a32 * b12;
  out[2] = a0 * b22 + a22 * b32;
  out[3] = a1 * b22 + a32 * b32;
  return out;
}
function rotate(out, a3, rad) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = a0 * c3 + a22 * s2;
  out[1] = a1 * c3 + a32 * s2;
  out[2] = a0 * -s2 + a22 * c3;
  out[3] = a1 * -s2 + a32 * c3;
  return out;
}
function scale(out, a3, v2) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var v0 = v2[0], v1 = v2[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a22 * v1;
  out[3] = a32 * v1;
  return out;
}
function fromRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = c3;
  out[1] = s2;
  out[2] = -s2;
  out[3] = c3;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v2[1];
  return out;
}
function str(a3) {
  return "mat2(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
}
function frob(a3) {
  return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3]);
}
function LDU(L2, D3, U2, a3) {
  L2[2] = a3[2] / a3[0];
  U2[0] = a3[0];
  U2[1] = a3[1];
  U2[3] = a3[3] - L2[2] * U2[1];
  return [L2, D3, U2];
}
function add(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  out[2] = a3[2] + b10[2];
  out[3] = a3[3] + b10[3];
  return out;
}
function subtract(out, a3, b10) {
  out[0] = a3[0] - b10[0];
  out[1] = a3[1] - b10[1];
  out[2] = a3[2] - b10[2];
  out[3] = a3[3] - b10[3];
  return out;
}
function exactEquals(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1] && a3[2] === b10[2] && a3[3] === b10[3];
}
function equals2(a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32));
}
function multiplyScalar(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  out[2] = a3[2] * b10;
  out[3] = a3[3] * b10;
  return out;
}
function multiplyScalarAndAdd(out, a3, b10, scale12) {
  out[0] = a3[0] + b10[0] * scale12;
  out[1] = a3[1] + b10[1] * scale12;
  out[2] = a3[2] + b10[2] * scale12;
  out[3] = a3[3] + b10[3] * scale12;
  return out;
}
var mul, sub;
var init_mat2 = __esm({
  "node_modules/gl-matrix/esm/mat2.js"() {
    init_common();
    mul = multiply;
    sub = subtract;
  }
});

// node_modules/gl-matrix/esm/mat2d.js
var mat2d_exports = {};
__export(mat2d_exports, {
  add: () => add2,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromRotation: () => fromRotation2,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues2,
  identity: () => identity3,
  invert: () => invert2,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  rotate: () => rotate2,
  scale: () => scale2,
  set: () => set3,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  translate: () => translate
});
function create2() {
  var out = new ARRAY_TYPE(6);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
function clone3(a3) {
  var out = new ARRAY_TYPE(6);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  return out;
}
function copy2(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  return out;
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
function fromValues2(a3, b10, c3, d2, tx, ty) {
  var out = new ARRAY_TYPE(6);
  out[0] = a3;
  out[1] = b10;
  out[2] = c3;
  out[3] = d2;
  out[4] = tx;
  out[5] = ty;
  return out;
}
function set3(out, a3, b10, c3, d2, tx, ty) {
  out[0] = a3;
  out[1] = b10;
  out[2] = c3;
  out[3] = d2;
  out[4] = tx;
  out[5] = ty;
  return out;
}
function invert2(out, a3) {
  var aa2 = a3[0], ab = a3[1], ac2 = a3[2], ad = a3[3];
  var atx = a3[4], aty = a3[5];
  var det = aa2 * ad - ab * ac2;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac2 * det;
  out[3] = aa2 * det;
  out[4] = (ac2 * aty - ad * atx) * det;
  out[5] = (ab * atx - aa2 * aty) * det;
  return out;
}
function determinant2(a3) {
  return a3[0] * a3[3] - a3[1] * a3[2];
}
function multiply2(out, a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5];
  out[0] = a0 * b02 + a22 * b12;
  out[1] = a1 * b02 + a32 * b12;
  out[2] = a0 * b22 + a22 * b32;
  out[3] = a1 * b22 + a32 * b32;
  out[4] = a0 * b42 + a22 * b52 + a4;
  out[5] = a1 * b42 + a32 * b52 + a5;
  return out;
}
function rotate2(out, a3, rad) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5];
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = a0 * c3 + a22 * s2;
  out[1] = a1 * c3 + a32 * s2;
  out[2] = a0 * -s2 + a22 * c3;
  out[3] = a1 * -s2 + a32 * c3;
  out[4] = a4;
  out[5] = a5;
  return out;
}
function scale2(out, a3, v2) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5];
  var v0 = v2[0], v1 = v2[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a22 * v1;
  out[3] = a32 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
function translate(out, a3, v2) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5];
  var v0 = v2[0], v1 = v2[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a22;
  out[3] = a32;
  out[4] = a0 * v0 + a22 * v1 + a4;
  out[5] = a1 * v0 + a32 * v1 + a5;
  return out;
}
function fromRotation2(out, rad) {
  var s2 = Math.sin(rad), c3 = Math.cos(rad);
  out[0] = c3;
  out[1] = s2;
  out[2] = -s2;
  out[3] = c3;
  out[4] = 0;
  out[5] = 0;
  return out;
}
function fromScaling2(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v2[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v2[0];
  out[5] = v2[1];
  return out;
}
function str2(a3) {
  return "mat2d(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ")";
}
function frob2(a3) {
  return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3] + a3[4] * a3[4] + a3[5] * a3[5] + 1);
}
function add2(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  out[2] = a3[2] + b10[2];
  out[3] = a3[3] + b10[3];
  out[4] = a3[4] + b10[4];
  out[5] = a3[5] + b10[5];
  return out;
}
function subtract2(out, a3, b10) {
  out[0] = a3[0] - b10[0];
  out[1] = a3[1] - b10[1];
  out[2] = a3[2] - b10[2];
  out[3] = a3[3] - b10[3];
  out[4] = a3[4] - b10[4];
  out[5] = a3[5] - b10[5];
  return out;
}
function multiplyScalar2(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  out[2] = a3[2] * b10;
  out[3] = a3[3] * b10;
  out[4] = a3[4] * b10;
  out[5] = a3[5] * b10;
  return out;
}
function multiplyScalarAndAdd2(out, a3, b10, scale12) {
  out[0] = a3[0] + b10[0] * scale12;
  out[1] = a3[1] + b10[1] * scale12;
  out[2] = a3[2] + b10[2] * scale12;
  out[3] = a3[3] + b10[3] * scale12;
  out[4] = a3[4] + b10[4] * scale12;
  out[5] = a3[5] + b10[5] * scale12;
  return out;
}
function exactEquals2(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1] && a3[2] === b10[2] && a3[3] === b10[3] && a3[4] === b10[4] && a3[5] === b10[5];
}
function equals3(a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52));
}
var mul2, sub2;
var init_mat2d = __esm({
  "node_modules/gl-matrix/esm/mat2d.js"() {
    init_common();
    mul2 = multiply2;
    sub2 = subtract2;
  }
});

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add3,
  adjoint: () => adjoint2,
  clone: () => clone4,
  copy: () => copy3,
  create: () => create3,
  determinant: () => determinant3,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  frob: () => frob3,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation3,
  fromScaling: () => fromScaling3,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues3,
  identity: () => identity4,
  invert: () => invert3,
  mul: () => mul3,
  multiply: () => multiply3,
  multiplyScalar: () => multiplyScalar3,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd3,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate3,
  scale: () => scale3,
  set: () => set4,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  translate: () => translate2,
  transpose: () => transpose2
});
function create3() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[4];
  out[4] = a3[5];
  out[5] = a3[6];
  out[6] = a3[8];
  out[7] = a3[9];
  out[8] = a3[10];
  return out;
}
function clone4(a3) {
  var out = new ARRAY_TYPE(9);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  out[8] = a3[8];
  return out;
}
function copy3(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  out[8] = a3[8];
  return out;
}
function fromValues3(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set4(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity4(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose2(out, a3) {
  if (out === a3) {
    var a01 = a3[1], a02 = a3[2], a12 = a3[5];
    out[1] = a3[3];
    out[2] = a3[6];
    out[3] = a01;
    out[5] = a3[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a3[0];
    out[1] = a3[3];
    out[2] = a3[6];
    out[3] = a3[1];
    out[4] = a3[4];
    out[5] = a3[7];
    out[6] = a3[2];
    out[7] = a3[5];
    out[8] = a3[8];
  }
  return out;
}
function invert3(out, a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2];
  var a10 = a3[3], a11 = a3[4], a12 = a3[5];
  var a20 = a3[6], a21 = a3[7], a22 = a3[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint2(out, a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2];
  var a10 = a3[3], a11 = a3[4], a12 = a3[5];
  var a20 = a3[6], a21 = a3[7], a22 = a3[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant3(a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2];
  var a10 = a3[3], a11 = a3[4], a12 = a3[5];
  var a20 = a3[6], a21 = a3[7], a22 = a3[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply3(out, a3, b10) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2];
  var a10 = a3[3], a11 = a3[4], a12 = a3[5];
  var a20 = a3[6], a21 = a3[7], a22 = a3[8];
  var b00 = b10[0], b01 = b10[1], b02 = b10[2];
  var b102 = b10[3], b11 = b10[4], b12 = b10[5];
  var b20 = b10[6], b21 = b10[7], b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate2(out, a3, v2) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a10 = a3[3], a11 = a3[4], a12 = a3[5], a20 = a3[6], a21 = a3[7], a22 = a3[8], x4 = v2[0], y4 = v2[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x4 * a00 + y4 * a10 + a20;
  out[7] = x4 * a01 + y4 * a11 + a21;
  out[8] = x4 * a02 + y4 * a12 + a22;
  return out;
}
function rotate3(out, a3, rad) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a10 = a3[3], a11 = a3[4], a12 = a3[5], a20 = a3[6], a21 = a3[7], a22 = a3[8], s2 = Math.sin(rad), c3 = Math.cos(rad);
  out[0] = c3 * a00 + s2 * a10;
  out[1] = c3 * a01 + s2 * a11;
  out[2] = c3 * a02 + s2 * a12;
  out[3] = c3 * a10 - s2 * a00;
  out[4] = c3 * a11 - s2 * a01;
  out[5] = c3 * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale3(out, a3, v2) {
  var x4 = v2[0], y4 = v2[1];
  out[0] = x4 * a3[0];
  out[1] = x4 * a3[1];
  out[2] = x4 * a3[2];
  out[3] = y4 * a3[3];
  out[4] = y4 * a3[4];
  out[5] = y4 * a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  out[8] = a3[8];
  return out;
}
function fromTranslation2(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v2[0];
  out[7] = v2[1];
  out[8] = 1;
  return out;
}
function fromRotation3(out, rad) {
  var s2 = Math.sin(rad), c3 = Math.cos(rad);
  out[0] = c3;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c3;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling3(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v2[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = 0;
  out[3] = a3[2];
  out[4] = a3[3];
  out[5] = 0;
  out[6] = a3[4];
  out[7] = a3[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q2) {
  var x4 = q2[0], y4 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x4 + x4;
  var y22 = y4 + y4;
  var z22 = z2 + z2;
  var xx = x4 * x22;
  var yx = y4 * x22;
  var yy = y4 * y22;
  var zx = z2 * x22;
  var zy = z2 * y22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str3(a3) {
  return "mat3(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ", " + a3[8] + ")";
}
function frob3(a3) {
  return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3] + a3[4] * a3[4] + a3[5] * a3[5] + a3[6] * a3[6] + a3[7] * a3[7] + a3[8] * a3[8]);
}
function add3(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  out[2] = a3[2] + b10[2];
  out[3] = a3[3] + b10[3];
  out[4] = a3[4] + b10[4];
  out[5] = a3[5] + b10[5];
  out[6] = a3[6] + b10[6];
  out[7] = a3[7] + b10[7];
  out[8] = a3[8] + b10[8];
  return out;
}
function subtract3(out, a3, b10) {
  out[0] = a3[0] - b10[0];
  out[1] = a3[1] - b10[1];
  out[2] = a3[2] - b10[2];
  out[3] = a3[3] - b10[3];
  out[4] = a3[4] - b10[4];
  out[5] = a3[5] - b10[5];
  out[6] = a3[6] - b10[6];
  out[7] = a3[7] - b10[7];
  out[8] = a3[8] - b10[8];
  return out;
}
function multiplyScalar3(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  out[2] = a3[2] * b10;
  out[3] = a3[3] * b10;
  out[4] = a3[4] * b10;
  out[5] = a3[5] * b10;
  out[6] = a3[6] * b10;
  out[7] = a3[7] * b10;
  out[8] = a3[8] * b10;
  return out;
}
function multiplyScalarAndAdd3(out, a3, b10, scale12) {
  out[0] = a3[0] + b10[0] * scale12;
  out[1] = a3[1] + b10[1] * scale12;
  out[2] = a3[2] + b10[2] * scale12;
  out[3] = a3[3] + b10[3] * scale12;
  out[4] = a3[4] + b10[4] * scale12;
  out[5] = a3[5] + b10[5] * scale12;
  out[6] = a3[6] + b10[6] * scale12;
  out[7] = a3[7] + b10[7] * scale12;
  out[8] = a3[8] + b10[8] * scale12;
  return out;
}
function exactEquals3(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1] && a3[2] === b10[2] && a3[3] === b10[3] && a3[4] === b10[4] && a3[5] === b10[5] && a3[6] === b10[6] && a3[7] === b10[7] && a3[8] === b10[8];
}
function equals4(a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7], a8 = a3[8];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7], b82 = b10[8];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82));
}
var mul3, sub3;
var init_mat3 = __esm({
  "node_modules/gl-matrix/esm/mat3.js"() {
    init_common();
    mul3 = multiply3;
    sub3 = subtract3;
  }
});

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add4,
  adjoint: () => adjoint3,
  clone: () => clone5,
  copy: () => copy4,
  create: () => create4,
  decompose: () => decompose,
  determinant: () => determinant4,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  frob: () => frob4,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation4,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling4,
  fromTranslation: () => fromTranslation3,
  fromValues: () => fromValues4,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity5,
  invert: () => invert4,
  lookAt: () => lookAt,
  mul: () => mul4,
  multiply: () => multiply4,
  multiplyScalar: () => multiplyScalar4,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd4,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate4,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale4,
  set: () => set5,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  targetTo: () => targetTo,
  translate: () => translate3,
  transpose: () => transpose3
});
function create4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone5(a3) {
  var out = new ARRAY_TYPE(16);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  out[8] = a3[8];
  out[9] = a3[9];
  out[10] = a3[10];
  out[11] = a3[11];
  out[12] = a3[12];
  out[13] = a3[13];
  out[14] = a3[14];
  out[15] = a3[15];
  return out;
}
function copy4(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  out[8] = a3[8];
  out[9] = a3[9];
  out[10] = a3[10];
  out[11] = a3[11];
  out[12] = a3[12];
  out[13] = a3[13];
  out[14] = a3[14];
  out[15] = a3[15];
  return out;
}
function fromValues4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set5(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity5(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose3(out, a3) {
  if (out === a3) {
    var a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a12 = a3[6], a13 = a3[7];
    var a23 = a3[11];
    out[1] = a3[4];
    out[2] = a3[8];
    out[3] = a3[12];
    out[4] = a01;
    out[6] = a3[9];
    out[7] = a3[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a3[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a3[0];
    out[1] = a3[4];
    out[2] = a3[8];
    out[3] = a3[12];
    out[4] = a3[1];
    out[5] = a3[5];
    out[6] = a3[9];
    out[7] = a3[13];
    out[8] = a3[2];
    out[9] = a3[6];
    out[10] = a3[10];
    out[11] = a3[14];
    out[12] = a3[3];
    out[13] = a3[7];
    out[14] = a3[11];
    out[15] = a3[15];
  }
  return out;
}
function invert4(out, a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint3(out, a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant4(a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b02 = a00 * a11 - a01 * a10;
  var b12 = a00 * a12 - a02 * a10;
  var b22 = a01 * a12 - a02 * a11;
  var b32 = a20 * a31 - a21 * a30;
  var b42 = a20 * a32 - a22 * a30;
  var b52 = a21 * a32 - a22 * a31;
  var b62 = a00 * b52 - a01 * b42 + a02 * b32;
  var b72 = a10 * b52 - a11 * b42 + a12 * b32;
  var b82 = a20 * b22 - a21 * b12 + a22 * b02;
  var b92 = a30 * b22 - a31 * b12 + a32 * b02;
  return a13 * b62 - a03 * b72 + a33 * b82 - a23 * b92;
}
function multiply4(out, a3, b10) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  out[0] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[1] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[2] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[3] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  b02 = b10[4];
  b12 = b10[5];
  b22 = b10[6];
  b32 = b10[7];
  out[4] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[5] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[6] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[7] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  b02 = b10[8];
  b12 = b10[9];
  b22 = b10[10];
  b32 = b10[11];
  out[8] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[9] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[10] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[11] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  b02 = b10[12];
  b12 = b10[13];
  b22 = b10[14];
  b32 = b10[15];
  out[12] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[13] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[14] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[15] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  return out;
}
function translate3(out, a3, v2) {
  var x4 = v2[0], y4 = v2[1], z2 = v2[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a3 === out) {
    out[12] = a3[0] * x4 + a3[4] * y4 + a3[8] * z2 + a3[12];
    out[13] = a3[1] * x4 + a3[5] * y4 + a3[9] * z2 + a3[13];
    out[14] = a3[2] * x4 + a3[6] * y4 + a3[10] * z2 + a3[14];
    out[15] = a3[3] * x4 + a3[7] * y4 + a3[11] * z2 + a3[15];
  } else {
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x4 + a10 * y4 + a20 * z2 + a3[12];
    out[13] = a01 * x4 + a11 * y4 + a21 * z2 + a3[13];
    out[14] = a02 * x4 + a12 * y4 + a22 * z2 + a3[14];
    out[15] = a03 * x4 + a13 * y4 + a23 * z2 + a3[15];
  }
  return out;
}
function scale4(out, a3, v2) {
  var x4 = v2[0], y4 = v2[1], z2 = v2[2];
  out[0] = a3[0] * x4;
  out[1] = a3[1] * x4;
  out[2] = a3[2] * x4;
  out[3] = a3[3] * x4;
  out[4] = a3[4] * y4;
  out[5] = a3[5] * y4;
  out[6] = a3[6] * y4;
  out[7] = a3[7] * y4;
  out[8] = a3[8] * z2;
  out[9] = a3[9] * z2;
  out[10] = a3[10] * z2;
  out[11] = a3[11] * z2;
  out[12] = a3[12];
  out[13] = a3[13];
  out[14] = a3[14];
  out[15] = a3[15];
  return out;
}
function rotate4(out, a3, rad, axis) {
  var x4 = axis[0], y4 = axis[1], z2 = axis[2];
  var len6 = Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2);
  var s2, c3, t4;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len6 < EPSILON) {
    return null;
  }
  len6 = 1 / len6;
  x4 *= len6;
  y4 *= len6;
  z2 *= len6;
  s2 = Math.sin(rad);
  c3 = Math.cos(rad);
  t4 = 1 - c3;
  a00 = a3[0];
  a01 = a3[1];
  a02 = a3[2];
  a03 = a3[3];
  a10 = a3[4];
  a11 = a3[5];
  a12 = a3[6];
  a13 = a3[7];
  a20 = a3[8];
  a21 = a3[9];
  a22 = a3[10];
  a23 = a3[11];
  b00 = x4 * x4 * t4 + c3;
  b01 = y4 * x4 * t4 + z2 * s2;
  b02 = z2 * x4 * t4 - y4 * s2;
  b10 = x4 * y4 * t4 - z2 * s2;
  b11 = y4 * y4 * t4 + c3;
  b12 = z2 * y4 * t4 + x4 * s2;
  b20 = x4 * z2 * t4 + y4 * s2;
  b21 = y4 * z2 * t4 - x4 * s2;
  b22 = z2 * z2 * t4 + c3;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a3 !== out) {
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  return out;
}
function rotateX(out, a3, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  var a10 = a3[4];
  var a11 = a3[5];
  var a12 = a3[6];
  var a13 = a3[7];
  var a20 = a3[8];
  var a21 = a3[9];
  var a22 = a3[10];
  var a23 = a3[11];
  if (a3 !== out) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  out[4] = a10 * c3 + a20 * s2;
  out[5] = a11 * c3 + a21 * s2;
  out[6] = a12 * c3 + a22 * s2;
  out[7] = a13 * c3 + a23 * s2;
  out[8] = a20 * c3 - a10 * s2;
  out[9] = a21 * c3 - a11 * s2;
  out[10] = a22 * c3 - a12 * s2;
  out[11] = a23 * c3 - a13 * s2;
  return out;
}
function rotateY(out, a3, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  var a00 = a3[0];
  var a01 = a3[1];
  var a02 = a3[2];
  var a03 = a3[3];
  var a20 = a3[8];
  var a21 = a3[9];
  var a22 = a3[10];
  var a23 = a3[11];
  if (a3 !== out) {
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  out[0] = a00 * c3 - a20 * s2;
  out[1] = a01 * c3 - a21 * s2;
  out[2] = a02 * c3 - a22 * s2;
  out[3] = a03 * c3 - a23 * s2;
  out[8] = a00 * s2 + a20 * c3;
  out[9] = a01 * s2 + a21 * c3;
  out[10] = a02 * s2 + a22 * c3;
  out[11] = a03 * s2 + a23 * c3;
  return out;
}
function rotateZ(out, a3, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  var a00 = a3[0];
  var a01 = a3[1];
  var a02 = a3[2];
  var a03 = a3[3];
  var a10 = a3[4];
  var a11 = a3[5];
  var a12 = a3[6];
  var a13 = a3[7];
  if (a3 !== out) {
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  out[0] = a00 * c3 + a10 * s2;
  out[1] = a01 * c3 + a11 * s2;
  out[2] = a02 * c3 + a12 * s2;
  out[3] = a03 * c3 + a13 * s2;
  out[4] = a10 * c3 - a00 * s2;
  out[5] = a11 * c3 - a01 * s2;
  out[6] = a12 * c3 - a02 * s2;
  out[7] = a13 * c3 - a03 * s2;
  return out;
}
function fromTranslation3(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling4(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation4(out, rad, axis) {
  var x4 = axis[0], y4 = axis[1], z2 = axis[2];
  var len6 = Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2);
  var s2, c3, t4;
  if (len6 < EPSILON) {
    return null;
  }
  len6 = 1 / len6;
  x4 *= len6;
  y4 *= len6;
  z2 *= len6;
  s2 = Math.sin(rad);
  c3 = Math.cos(rad);
  t4 = 1 - c3;
  out[0] = x4 * x4 * t4 + c3;
  out[1] = y4 * x4 * t4 + z2 * s2;
  out[2] = z2 * x4 * t4 - y4 * s2;
  out[3] = 0;
  out[4] = x4 * y4 * t4 - z2 * s2;
  out[5] = y4 * y4 * t4 + c3;
  out[6] = z2 * y4 * t4 + x4 * s2;
  out[7] = 0;
  out[8] = x4 * z2 * t4 + y4 * s2;
  out[9] = y4 * z2 * t4 - x4 * s2;
  out[10] = z2 * z2 * t4 + c3;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c3;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c3;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = c3;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c3;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = c3;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c3;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q2, v2) {
  var x4 = q2[0], y4 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x4 + x4;
  var y22 = y4 + y4;
  var z22 = z2 + z2;
  var xx = x4 * x22;
  var xy = x4 * y22;
  var xz = x4 * z22;
  var yy = y4 * y22;
  var yz = y4 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a3) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3], ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a3, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  var is1 = 1 / out_s[0];
  var is2 = 1 / out_s[1];
  var is3 = 1 / out_s[2];
  var sm11 = m11 * is1;
  var sm12 = m12 * is2;
  var sm13 = m13 * is3;
  var sm21 = m21 * is1;
  var sm22 = m22 * is2;
  var sm23 = m23 * is3;
  var sm31 = m31 * is1;
  var sm32 = m32 * is2;
  var sm33 = m33 * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S2;
    out_r[0] = (sm23 - sm32) / S2;
    out_r[1] = (sm31 - sm13) / S2;
    out_r[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S2;
    out_r[0] = 0.25 * S2;
    out_r[1] = (sm12 + sm21) / S2;
    out_r[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S2;
    out_r[0] = (sm12 + sm21) / S2;
    out_r[1] = 0.25 * S2;
    out_r[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S2;
    out_r[0] = (sm31 + sm13) / S2;
    out_r[1] = (sm23 + sm32) / S2;
    out_r[2] = 0.25 * S2;
  }
  return out_r;
}
function fromRotationTranslationScale(out, q2, v2, s2) {
  var x4 = q2[0], y4 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x4 + x4;
  var y22 = y4 + y4;
  var z22 = z2 + z2;
  var xx = x4 * x22;
  var xy = x4 * y22;
  var xz = x4 * z22;
  var yy = y4 * y22;
  var yz = y4 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q2, v2, s2, o2) {
  var x4 = q2[0], y4 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x4 + x4;
  var y22 = y4 + y4;
  var z22 = z2 + z2;
  var xx = x4 * x22;
  var xy = x4 * y22;
  var xz = x4 * z22;
  var yy = y4 * y22;
  var yz = y4 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  var ox = o2[0];
  var oy = o2[1];
  var oz = o2[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q2) {
  var x4 = q2[0], y4 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x4 + x4;
  var y22 = y4 + y4;
  var z22 = z2 + z2;
  var xx = x4 * x22;
  var yx = y4 * x22;
  var yy = y4 * y22;
  var zx = z2 * x22;
  var zy = z2 * y22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
function perspectiveZO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr2 = 1 / (left - right);
  var bt2 = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr2;
  out[13] = (top + bottom) * bt2;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr2 = 1 / (left - right);
  var bt2 = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr2;
  out[13] = (top + bottom) * bt2;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x22, y0, y1, y22, z0, z1, z2, len6;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity5(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len6 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len6;
  z1 *= len6;
  z2 *= len6;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x22 = upx * z1 - upy * z0;
  len6 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
  if (!len6) {
    x0 = 0;
    x1 = 0;
    x22 = 0;
  } else {
    len6 = 1 / len6;
    x0 *= len6;
    x1 *= len6;
    x22 *= len6;
  }
  y0 = z1 * x22 - z2 * x1;
  y1 = z2 * x0 - z0 * x22;
  y22 = z0 * x1 - z1 * x0;
  len6 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
  if (!len6) {
    y0 = 0;
    y1 = 0;
    y22 = 0;
  } else {
    len6 = 1 / len6;
    y0 *= len6;
    y1 *= len6;
    y22 *= len6;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x22;
  out[9] = y22;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len6 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    z0 *= len6;
    z1 *= len6;
    z2 *= len6;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
  len6 = x0 * x0 + x1 * x1 + x22 * x22;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    x0 *= len6;
    x1 *= len6;
    x22 *= len6;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x22;
  out[3] = 0;
  out[4] = z1 * x22 - z2 * x1;
  out[5] = z2 * x0 - z0 * x22;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str4(a3) {
  return "mat4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ", " + a3[8] + ", " + a3[9] + ", " + a3[10] + ", " + a3[11] + ", " + a3[12] + ", " + a3[13] + ", " + a3[14] + ", " + a3[15] + ")";
}
function frob4(a3) {
  return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3] + a3[4] * a3[4] + a3[5] * a3[5] + a3[6] * a3[6] + a3[7] * a3[7] + a3[8] * a3[8] + a3[9] * a3[9] + a3[10] * a3[10] + a3[11] * a3[11] + a3[12] * a3[12] + a3[13] * a3[13] + a3[14] * a3[14] + a3[15] * a3[15]);
}
function add4(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  out[2] = a3[2] + b10[2];
  out[3] = a3[3] + b10[3];
  out[4] = a3[4] + b10[4];
  out[5] = a3[5] + b10[5];
  out[6] = a3[6] + b10[6];
  out[7] = a3[7] + b10[7];
  out[8] = a3[8] + b10[8];
  out[9] = a3[9] + b10[9];
  out[10] = a3[10] + b10[10];
  out[11] = a3[11] + b10[11];
  out[12] = a3[12] + b10[12];
  out[13] = a3[13] + b10[13];
  out[14] = a3[14] + b10[14];
  out[15] = a3[15] + b10[15];
  return out;
}
function subtract4(out, a3, b10) {
  out[0] = a3[0] - b10[0];
  out[1] = a3[1] - b10[1];
  out[2] = a3[2] - b10[2];
  out[3] = a3[3] - b10[3];
  out[4] = a3[4] - b10[4];
  out[5] = a3[5] - b10[5];
  out[6] = a3[6] - b10[6];
  out[7] = a3[7] - b10[7];
  out[8] = a3[8] - b10[8];
  out[9] = a3[9] - b10[9];
  out[10] = a3[10] - b10[10];
  out[11] = a3[11] - b10[11];
  out[12] = a3[12] - b10[12];
  out[13] = a3[13] - b10[13];
  out[14] = a3[14] - b10[14];
  out[15] = a3[15] - b10[15];
  return out;
}
function multiplyScalar4(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  out[2] = a3[2] * b10;
  out[3] = a3[3] * b10;
  out[4] = a3[4] * b10;
  out[5] = a3[5] * b10;
  out[6] = a3[6] * b10;
  out[7] = a3[7] * b10;
  out[8] = a3[8] * b10;
  out[9] = a3[9] * b10;
  out[10] = a3[10] * b10;
  out[11] = a3[11] * b10;
  out[12] = a3[12] * b10;
  out[13] = a3[13] * b10;
  out[14] = a3[14] * b10;
  out[15] = a3[15] * b10;
  return out;
}
function multiplyScalarAndAdd4(out, a3, b10, scale12) {
  out[0] = a3[0] + b10[0] * scale12;
  out[1] = a3[1] + b10[1] * scale12;
  out[2] = a3[2] + b10[2] * scale12;
  out[3] = a3[3] + b10[3] * scale12;
  out[4] = a3[4] + b10[4] * scale12;
  out[5] = a3[5] + b10[5] * scale12;
  out[6] = a3[6] + b10[6] * scale12;
  out[7] = a3[7] + b10[7] * scale12;
  out[8] = a3[8] + b10[8] * scale12;
  out[9] = a3[9] + b10[9] * scale12;
  out[10] = a3[10] + b10[10] * scale12;
  out[11] = a3[11] + b10[11] * scale12;
  out[12] = a3[12] + b10[12] * scale12;
  out[13] = a3[13] + b10[13] * scale12;
  out[14] = a3[14] + b10[14] * scale12;
  out[15] = a3[15] + b10[15] * scale12;
  return out;
}
function exactEquals4(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1] && a3[2] === b10[2] && a3[3] === b10[3] && a3[4] === b10[4] && a3[5] === b10[5] && a3[6] === b10[6] && a3[7] === b10[7] && a3[8] === b10[8] && a3[9] === b10[9] && a3[10] === b10[10] && a3[11] === b10[11] && a3[12] === b10[12] && a3[13] === b10[13] && a3[14] === b10[14] && a3[15] === b10[15];
}
function equals5(a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7];
  var a8 = a3[8], a9 = a3[9], a10 = a3[10], a11 = a3[11];
  var a12 = a3[12], a13 = a3[13], a14 = a3[14], a15 = a3[15];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  var b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7];
  var b82 = b10[8], b92 = b10[9], b102 = b10[10], b11 = b10[11];
  var b122 = b10[12], b13 = b10[13], b14 = b10[14], b15 = b10[15];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82)) && Math.abs(a9 - b92) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b92)) && Math.abs(a10 - b102) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b102)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b122) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b122)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var perspective, ortho, mul4, sub4;
var init_mat4 = __esm({
  "node_modules/gl-matrix/esm/mat4.js"() {
    init_common();
    perspective = perspectiveNO;
    ortho = orthoNO;
    mul4 = multiply4;
    sub4 = subtract4;
  }
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add5,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone6,
  copy: () => copy5,
  create: () => create5,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues5,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul5,
  multiply: () => multiply5,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round2,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set6,
  slerp: () => slerp,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str5,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create5() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone6(a3) {
  var out = new ARRAY_TYPE(3);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  return out;
}
function length(a3) {
  var x4 = a3[0];
  var y4 = a3[1];
  var z2 = a3[2];
  return Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2);
}
function fromValues5(x4, y4, z2) {
  var out = new ARRAY_TYPE(3);
  out[0] = x4;
  out[1] = y4;
  out[2] = z2;
  return out;
}
function copy5(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  return out;
}
function set6(out, x4, y4, z2) {
  out[0] = x4;
  out[1] = y4;
  out[2] = z2;
  return out;
}
function add5(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  out[2] = a3[2] + b10[2];
  return out;
}
function subtract5(out, a3, b10) {
  out[0] = a3[0] - b10[0];
  out[1] = a3[1] - b10[1];
  out[2] = a3[2] - b10[2];
  return out;
}
function multiply5(out, a3, b10) {
  out[0] = a3[0] * b10[0];
  out[1] = a3[1] * b10[1];
  out[2] = a3[2] * b10[2];
  return out;
}
function divide(out, a3, b10) {
  out[0] = a3[0] / b10[0];
  out[1] = a3[1] / b10[1];
  out[2] = a3[2] / b10[2];
  return out;
}
function ceil(out, a3) {
  out[0] = Math.ceil(a3[0]);
  out[1] = Math.ceil(a3[1]);
  out[2] = Math.ceil(a3[2]);
  return out;
}
function floor(out, a3) {
  out[0] = Math.floor(a3[0]);
  out[1] = Math.floor(a3[1]);
  out[2] = Math.floor(a3[2]);
  return out;
}
function min(out, a3, b10) {
  out[0] = Math.min(a3[0], b10[0]);
  out[1] = Math.min(a3[1], b10[1]);
  out[2] = Math.min(a3[2], b10[2]);
  return out;
}
function max(out, a3, b10) {
  out[0] = Math.max(a3[0], b10[0]);
  out[1] = Math.max(a3[1], b10[1]);
  out[2] = Math.max(a3[2], b10[2]);
  return out;
}
function round2(out, a3) {
  out[0] = round(a3[0]);
  out[1] = round(a3[1]);
  out[2] = round(a3[2]);
  return out;
}
function scale5(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  out[2] = a3[2] * b10;
  return out;
}
function scaleAndAdd(out, a3, b10, scale12) {
  out[0] = a3[0] + b10[0] * scale12;
  out[1] = a3[1] + b10[1] * scale12;
  out[2] = a3[2] + b10[2] * scale12;
  return out;
}
function distance(a3, b10) {
  var x4 = b10[0] - a3[0];
  var y4 = b10[1] - a3[1];
  var z2 = b10[2] - a3[2];
  return Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2);
}
function squaredDistance(a3, b10) {
  var x4 = b10[0] - a3[0];
  var y4 = b10[1] - a3[1];
  var z2 = b10[2] - a3[2];
  return x4 * x4 + y4 * y4 + z2 * z2;
}
function squaredLength(a3) {
  var x4 = a3[0];
  var y4 = a3[1];
  var z2 = a3[2];
  return x4 * x4 + y4 * y4 + z2 * z2;
}
function negate(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  out[2] = -a3[2];
  return out;
}
function inverse(out, a3) {
  out[0] = 1 / a3[0];
  out[1] = 1 / a3[1];
  out[2] = 1 / a3[2];
  return out;
}
function normalize(out, a3) {
  var x4 = a3[0];
  var y4 = a3[1];
  var z2 = a3[2];
  var len6 = x4 * x4 + y4 * y4 + z2 * z2;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a3[0] * len6;
  out[1] = a3[1] * len6;
  out[2] = a3[2] * len6;
  return out;
}
function dot(a3, b10) {
  return a3[0] * b10[0] + a3[1] * b10[1] + a3[2] * b10[2];
}
function cross(out, a3, b10) {
  var ax = a3[0], ay = a3[1], az = a3[2];
  var bx = b10[0], by = b10[1], bz = b10[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a3, b10, t4) {
  var ax = a3[0];
  var ay = a3[1];
  var az = a3[2];
  out[0] = ax + t4 * (b10[0] - ax);
  out[1] = ay + t4 * (b10[1] - ay);
  out[2] = az + t4 * (b10[2] - az);
  return out;
}
function slerp(out, a3, b10, t4) {
  var angle3 = Math.acos(Math.min(Math.max(dot(a3, b10), -1), 1));
  var sinTotal = Math.sin(angle3);
  var ratioA = Math.sin((1 - t4) * angle3) / sinTotal;
  var ratioB = Math.sin(t4 * angle3) / sinTotal;
  out[0] = ratioA * a3[0] + ratioB * b10[0];
  out[1] = ratioA * a3[1] + ratioB * b10[1];
  out[2] = ratioA * a3[2] + ratioB * b10[2];
  return out;
}
function hermite(out, a3, b10, c3, d2, t4) {
  var factorTimes2 = t4 * t4;
  var factor1 = factorTimes2 * (2 * t4 - 3) + 1;
  var factor2 = factorTimes2 * (t4 - 2) + t4;
  var factor3 = factorTimes2 * (t4 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t4);
  out[0] = a3[0] * factor1 + b10[0] * factor2 + c3[0] * factor3 + d2[0] * factor4;
  out[1] = a3[1] * factor1 + b10[1] * factor2 + c3[1] * factor3 + d2[1] * factor4;
  out[2] = a3[2] * factor1 + b10[2] * factor2 + c3[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a3, b10, c3, d2, t4) {
  var inverseFactor = 1 - t4;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t4 * t4;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t4 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t4;
  out[0] = a3[0] * factor1 + b10[0] * factor2 + c3[0] * factor3 + d2[0] * factor4;
  out[1] = a3[1] * factor1 + b10[1] * factor2 + c3[1] * factor3 + d2[1] * factor4;
  out[2] = a3[2] * factor1 + b10[2] * factor2 + c3[2] * factor3 + d2[2] * factor4;
  return out;
}
function random(out, scale12) {
  scale12 = scale12 === void 0 ? 1 : scale12;
  var r2 = RANDOM() * 2 * Math.PI;
  var z2 = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z2 * z2) * scale12;
  out[0] = Math.cos(r2) * zScale;
  out[1] = Math.sin(r2) * zScale;
  out[2] = z2 * scale12;
  return out;
}
function transformMat4(out, a3, m3) {
  var x4 = a3[0], y4 = a3[1], z2 = a3[2];
  var w2 = m3[3] * x4 + m3[7] * y4 + m3[11] * z2 + m3[15];
  w2 = w2 || 1;
  out[0] = (m3[0] * x4 + m3[4] * y4 + m3[8] * z2 + m3[12]) / w2;
  out[1] = (m3[1] * x4 + m3[5] * y4 + m3[9] * z2 + m3[13]) / w2;
  out[2] = (m3[2] * x4 + m3[6] * y4 + m3[10] * z2 + m3[14]) / w2;
  return out;
}
function transformMat3(out, a3, m3) {
  var x4 = a3[0], y4 = a3[1], z2 = a3[2];
  out[0] = x4 * m3[0] + y4 * m3[3] + z2 * m3[6];
  out[1] = x4 * m3[1] + y4 * m3[4] + z2 * m3[7];
  out[2] = x4 * m3[2] + y4 * m3[5] + z2 * m3[8];
  return out;
}
function transformQuat(out, a3, q2) {
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3];
  var vx = a3[0], vy = a3[1], vz = a3[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}
function rotateX2(out, a3, b10, rad) {
  var p2 = [], r2 = [];
  p2[0] = a3[0] - b10[0];
  p2[1] = a3[1] - b10[1];
  p2[2] = a3[2] - b10[2];
  r2[0] = p2[0];
  r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r2[0] + b10[0];
  out[1] = r2[1] + b10[1];
  out[2] = r2[2] + b10[2];
  return out;
}
function rotateY2(out, a3, b10, rad) {
  var p2 = [], r2 = [];
  p2[0] = a3[0] - b10[0];
  p2[1] = a3[1] - b10[1];
  p2[2] = a3[2] - b10[2];
  r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r2[1] = p2[1];
  r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r2[0] + b10[0];
  out[1] = r2[1] + b10[1];
  out[2] = r2[2] + b10[2];
  return out;
}
function rotateZ2(out, a3, b10, rad) {
  var p2 = [], r2 = [];
  p2[0] = a3[0] - b10[0];
  p2[1] = a3[1] - b10[1];
  p2[2] = a3[2] - b10[2];
  r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r2[2] = p2[2];
  out[0] = r2[0] + b10[0];
  out[1] = r2[1] + b10[1];
  out[2] = r2[2] + b10[2];
  return out;
}
function angle(a3, b10) {
  var ax = a3[0], ay = a3[1], az = a3[2], bx = b10[0], by = b10[1], bz = b10[2], mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)), cosine = mag && dot(a3, b10) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str5(a3) {
  return "vec3(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ")";
}
function exactEquals5(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1] && a3[2] === b10[2];
}
function equals6(a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub5, mul5, div, dist, sqrDist, len, sqrLen, forEach;
var init_vec3 = __esm({
  "node_modules/gl-matrix/esm/vec3.js"() {
    init_common();
    sub5 = subtract5;
    mul5 = multiply5;
    div = divide;
    dist = distance;
    sqrDist = squaredDistance;
    len = length;
    sqrLen = squaredLength;
    forEach = function() {
      var vec = create5();
      return function(a3, stride, offset, count, fn2, arg) {
        var i2, l2;
        if (!stride) {
          stride = 3;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l2 = Math.min(count * stride + offset, a3.length);
        } else {
          l2 = a3.length;
        }
        for (i2 = offset; i2 < l2; i2 += stride) {
          vec[0] = a3[i2];
          vec[1] = a3[i2 + 1];
          vec[2] = a3[i2 + 2];
          fn2(vec, vec, arg);
          a3[i2] = vec[0];
          a3[i2 + 1] = vec[1];
          a3[i2 + 2] = vec[2];
        }
        return a3;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add6,
  ceil: () => ceil2,
  clone: () => clone7,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals7,
  exactEquals: () => exactEquals6,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues6,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round3,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set7,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str6,
  sub: () => sub6,
  subtract: () => subtract6,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create6() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone7(a3) {
  var out = new ARRAY_TYPE(4);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  return out;
}
function fromValues6(x4, y4, z2, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x4;
  out[1] = y4;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function copy6(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  return out;
}
function set7(out, x4, y4, z2, w2) {
  out[0] = x4;
  out[1] = y4;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function add6(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  out[2] = a3[2] + b10[2];
  out[3] = a3[3] + b10[3];
  return out;
}
function subtract6(out, a3, b10) {
  out[0] = a3[0] - b10[0];
  out[1] = a3[1] - b10[1];
  out[2] = a3[2] - b10[2];
  out[3] = a3[3] - b10[3];
  return out;
}
function multiply6(out, a3, b10) {
  out[0] = a3[0] * b10[0];
  out[1] = a3[1] * b10[1];
  out[2] = a3[2] * b10[2];
  out[3] = a3[3] * b10[3];
  return out;
}
function divide2(out, a3, b10) {
  out[0] = a3[0] / b10[0];
  out[1] = a3[1] / b10[1];
  out[2] = a3[2] / b10[2];
  out[3] = a3[3] / b10[3];
  return out;
}
function ceil2(out, a3) {
  out[0] = Math.ceil(a3[0]);
  out[1] = Math.ceil(a3[1]);
  out[2] = Math.ceil(a3[2]);
  out[3] = Math.ceil(a3[3]);
  return out;
}
function floor2(out, a3) {
  out[0] = Math.floor(a3[0]);
  out[1] = Math.floor(a3[1]);
  out[2] = Math.floor(a3[2]);
  out[3] = Math.floor(a3[3]);
  return out;
}
function min2(out, a3, b10) {
  out[0] = Math.min(a3[0], b10[0]);
  out[1] = Math.min(a3[1], b10[1]);
  out[2] = Math.min(a3[2], b10[2]);
  out[3] = Math.min(a3[3], b10[3]);
  return out;
}
function max2(out, a3, b10) {
  out[0] = Math.max(a3[0], b10[0]);
  out[1] = Math.max(a3[1], b10[1]);
  out[2] = Math.max(a3[2], b10[2]);
  out[3] = Math.max(a3[3], b10[3]);
  return out;
}
function round3(out, a3) {
  out[0] = round(a3[0]);
  out[1] = round(a3[1]);
  out[2] = round(a3[2]);
  out[3] = round(a3[3]);
  return out;
}
function scale6(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  out[2] = a3[2] * b10;
  out[3] = a3[3] * b10;
  return out;
}
function scaleAndAdd2(out, a3, b10, scale12) {
  out[0] = a3[0] + b10[0] * scale12;
  out[1] = a3[1] + b10[1] * scale12;
  out[2] = a3[2] + b10[2] * scale12;
  out[3] = a3[3] + b10[3] * scale12;
  return out;
}
function distance2(a3, b10) {
  var x4 = b10[0] - a3[0];
  var y4 = b10[1] - a3[1];
  var z2 = b10[2] - a3[2];
  var w2 = b10[3] - a3[3];
  return Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2 + w2 * w2);
}
function squaredDistance2(a3, b10) {
  var x4 = b10[0] - a3[0];
  var y4 = b10[1] - a3[1];
  var z2 = b10[2] - a3[2];
  var w2 = b10[3] - a3[3];
  return x4 * x4 + y4 * y4 + z2 * z2 + w2 * w2;
}
function length2(a3) {
  var x4 = a3[0];
  var y4 = a3[1];
  var z2 = a3[2];
  var w2 = a3[3];
  return Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2 + w2 * w2);
}
function squaredLength2(a3) {
  var x4 = a3[0];
  var y4 = a3[1];
  var z2 = a3[2];
  var w2 = a3[3];
  return x4 * x4 + y4 * y4 + z2 * z2 + w2 * w2;
}
function negate2(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  out[2] = -a3[2];
  out[3] = -a3[3];
  return out;
}
function inverse2(out, a3) {
  out[0] = 1 / a3[0];
  out[1] = 1 / a3[1];
  out[2] = 1 / a3[2];
  out[3] = 1 / a3[3];
  return out;
}
function normalize2(out, a3) {
  var x4 = a3[0];
  var y4 = a3[1];
  var z2 = a3[2];
  var w2 = a3[3];
  var len6 = x4 * x4 + y4 * y4 + z2 * z2 + w2 * w2;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = x4 * len6;
  out[1] = y4 * len6;
  out[2] = z2 * len6;
  out[3] = w2 * len6;
  return out;
}
function dot2(a3, b10) {
  return a3[0] * b10[0] + a3[1] * b10[1] + a3[2] * b10[2] + a3[3] * b10[3];
}
function cross2(out, u2, v2, w2) {
  var A3 = v2[0] * w2[1] - v2[1] * w2[0], B3 = v2[0] * w2[2] - v2[2] * w2[0], C3 = v2[0] * w2[3] - v2[3] * w2[0], D3 = v2[1] * w2[2] - v2[2] * w2[1], E3 = v2[1] * w2[3] - v2[3] * w2[1], F2 = v2[2] * w2[3] - v2[3] * w2[2];
  var G2 = u2[0];
  var H2 = u2[1];
  var I2 = u2[2];
  var J2 = u2[3];
  out[0] = H2 * F2 - I2 * E3 + J2 * D3;
  out[1] = -(G2 * F2) + I2 * C3 - J2 * B3;
  out[2] = G2 * E3 - H2 * C3 + J2 * A3;
  out[3] = -(G2 * D3) + H2 * B3 - I2 * A3;
  return out;
}
function lerp2(out, a3, b10, t4) {
  var ax = a3[0];
  var ay = a3[1];
  var az = a3[2];
  var aw = a3[3];
  out[0] = ax + t4 * (b10[0] - ax);
  out[1] = ay + t4 * (b10[1] - ay);
  out[2] = az + t4 * (b10[2] - az);
  out[3] = aw + t4 * (b10[3] - aw);
  return out;
}
function random2(out, scale12) {
  scale12 = scale12 === void 0 ? 1 : scale12;
  var v1, v2, v3, v4;
  var s1, s2;
  var rand;
  rand = RANDOM();
  v1 = rand * 2 - 1;
  v2 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s1 = v1 * v1 + v2 * v2;
  rand = RANDOM();
  v3 = rand * 2 - 1;
  v4 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s2 = v3 * v3 + v4 * v4;
  var d2 = Math.sqrt((1 - s1) / s2);
  out[0] = scale12 * v1;
  out[1] = scale12 * v2;
  out[2] = scale12 * v3 * d2;
  out[3] = scale12 * v4 * d2;
  return out;
}
function transformMat42(out, a3, m3) {
  var x4 = a3[0], y4 = a3[1], z2 = a3[2], w2 = a3[3];
  out[0] = m3[0] * x4 + m3[4] * y4 + m3[8] * z2 + m3[12] * w2;
  out[1] = m3[1] * x4 + m3[5] * y4 + m3[9] * z2 + m3[13] * w2;
  out[2] = m3[2] * x4 + m3[6] * y4 + m3[10] * z2 + m3[14] * w2;
  out[3] = m3[3] * x4 + m3[7] * y4 + m3[11] * z2 + m3[15] * w2;
  return out;
}
function transformQuat2(out, a3, q2) {
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3];
  var vx = a3[0], vy = a3[1], vz = a3[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  out[3] = a3[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str6(a3) {
  return "vec4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
}
function exactEquals6(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1] && a3[2] === b10[2] && a3[3] === b10[3];
}
function equals7(a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32));
}
var sub6, mul6, div2, dist2, sqrDist2, len2, sqrLen2, forEach2;
var init_vec4 = __esm({
  "node_modules/gl-matrix/esm/vec4.js"() {
    init_common();
    sub6 = subtract6;
    mul6 = multiply6;
    div2 = divide2;
    dist2 = distance2;
    sqrDist2 = squaredDistance2;
    len2 = length2;
    sqrLen2 = squaredLength2;
    forEach2 = function() {
      var vec = create6();
      return function(a3, stride, offset, count, fn2, arg) {
        var i2, l2;
        if (!stride) {
          stride = 4;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l2 = Math.min(count * stride + offset, a3.length);
        } else {
          l2 = a3.length;
        }
        for (i2 = offset; i2 < l2; i2 += stride) {
          vec[0] = a3[i2];
          vec[1] = a3[i2 + 1];
          vec[2] = a3[i2 + 2];
          vec[3] = a3[i2 + 3];
          fn2(vec, vec, arg);
          a3[i2] = vec[0];
          a3[i2 + 1] = vec[1];
          a3[i2 + 2] = vec[2];
          a3[i2 + 3] = vec[3];
        }
        return a3;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add7,
  calculateW: () => calculateW,
  clone: () => clone8,
  conjugate: () => conjugate,
  copy: () => copy7,
  create: () => create7,
  dot: () => dot3,
  equals: () => equals8,
  exactEquals: () => exactEquals7,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues7,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity6,
  invert: () => invert5,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul7,
  multiply: () => multiply7,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale7,
  set: () => set8,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp2,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str7
});
function create7() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity6(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s2 = Math.sin(rad);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q2) {
  var rad = Math.acos(q2[3]) * 2;
  var s2 = Math.sin(rad / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q2[0] / s2;
    out_axis[1] = q2[1] / s2;
    out_axis[2] = q2[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a3, b10) {
  var dotproduct = dot3(a3, b10);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply7(out, a3, b10) {
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bx = b10[0], by = b10[1], bz = b10[2], bw = b10[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a3, rad) {
  rad *= 0.5;
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a3, rad) {
  rad *= 0.5;
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a3, rad) {
  rad *= 0.5;
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a3) {
  var x4 = a3[0], y4 = a3[1], z2 = a3[2];
  out[0] = x4;
  out[1] = y4;
  out[2] = z2;
  out[3] = Math.sqrt(Math.abs(1 - x4 * x4 - y4 * y4 - z2 * z2));
  return out;
}
function exp(out, a3) {
  var x4 = a3[0], y4 = a3[1], z2 = a3[2], w2 = a3[3];
  var r2 = Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2);
  var et2 = Math.exp(w2);
  var s2 = r2 > 0 ? et2 * Math.sin(r2) / r2 : 0;
  out[0] = x4 * s2;
  out[1] = y4 * s2;
  out[2] = z2 * s2;
  out[3] = et2 * Math.cos(r2);
  return out;
}
function ln(out, a3) {
  var x4 = a3[0], y4 = a3[1], z2 = a3[2], w2 = a3[3];
  var r2 = Math.sqrt(x4 * x4 + y4 * y4 + z2 * z2);
  var t4 = r2 > 0 ? Math.atan2(r2, w2) / r2 : 0;
  out[0] = x4 * t4;
  out[1] = y4 * t4;
  out[2] = z2 * t4;
  out[3] = 0.5 * Math.log(x4 * x4 + y4 * y4 + z2 * z2 + w2 * w2);
  return out;
}
function pow(out, a3, b10) {
  ln(out, a3);
  scale7(out, out, b10);
  exp(out, out);
  return out;
}
function slerp2(out, a3, b10, t4) {
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bx = b10[0], by = b10[1], bz = b10[2], bw = b10[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t4) * omega) / sinom;
    scale1 = Math.sin(t4 * omega) / sinom;
  } else {
    scale0 = 1 - t4;
    scale1 = t4;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert5(out, a3) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var dot6 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
  var invDot = dot6 ? 1 / dot6 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a32 * invDot;
  return out;
}
function conjugate(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  out[2] = -a3[2];
  out[3] = a3[3];
  return out;
}
function fromMat3(out, m3) {
  var fTrace = m3[0] + m3[4] + m3[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m3[5] - m3[7]) * fRoot;
    out[1] = (m3[6] - m3[2]) * fRoot;
    out[2] = (m3[1] - m3[3]) * fRoot;
  } else {
    var i2 = 0;
    if (m3[4] > m3[0]) i2 = 1;
    if (m3[8] > m3[i2 * 3 + i2]) i2 = 2;
    var j2 = (i2 + 1) % 3;
    var k2 = (i2 + 2) % 3;
    fRoot = Math.sqrt(m3[i2 * 3 + i2] - m3[j2 * 3 + j2] - m3[k2 * 3 + k2] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m3[j2 * 3 + k2] - m3[k2 * 3 + j2]) * fRoot;
    out[j2] = (m3[j2 * 3 + i2] + m3[i2 * 3 + j2]) * fRoot;
    out[k2] = (m3[k2 * 3 + i2] + m3[i2 * 3 + k2]) * fRoot;
  }
  return out;
}
function fromEuler(out, x4, y4, z2) {
  var order = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ANGLE_ORDER;
  var halfToRad = Math.PI / 360;
  x4 *= halfToRad;
  z2 *= halfToRad;
  y4 *= halfToRad;
  var sx = Math.sin(x4);
  var cx = Math.cos(x4);
  var sy = Math.sin(y4);
  var cy = Math.cos(y4);
  var sz = Math.sin(z2);
  var cz = Math.cos(z2);
  switch (order) {
    case "xyz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "xzy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yxz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yzx":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zxy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zyx":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    default:
      throw new Error("Unknown angle order " + order);
  }
  return out;
}
function str7(a3) {
  return "quat(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
}
function equals8(a3, b10) {
  return Math.abs(dot2(a3, b10)) >= 1 - EPSILON;
}
var clone8, fromValues7, copy7, set8, add7, mul7, scale7, dot3, lerp3, length3, len3, squaredLength3, sqrLen3, normalize3, exactEquals7, rotationTo, sqlerp, setAxes;
var init_quat = __esm({
  "node_modules/gl-matrix/esm/quat.js"() {
    init_common();
    init_mat3();
    init_vec3();
    init_vec4();
    clone8 = clone7;
    fromValues7 = fromValues6;
    copy7 = copy6;
    set8 = set7;
    add7 = add6;
    mul7 = multiply7;
    scale7 = scale6;
    dot3 = dot2;
    lerp3 = lerp2;
    length3 = length2;
    len3 = length3;
    squaredLength3 = squaredLength2;
    sqrLen3 = squaredLength3;
    normalize3 = normalize2;
    exactEquals7 = exactEquals6;
    rotationTo = function() {
      var tmpvec3 = create5();
      var xUnitVec3 = fromValues5(1, 0, 0);
      var yUnitVec3 = fromValues5(0, 1, 0);
      return function(out, a3, b10) {
        var dot6 = dot(a3, b10);
        if (dot6 < -0.999999) {
          cross(tmpvec3, xUnitVec3, a3);
          if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a3);
          normalize(tmpvec3, tmpvec3);
          setAxisAngle(out, tmpvec3, Math.PI);
          return out;
        } else if (dot6 > 0.999999) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        } else {
          cross(tmpvec3, a3, b10);
          out[0] = tmpvec3[0];
          out[1] = tmpvec3[1];
          out[2] = tmpvec3[2];
          out[3] = 1 + dot6;
          return normalize3(out, out);
        }
      };
    }();
    sqlerp = function() {
      var temp1 = create7();
      var temp2 = create7();
      return function(out, a3, b10, c3, d2, t4) {
        slerp2(temp1, a3, d2, t4);
        slerp2(temp2, b10, c3, t4);
        slerp2(out, temp1, temp2, 2 * t4 * (1 - t4));
        return out;
      };
    }();
    setAxes = function() {
      var matr = create3();
      return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize3(out, fromMat3(out, matr));
      };
    }();
  }
});

// node_modules/gl-matrix/esm/quat2.js
var quat2_exports = {};
__export(quat2_exports, {
  add: () => add8,
  clone: () => clone9,
  conjugate: () => conjugate2,
  copy: () => copy8,
  create: () => create8,
  dot: () => dot4,
  equals: () => equals9,
  exactEquals: () => exactEquals8,
  fromMat4: () => fromMat42,
  fromRotation: () => fromRotation5,
  fromRotationTranslation: () => fromRotationTranslation2,
  fromRotationTranslationValues: () => fromRotationTranslationValues,
  fromTranslation: () => fromTranslation4,
  fromValues: () => fromValues8,
  getDual: () => getDual,
  getReal: () => getReal,
  getTranslation: () => getTranslation2,
  identity: () => identity7,
  invert: () => invert6,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  mul: () => mul8,
  multiply: () => multiply8,
  normalize: () => normalize4,
  rotateAroundAxis: () => rotateAroundAxis,
  rotateByQuatAppend: () => rotateByQuatAppend,
  rotateByQuatPrepend: () => rotateByQuatPrepend,
  rotateX: () => rotateX4,
  rotateY: () => rotateY4,
  rotateZ: () => rotateZ4,
  scale: () => scale8,
  set: () => set9,
  setDual: () => setDual,
  setReal: () => setReal,
  sqrLen: () => sqrLen4,
  squaredLength: () => squaredLength4,
  str: () => str8,
  translate: () => translate4
});
function create8() {
  var dq = new ARRAY_TYPE(8);
  if (ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}
function clone9(a3) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = a3[0];
  dq[1] = a3[1];
  dq[2] = a3[2];
  dq[3] = a3[3];
  dq[4] = a3[4];
  dq[5] = a3[5];
  dq[6] = a3[6];
  dq[7] = a3[7];
  return dq;
}
function fromValues8(x1, y1, z1, w1, x22, y22, z2, w2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x22;
  dq[5] = y22;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x22, y22, z2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x22 * 0.5, ay = y22 * 0.5, az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
function fromRotationTranslation2(out, q2, t4) {
  var ax = t4[0] * 0.5, ay = t4[1] * 0.5, az = t4[2] * 0.5, bx = q2[0], by = q2[1], bz = q2[2], bw = q2[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
function fromTranslation4(out, t4) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t4[0] * 0.5;
  out[5] = t4[1] * 0.5;
  out[6] = t4[2] * 0.5;
  out[7] = 0;
  return out;
}
function fromRotation5(out, q2) {
  out[0] = q2[0];
  out[1] = q2[1];
  out[2] = q2[2];
  out[3] = q2[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function fromMat42(out, a3) {
  var outer = create7();
  getRotation(outer, a3);
  var t4 = new ARRAY_TYPE(3);
  getTranslation(t4, a3);
  fromRotationTranslation2(out, outer, t4);
  return out;
}
function copy8(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  return out;
}
function identity7(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function set9(out, x1, y1, z1, w1, x22, y22, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x22;
  out[5] = y22;
  out[6] = z2;
  out[7] = w2;
  return out;
}
function getDual(out, a3) {
  out[0] = a3[4];
  out[1] = a3[5];
  out[2] = a3[6];
  out[3] = a3[7];
  return out;
}
function setDual(out, q2) {
  out[4] = q2[0];
  out[5] = q2[1];
  out[6] = q2[2];
  out[7] = q2[3];
  return out;
}
function getTranslation2(out, a3) {
  var ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7], bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
function translate4(out, a3, v2) {
  var ax1 = a3[0], ay1 = a3[1], az1 = a3[2], aw1 = a3[3], bx1 = v2[0] * 0.5, by1 = v2[1] * 0.5, bz1 = v2[2] * 0.5, ax2 = a3[4], ay2 = a3[5], az2 = a3[6], aw2 = a3[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
function rotateX4(out, a3, rad) {
  var bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3], ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateX3(out, a3, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateY4(out, a3, rad) {
  var bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3], ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateY3(out, a3, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateZ4(out, a3, rad) {
  var bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3], ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateZ3(out, a3, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateByQuatAppend(out, a3, q2) {
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3], ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a3[4];
  ay = a3[5];
  az = a3[6];
  aw = a3[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
function rotateByQuatPrepend(out, q2, a3) {
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3], bx = a3[0], by = a3[1], bz = a3[2], bw = a3[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a3[4];
  by = a3[5];
  bz = a3[6];
  bw = a3[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
function rotateAroundAxis(out, a3, axis, rad) {
  if (Math.abs(rad) < EPSILON) {
    return copy8(out, a3);
  }
  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
  rad = rad * 0.5;
  var s2 = Math.sin(rad);
  var bx = s2 * axis[0] / axisLength;
  var by = s2 * axis[1] / axisLength;
  var bz = s2 * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a3[0], ay1 = a3[1], az1 = a3[2], aw1 = a3[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function add8(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  out[2] = a3[2] + b10[2];
  out[3] = a3[3] + b10[3];
  out[4] = a3[4] + b10[4];
  out[5] = a3[5] + b10[5];
  out[6] = a3[6] + b10[6];
  out[7] = a3[7] + b10[7];
  return out;
}
function multiply8(out, a3, b10) {
  var ax0 = a3[0], ay0 = a3[1], az0 = a3[2], aw0 = a3[3], bx1 = b10[4], by1 = b10[5], bz1 = b10[6], bw1 = b10[7], ax1 = a3[4], ay1 = a3[5], az1 = a3[6], aw1 = a3[7], bx0 = b10[0], by0 = b10[1], bz0 = b10[2], bw0 = b10[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
function scale8(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  out[2] = a3[2] * b10;
  out[3] = a3[3] * b10;
  out[4] = a3[4] * b10;
  out[5] = a3[5] * b10;
  out[6] = a3[6] * b10;
  out[7] = a3[7] * b10;
  return out;
}
function lerp4(out, a3, b10, t4) {
  var mt2 = 1 - t4;
  if (dot4(a3, b10) < 0) t4 = -t4;
  out[0] = a3[0] * mt2 + b10[0] * t4;
  out[1] = a3[1] * mt2 + b10[1] * t4;
  out[2] = a3[2] * mt2 + b10[2] * t4;
  out[3] = a3[3] * mt2 + b10[3] * t4;
  out[4] = a3[4] * mt2 + b10[4] * t4;
  out[5] = a3[5] * mt2 + b10[5] * t4;
  out[6] = a3[6] * mt2 + b10[6] * t4;
  out[7] = a3[7] * mt2 + b10[7] * t4;
  return out;
}
function invert6(out, a3) {
  var sqlen = squaredLength4(a3);
  out[0] = -a3[0] / sqlen;
  out[1] = -a3[1] / sqlen;
  out[2] = -a3[2] / sqlen;
  out[3] = a3[3] / sqlen;
  out[4] = -a3[4] / sqlen;
  out[5] = -a3[5] / sqlen;
  out[6] = -a3[6] / sqlen;
  out[7] = a3[7] / sqlen;
  return out;
}
function conjugate2(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  out[2] = -a3[2];
  out[3] = a3[3];
  out[4] = -a3[4];
  out[5] = -a3[5];
  out[6] = -a3[6];
  out[7] = a3[7];
  return out;
}
function normalize4(out, a3) {
  var magnitude = squaredLength4(a3);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a3[0] / magnitude;
    var a1 = a3[1] / magnitude;
    var a22 = a3[2] / magnitude;
    var a32 = a3[3] / magnitude;
    var b02 = a3[4];
    var b12 = a3[5];
    var b22 = a3[6];
    var b32 = a3[7];
    var a_dot_b = a0 * b02 + a1 * b12 + a22 * b22 + a32 * b32;
    out[0] = a0;
    out[1] = a1;
    out[2] = a22;
    out[3] = a32;
    out[4] = (b02 - a0 * a_dot_b) / magnitude;
    out[5] = (b12 - a1 * a_dot_b) / magnitude;
    out[6] = (b22 - a22 * a_dot_b) / magnitude;
    out[7] = (b32 - a32 * a_dot_b) / magnitude;
  }
  return out;
}
function str8(a3) {
  return "quat2(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ")";
}
function exactEquals8(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1] && a3[2] === b10[2] && a3[3] === b10[3] && a3[4] === b10[4] && a3[5] === b10[5] && a3[6] === b10[6] && a3[7] === b10[7];
}
function equals9(a3, b10) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72));
}
var getReal, setReal, mul8, dot4, length4, len4, squaredLength4, sqrLen4;
var init_quat2 = __esm({
  "node_modules/gl-matrix/esm/quat2.js"() {
    init_common();
    init_quat();
    init_mat4();
    getReal = copy7;
    setReal = copy7;
    mul8 = multiply8;
    dot4 = dot3;
    length4 = length3;
    len4 = length4;
    squaredLength4 = squaredLength3;
    sqrLen4 = squaredLength4;
  }
});

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add9,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone10,
  copy: () => copy9,
  create: () => create9,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot5,
  equals: () => equals10,
  exactEquals: () => exactEquals9,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues9,
  inverse: () => inverse3,
  len: () => len5,
  length: () => length5,
  lerp: () => lerp5,
  max: () => max3,
  min: () => min3,
  mul: () => mul9,
  multiply: () => multiply9,
  negate: () => negate3,
  normalize: () => normalize5,
  random: () => random4,
  rotate: () => rotate5,
  round: () => round4,
  scale: () => scale9,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set10,
  signedAngle: () => signedAngle,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen5,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength5,
  str: () => str9,
  sub: () => sub7,
  subtract: () => subtract7,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create9() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone10(a3) {
  var out = new ARRAY_TYPE(2);
  out[0] = a3[0];
  out[1] = a3[1];
  return out;
}
function fromValues9(x4, y4) {
  var out = new ARRAY_TYPE(2);
  out[0] = x4;
  out[1] = y4;
  return out;
}
function copy9(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  return out;
}
function set10(out, x4, y4) {
  out[0] = x4;
  out[1] = y4;
  return out;
}
function add9(out, a3, b10) {
  out[0] = a3[0] + b10[0];
  out[1] = a3[1] + b10[1];
  return out;
}
function subtract7(out, a3, b10) {
  out[0] = a3[0] - b10[0];
  out[1] = a3[1] - b10[1];
  return out;
}
function multiply9(out, a3, b10) {
  out[0] = a3[0] * b10[0];
  out[1] = a3[1] * b10[1];
  return out;
}
function divide3(out, a3, b10) {
  out[0] = a3[0] / b10[0];
  out[1] = a3[1] / b10[1];
  return out;
}
function ceil3(out, a3) {
  out[0] = Math.ceil(a3[0]);
  out[1] = Math.ceil(a3[1]);
  return out;
}
function floor3(out, a3) {
  out[0] = Math.floor(a3[0]);
  out[1] = Math.floor(a3[1]);
  return out;
}
function min3(out, a3, b10) {
  out[0] = Math.min(a3[0], b10[0]);
  out[1] = Math.min(a3[1], b10[1]);
  return out;
}
function max3(out, a3, b10) {
  out[0] = Math.max(a3[0], b10[0]);
  out[1] = Math.max(a3[1], b10[1]);
  return out;
}
function round4(out, a3) {
  out[0] = round(a3[0]);
  out[1] = round(a3[1]);
  return out;
}
function scale9(out, a3, b10) {
  out[0] = a3[0] * b10;
  out[1] = a3[1] * b10;
  return out;
}
function scaleAndAdd3(out, a3, b10, scale12) {
  out[0] = a3[0] + b10[0] * scale12;
  out[1] = a3[1] + b10[1] * scale12;
  return out;
}
function distance3(a3, b10) {
  var x4 = b10[0] - a3[0], y4 = b10[1] - a3[1];
  return Math.sqrt(x4 * x4 + y4 * y4);
}
function squaredDistance3(a3, b10) {
  var x4 = b10[0] - a3[0], y4 = b10[1] - a3[1];
  return x4 * x4 + y4 * y4;
}
function length5(a3) {
  var x4 = a3[0], y4 = a3[1];
  return Math.sqrt(x4 * x4 + y4 * y4);
}
function squaredLength5(a3) {
  var x4 = a3[0], y4 = a3[1];
  return x4 * x4 + y4 * y4;
}
function negate3(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  return out;
}
function inverse3(out, a3) {
  out[0] = 1 / a3[0];
  out[1] = 1 / a3[1];
  return out;
}
function normalize5(out, a3) {
  var x4 = a3[0], y4 = a3[1];
  var len6 = x4 * x4 + y4 * y4;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a3[0] * len6;
  out[1] = a3[1] * len6;
  return out;
}
function dot5(a3, b10) {
  return a3[0] * b10[0] + a3[1] * b10[1];
}
function cross3(out, a3, b10) {
  var z2 = a3[0] * b10[1] - a3[1] * b10[0];
  out[0] = out[1] = 0;
  out[2] = z2;
  return out;
}
function lerp5(out, a3, b10, t4) {
  var ax = a3[0], ay = a3[1];
  out[0] = ax + t4 * (b10[0] - ax);
  out[1] = ay + t4 * (b10[1] - ay);
  return out;
}
function random4(out, scale12) {
  scale12 = scale12 === void 0 ? 1 : scale12;
  var r2 = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r2) * scale12;
  out[1] = Math.sin(r2) * scale12;
  return out;
}
function transformMat2(out, a3, m3) {
  var x4 = a3[0], y4 = a3[1];
  out[0] = m3[0] * x4 + m3[2] * y4;
  out[1] = m3[1] * x4 + m3[3] * y4;
  return out;
}
function transformMat2d(out, a3, m3) {
  var x4 = a3[0], y4 = a3[1];
  out[0] = m3[0] * x4 + m3[2] * y4 + m3[4];
  out[1] = m3[1] * x4 + m3[3] * y4 + m3[5];
  return out;
}
function transformMat32(out, a3, m3) {
  var x4 = a3[0], y4 = a3[1];
  out[0] = m3[0] * x4 + m3[3] * y4 + m3[6];
  out[1] = m3[1] * x4 + m3[4] * y4 + m3[7];
  return out;
}
function transformMat43(out, a3, m3) {
  var x4 = a3[0];
  var y4 = a3[1];
  out[0] = m3[0] * x4 + m3[4] * y4 + m3[12];
  out[1] = m3[1] * x4 + m3[5] * y4 + m3[13];
  return out;
}
function rotate5(out, a3, b10, rad) {
  var p0 = a3[0] - b10[0], p1 = a3[1] - b10[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b10[0];
  out[1] = p0 * sinC + p1 * cosC + b10[1];
  return out;
}
function angle2(a3, b10) {
  var ax = a3[0], ay = a3[1], bx = b10[0], by = b10[1];
  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
}
function signedAngle(a3, b10) {
  var ax = a3[0], ay = a3[1], bx = b10[0], by = b10[1];
  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str9(a3) {
  return "vec2(" + a3[0] + ", " + a3[1] + ")";
}
function exactEquals9(a3, b10) {
  return a3[0] === b10[0] && a3[1] === b10[1];
}
function equals10(a3, b10) {
  var a0 = a3[0], a1 = a3[1];
  var b02 = b10[0], b12 = b10[1];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12));
}
var len5, sub7, mul9, div3, dist3, sqrDist3, sqrLen5, forEach3;
var init_vec2 = __esm({
  "node_modules/gl-matrix/esm/vec2.js"() {
    init_common();
    len5 = length5;
    sub7 = subtract7;
    mul9 = multiply9;
    div3 = divide3;
    dist3 = distance3;
    sqrDist3 = squaredDistance3;
    sqrLen5 = squaredLength5;
    forEach3 = function() {
      var vec = create9();
      return function(a3, stride, offset, count, fn2, arg) {
        var i2, l2;
        if (!stride) {
          stride = 2;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l2 = Math.min(count * stride + offset, a3.length);
        } else {
          l2 = a3.length;
        }
        for (i2 = offset; i2 < l2; i2 += stride) {
          vec[0] = a3[i2];
          vec[1] = a3[i2 + 1];
          fn2(vec, vec, arg);
          a3[i2] = vec[0];
          a3[i2 + 1] = vec[1];
        }
        return a3;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  glMatrix: () => common_exports,
  mat2: () => mat2_exports,
  mat2d: () => mat2d_exports,
  mat3: () => mat3_exports,
  mat4: () => mat4_exports,
  quat: () => quat_exports,
  quat2: () => quat2_exports,
  vec2: () => vec2_exports,
  vec3: () => vec3_exports,
  vec4: () => vec4_exports
});
var init_esm2 = __esm({
  "node_modules/gl-matrix/esm/index.js"() {
    init_common();
    init_mat2();
    init_mat2d();
    init_mat3();
    init_mat4();
    init_quat();
    init_quat2();
    init_vec2();
    init_vec3();
    init_vec4();
  }
});

// node_modules/d3-timer/src/timer.js
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
function timer(callback, delay, time) {
  var t4 = new Timer();
  t4.restart(callback, delay, time);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e8;
  while (t4) {
    if ((e8 = clockNow - t4._time) >= 0) t4._call.call(null, e8);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time) time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
var frame, timeout, interval, pokeDelay, taskHead, taskTail, clockLast, clockNow, clockSkew, clock, setFrame;
var init_timer = __esm({
  "node_modules/d3-timer/src/timer.js"() {
    frame = 0;
    timeout = 0;
    interval = 0;
    pokeDelay = 1e3;
    clockLast = 0;
    clockNow = 0;
    clockSkew = 0;
    clock = typeof performance === "object" && performance.now ? performance : Date;
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
      setTimeout(f2, 17);
    };
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
  }
});

// node_modules/d3-timer/src/timeout.js
var init_timeout = __esm({
  "node_modules/d3-timer/src/timeout.js"() {
    init_timer();
  }
});

// node_modules/d3-timer/src/interval.js
var init_interval = __esm({
  "node_modules/d3-timer/src/interval.js"() {
    init_timer();
  }
});

// node_modules/d3-timer/src/index.js
var init_src = __esm({
  "node_modules/d3-timer/src/index.js"() {
    init_timer();
    init_timeout();
    init_interval();
  }
});

// node_modules/@antv/matrix-util/lib/ext.js
var require_ext = __commonJS({
  "node_modules/@antv/matrix-util/lib/ext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var gl_matrix_1 = (init_esm2(), __toCommonJS(esm_exports2));
    function leftTranslate3(out, a3, v2) {
      var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      gl_matrix_1.mat3.fromTranslation(transMat, v2);
      return gl_matrix_1.mat3.multiply(out, transMat, a3);
    }
    exports.leftTranslate = leftTranslate3;
    function leftRotate3(out, a3, rad) {
      var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      gl_matrix_1.mat3.fromRotation(rotateMat, rad);
      return gl_matrix_1.mat3.multiply(out, rotateMat, a3);
    }
    exports.leftRotate = leftRotate3;
    function leftScale3(out, a3, v2) {
      var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      gl_matrix_1.mat3.fromScaling(scaleMat, v2);
      return gl_matrix_1.mat3.multiply(out, scaleMat, a3);
    }
    exports.leftScale = leftScale3;
    function leftMultiply3(out, a3, a1) {
      return gl_matrix_1.mat3.multiply(out, a1, a3);
    }
    function transform16(m3, actions) {
      var matrix = m3 ? [].concat(m3) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
      for (var i2 = 0, len6 = actions.length; i2 < len6; i2++) {
        var action = actions[i2];
        switch (action[0]) {
          case "t":
            leftTranslate3(matrix, matrix, [action[1], action[2]]);
            break;
          case "s":
            leftScale3(matrix, matrix, [action[1], action[2]]);
            break;
          case "r":
            leftRotate3(matrix, matrix, action[1]);
            break;
          case "m":
            leftMultiply3(matrix, matrix, action[1]);
            break;
          default:
            break;
        }
      }
      return matrix;
    }
    exports.transform = transform16;
    function direction3(v1, v2) {
      return v1[0] * v2[1] - v2[0] * v1[1];
    }
    exports.direction = direction3;
    function angleTo3(v1, v2, direct) {
      var ang = gl_matrix_1.vec2.angle(v1, v2);
      var angleLargeThanPI = direction3(v1, v2) >= 0;
      if (direct) {
        if (angleLargeThanPI) {
          return Math.PI * 2 - ang;
        }
        return ang;
      }
      if (angleLargeThanPI) {
        return ang;
      }
      return Math.PI * 2 - ang;
    }
    exports.angleTo = angleTo3;
    function vertical3(out, v2, flag) {
      if (flag) {
        out[0] = v2[1];
        out[1] = -1 * v2[0];
      } else {
        out[0] = -1 * v2[1];
        out[1] = v2[0];
      }
      return out;
    }
    exports.vertical = vertical3;
  }
});

// node_modules/@antv/algorithm/lib/workers/constant.js
var require_constant = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/constant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MESSAGE = exports.ALGORITHM = void 0;
    var ALGORITHM = {
      pageRank: "pageRank",
      breadthFirstSearch: "breadthFirstSearch",
      connectedComponent: "connectedComponent",
      depthFirstSearch: "depthFirstSearch",
      detectCycle: "detectCycle",
      detectDirectedCycle: "detectDirectedCycle",
      detectAllCycles: "detectAllCycles",
      detectAllDirectedCycle: "detectAllDirectedCycle",
      detectAllUndirectedCycle: "detectAllUndirectedCycle",
      dijkstra: "dijkstra",
      findAllPath: "findAllPath",
      findShortestPath: "findShortestPath",
      floydWarshall: "floydWarshall",
      getAdjMatrix: "getAdjMatrix",
      getDegree: "getDegree",
      getInDegree: "getInDegree",
      getNeighbors: "getNeighbors",
      getOutDegree: "getOutDegree",
      labelPropagation: "labelPropagation",
      louvain: "louvain",
      GADDI: "GADDI",
      minimumSpanningTree: "minimumSpanningTree",
      SUCCESS: "SUCCESS",
      FAILURE: "FAILURE"
    };
    exports.ALGORITHM = ALGORITHM;
    var MESSAGE = {
      SUCCESS: "SUCCESS",
      FAILURE: "FAILURE"
    };
    exports.MESSAGE = MESSAGE;
  }
});

// node_modules/@antv/algorithm/lib/adjacent-matrix.js
var require_adjacent_matrix = __commonJS({
  "node_modules/@antv/algorithm/lib/adjacent-matrix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var adjMatrix3 = function adjMatrix4(graphData, directed) {
      var nodes = graphData.nodes, edges = graphData.edges;
      var matrix = [];
      var nodeMap = {};
      if (!nodes) {
        throw new Error("invalid nodes data!");
      }
      if (nodes) {
        nodes.forEach(function(node, i2) {
          nodeMap[node.id] = i2;
          var row = [];
          matrix.push(row);
        });
      }
      if (edges) {
        edges.forEach(function(edge) {
          var source = edge.source, target = edge.target;
          var sIndex = nodeMap[source];
          var tIndex = nodeMap[target];
          if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0) return;
          matrix[sIndex][tIndex] = 1;
          if (!directed) {
            matrix[tIndex][sIndex] = 1;
          }
        });
      }
      return matrix;
    };
    var _default = adjMatrix3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/linked-list.js
var require_linked_list = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/linked-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.LinkedListNode = void 0;
    var defaultComparator3 = function defaultComparator4(a3, b10) {
      if (a3 === b10) {
        return true;
      }
      return false;
    };
    var LinkedListNode2 = (
      /** @class */
      function() {
        function LinkedListNode3(value, next) {
          if (next === void 0) {
            next = null;
          }
          this.value = value;
          this.next = next;
        }
        LinkedListNode3.prototype.toString = function(callback) {
          return callback ? callback(this.value) : "".concat(this.value);
        };
        return LinkedListNode3;
      }()
    );
    exports.LinkedListNode = LinkedListNode2;
    var LinkedList2 = (
      /** @class */
      function() {
        function LinkedList3(comparator) {
          if (comparator === void 0) {
            comparator = defaultComparator3;
          }
          this.head = null;
          this.tail = null;
          this.compare = comparator;
        }
        LinkedList3.prototype.prepend = function(value) {
          var newNode = new LinkedListNode2(value, this.head);
          this.head = newNode;
          if (!this.tail) {
            this.tail = newNode;
          }
          return this;
        };
        LinkedList3.prototype.append = function(value) {
          var newNode = new LinkedListNode2(value);
          if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
            return this;
          }
          this.tail.next = newNode;
          this.tail = newNode;
          return this;
        };
        LinkedList3.prototype.delete = function(value) {
          if (!this.head) {
            return null;
          }
          var deleteNode = null;
          while (this.head && this.compare(this.head.value, value)) {
            deleteNode = this.head;
            this.head = this.head.next;
          }
          var currentNode = this.head;
          if (currentNode !== null) {
            while (currentNode.next) {
              if (this.compare(currentNode.next.value, value)) {
                deleteNode = currentNode.next;
                currentNode.next = currentNode.next.next;
              } else {
                currentNode = currentNode.next;
              }
            }
          }
          if (this.compare(this.tail.value, value)) {
            this.tail = currentNode;
          }
          return deleteNode;
        };
        LinkedList3.prototype.find = function(_a2) {
          var _b = _a2.value, value = _b === void 0 ? void 0 : _b, _c = _a2.callback, callback = _c === void 0 ? void 0 : _c;
          if (!this.head) {
            return null;
          }
          var currentNode = this.head;
          while (currentNode) {
            if (callback && callback(currentNode.value)) {
              return currentNode;
            }
            if (value !== void 0 && this.compare(currentNode.value, value)) {
              return currentNode;
            }
            currentNode = currentNode.next;
          }
          return null;
        };
        LinkedList3.prototype.deleteTail = function() {
          var deletedTail = this.tail;
          if (this.head === this.tail) {
            this.head = null;
            this.tail = null;
            return deletedTail;
          }
          var currentNode = this.head;
          while (currentNode.next) {
            if (!currentNode.next.next) {
              currentNode.next = null;
            } else {
              currentNode = currentNode.next;
            }
          }
          this.tail = currentNode;
          return deletedTail;
        };
        LinkedList3.prototype.deleteHead = function() {
          if (!this.head) {
            return null;
          }
          var deletedHead = this.head;
          if (this.head.next) {
            this.head = this.head.next;
          } else {
            this.head = null;
            this.tail = null;
          }
          return deletedHead;
        };
        LinkedList3.prototype.fromArray = function(values3) {
          var _this = this;
          values3.forEach(function(value) {
            return _this.append(value);
          });
          return this;
        };
        LinkedList3.prototype.toArray = function() {
          var nodes = [];
          var currentNode = this.head;
          while (currentNode) {
            nodes.push(currentNode);
            currentNode = currentNode.next;
          }
          return nodes;
        };
        LinkedList3.prototype.reverse = function() {
          var currentNode = this.head;
          var prevNode = null;
          var nextNode = null;
          while (currentNode) {
            nextNode = currentNode.next;
            currentNode.next = prevNode;
            prevNode = currentNode;
            currentNode = nextNode;
          }
          this.tail = this.head;
          this.head = prevNode;
        };
        LinkedList3.prototype.toString = function(callback) {
          if (callback === void 0) {
            callback = void 0;
          }
          return this.toArray().map(function(node) {
            return node.toString(callback);
          }).toString();
        };
        return LinkedList3;
      }()
    );
    var _default = LinkedList2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/queue.js
var require_queue = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _linkedList = _interopRequireDefault(require_linked_list());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Queue2 = (
      /** @class */
      function() {
        function Queue3() {
          this.linkedList = new _linkedList.default();
        }
        Queue3.prototype.isEmpty = function() {
          return !this.linkedList.head;
        };
        Queue3.prototype.peek = function() {
          if (!this.linkedList.head) {
            return null;
          }
          return this.linkedList.head.value;
        };
        Queue3.prototype.enqueue = function(value) {
          this.linkedList.append(value);
        };
        Queue3.prototype.dequeue = function() {
          var removeHead = this.linkedList.deleteHead();
          return removeHead ? removeHead.value : null;
        };
        Queue3.prototype.toString = function(callback) {
          return this.linkedList.toString(callback);
        };
        return Queue3;
      }()
    );
    var _default = Queue2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/util.js
var require_util = __commonJS({
  "node_modules/@antv/algorithm/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.uniqueId = exports.getOutEdgesNodeId = exports.getNeighbors = exports.getEdgesByNodeId = void 0;
    var getNeighbors3 = function getNeighbors4(nodeId, edges, type) {
      if (edges === void 0) {
        edges = [];
      }
      var currentEdges = edges.filter(function(edge) {
        return edge.source === nodeId || edge.target === nodeId;
      });
      if (type === "target") {
        var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
          return edge.source === nodeId;
        };
        return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
          return edge.target;
        });
      }
      if (type === "source") {
        var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
          return edge.target === nodeId;
        };
        return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
          return edge.source;
        });
      }
      var neighhborsConverter = function neighhborsConverter2(edge) {
        return edge.source === nodeId ? edge.target : edge.source;
      };
      return currentEdges.map(neighhborsConverter);
    };
    exports.getNeighbors = getNeighbors3;
    var getOutEdgesNodeId3 = function getOutEdgesNodeId4(nodeId, edges) {
      return edges.filter(function(edge) {
        return edge.source === nodeId;
      });
    };
    exports.getOutEdgesNodeId = getOutEdgesNodeId3;
    var getEdgesByNodeId3 = function getEdgesByNodeId4(nodeId, edges) {
      return edges.filter(function(edge) {
        return edge.source === nodeId || edge.target === nodeId;
      });
    };
    exports.getEdgesByNodeId = getEdgesByNodeId3;
    var uniqueId5 = function uniqueId6(index2) {
      if (index2 === void 0) {
        index2 = 0;
      }
      var random1 = "".concat(Math.random()).split(".")[1].substr(0, 5);
      var random22 = "".concat(Math.random()).split(".")[1].substr(0, 5);
      return "".concat(index2, "-").concat(random1).concat(random22);
    };
    exports.uniqueId = uniqueId5;
  }
});

// node_modules/@antv/algorithm/lib/bfs.js
var require_bfs = __commonJS({
  "node_modules/@antv/algorithm/lib/bfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _queue = _interopRequireDefault(require_queue());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function initCallbacks3(callbacks) {
      if (callbacks === void 0) {
        callbacks = {};
      }
      var initiatedCallback = callbacks;
      var stubCallback = function stubCallback2() {
      };
      var allowTraversalCallback = /* @__PURE__ */ function() {
        var seen = {};
        return function(_a2) {
          var next = _a2.next;
          var id = next;
          if (!seen[id]) {
            seen[id] = true;
            return true;
          }
          return false;
        };
      }();
      initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
      initiatedCallback.enter = callbacks.enter || stubCallback;
      initiatedCallback.leave = callbacks.leave || stubCallback;
      return initiatedCallback;
    }
    var breadthFirstSearch3 = function breadthFirstSearch4(graphData, startNodeId, originalCallbacks, directed) {
      if (directed === void 0) {
        directed = true;
      }
      var callbacks = initCallbacks3(originalCallbacks);
      var nodeQueue = new _queue.default();
      var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
      nodeQueue.enqueue(startNodeId);
      var previousNode = "";
      var _loop_1 = function _loop_12() {
        var currentNode = nodeQueue.dequeue();
        callbacks.enter({
          current: currentNode,
          previous: previousNode
        });
        (0, _util.getNeighbors)(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
          if (callbacks.allowTraversal({
            previous: previousNode,
            current: currentNode,
            next: nextNode
          })) {
            nodeQueue.enqueue(nextNode);
          }
        });
        callbacks.leave({
          current: currentNode,
          previous: previousNode
        });
        previousNode = currentNode;
      };
      while (!nodeQueue.isEmpty()) {
        _loop_1();
      }
    };
    var _default = breadthFirstSearch3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/connected-component.js
var require_connected_component = __commonJS({
  "node_modules/@antv/algorithm/lib/connected-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getConnectedComponents2;
    exports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;
    var _util = require_util();
    var detectConnectedComponents3 = function detectConnectedComponents4(graphData) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var allComponents = [];
      var visited = {};
      var nodeStack = [];
      var getComponent = function getComponent2(node2) {
        nodeStack.push(node2);
        visited[node2.id] = true;
        var neighbors = (0, _util.getNeighbors)(node2.id, edges);
        var _loop_1 = function _loop_12(i4) {
          var neighbor = neighbors[i4];
          if (!visited[neighbor]) {
            var targetNode = nodes.filter(function(node3) {
              return node3.id === neighbor;
            });
            if (targetNode.length > 0) {
              getComponent2(targetNode[0]);
            }
          }
        };
        for (var i3 = 0; i3 < neighbors.length; ++i3) {
          _loop_1(i3);
        }
      };
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (!visited[node.id]) {
          getComponent(node);
          var component = [];
          while (nodeStack.length > 0) {
            component.push(nodeStack.pop());
          }
          allComponents.push(component);
        }
      }
      return allComponents;
    };
    exports.detectConnectedComponents = detectConnectedComponents3;
    var detectStrongConnectComponents3 = function detectStrongConnectComponents4(graphData) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodeStack = [];
      var inStack = {};
      var indices = {};
      var lowLink = {};
      var allComponents = [];
      var index2 = 0;
      var getComponent = function getComponent2(node2) {
        indices[node2.id] = index2;
        lowLink[node2.id] = index2;
        index2 += 1;
        nodeStack.push(node2);
        inStack[node2.id] = true;
        var neighbors = (0, _util.getNeighbors)(node2.id, edges, "target").filter(function(n2) {
          return nodes.map(function(node3) {
            return node3.id;
          }).indexOf(n2) > -1;
        });
        var _loop_2 = function _loop_22(i3) {
          var targetNodeID = neighbors[i3];
          if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {
            var targetNode = nodes.filter(function(node3) {
              return node3.id === targetNodeID;
            });
            if (targetNode.length > 0) {
              getComponent2(targetNode[0]);
            }
            lowLink[node2.id] = Math.min(lowLink[node2.id], lowLink[targetNodeID]);
          } else if (inStack[targetNodeID]) {
            lowLink[node2.id] = Math.min(lowLink[node2.id], indices[targetNodeID]);
          }
        };
        for (var i2 = 0; i2 < neighbors.length; i2++) {
          _loop_2(i2);
        }
        if (lowLink[node2.id] === indices[node2.id]) {
          var component = [];
          while (nodeStack.length > 0) {
            var tmpNode = nodeStack.pop();
            inStack[tmpNode.id] = false;
            component.push(tmpNode);
            if (tmpNode === node2) break;
          }
          if (component.length > 0) {
            allComponents.push(component);
          }
        }
      };
      for (var _i2 = 0, nodes_1 = nodes; _i2 < nodes_1.length; _i2++) {
        var node = nodes_1[_i2];
        if (!indices[node.id] && indices[node.id] !== 0) {
          getComponent(node);
        }
      }
      return allComponents;
    };
    exports.detectStrongConnectComponents = detectStrongConnectComponents3;
    function getConnectedComponents2(graphData, directed) {
      if (directed) return detectStrongConnectComponents3(graphData);
      return detectConnectedComponents3(graphData);
    }
  }
});

// node_modules/@antv/algorithm/lib/degree.js
var require_degree = __commonJS({
  "node_modules/@antv/algorithm/lib/degree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOutDegree = exports.getInDegree = exports.default = void 0;
    var degree4 = function degree5(graphData) {
      var degrees3 = {};
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      nodes.forEach(function(node) {
        degrees3[node.id] = {
          degree: 0,
          inDegree: 0,
          outDegree: 0
        };
      });
      edges.forEach(function(edge) {
        degrees3[edge.source].degree++;
        degrees3[edge.source].outDegree++;
        degrees3[edge.target].degree++;
        degrees3[edge.target].inDegree++;
      });
      return degrees3;
    };
    var _default = degree4;
    exports.default = _default;
    var getInDegree3 = function getInDegree4(graphData, nodeId) {
      var nodeDegree = degree4(graphData);
      if (nodeDegree[nodeId]) {
        return degree4(graphData)[nodeId].inDegree;
      }
      return 0;
    };
    exports.getInDegree = getInDegree3;
    var getOutDegree3 = function getOutDegree4(graphData, nodeId) {
      var nodeDegree = degree4(graphData);
      if (nodeDegree[nodeId]) {
        return degree4(graphData)[nodeId].outDegree;
      }
      return 0;
    };
    exports.getOutDegree = getOutDegree3;
  }
});

// node_modules/@antv/algorithm/lib/dfs.js
var require_dfs = __commonJS({
  "node_modules/@antv/algorithm/lib/dfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = depthFirstSearch2;
    var _util = require_util();
    function initCallbacks3(callbacks) {
      if (callbacks === void 0) {
        callbacks = {};
      }
      var initiatedCallback = callbacks;
      var stubCallback = function stubCallback2() {
      };
      var allowTraversalCallback = /* @__PURE__ */ function() {
        var seen = {};
        return function(_a2) {
          var next = _a2.next;
          if (!seen[next]) {
            seen[next] = true;
            return true;
          }
          return false;
        };
      }();
      initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
      initiatedCallback.enter = callbacks.enter || stubCallback;
      initiatedCallback.leave = callbacks.leave || stubCallback;
      return initiatedCallback;
    }
    function depthFirstSearchRecursive2(graphData, currentNode, previousNode, callbacks, directed) {
      if (directed === void 0) {
        directed = true;
      }
      callbacks.enter({
        current: currentNode,
        previous: previousNode
      });
      var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
      (0, _util.getNeighbors)(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
        if (callbacks.allowTraversal({
          previous: previousNode,
          current: currentNode,
          next: nextNode
        })) {
          depthFirstSearchRecursive2(graphData, nextNode, currentNode, callbacks, directed);
        }
      });
      callbacks.leave({
        current: currentNode,
        previous: previousNode
      });
    }
    function depthFirstSearch2(graphData, startNodeId, callbacks, directed) {
      if (directed === void 0) {
        directed = true;
      }
      depthFirstSearchRecursive2(graphData, startNodeId, "", initCallbacks3(callbacks), directed);
    }
  }
});

// node_modules/@antv/algorithm/lib/detect-cycle.js
var require_detect_cycle = __commonJS({
  "node_modules/@antv/algorithm/lib/detect-cycle.js"(exports) {
    "use strict";
    function _typeof9(obj) {
      "@babel/helpers - typeof";
      return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof9(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.detectAllUndirectedCycle = exports.detectAllDirectedCycle = exports.detectAllCycles = exports.default = void 0;
    var _dfs = _interopRequireDefault(require_dfs());
    var _connectedComponent = _interopRequireWildcard(require_connected_component());
    var _util = require_util();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof9(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache3 = _getRequireWildcardCache(nodeInterop);
      if (cache3 && cache3.has(obj)) {
        return cache3.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache3) {
        cache3.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var detectDirectedCycle4 = function detectDirectedCycle5(graphData) {
      var cycle = null;
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
      var dfsParentMap = {};
      var unvisitedSet = {};
      var visitingSet = {};
      var visitedSet = {};
      nodes.forEach(function(node) {
        unvisitedSet[node.id] = node;
      });
      var callbacks = {
        enter: function enter(_a3) {
          var currentNode = _a3.current, previousNode = _a3.previous;
          if (visitingSet[currentNode]) {
            cycle = {};
            var currentCycleNode = currentNode;
            var previousCycleNode = previousNode;
            while (previousCycleNode !== currentNode) {
              cycle[currentCycleNode] = previousCycleNode;
              currentCycleNode = previousCycleNode;
              previousCycleNode = dfsParentMap[previousCycleNode];
            }
            cycle[currentCycleNode] = previousCycleNode;
          } else {
            visitingSet[currentNode] = currentNode;
            delete unvisitedSet[currentNode];
            dfsParentMap[currentNode] = previousNode;
          }
        },
        leave: function leave(_a3) {
          var currentNode = _a3.current;
          visitedSet[currentNode] = currentNode;
          delete visitingSet[currentNode];
        },
        allowTraversal: function allowTraversal(_a3) {
          var nextNode = _a3.next;
          if (cycle) {
            return false;
          }
          return !visitedSet[nextNode];
        }
      };
      while (Object.keys(unvisitedSet).length) {
        var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];
        (0, _dfs.default)(graphData, firsetUnVisitedKey, callbacks);
      }
      return cycle;
    };
    var detectAllUndirectedCycle3 = function detectAllUndirectedCycle4(graphData, nodeIds, include) {
      var _a2, _b;
      if (include === void 0) {
        include = true;
      }
      var allCycles = [];
      var components3 = (0, _connectedComponent.default)(graphData, false);
      for (var _i2 = 0, components_1 = components3; _i2 < components_1.length; _i2++) {
        var component = components_1[_i2];
        if (!component.length) continue;
        var root = component[0];
        var rootId = root.id;
        var stack = [root];
        var parent_1 = (_a2 = {}, _a2[rootId] = root, _a2);
        var used = (_b = {}, _b[rootId] = /* @__PURE__ */ new Set(), _b);
        while (stack.length > 0) {
          var curNode = stack.pop();
          var curNodeId = curNode.id;
          var neighbors = (0, _util.getNeighbors)(curNodeId, graphData.edges);
          var _loop_1 = function _loop_12(i3) {
            var _c;
            var neighborId = neighbors[i3];
            var neighbor = graphData.nodes.find(function(node) {
              return node.id === neighborId;
            });
            if (neighborId === curNodeId) {
              allCycles.push((_c = {}, _c[neighborId] = curNode, _c));
            } else if (!(neighborId in used)) {
              parent_1[neighborId] = curNode;
              stack.push(neighbor);
              used[neighborId] = /* @__PURE__ */ new Set([curNode]);
            } else if (!used[curNodeId].has(neighbor)) {
              var cycleValid = true;
              var cyclePath = [neighbor, curNode];
              var p2 = parent_1[curNodeId];
              while (used[neighborId].size && !used[neighborId].has(p2)) {
                cyclePath.push(p2);
                if (p2 === parent_1[p2.id]) break;
                else p2 = parent_1[p2.id];
              }
              cyclePath.push(p2);
              if (nodeIds && include) {
                cycleValid = false;
                if (cyclePath.findIndex(function(node) {
                  return nodeIds.indexOf(node.id) > -1;
                }) > -1) {
                  cycleValid = true;
                }
              } else if (nodeIds && !include) {
                if (cyclePath.findIndex(function(node) {
                  return nodeIds.indexOf(node.id) > -1;
                }) > -1) {
                  cycleValid = false;
                }
              }
              if (cycleValid) {
                var cycle = {};
                for (var index2 = 1; index2 < cyclePath.length; index2 += 1) {
                  cycle[cyclePath[index2 - 1].id] = cyclePath[index2];
                }
                if (cyclePath.length) {
                  cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];
                }
                allCycles.push(cycle);
              }
              used[neighborId].add(curNode);
            }
          };
          for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
            _loop_1(i2);
          }
        }
      }
      return allCycles;
    };
    exports.detectAllUndirectedCycle = detectAllUndirectedCycle3;
    var detectAllDirectedCycle3 = function detectAllDirectedCycle4(graphData, nodeIds, include) {
      if (include === void 0) {
        include = true;
      }
      var path = [];
      var blocked = /* @__PURE__ */ new Set();
      var B3 = [];
      var allCycles = [];
      var idx2Node = {};
      var node2Idx = {};
      var unblock = function unblock2(thisNode) {
        var stack = [thisNode];
        while (stack.length > 0) {
          var node2 = stack.pop();
          if (blocked.has(node2)) {
            blocked.delete(node2);
            B3[node2.id].forEach(function(n2) {
              stack.push(n2);
            });
            B3[node2.id].clear();
          }
        }
      };
      var circuit = function circuit2(node2, start, adjList2) {
        var closed = false;
        if (nodeIds && include === false && nodeIds.indexOf(node2.id) > -1) return closed;
        path.push(node2);
        blocked.add(node2);
        var neighbors = adjList2[node2.id];
        for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
          var neighbor = idx2Node[neighbors[i3]];
          if (neighbor === start) {
            var cycle = {};
            for (var index2 = 1; index2 < path.length; index2 += 1) {
              cycle[path[index2 - 1].id] = path[index2];
            }
            if (path.length) {
              cycle[path[path.length - 1].id] = path[0];
            }
            allCycles.push(cycle);
            closed = true;
          } else if (!blocked.has(neighbor)) {
            if (circuit2(neighbor, start, adjList2)) {
              closed = true;
            }
          }
        }
        if (closed) {
          unblock(node2);
        } else {
          for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
            var neighbor = idx2Node[neighbors[i3]];
            if (!B3[neighbor.id].has(node2)) {
              B3[neighbor.id].add(node2);
            }
          }
        }
        path.pop();
        return closed;
      };
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
      for (var i2 = 0; i2 < nodes.length; i2 += 1) {
        var node = nodes[i2];
        var nodeId = node.id;
        node2Idx[nodeId] = i2;
        idx2Node[i2] = node;
      }
      if (nodeIds && include) {
        var _loop_2 = function _loop_22(i3) {
          var nodeId2 = nodeIds[i3];
          node2Idx[nodes[i3].id] = node2Idx[nodeId2];
          node2Idx[nodeId2] = 0;
          idx2Node[0] = nodes.find(function(node2) {
            return node2.id === nodeId2;
          });
          idx2Node[node2Idx[nodes[i3].id]] = nodes[i3];
        };
        for (var i2 = 0; i2 < nodeIds.length; i2++) {
          _loop_2(i2);
        }
      }
      var getMinComponentAdj = function getMinComponentAdj2(components3) {
        var _a3;
        var minCompIdx;
        var minIdx2 = Infinity;
        for (var i3 = 0; i3 < components3.length; i3 += 1) {
          var comp = components3[i3];
          for (var j2 = 0; j2 < comp.length; j2++) {
            var nodeIdx_1 = node2Idx[comp[j2].id];
            if (nodeIdx_1 < minIdx2) {
              minIdx2 = nodeIdx_1;
              minCompIdx = i3;
            }
          }
        }
        var component2 = components3[minCompIdx];
        var adjList2 = [];
        for (var i3 = 0; i3 < component2.length; i3 += 1) {
          var node2 = component2[i3];
          adjList2[node2.id] = [];
          for (var _i2 = 0, _b = (0, _util.getNeighbors)(node2.id, graphData.edges, "target").filter(function(n2) {
            return component2.map(function(c3) {
              return c3.id;
            }).indexOf(n2) > -1;
          }); _i2 < _b.length; _i2++) {
            var neighbor = _b[_i2];
            if (neighbor === node2.id && !(include === false && nodeIds.indexOf(node2.id) > -1)) {
              allCycles.push((_a3 = {}, _a3[node2.id] = node2, _a3));
            } else {
              adjList2[node2.id].push(node2Idx[neighbor]);
            }
          }
        }
        return {
          component: component2,
          adjList: adjList2,
          minIdx: minIdx2
        };
      };
      var nodeIdx = 0;
      while (nodeIdx < nodes.length) {
        var subgraphNodes = nodes.filter(function(n2) {
          return node2Idx[n2.id] >= nodeIdx;
        });
        var sccs = (0, _connectedComponent.detectStrongConnectComponents)({
          nodes: subgraphNodes,
          edges: graphData.edges
        }).filter(function(component2) {
          return component2.length > 1;
        });
        if (sccs.length === 0) break;
        var scc = getMinComponentAdj(sccs);
        var minIdx = scc.minIdx, adjList = scc.adjList, component = scc.component;
        if (component.length > 1) {
          component.forEach(function(node2) {
            B3[node2.id] = /* @__PURE__ */ new Set();
          });
          var startNode = idx2Node[minIdx];
          if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;
          circuit(startNode, startNode, adjList);
          nodeIdx = minIdx + 1;
        } else {
          break;
        }
      }
      return allCycles;
    };
    exports.detectAllDirectedCycle = detectAllDirectedCycle3;
    var detectAllCycles3 = function detectAllCycles4(graphData, directed, nodeIds, include) {
      if (include === void 0) {
        include = true;
      }
      if (directed) return detectAllDirectedCycle3(graphData, nodeIds, include);
      return detectAllUndirectedCycle3(graphData, nodeIds, include);
    };
    exports.detectAllCycles = detectAllCycles3;
    var _default = detectDirectedCycle4;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/@antv/algorithm/lib/dijkstra.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _util2 = require_util();
    var minVertex3 = function minVertex4(D3, nodes, marks) {
      var minDis = Infinity;
      var minNode;
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var nodeId = nodes[i2].id;
        if (!marks[nodeId] && D3[nodeId] <= minDis) {
          minDis = D3[nodeId];
          minNode = nodes[i2];
        }
      }
      return minNode;
    };
    var dijkstra5 = function dijkstra6(graphData, source, directed, weightPropertyName) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodeIds = [];
      var marks = {};
      var D3 = {};
      var prevs = {};
      nodes.forEach(function(node, i3) {
        var id = node.id;
        nodeIds.push(id);
        D3[id] = Infinity;
        if (id === source) D3[id] = 0;
      });
      var nodeNum = nodes.length;
      var _loop_1 = function _loop_12(i3) {
        var minNode = minVertex3(D3, nodes, marks);
        var minNodeId = minNode.id;
        marks[minNodeId] = true;
        if (D3[minNodeId] === Infinity) return "continue";
        var relatedEdges = [];
        if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);
        else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);
        relatedEdges.forEach(function(edge) {
          var edgeTarget = edge.target;
          var edgeSource = edge.source;
          var w2 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
          var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
          if (D3[w2] > D3[minNode.id] + weight) {
            D3[w2] = D3[minNode.id] + weight;
            prevs[w2] = [minNode.id];
          } else if (D3[w2] === D3[minNode.id] + weight) {
            prevs[w2].push(minNode.id);
          }
        });
      };
      for (var i2 = 0; i2 < nodeNum; i2++) {
        _loop_1(i2);
      }
      prevs[source] = [source];
      var paths = {};
      for (var target in D3) {
        if (D3[target] !== Infinity) {
          findAllPaths2(source, target, prevs, paths);
        }
      }
      var path = {};
      for (var target in paths) {
        path[target] = paths[target][0];
      }
      return {
        length: D3,
        path,
        allPath: paths
      };
    };
    var _default = dijkstra5;
    exports.default = _default;
    function findAllPaths2(source, target, prevs, foundPaths) {
      if (source === target) {
        return [source];
      }
      if (foundPaths[target]) {
        return foundPaths[target];
      }
      var paths = [];
      for (var _i2 = 0, _a2 = prevs[target]; _i2 < _a2.length; _i2++) {
        var prev = _a2[_i2];
        var prevPaths = findAllPaths2(source, prev, prevs, foundPaths);
        if (!prevPaths) return;
        for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
          var prePath = prevPaths_1[_b];
          if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));
          else paths.push([prePath, target]);
        }
      }
      foundPaths[target] = paths;
      return foundPaths[target];
    }
  }
});

// node_modules/@antv/algorithm/lib/find-path.js
var require_find_path = __commonJS({
  "node_modules/@antv/algorithm/lib/find-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findShortestPath = exports.findAllPath = void 0;
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var findShortestPath3 = function findShortestPath4(graphData, start, end2, directed, weightPropertyName) {
      var _a2 = (0, _dijkstra.default)(graphData, start, directed, weightPropertyName), length6 = _a2.length, path = _a2.path, allPath = _a2.allPath;
      return {
        length: length6[end2],
        path: path[end2],
        allPath: allPath[end2]
      };
    };
    exports.findShortestPath = findShortestPath3;
    var findAllPath3 = function findAllPath4(graphData, start, end2, directed) {
      var _a2;
      if (start === end2) return [[start]];
      var _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var visited = [start];
      var isVisited = (_a2 = {}, _a2[start] = true, _a2);
      var stack = [];
      var allPath = [];
      var neighbors = directed ? (0, _util.getNeighbors)(start, edges, "target") : (0, _util.getNeighbors)(start, edges);
      stack.push(neighbors);
      while (visited.length > 0 && stack.length > 0) {
        var children = stack[stack.length - 1];
        if (children.length) {
          var child = children.shift();
          if (child) {
            visited.push(child);
            isVisited[child] = true;
            neighbors = directed ? (0, _util.getNeighbors)(child, edges, "target") : (0, _util.getNeighbors)(child, edges);
            stack.push(neighbors.filter(function(neighbor) {
              return !isVisited[neighbor];
            }));
          }
        } else {
          var node = visited.pop();
          isVisited[node] = false;
          stack.pop();
          continue;
        }
        if (visited[visited.length - 1] === end2) {
          var path = visited.map(function(node2) {
            return node2;
          });
          allPath.push(path);
          var node = visited.pop();
          isVisited[node] = false;
          stack.pop();
        }
      }
      return allPath;
    };
    exports.findAllPath = findAllPath3;
  }
});

// node_modules/@antv/algorithm/lib/floydWarshall.js
var require_floydWarshall = __commonJS({
  "node_modules/@antv/algorithm/lib/floydWarshall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var floydWarshall6 = function floydWarshall7(graphData, directed) {
      var adjacentMatrix = (0, _adjacentMatrix.default)(graphData, directed);
      var dist4 = [];
      var size3 = adjacentMatrix.length;
      for (var i2 = 0; i2 < size3; i2 += 1) {
        dist4[i2] = [];
        for (var j2 = 0; j2 < size3; j2 += 1) {
          if (i2 === j2) {
            dist4[i2][j2] = 0;
          } else if (adjacentMatrix[i2][j2] === 0 || !adjacentMatrix[i2][j2]) {
            dist4[i2][j2] = Infinity;
          } else {
            dist4[i2][j2] = adjacentMatrix[i2][j2];
          }
        }
      }
      for (var k2 = 0; k2 < size3; k2 += 1) {
        for (var i2 = 0; i2 < size3; i2 += 1) {
          for (var j2 = 0; j2 < size3; j2 += 1) {
            if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
              dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
            }
          }
        }
      }
      return dist4;
    };
    var _default = floydWarshall6;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/label-propagation.js
var require_label_propagation = __commonJS({
  "node_modules/@antv/algorithm/lib/label-propagation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var labelPropagation3 = function labelPropagation4(graphData, directed, weightPropertyName, maxIteration) {
      if (directed === void 0) {
        directed = false;
      }
      if (weightPropertyName === void 0) {
        weightPropertyName = "weight";
      }
      if (maxIteration === void 0) {
        maxIteration = 1e3;
      }
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var clusters = {};
      var nodeMap = {};
      nodes.forEach(function(node, i2) {
        var cid = (0, _util.uniqueId)();
        node.clusterId = cid;
        clusters[cid] = {
          id: cid,
          nodes: [node]
        };
        nodeMap[node.id] = {
          node,
          idx: i2
        };
      });
      var adjMatrix3 = (0, _adjacentMatrix.default)(graphData, directed);
      var ks = [];
      var neighbors = {};
      adjMatrix3.forEach(function(row, i2) {
        var k2 = 0;
        var iid = nodes[i2].id;
        neighbors[iid] = {};
        row.forEach(function(entry, j2) {
          if (!entry) return;
          k2 += entry;
          var jid = nodes[j2].id;
          neighbors[iid][jid] = entry;
        });
        ks.push(k2);
      });
      var iter = 0;
      var _loop_1 = function _loop_12() {
        var changed = false;
        nodes.forEach(function(node) {
          var neighborClusters = {};
          Object.keys(neighbors[node.id]).forEach(function(neighborId) {
            var neighborWeight = neighbors[node.id][neighborId];
            var neighborNode = nodeMap[neighborId].node;
            var neighborClusterId = neighborNode.clusterId;
            if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;
            neighborClusters[neighborClusterId] += neighborWeight;
          });
          var maxWeight = -Infinity;
          var bestClusterIds = [];
          Object.keys(neighborClusters).forEach(function(clusterId) {
            if (maxWeight < neighborClusters[clusterId]) {
              maxWeight = neighborClusters[clusterId];
              bestClusterIds = [clusterId];
            } else if (maxWeight === neighborClusters[clusterId]) {
              bestClusterIds.push(clusterId);
            }
          });
          if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;
          var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);
          if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);
          if (bestClusterIds && bestClusterIds.length) {
            changed = true;
            var selfCluster = clusters[node.clusterId];
            var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
            selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
            var randomIdx = Math.floor(Math.random() * bestClusterIds.length);
            var bestCluster = clusters[bestClusterIds[randomIdx]];
            bestCluster.nodes.push(node);
            node.clusterId = bestCluster.id;
          }
        });
        if (!changed) return "break";
        iter++;
      };
      while (iter < maxIteration) {
        var state_1 = _loop_1();
        if (state_1 === "break") break;
      }
      Object.keys(clusters).forEach(function(clusterId) {
        var cluster = clusters[clusterId];
        if (!cluster.nodes || !cluster.nodes.length) {
          delete clusters[clusterId];
        }
      });
      var clusterEdges = [];
      var clusterEdgeMap = {};
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var weight = edge[weightPropertyName] || 1;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
        if (clusterEdgeMap[newEdgeId]) {
          clusterEdgeMap[newEdgeId].weight += weight;
          clusterEdgeMap[newEdgeId].count++;
        } else {
          var newEdge = {
            source: sourceClusterId,
            target: targetClusterId,
            weight,
            count: 1
          };
          clusterEdgeMap[newEdgeId] = newEdge;
          clusterEdges.push(newEdge);
        }
      });
      var clustersArray = [];
      Object.keys(clusters).forEach(function(clusterId) {
        clustersArray.push(clusters[clusterId]);
      });
      return {
        clusters: clustersArray,
        clusterEdges
      };
    };
    var _default = labelPropagation3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/utils/vector.js
var require_vector = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var Vector2 = (
      /** @class */
      function() {
        function Vector3(arr) {
          this.arr = arr;
        }
        Vector3.prototype.getArr = function() {
          return this.arr || [];
        };
        Vector3.prototype.add = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            return new Vector3(otherArr);
          }
          if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return new Vector3(this.arr);
          }
          if (this.arr.length === otherArr.length) {
            var res = [];
            for (var index2 in this.arr) {
              res[index2] = this.arr[index2] + otherArr[index2];
            }
            return new Vector3(res);
          }
        };
        Vector3.prototype.subtract = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            return new Vector3(otherArr);
          }
          if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return new Vector3(this.arr);
          }
          if (this.arr.length === otherArr.length) {
            var res = [];
            for (var index2 in this.arr) {
              res[index2] = this.arr[index2] - otherArr[index2];
            }
            return new Vector3(res);
          }
        };
        Vector3.prototype.avg = function(length6) {
          var res = [];
          if (length6 !== 0) {
            for (var index2 in this.arr) {
              res[index2] = this.arr[index2] / length6;
            }
          }
          return new Vector3(res);
        };
        Vector3.prototype.negate = function() {
          var res = [];
          for (var index2 in this.arr) {
            res[index2] = -this.arr[index2];
          }
          return new Vector3(res);
        };
        Vector3.prototype.squareEuclideanDistance = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return 0;
          }
          if (this.arr.length === otherArr.length) {
            var res = 0;
            for (var index2 in this.arr) {
              res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
            }
            return res;
          }
        };
        Vector3.prototype.euclideanDistance = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return 0;
          }
          if (this.arr.length === otherArr.length) {
            var res = 0;
            for (var index2 in this.arr) {
              res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
            }
            return Math.sqrt(res);
          } else {
            console.error("The two vectors are unequal in length.");
          }
        };
        Vector3.prototype.normalize = function() {
          var res = [];
          var cloneArr = (0, _util.clone)(this.arr);
          cloneArr.sort(function(a3, b10) {
            return a3 - b10;
          });
          var max8 = cloneArr[cloneArr.length - 1];
          var min6 = cloneArr[0];
          for (var index2 in this.arr) {
            res[index2] = (this.arr[index2] - min6) / (max8 - min6);
          }
          return new Vector3(res);
        };
        Vector3.prototype.norm2 = function() {
          var _a2;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            return 0;
          }
          var res = 0;
          for (var index2 in this.arr) {
            res += Math.pow(this.arr[index2], 2);
          }
          return Math.sqrt(res);
        };
        Vector3.prototype.dot = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return 0;
          }
          if (this.arr.length === otherArr.length) {
            var res = 0;
            for (var index2 in this.arr) {
              res += this.arr[index2] * otherVector.arr[index2];
            }
            return res;
          } else {
            console.error("The two vectors are unequal in length.");
          }
        };
        Vector3.prototype.equal = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return false;
          }
          for (var index2 in this.arr) {
            if (this.arr[index2] !== otherArr[index2]) {
              return false;
            }
          }
          return true;
        };
        return Vector3;
      }()
    );
    var _default = Vector2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/constants/time.js
var require_time = __commonJS({
  "node_modules/@antv/algorithm/lib/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.secondReg = exports.dateReg = void 0;
    var secondReg2 = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/;
    exports.secondReg = secondReg2;
    var dateReg2 = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/;
    exports.dateReg = dateReg2;
  }
});

// node_modules/@antv/algorithm/lib/utils/node-properties.js
var require_node_properties = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/node-properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPropertyWeight = exports.getAllSortProperties = exports.getAllProperties = exports.default = void 0;
    var _time = require_time();
    var getAllSortProperties = function getAllSortProperties2(nodes, n2) {
      if (nodes === void 0) {
        nodes = [];
      }
      if (n2 === void 0) {
        n2 = 100;
      }
      var propertyKeyInfo = {};
      nodes.forEach(function(node) {
        if (!node.properties) {
          return;
        }
        Object.keys(node.properties).forEach(function(propertyKey) {
          if (propertyKey === "id" || !"".concat(node.properties[propertyKey]).match(_time.secondReg) && !"".concat(node.properties[propertyKey]).match(_time.dateReg) && isNaN(Number(node.properties[propertyKey]))) {
            if (propertyKeyInfo.hasOwnProperty(propertyKey)) {
              delete propertyKeyInfo[propertyKey];
            }
            return;
          }
          if (propertyKeyInfo.hasOwnProperty(propertyKey)) {
            propertyKeyInfo[propertyKey] += 1;
          } else {
            propertyKeyInfo[propertyKey] = 1;
          }
        });
      });
      var sortKeys = Object.keys(propertyKeyInfo).sort(function(a3, b10) {
        return propertyKeyInfo[b10] - propertyKeyInfo[a3];
      });
      return sortKeys.length < n2 ? sortKeys : sortKeys.slice(0, n2);
    };
    exports.getAllSortProperties = getAllSortProperties;
    var processProperty = function processProperty2(properties, propertyKeys) {
      return propertyKeys.map(function(key) {
        if (properties.hasOwnProperty(key)) {
          return properties[key];
        }
        return 0;
      });
    };
    var getPropertyWeight = function getPropertyWeight2(nodes) {
      var propertyKeys = getAllSortProperties(nodes);
      var allPropertiesWeight = [];
      for (var i2 = 0; i2 < nodes.length; i2++) {
        allPropertiesWeight[i2] = processProperty(nodes[i2].properties, propertyKeys);
      }
      return allPropertiesWeight;
    };
    exports.getPropertyWeight = getPropertyWeight;
    var getAllProperties3 = function getAllProperties4(nodes, key) {
      if (key === void 0) {
        key = void 0;
      }
      var allProperties = [];
      nodes.forEach(function(node) {
        if (key === void 0) {
          allProperties.push(node);
        }
        if (node[key] !== void 0) {
          allProperties.push(node[key]);
        }
      });
      return allProperties;
    };
    exports.getAllProperties = getAllProperties3;
    var _default = {
      getAllSortProperties,
      getPropertyWeight,
      getAllProperties: getAllProperties3
    };
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/types.js
var require_types = __commonJS({
  "node_modules/@antv/algorithm/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DistanceType = void 0;
    var DistanceType2;
    exports.DistanceType = DistanceType2;
    (function(DistanceType3) {
      DistanceType3["EuclideanDistance"] = "euclideanDistance";
    })(DistanceType2 || (exports.DistanceType = DistanceType2 = {}));
  }
});

// node_modules/@antv/algorithm/lib/utils/data-preprocessing.js
var require_data_preprocessing = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/data-preprocessing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.oneHot = exports.getDistance = exports.getAllKeyValueMap = exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _types = require_types();
    var _vector = _interopRequireDefault(require_vector());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getAllKeyValueMap3 = function getAllKeyValueMap4(dataList, involvedKeys, uninvolvedKeys) {
      var keys3 = [];
      if (involvedKeys === null || involvedKeys === void 0 ? void 0 : involvedKeys.length) {
        keys3 = involvedKeys;
      } else {
        dataList.forEach(function(data) {
          keys3 = keys3.concat(Object.keys(data));
        });
        keys3 = (0, _util.uniq)(keys3);
      }
      var allKeyValueMap = {};
      keys3.forEach(function(key) {
        var value = [];
        dataList.forEach(function(data) {
          if (data[key] !== void 0 && data[key] !== "") {
            value.push(data[key]);
          }
        });
        if (value.length && !(uninvolvedKeys === null || uninvolvedKeys === void 0 ? void 0 : uninvolvedKeys.includes(key))) {
          allKeyValueMap[key] = (0, _util.uniq)(value);
        }
      });
      return allKeyValueMap;
    };
    exports.getAllKeyValueMap = getAllKeyValueMap3;
    var oneHot3 = function oneHot4(dataList, involvedKeys, uninvolvedKeys) {
      var allKeyValueMap = getAllKeyValueMap3(dataList, involvedKeys, uninvolvedKeys);
      var oneHotCode = [];
      if (!Object.keys(allKeyValueMap).length) {
        return oneHotCode;
      }
      var allValue = Object.values(allKeyValueMap);
      var isAllNumber = allValue.every(function(value) {
        return value.every(function(item) {
          return typeof item === "number";
        });
      });
      dataList.forEach(function(data, index2) {
        var code = [];
        Object.keys(allKeyValueMap).forEach(function(key) {
          var keyValue = data[key];
          var allKeyValue = allKeyValueMap[key];
          var valueIndex = allKeyValue.findIndex(function(value) {
            return keyValue === value;
          });
          var subCode = [];
          if (isAllNumber) {
            subCode.push(keyValue);
          } else {
            for (var i2 = 0; i2 < allKeyValue.length; i2++) {
              if (i2 === valueIndex) {
                subCode.push(1);
              } else {
                subCode.push(0);
              }
            }
          }
          code = code.concat(subCode);
        });
        oneHotCode[index2] = code;
      });
      return oneHotCode;
    };
    exports.oneHot = oneHot3;
    var getDistance3 = function getDistance4(item, otherItem, distanceType, graphData) {
      if (distanceType === void 0) {
        distanceType = _types.DistanceType.EuclideanDistance;
      }
      var distance11 = 0;
      switch (distanceType) {
        case _types.DistanceType.EuclideanDistance:
          distance11 = new _vector.default(item).euclideanDistance(new _vector.default(otherItem));
          break;
        default:
          break;
      }
      return distance11;
    };
    exports.getDistance = getDistance3;
    var _default = {
      getAllKeyValueMap: getAllKeyValueMap3,
      oneHot: oneHot3,
      getDistance: getDistance3
    };
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/louvain.js
var require_louvain = __commonJS({
  "node_modules/@antv/algorithm/lib/louvain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _vector = _interopRequireDefault(require_vector());
    var _nodeProperties = require_node_properties();
    var _dataPreprocessing = require_data_preprocessing();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getModularity3 = function getModularity4(nodes, adjMatrix3, ks, m3) {
      var length6 = adjMatrix3.length;
      var param = 2 * m3;
      var modularity = 0;
      for (var i2 = 0; i2 < length6; i2++) {
        var clusteri = nodes[i2].clusterId;
        for (var j2 = 0; j2 < length6; j2++) {
          var clusterj = nodes[j2].clusterId;
          if (clusteri !== clusterj) continue;
          var entry = adjMatrix3[i2][j2] || 0;
          var ki2 = ks[i2] || 0;
          var kj = ks[j2] || 0;
          modularity += entry - ki2 * kj / param;
        }
      }
      modularity *= 1 / param;
      return modularity;
    };
    var getInertialModularity3 = function getInertialModularity4(nodes, allPropertiesWeight) {
      if (nodes === void 0) {
        nodes = [];
      }
      var length6 = nodes.length;
      var totalProperties = new _vector.default([]);
      for (var i2 = 0; i2 < length6; i2++) {
        totalProperties = totalProperties.add(new _vector.default(allPropertiesWeight[i2]));
      }
      var avgProperties = totalProperties.avg(length6);
      avgProperties.normalize();
      var variance = 0;
      for (var i2 = 0; i2 < length6; i2++) {
        var propertiesi = new _vector.default(allPropertiesWeight[i2]);
        var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);
        variance += squareEuclideanDistance;
      }
      var squareEuclideanDistanceInfo = [];
      nodes.forEach(function() {
        squareEuclideanDistanceInfo.push([]);
      });
      for (var i2 = 0; i2 < length6; i2++) {
        var propertiesi = new _vector.default(allPropertiesWeight[i2]);
        nodes[i2]["clusterInertial"] = 0;
        for (var j2 = 0; j2 < length6; j2++) {
          if (i2 === j2) {
            squareEuclideanDistanceInfo[i2][j2] = 0;
            continue;
          }
          var propertiesj = new _vector.default(allPropertiesWeight[j2]);
          squareEuclideanDistanceInfo[i2][j2] = propertiesi.squareEuclideanDistance(propertiesj);
          nodes[i2]["clusterInertial"] += squareEuclideanDistanceInfo[i2][j2];
        }
      }
      var inertialModularity = 0;
      var param = 2 * length6 * variance;
      for (var i2 = 0; i2 < length6; i2++) {
        var clusteri = nodes[i2].clusterId;
        for (var j2 = 0; j2 < length6; j2++) {
          var clusterj = nodes[j2].clusterId;
          if (i2 === j2 || clusteri !== clusterj) continue;
          var inertial = nodes[i2].clusterInertial * nodes[j2].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i2][j2] / param;
          inertialModularity += inertial;
        }
      }
      return Number(inertialModularity.toFixed(4));
    };
    var louvain3 = function louvain4(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
      if (directed === void 0) {
        directed = false;
      }
      if (weightPropertyName === void 0) {
        weightPropertyName = "weight";
      }
      if (threshold === void 0) {
        threshold = 1e-4;
      }
      if (inertialModularity === void 0) {
        inertialModularity = false;
      }
      if (propertyKey === void 0) {
        propertyKey = void 0;
      }
      if (involvedKeys === void 0) {
        involvedKeys = [];
      }
      if (uninvolvedKeys === void 0) {
        uninvolvedKeys = ["id"];
      }
      if (inertialWeight === void 0) {
        inertialWeight = 1;
      }
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var allPropertiesWeight = [];
      if (inertialModularity) {
        nodes.forEach(function(node, index2) {
          node.properties = node.properties || {};
          node.originIndex = index2;
        });
        var nodeTypeInfo_1 = [];
        if (nodes.every(function(node) {
          return node.hasOwnProperty("nodeType");
        })) {
          nodeTypeInfo_1 = Array.from(new Set(nodes.map(function(node) {
            return node.nodeType;
          })));
          nodes.forEach(function(node) {
            node.properties.nodeType = nodeTypeInfo_1.findIndex(function(nodeType) {
              return nodeType === node.nodeType;
            });
          });
        }
        var properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey);
        allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys);
      }
      var uniqueId5 = 1;
      var clusters = {};
      var nodeMap = {};
      nodes.forEach(function(node, i2) {
        var cid = String(uniqueId5++);
        node.clusterId = cid;
        clusters[cid] = {
          id: cid,
          nodes: [node]
        };
        nodeMap[node.id] = {
          node,
          idx: i2
        };
      });
      var adjMatrix3 = (0, _adjacentMatrix.default)(graphData, directed);
      var ks = [];
      var neighbors = {};
      var m3 = 0;
      adjMatrix3.forEach(function(row, i2) {
        var k2 = 0;
        var iid = nodes[i2].id;
        neighbors[iid] = {};
        row.forEach(function(entry, j2) {
          if (!entry) return;
          k2 += entry;
          var jid = nodes[j2].id;
          neighbors[iid][jid] = entry;
          m3 += entry;
        });
        ks.push(k2);
      });
      m3 /= 2;
      var totalModularity = Infinity;
      var previousModularity = Infinity;
      var iter = 0;
      var finalNodes = [];
      var finalClusters = {};
      while (true) {
        if (inertialModularity && nodes.every(function(node) {
          return node.hasOwnProperty("properties");
        })) {
          totalModularity = getModularity3(nodes, adjMatrix3, ks, m3) + getInertialModularity3(nodes, allPropertiesWeight) * inertialWeight;
        } else {
          totalModularity = getModularity3(nodes, adjMatrix3, ks, m3);
        }
        if (iter === 0) {
          previousModularity = totalModularity;
          finalNodes = nodes;
          finalClusters = clusters;
        }
        var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;
        if (totalModularity > previousModularity) {
          finalNodes = nodes.map(function(node) {
            return {
              node,
              clusterId: node.clusterId
            };
          });
          finalClusters = (0, _util.clone)(clusters);
          previousModularity = totalModularity;
        }
        if (increaseWithinThreshold || iter > 100) {
          break;
        }
        ;
        iter++;
        Object.keys(clusters).forEach(function(clusterId) {
          var sumTot = 0;
          edges.forEach(function(edge) {
            var source = edge.source, target = edge.target;
            var sourceClusterId = nodeMap[source].node.clusterId;
            var targetClusterId = nodeMap[target].node.clusterId;
            if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {
              sumTot = sumTot + (edge[weightPropertyName] || 1);
            }
          });
          clusters[clusterId].sumTot = sumTot;
        });
        nodes.forEach(function(node, i2) {
          var selfCluster = clusters[node.clusterId];
          var bestIncrease = 0;
          var bestCluster;
          var commonParam = ks[i2] / (2 * m3);
          var kiin = 0;
          var selfClusterNodes = selfCluster.nodes;
          selfClusterNodes.forEach(function(scNode) {
            var scNodeIdx = nodeMap[scNode.id].idx;
            kiin += adjMatrix3[i2][scNodeIdx] || 0;
          });
          var removeModurarity = kiin - selfCluster.sumTot * commonParam;
          var selfClusterNodesAfterRemove = selfClusterNodes.filter(function(scNode) {
            return scNode.id !== node.id;
          });
          var propertiesWeightRemove = [];
          selfClusterNodesAfterRemove.forEach(function(nodeRemove, index2) {
            propertiesWeightRemove[index2] = allPropertiesWeight[nodeRemove.originIndex];
          });
          var removeInertialModularity = getInertialModularity3(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;
          var nodeNeighborIds = neighbors[node.id];
          Object.keys(nodeNeighborIds).forEach(function(neighborNodeId) {
            var neighborNode = nodeMap[neighborNodeId].node;
            var neighborClusterId = neighborNode.clusterId;
            if (neighborClusterId === node.clusterId) return;
            var neighborCluster = clusters[neighborClusterId];
            var clusterNodes = neighborCluster.nodes;
            if (!clusterNodes || !clusterNodes.length) return;
            var neighborClusterKiin = 0;
            clusterNodes.forEach(function(cNode) {
              var cNodeIdx = nodeMap[cNode.id].idx;
              neighborClusterKiin += adjMatrix3[i2][cNodeIdx] || 0;
            });
            var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;
            var clusterNodesAfterAdd = clusterNodes.concat([node]);
            var propertiesWeightAdd = [];
            clusterNodesAfterAdd.forEach(function(nodeAdd, index2) {
              propertiesWeightAdd[index2] = allPropertiesWeight[nodeAdd.originIndex];
            });
            var addInertialModularity = getInertialModularity3(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;
            var increase = addModurarity - removeModurarity;
            if (inertialModularity) {
              increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);
            }
            if (increase > bestIncrease) {
              bestIncrease = increase;
              bestCluster = neighborCluster;
            }
          });
          if (bestIncrease > 0) {
            bestCluster.nodes.push(node);
            var previousClusterId_1 = node.clusterId;
            node.clusterId = bestCluster.id;
            var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
            selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
            var neighborClusterSumTot_1 = 0;
            var selfClusterSumTot_1 = 0;
            edges.forEach(function(edge) {
              var source = edge.source, target = edge.target;
              var sourceClusterId = nodeMap[source].node.clusterId;
              var targetClusterId = nodeMap[target].node.clusterId;
              if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {
                neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);
              }
              if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {
                selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);
              }
            });
            bestCluster.sumTot = neighborClusterSumTot_1;
            selfCluster.sumTot = selfClusterSumTot_1;
          }
        });
      }
      var newClusterIdMap = {};
      var clusterIdx = 0;
      Object.keys(finalClusters).forEach(function(clusterId) {
        var cluster = finalClusters[clusterId];
        if (!cluster.nodes || !cluster.nodes.length) {
          delete finalClusters[clusterId];
          return;
        }
        var newId = String(clusterIdx + 1);
        if (newId === clusterId) {
          return;
        }
        cluster.id = newId;
        cluster.nodes = cluster.nodes.map(function(item) {
          return {
            id: item.id,
            clusterId: newId
          };
        });
        finalClusters[newId] = cluster;
        newClusterIdMap[clusterId] = newId;
        delete finalClusters[clusterId];
        clusterIdx++;
      });
      finalNodes.forEach(function(nodeInfo) {
        var node = nodeInfo.node, clusterId = nodeInfo.clusterId;
        if (!node) return;
        node.clusterId = clusterId;
        if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];
      });
      var clusterEdges = [];
      var clusterEdgeMap = {};
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var weight = edge[weightPropertyName] || 1;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        if (!sourceClusterId || !targetClusterId) return;
        var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
        if (clusterEdgeMap[newEdgeId]) {
          clusterEdgeMap[newEdgeId].weight += weight;
          clusterEdgeMap[newEdgeId].count++;
        } else {
          var newEdge = {
            source: sourceClusterId,
            target: targetClusterId,
            weight,
            count: 1
          };
          clusterEdgeMap[newEdgeId] = newEdge;
          clusterEdges.push(newEdge);
        }
      });
      var clustersArray = [];
      Object.keys(finalClusters).forEach(function(clusterId) {
        clustersArray.push(finalClusters[clusterId]);
      });
      return {
        clusters: clustersArray,
        clusterEdges
      };
    };
    var _default = louvain3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/union-find.js
var require_union_find = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/union-find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UnionFind2 = (
      /** @class */
      function() {
        function UnionFind3(items) {
          this.count = items.length;
          this.parent = {};
          for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
            var i2 = items_1[_i2];
            this.parent[i2] = i2;
          }
        }
        UnionFind3.prototype.find = function(item) {
          while (this.parent[item] !== item) {
            item = this.parent[item];
          }
          return item;
        };
        UnionFind3.prototype.union = function(a3, b10) {
          var rootA = this.find(a3);
          var rootB = this.find(b10);
          if (rootA === rootB) return;
          if (rootA < rootB) {
            if (this.parent[b10] !== b10) this.union(this.parent[b10], a3);
            this.parent[b10] = this.parent[a3];
          } else {
            if (this.parent[a3] !== a3) this.union(this.parent[a3], b10);
            this.parent[a3] = this.parent[b10];
          }
        };
        UnionFind3.prototype.connected = function(a3, b10) {
          return this.find(a3) === this.find(b10);
        };
        return UnionFind3;
      }()
    );
    var _default = UnionFind2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/binary-heap.js
var require_binary_heap = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/binary-heap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var defaultCompare3 = function defaultCompare4(a3, b10) {
      return a3 - b10;
    };
    var MinBinaryHeap2 = (
      /** @class */
      function() {
        function MinBinaryHeap3(compareFn) {
          if (compareFn === void 0) {
            compareFn = defaultCompare3;
          }
          this.compareFn = compareFn;
          this.list = [];
        }
        MinBinaryHeap3.prototype.getLeft = function(index2) {
          return 2 * index2 + 1;
        };
        MinBinaryHeap3.prototype.getRight = function(index2) {
          return 2 * index2 + 2;
        };
        MinBinaryHeap3.prototype.getParent = function(index2) {
          if (index2 === 0) {
            return null;
          }
          return Math.floor((index2 - 1) / 2);
        };
        MinBinaryHeap3.prototype.isEmpty = function() {
          return this.list.length <= 0;
        };
        MinBinaryHeap3.prototype.top = function() {
          return this.isEmpty() ? void 0 : this.list[0];
        };
        MinBinaryHeap3.prototype.delMin = function() {
          var top = this.top();
          var bottom = this.list.pop();
          if (this.list.length > 0) {
            this.list[0] = bottom;
            this.moveDown(0);
          }
          return top;
        };
        MinBinaryHeap3.prototype.insert = function(value) {
          if (value !== null) {
            this.list.push(value);
            var index2 = this.list.length - 1;
            this.moveUp(index2);
            return true;
          }
          return false;
        };
        MinBinaryHeap3.prototype.moveUp = function(index2) {
          var parent = this.getParent(index2);
          while (index2 && index2 > 0 && this.compareFn(this.list[parent], this.list[index2]) > 0) {
            var tmp = this.list[parent];
            this.list[parent] = this.list[index2];
            this.list[index2] = tmp;
            index2 = parent;
            parent = this.getParent(index2);
          }
        };
        MinBinaryHeap3.prototype.moveDown = function(index2) {
          var _a2;
          var element = index2;
          var left = this.getLeft(index2);
          var right = this.getRight(index2);
          var size3 = this.list.length;
          if (left !== null && left < size3 && this.compareFn(this.list[element], this.list[left]) > 0) {
            element = left;
          } else if (right !== null && right < size3 && this.compareFn(this.list[element], this.list[right]) > 0) {
            element = right;
          }
          if (index2 !== element) {
            _a2 = [this.list[element], this.list[index2]], this.list[index2] = _a2[0], this.list[element] = _a2[1];
            this.moveDown(element);
          }
        };
        return MinBinaryHeap3;
      }()
    );
    var _default = MinBinaryHeap2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/mts.js
var require_mts = __commonJS({
  "node_modules/@antv/algorithm/lib/mts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _unionFind = _interopRequireDefault(require_union_find());
    var _binaryHeap = _interopRequireDefault(require_binary_heap());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var primMST3 = function primMST4(graphData, weight) {
      var selectedEdges = [];
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      if (nodes.length === 0) {
        return selectedEdges;
      }
      var currNode = nodes[0];
      var visited = /* @__PURE__ */ new Set();
      visited.add(currNode);
      var compareWeight = function compareWeight2(a3, b10) {
        if (weight) {
          return a3.weight - b10.weight;
        }
        return 0;
      };
      var edgeQueue = new _binaryHeap.default(compareWeight);
      (0, _util.getEdgesByNodeId)(currNode.id, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
      while (!edgeQueue.isEmpty()) {
        var currEdge = edgeQueue.delMin();
        var source = currEdge.source;
        var target = currEdge.target;
        if (visited.has(source) && visited.has(target)) continue;
        selectedEdges.push(currEdge);
        if (!visited.has(source)) {
          visited.add(source);
          (0, _util.getEdgesByNodeId)(source, edges).forEach(function(edge) {
            edgeQueue.insert(edge);
          });
        }
        if (!visited.has(target)) {
          visited.add(target);
          (0, _util.getEdgesByNodeId)(target, edges).forEach(function(edge) {
            edgeQueue.insert(edge);
          });
        }
      }
      return selectedEdges;
    };
    var kruskalMST3 = function kruskalMST4(graphData, weight) {
      var selectedEdges = [];
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      if (nodes.length === 0) {
        return selectedEdges;
      }
      var weightEdges = edges.map(function(edge) {
        return edge;
      });
      if (weight) {
        weightEdges.sort(function(a3, b10) {
          return a3.weight - b10.weight;
        });
      }
      var disjointSet = new _unionFind.default(nodes.map(function(n2) {
        return n2.id;
      }));
      while (weightEdges.length > 0) {
        var curEdge = weightEdges.shift();
        var source = curEdge.source;
        var target = curEdge.target;
        if (!disjointSet.connected(source, target)) {
          selectedEdges.push(curEdge);
          disjointSet.union(source, target);
        }
      }
      return selectedEdges;
    };
    var minimumSpanningTree3 = function minimumSpanningTree4(graphData, weight, algo) {
      var algos = {
        prim: primMST3,
        kruskal: kruskalMST3
      };
      if (!algo) return kruskalMST3(graphData, weight);
      return algos[algo](graphData, weight);
    };
    var _default = minimumSpanningTree3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/pageRank.js
var require_pageRank = __commonJS({
  "node_modules/@antv/algorithm/lib/pageRank.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _degree = _interopRequireDefault(require_degree());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pageRank3 = function pageRank4(graphData, epsilon, linkProb) {
      if (typeof epsilon !== "number") epsilon = 1e-6;
      if (typeof linkProb !== "number") linkProb = 0.85;
      var distance11 = 1;
      var leakedRank = 0;
      var maxIterations = 1e3;
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodesCount = nodes.length;
      var currentRank;
      var curRanks = {};
      var prevRanks = {};
      for (var j2 = 0; j2 < nodesCount; ++j2) {
        var node = nodes[j2];
        var nodeId = node.id;
        curRanks[nodeId] = 1 / nodesCount;
        prevRanks[nodeId] = 1 / nodesCount;
      }
      var nodeDegree = (0, _degree.default)(graphData);
      while (maxIterations > 0 && distance11 > epsilon) {
        leakedRank = 0;
        for (var j2 = 0; j2 < nodesCount; ++j2) {
          var node = nodes[j2];
          var nodeId = node.id;
          currentRank = 0;
          if (nodeDegree[node.id].inDegree === 0) {
            curRanks[nodeId] = 0;
          } else {
            var neighbors = (0, _util.getNeighbors)(nodeId, edges, "source");
            for (var i2 = 0; i2 < neighbors.length; ++i2) {
              var neighbor = neighbors[i2];
              var outDegree = nodeDegree[neighbor].outDegree;
              if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;
            }
            curRanks[nodeId] = linkProb * currentRank;
            leakedRank += curRanks[nodeId];
          }
        }
        leakedRank = (1 - leakedRank) / nodesCount;
        distance11 = 0;
        for (var j2 = 0; j2 < nodesCount; ++j2) {
          var node = nodes[j2];
          var nodeId = node.id;
          currentRank = curRanks[nodeId] + leakedRank;
          distance11 += Math.abs(currentRank - prevRanks[nodeId]);
          prevRanks[nodeId] = currentRank;
        }
        maxIterations -= 1;
      }
      return prevRanks;
    };
    var _default = pageRank3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/gSpan/struct.js
var require_struct = __commonJS({
  "node_modules/@antv/algorithm/lib/gSpan/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VACANT_NODE_LABEL = exports.VACANT_NODE_ID = exports.VACANT_GRAPH_ID = exports.VACANT_EDGE_LABEL = exports.VACANT_EDGE_ID = exports.Node = exports.Graph = exports.Edge = exports.AUTO_EDGE_ID = void 0;
    var VACANT_EDGE_ID2 = -1;
    exports.VACANT_EDGE_ID = VACANT_EDGE_ID2;
    var VACANT_NODE_ID2 = -1;
    exports.VACANT_NODE_ID = VACANT_NODE_ID2;
    var VACANT_EDGE_LABEL2 = "-1";
    exports.VACANT_EDGE_LABEL = VACANT_EDGE_LABEL2;
    var VACANT_NODE_LABEL2 = "-1";
    exports.VACANT_NODE_LABEL = VACANT_NODE_LABEL2;
    var VACANT_GRAPH_ID2 = -1;
    exports.VACANT_GRAPH_ID = VACANT_GRAPH_ID2;
    var AUTO_EDGE_ID = "-1";
    exports.AUTO_EDGE_ID = AUTO_EDGE_ID;
    var Edge3 = (
      /** @class */
      /* @__PURE__ */ function() {
        function Edge4(id, from, to2, label) {
          if (id === void 0) {
            id = VACANT_EDGE_ID2;
          }
          if (from === void 0) {
            from = VACANT_NODE_ID2;
          }
          if (to2 === void 0) {
            to2 = VACANT_NODE_ID2;
          }
          if (label === void 0) {
            label = VACANT_EDGE_LABEL2;
          }
          this.id = id;
          this.from = from;
          this.to = to2;
          this.label = label;
        }
        return Edge4;
      }()
    );
    exports.Edge = Edge3;
    var Node3 = (
      /** @class */
      function() {
        function Node4(id, label) {
          if (id === void 0) {
            id = VACANT_NODE_ID2;
          }
          if (label === void 0) {
            label = VACANT_NODE_LABEL2;
          }
          this.id = id;
          this.label = label;
          this.edges = [];
          this.edgeMap = {};
        }
        Node4.prototype.addEdge = function(edge) {
          this.edges.push(edge);
          this.edgeMap[edge.id] = edge;
        };
        return Node4;
      }()
    );
    exports.Node = Node3;
    var Graph4 = (
      /** @class */
      function() {
        function Graph5(id, edgeIdAutoIncrease, directed) {
          if (id === void 0) {
            id = VACANT_NODE_ID2;
          }
          if (edgeIdAutoIncrease === void 0) {
            edgeIdAutoIncrease = true;
          }
          if (directed === void 0) {
            directed = false;
          }
          this.id = id;
          this.edgeIdAutoIncrease = edgeIdAutoIncrease;
          this.edges = [];
          this.nodes = [];
          this.nodeMap = {};
          this.edgeMap = {};
          this.nodeLabelMap = {};
          this.edgeLabelMap = {};
          this.counter = 0;
          this.directed = directed;
        }
        Graph5.prototype.getNodeNum = function() {
          return this.nodes.length;
        };
        Graph5.prototype.addNode = function(id, label) {
          if (this.nodeMap[id]) return;
          var node = new Node3(id, label);
          this.nodes.push(node);
          this.nodeMap[id] = node;
          if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];
          this.nodeLabelMap[label].push(id);
        };
        Graph5.prototype.addEdge = function(id, from, to2, label) {
          if (this.edgeIdAutoIncrease || id === void 0) id = this.counter++;
          if (this.nodeMap[from] && this.nodeMap[to2] && this.nodeMap[to2].edgeMap[id]) return;
          var edge = new Edge3(id, from, to2, label);
          this.edges.push(edge);
          this.edgeMap[id] = edge;
          this.nodeMap[from].addEdge(edge);
          if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];
          this.edgeLabelMap[label].push(edge);
          if (!this.directed) {
            var rEdge = new Edge3(id, to2, from, label);
            this.nodeMap[to2].addEdge(rEdge);
            this.edgeLabelMap[label].push(rEdge);
          }
        };
        return Graph5;
      }()
    );
    exports.Graph = Graph4;
  }
});

// node_modules/@antv/algorithm/lib/gSpan/gSpan.js
var require_gSpan = __commonJS({
  "node_modules/@antv/algorithm/lib/gSpan/gSpan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _struct = require_struct();
    var DFSedge2 = (
      /** @class */
      function() {
        function DFSedge3(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
          this.fromNode = fromNode;
          this.toNode = toNode;
          this.nodeEdgeNodeLabel = {
            nodeLabel1: fromNodeLabel || _struct.VACANT_NODE_LABEL,
            edgeLabel: edgeLabel || _struct.VACANT_EDGE_LABEL,
            nodeLabel2: toNodeLabel || _struct.VACANT_NODE_LABEL
          };
        }
        DFSedge3.prototype.equalTo = function(other) {
          return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
        };
        DFSedge3.prototype.notEqualTo = function(other) {
          return !this.equalTo(other);
        };
        return DFSedge3;
      }()
    );
    var DFScode2 = (
      /** @class */
      function() {
        function DFScode3() {
          this.rmpath = [];
          this.dfsEdgeList = [];
        }
        DFScode3.prototype.equalTo = function(other) {
          var aLength = this.dfsEdgeList.length;
          var bLength = other.length;
          if (aLength !== bLength) return false;
          for (var i2 = 0; i2 < aLength; i2++) {
            if (this.dfsEdgeList[i2] !== other[i2]) return false;
          }
          return true;
        };
        DFScode3.prototype.notEqualTo = function(other) {
          return !this.equalTo(other);
        };
        DFScode3.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
          this.dfsEdgeList.push(new DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
          return this.dfsEdgeList;
        };
        DFScode3.prototype.toGraph = function(graphId, directed) {
          if (graphId === void 0) {
            graphId = _struct.VACANT_GRAPH_ID;
          }
          if (directed === void 0) {
            directed = false;
          }
          var graph = new _struct.Graph(graphId, true, directed);
          this.dfsEdgeList.forEach(function(dfsEdge) {
            var fromNodeId = dfsEdge.fromNode;
            var toNodeId = dfsEdge.toNode;
            var _a2 = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            if (nodeLabel1 !== _struct.VACANT_NODE_LABEL) graph.addNode(fromNodeId, nodeLabel1);
            if (nodeLabel2 !== _struct.VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);
            if (nodeLabel1 !== _struct.VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1) graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
          });
          return graph;
        };
        DFScode3.prototype.buildRmpath = function() {
          this.rmpath = [];
          var oldFrom = void 0;
          var selfLength = this.dfsEdgeList.length;
          for (var i2 = selfLength - 1; i2 >= 0; i2--) {
            var dfsEdge = this.dfsEdgeList[i2];
            var fromNodeIdx = dfsEdge.fromNode;
            var toNodeIdx = dfsEdge.toNode;
            if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
              this.rmpath.push(i2);
              oldFrom = fromNodeIdx;
            }
          }
          return this.rmpath;
        };
        DFScode3.prototype.getNodeNum = function() {
          var nodeMap = {};
          this.dfsEdgeList.forEach(function(dfsEdge) {
            if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;
            if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;
          });
          return Object.keys(nodeMap).length;
        };
        return DFScode3;
      }()
    );
    var History2 = (
      /** @class */
      function() {
        function History3(pdfs) {
          this.his = {};
          this.nodesUsed = {};
          this.edgesUsed = {};
          this.edges = [];
          if (!pdfs) return;
          while (pdfs) {
            var e8 = pdfs.edge;
            this.edges.push(e8);
            this.nodesUsed[e8.from] = 1;
            this.nodesUsed[e8.to] = 1;
            this.edgesUsed[e8.id] = 1;
            pdfs = pdfs.preNode;
          }
          this.edges = this.edges.reverse();
        }
        History3.prototype.hasNode = function(node) {
          return this.nodesUsed[node.id] === 1;
        };
        History3.prototype.hasEdge = function(edge) {
          return this.edgesUsed[edge.id] === 1;
        };
        return History3;
      }()
    );
    var GSpan2 = (
      /** @class */
      function() {
        function GSpan3(_a2) {
          var graphs = _a2.graphs, _b = _a2.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a2.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a2.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e2 = _a2.top, top = _e2 === void 0 ? 10 : _e2, _f = _a2.directed, directed = _f === void 0 ? false : _f, _g = _a2.verbose, verbose = _g === void 0 ? false : _g;
          this.graphs = graphs;
          this.dfsCode = new DFScode2();
          this.support = 0;
          this.frequentSize1Subgraphs = [];
          this.frequentSubgraphs = [];
          this.minSupport = minSupport;
          this.top = top;
          this.directed = directed;
          this.counter = 0;
          this.maxNodeNum = maxNodeNum;
          this.minNodeNum = minNodeNum;
          this.verbose = verbose;
          if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;
          this.reportDF = [];
        }
        GSpan3.prototype.findForwardRootEdges = function(graph, fromNode) {
          var _this = this;
          var result = [];
          var nodeMap = graph.nodeMap;
          fromNode.edges.forEach(function(edge) {
            if (_this.directed || fromNode.label <= nodeMap[edge.to].label) result.push(edge);
          });
          return result;
        };
        GSpan3.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
          if (!this.directed && edge1 === edge2) return null;
          var nodeMap = graph.nodeMap;
          var edge2To = nodeMap[edge2.to];
          var edge2ToEdges = edge2To.edges;
          var edgeLength = edge2ToEdges.length;
          for (var i2 = 0; i2 < edgeLength; i2++) {
            var edge = edge2ToEdges[i2];
            if (history.hasEdge(edge) || edge.to !== edge1.from) continue;
            if (!this.directed) {
              if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
                return edge;
              }
            } else {
              if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
                return edge;
              }
            }
          }
          return null;
        };
        GSpan3.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
          var result = [];
          var rightmostEdgeToId = rightmostEdge.to;
          var edges = graph.nodeMap[rightmostEdgeToId].edges;
          var edgeLength = edges.length;
          for (var i2 = 0; i2 < edgeLength; i2++) {
            var edge = edges[i2];
            var toNode = graph.nodeMap[edge.to];
            if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
              result.push(edge);
            }
          }
          return result;
        };
        GSpan3.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
          var result = [];
          var nodeMap = graph.nodeMap;
          var toNodeLabel = nodeMap[rightmostEdge.to].label;
          var fromNode = nodeMap[rightmostEdge.from];
          var edges = fromNode.edges;
          var edgeLength = edges.length;
          for (var i2 = 0; i2 < edgeLength; i2++) {
            var edge = edges[i2];
            var newToNodeLabel = nodeMap[edge.to].label;
            if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
              continue;
            }
            if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
              result.push(edge);
            }
          }
          return result;
        };
        GSpan3.prototype.getSupport = function(projected) {
          var graphMap = {};
          projected.forEach(function(pro) {
            if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;
          });
          return Object.keys(graphMap).length;
        };
        GSpan3.prototype.findMinLabel = function(obj) {
          var minLabel = void 0;
          Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
            var _a2 = obj[nodeEdgeNodeLabel], nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            if (!minLabel) {
              minLabel = {
                nodeLabel1,
                edgeLabel,
                nodeLabel2
              };
              return;
            }
            if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
              minLabel = {
                nodeLabel1,
                edgeLabel,
                nodeLabel2
              };
            }
          });
          return minLabel;
        };
        GSpan3.prototype.isMin = function() {
          var _this = this;
          var dfsCode = this.dfsCode;
          if (this.verbose) console.log("isMin checking", dfsCode);
          if (dfsCode.dfsEdgeList.length === 1) return true;
          var directed = this.directed;
          var graph = dfsCode.toGraph(_struct.VACANT_GRAPH_ID, directed);
          var nodeMap = graph.nodeMap;
          var dfsCodeMin = new DFScode2();
          var root = {};
          graph.nodes.forEach(function(node) {
            var forwardEdges = _this.findForwardRootEdges(graph, node);
            forwardEdges.forEach(function(edge) {
              var otherNode = nodeMap[edge.to];
              var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
              if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {
                projected: [],
                nodeLabel1: node.label,
                edgeLabel: edge.label,
                nodeLabel2: otherNode.label
              };
              var pdfs = {
                graphId: graph.id,
                edge,
                preNode: null
              };
              root[nodeEdgeNodeLabel].projected.push(pdfs);
            });
          });
          var minLabel = this.findMinLabel(root);
          if (!minLabel) return;
          dfsCodeMin.dfsEdgeList.push(new DFSedge2(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
          var projectIsMin = function projectIsMin2(projected) {
            var rmpath = dfsCodeMin.buildRmpath();
            var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
            var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
            var backwardRoot = {};
            var flag = false, newTo = 0;
            var end2 = directed ? -1 : 0;
            var _loop_1 = function _loop_12(i3) {
              if (flag) return "break";
              projected.forEach(function(p2) {
                var history = new History2(p2);
                var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i3]], history.edges[rmpath[0]], history);
                if (backwardEdge) {
                  if (!backwardRoot[backwardEdge.label]) {
                    backwardRoot[backwardEdge.label] = {
                      projected: [],
                      edgeLabel: backwardEdge.label
                    };
                  }
                  backwardRoot[backwardEdge.label].projected.push({
                    graphId: graph.id,
                    edge: backwardRoot,
                    preNode: p2
                  });
                  newTo = dfsCodeMin.dfsEdgeList[rmpath[i3]].fromNode;
                  flag = true;
                }
              });
            };
            for (var i2 = rmpath.length - 1; i2 > end2; i2--) {
              var state_1 = _loop_1(i2);
              if (state_1 === "break") break;
            }
            if (flag) {
              var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);
              dfsCodeMin.dfsEdgeList.push(new DFSedge2(maxToC, newTo, _struct.VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, _struct.VACANT_NODE_LABEL));
              var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
              if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1]) return false;
              return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
            }
            var forwardRoot = {};
            flag = false;
            var newFrom = 0;
            projected.forEach(function(p2) {
              var history = new History2(p2);
              var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
              if (forwardPureEdges.length > 0) {
                flag = true;
                newFrom = maxToC;
                forwardPureEdges.forEach(function(edge) {
                  var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                  if (!forwardRoot[key2]) forwardRoot[key2] = {
                    projected: [],
                    edgeLabel: edge.label,
                    nodeLabel2: nodeMap[edge.to].label
                  };
                  forwardRoot[key2].projected.push({
                    graphId: graph.id,
                    edge,
                    preNode: p2
                  });
                });
              }
            });
            var pathLength = rmpath.length;
            var _loop_2 = function _loop_22(i3) {
              if (flag) return "break";
              var value = rmpath[i3];
              projected.forEach(function(p2) {
                var history = new History2(p2);
                var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
                if (forwardRmpathEdges.length > 0) {
                  flag = true;
                  newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
                  forwardRmpathEdges.forEach(function(edge) {
                    var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                    if (!forwardRoot[key2]) forwardRoot[key2] = {
                      projected: [],
                      edgeLabel: edge.label,
                      nodeLabel2: nodeMap[edge.to].label
                    };
                    forwardRoot[key2].projected.push({
                      graphId: graph.id,
                      edge,
                      preNode: p2
                    });
                  });
                }
              });
            };
            for (var i2 = 0; i2 < pathLength; i2++) {
              var state_2 = _loop_2(i2);
              if (state_2 === "break") break;
            }
            if (!flag) return true;
            var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);
            dfsCodeMin.dfsEdgeList.push(new DFSedge2(newFrom, maxToC + 1, _struct.VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
            var idx = dfsCodeMin.dfsEdgeList.length - 1;
            if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx]) return false;
            return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
          };
          var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
          return projectIsMin(root[key].projected);
        };
        GSpan3.prototype.report = function() {
          if (this.dfsCode.getNodeNum() < this.minNodeNum) return;
          this.counter++;
          var graph = this.dfsCode.toGraph(this.counter, this.directed);
          this.frequentSubgraphs.push((0, _util.clone)(graph));
        };
        GSpan3.prototype.subGraphMining = function(projected) {
          var _this = this;
          var support = this.getSupport(projected);
          if (support < this.minSupport) return;
          if (!this.isMin()) return;
          this.report();
          var nodeNum = this.dfsCode.getNodeNum();
          var rmpath = this.dfsCode.buildRmpath();
          var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
          var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
          var forwardRoot = {};
          var backwardRoot = {};
          projected.forEach(function(p2) {
            var graph = _this.graphs[p2.graphId];
            var nodeMap = graph.nodeMap;
            var history = new History2(p2);
            for (var i2 = rmpath.length - 1; i2 >= 0; i2--) {
              var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
              if (backwardEdge) {
                var key = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(backwardEdge.label);
                if (!backwardRoot[key]) backwardRoot[key] = {
                  projected: [],
                  toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
                  edgeLabel: backwardEdge.label
                };
                backwardRoot[key].projected.push({
                  graphId: p2.graphId,
                  edge: backwardEdge,
                  preNode: p2
                });
              }
            }
            if (nodeNum >= _this.maxNodeNum) return;
            var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
            forwardPureEdges.forEach(function(edge) {
              var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2]) forwardRoot[key2] = {
                projected: [],
                fromNodeId: maxToC,
                edgeLabel: edge.label,
                nodeLabel2: nodeMap[edge.to].label
              };
              forwardRoot[key2].projected.push({
                graphId: p2.graphId,
                edge,
                preNode: p2
              });
            });
            var _loop_3 = function _loop_32(i3) {
              var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i3]], minNodeLabel, history);
              forwardRmpathEdges.forEach(function(edge) {
                var key2 = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
                if (!forwardRoot[key2]) forwardRoot[key2] = {
                  projected: [],
                  fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode,
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
                forwardRoot[key2].projected.push({
                  graphId: p2.graphId,
                  edge,
                  preNode: p2
                });
              });
            };
            for (var i2 = 0; i2 < rmpath.length; i2++) {
              _loop_3(i2);
            }
          });
          Object.keys(backwardRoot).forEach(function(key) {
            var _a2 = backwardRoot[key], toNodeId = _a2.toNodeId, edgeLabel = _a2.edgeLabel;
            _this.dfsCode.dfsEdgeList.push(new DFSedge2(maxToC, toNodeId, "-1", edgeLabel, "-1"));
            _this.subGraphMining(backwardRoot[key].projected);
            _this.dfsCode.dfsEdgeList.pop();
          });
          Object.keys(forwardRoot).forEach(function(key) {
            var _a2 = forwardRoot[key], fromNodeId = _a2.fromNodeId, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            _this.dfsCode.dfsEdgeList.push(new DFSedge2(fromNodeId, maxToC + 1, _struct.VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
            _this.subGraphMining(forwardRoot[key].projected);
            _this.dfsCode.dfsEdgeList.pop();
          });
        };
        GSpan3.prototype.generate1EdgeFrequentSubGraphs = function() {
          var graphs = this.graphs;
          var directed = this.directed;
          var minSupport = this.minSupport;
          var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
          var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
          var nodeLableCounted = {};
          var nodeEdgeNodeLabelCounted = {};
          Object.keys(graphs).forEach(function(key) {
            var graph = graphs[key];
            var nodeMap = graph.nodeMap;
            graph.nodes.forEach(function(node, i2) {
              var nodeLabel = node.label;
              var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
              if (!nodeLableCounted[graphNodeKey]) {
                var counter = nodeLabelCounter[nodeLabel] || 0;
                counter++;
                nodeLabelCounter[nodeLabel] = counter;
              }
              nodeLableCounted[graphNodeKey] = {
                graphKey: key,
                label: nodeLabel
              };
              node.edges.forEach(function(edge) {
                var nodeLabel1 = nodeLabel;
                var nodeLabel2 = nodeMap[edge.to].label;
                if (!directed && nodeLabel1 > nodeLabel2) {
                  var tmp = nodeLabel2;
                  nodeLabel2 = nodeLabel1;
                  nodeLabel1 = tmp;
                }
                var edgeLabel = edge.label;
                var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
                var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
                if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
                  var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
                  counter2++;
                  nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
                }
                nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
                  graphId: key,
                  nodeLabel1,
                  edgeLabel,
                  nodeLabel2
                };
              });
            });
          });
          Object.keys(nodeLabelCounter).forEach(function(label) {
            var count = nodeLabelCounter[label];
            if (count < minSupport) return;
            var g2 = {
              nodes: [],
              edges: []
            };
            g2.nodes.push({
              id: "0",
              label
            });
            frequentSize1Subgraphs.push(g2);
          });
          return frequentSize1Subgraphs;
        };
        GSpan3.prototype.run = function() {
          var _this = this;
          this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
          if (this.maxNodeNum < 2) return;
          var graphs = this.graphs;
          var directed = this.directed;
          var root = {};
          Object.keys(graphs).forEach(function(graphId) {
            var graph = graphs[graphId];
            var nodeMap = graph.nodeMap;
            graph.nodes.forEach(function(node) {
              var forwardRootEdges = _this.findForwardRootEdges(graph, node);
              forwardRootEdges.forEach(function(edge) {
                var toNode = nodeMap[edge.to];
                var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
                if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {
                  projected: [],
                  nodeLabel1: node.label,
                  edgeLabel: edge.label,
                  nodeLabel2: toNode.label
                };
                var pdfs = {
                  graphId,
                  edge,
                  preNode: null
                };
                root[nodeEdgeNodeLabel].projected.push(pdfs);
              });
            });
          });
          Object.keys(root).forEach(function(nodeEdgeNodeLabel) {
            var _a2 = root[nodeEdgeNodeLabel], projected = _a2.projected, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            _this.dfsCode.dfsEdgeList.push(new DFSedge2(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
            _this.subGraphMining(projected);
            _this.dfsCode.dfsEdgeList.pop();
          });
        };
        return GSpan3;
      }()
    );
    var formatGraphs3 = function formatGraphs4(graphs, directed, nodeLabelProp, edgeLabelProp) {
      var result = {};
      Object.keys(graphs).forEach(function(key, i2) {
        var graph = graphs[key];
        var fGraph = new _struct.Graph(i2, true, directed);
        var nodeIdxMap = {};
        graph.nodes.forEach(function(node, j2) {
          fGraph.addNode(j2, node[nodeLabelProp]);
          nodeIdxMap[node.id] = j2;
        });
        graph.edges.forEach(function(edge, k2) {
          var sourceIdx = nodeIdxMap[edge.source];
          var targetIdx = nodeIdxMap[edge.target];
          fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);
        });
        if (fGraph && fGraph.getNodeNum()) result[fGraph.id] = fGraph;
      });
      return result;
    };
    var toGraphDatas3 = function toGraphDatas4(graphs, nodeLabelProp, edgeLabelProp) {
      var result = [];
      graphs.forEach(function(graph) {
        var graphData = {
          nodes: [],
          edges: []
        };
        graph.nodes.forEach(function(node) {
          var _a2;
          graphData.nodes.push((_a2 = {
            id: "".concat(node.id)
          }, _a2[nodeLabelProp] = node.label, _a2));
        });
        graph.edges.forEach(function(edge) {
          var _a2;
          graphData.edges.push((_a2 = {
            source: "".concat(edge.from),
            target: "".concat(edge.to)
          }, _a2[edgeLabelProp] = edge.label, _a2));
        });
        result.push(graphData);
      });
      return result;
    };
    var DEFAULT_LABEL_NAME2 = "cluster";
    var gSpan3 = function gSpan4(params) {
      var graphs = params.graphs, _a2 = params.directed, directed = _a2 === void 0 ? false : _a2, _b = params.nodeLabelProp, nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME2 : _b, _c = params.edgeLabelProp, edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME2 : _c;
      var formattedGraphs = formatGraphs3(graphs, directed, nodeLabelProp, edgeLabelProp);
      var minSupport = params.minSupport, maxNodeNum = params.maxNodeNum, minNodeNum = params.minNodeNum, verbose = params.verbose, top = params.top;
      var algoParams = {
        graphs: formattedGraphs,
        minSupport,
        maxNodeNum,
        minNodeNum,
        top,
        verbose,
        directed
      };
      var calculator = new GSpan2(algoParams);
      calculator.run();
      var result = toGraphDatas3(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);
      return result;
    };
    var _default = gSpan3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/gaddi.js
var require_gaddi = __commonJS({
  "node_modules/@antv/algorithm/lib/gaddi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var _floydWarshall = _interopRequireDefault(require_floydWarshall());
    var _gSpan = _interopRequireDefault(require_gSpan());
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var findKNeighborUnits3 = function findKNeighborUnits4(graphData, spm, nodeLabelProp, k2) {
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (k2 === void 0) {
        k2 = 2;
      }
      var units = [];
      var nodes = graphData.nodes;
      spm.forEach(function(row, i2) {
        units.push(findKNeighborUnit3(nodes, row, i2, nodeLabelProp, k2));
      });
      return units;
    };
    var findKNeighborUnit3 = function findKNeighborUnit4(nodes, row, i2, nodeLabelProp, k2) {
      var unitNodeIdxs = [i2];
      var neighbors = [];
      var labelCountMap = {};
      row.forEach(function(v2, j2) {
        if (v2 <= k2 && i2 !== j2) {
          unitNodeIdxs.push(j2);
          neighbors.push(nodes[j2]);
          var label = nodes[j2][nodeLabelProp];
          if (!labelCountMap[label]) labelCountMap[label] = {
            count: 1,
            dists: [v2]
          };
          else {
            labelCountMap[label].count++;
            labelCountMap[label].dists.push(v2);
          }
        }
      });
      Object.keys(labelCountMap).forEach(function(label) {
        labelCountMap[label].dists = labelCountMap[label].dists.sort(function(a3, b10) {
          return a3 - b10;
        });
      });
      return {
        nodeIdx: i2,
        nodeId: nodes[i2].id,
        nodeIdxs: unitNodeIdxs,
        neighbors,
        neighborNum: unitNodeIdxs.length - 1,
        nodeLabelCountMap: labelCountMap
      };
    };
    var findNodePairsRandomly3 = function findNodePairsRandomly4(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm) {
      var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);
      var nodePairMap = {};
      var foundNodePairCount = 0;
      kNeighborUnits.forEach(function(unit, i2) {
        var nodePairForICount = 0;
        var outerLoopCount = 0;
        var neighbors = unit.nodeIdxs;
        var neighborNum = unit.neighborNum - 1;
        while (nodePairForICount < nodePairNumEachNode) {
          var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];
          var innerLoopCount = 0;
          while (nodePairMap["".concat(i2, "-").concat(oidx)] || nodePairMap["".concat(oidx, "-").concat(i2)]) {
            oidx = Math.floor(Math.random() * nodeNum);
            innerLoopCount++;
            if (innerLoopCount > 2 * nodeNum) break;
          }
          if (innerLoopCount < 2 * nodeNum) {
            nodePairMap["".concat(i2, "-").concat(oidx)] = {
              start: i2,
              end: oidx,
              distance: spm[i2][oidx]
            };
            nodePairForICount++;
            foundNodePairCount++;
            if (foundNodePairCount >= maxNodePairNum) return nodePairMap;
          }
          outerLoopCount++;
          if (outerLoopCount > 2 * nodeNum) break;
        }
        if (nodePairForICount < nodePairNumEachNode) {
          var gap = nodePairNumEachNode - nodePairForICount;
          nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i2 - 1);
        }
      });
      return nodePairMap;
    };
    var getIntersectNeighborInducedGraph3 = function getIntersectNeighborInducedGraph4(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {
      var nodes = graphData.nodes;
      if (!cachedInducedGraphMap) cachedInducedGraphMap = {};
      Object.keys(nodePairMap).forEach(function(key) {
        var _a2, _b;
        if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;
        cachedInducedGraphMap[key] = {
          nodes: [],
          edges: []
        };
        var pair = nodePairMap[key];
        var startUnitNodeIds = (_a2 = neighborUnits[pair.start]) === null || _a2 === void 0 ? void 0 : _a2.nodeIdxs;
        var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;
        if (!startUnitNodeIds || !endUnitNodeIds) return;
        var endSet = new Set(endUnitNodeIds);
        var intersect2 = startUnitNodeIds.filter(function(x4) {
          return endSet.has(x4);
        });
        if (!intersect2 || !intersect2.length) return;
        var intersectIdMap = {};
        var intersectLength = intersect2.length;
        for (var i2 = 0; i2 < intersectLength; i2++) {
          var node = nodes[intersect2[i2]];
          cachedInducedGraphMap[key].nodes.push(node);
          intersectIdMap[node.id] = true;
        }
        graphData.edges.forEach(function(edge) {
          if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);
        });
      });
      return cachedInducedGraphMap;
    };
    var getMatchedCount3 = function getMatchedCount4(graph, structure, nodeLabelProp, edgeLabelProp) {
      var _a2, _b;
      var nodeMap = {};
      graph.nodes.forEach(function(node) {
        nodeMap[node.id] = node;
      });
      var count = 0;
      if (!((_a2 = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2) return 0;
      graph.edges.forEach(function(e8) {
        var sourceLabel = nodeMap[e8.source][nodeLabelProp];
        var targetLabel = nodeMap[e8.target][nodeLabelProp];
        var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];
        var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];
        var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];
        if (e8[edgeLabelProp] !== strEdgeLabel) return;
        if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {
          count++;
        }
      });
      return count;
    };
    var findRepresentStructure3 = function findRepresentStructure4(matchedCountMap, structureNum, structures) {
      var maxOffset = Infinity, representClusterType = 0;
      var _loop_1 = function _loop_12(i3) {
        var countMapI = matchedCountMap[i3];
        var sortedGraphKeys = Object.keys(countMapI).sort(function(a3, b10) {
          return countMapI[a3] - countMapI[b10];
        });
        var groupNum = 10;
        var clusters = [];
        sortedGraphKeys.forEach(function(key, j2) {
          if (!clusters[j2 % groupNum]) clusters[j2 % groupNum] = {
            graphs: [],
            totalCount: 0,
            aveCount: 0
          };
          clusters[j2 % groupNum].graphs.push(key);
          clusters[j2 % groupNum].totalCount += countMapI[key];
        });
        var aveIntraDist = 0;
        var aveCounts = [];
        clusters.forEach(function(graphsInCluster) {
          var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;
          graphsInCluster.aveCount = aveCount;
          aveCounts.push(aveCount);
          var aveIntraPerCluster = 0;
          var graphsNum = graphsInCluster.length;
          graphsInCluster.graphs.forEach(function(graphKey1, j2) {
            var graph1Count = countMapI[graphKey1];
            graphsInCluster.graphs.forEach(function(graphKey2, k2) {
              if (j2 === k2) return;
              aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);
            });
          });
          aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;
          aveIntraDist += aveIntraPerCluster;
        });
        aveIntraDist /= clusters.length;
        var aveInterDist = 0;
        aveCounts.forEach(function(aveCount1, j2) {
          aveCounts.forEach(function(aveCount2, k2) {
            if (j2 === k2) return;
            aveInterDist += Math.abs(aveCount1 - aveCount2);
          });
          aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;
        });
        var offset = aveInterDist - aveIntraDist;
        if (maxOffset < offset) {
          maxOffset = offset;
          representClusterType = i3;
        }
      };
      for (var i2 = 0; i2 < structureNum; i2++) {
        _loop_1(i2);
      }
      return {
        structure: structures[representClusterType],
        structureCountMap: matchedCountMap[representClusterType]
      };
    };
    var getNodeMaps3 = function getNodeMaps4(nodes, nodeLabelProp) {
      var nodeMap = {}, nodeLabelMap = {};
      nodes.forEach(function(node, i2) {
        nodeMap[node.id] = {
          idx: i2,
          node,
          degree: 0,
          inDegree: 0,
          outDegree: 0
        };
        var label = node[nodeLabelProp];
        if (!nodeLabelMap[label]) nodeLabelMap[label] = [];
        nodeLabelMap[label].push(node);
      });
      return {
        nodeMap,
        nodeLabelMap
      };
    };
    var getEdgeMaps3 = function getEdgeMaps4(edges, edgeLabelProp, nodeMap) {
      var edgeMap = {}, edgeLabelMap = {};
      edges.forEach(function(edge, i2) {
        edgeMap["".concat(_util.uniqueId)] = {
          idx: i2,
          edge
        };
        var label = edge[edgeLabelProp];
        if (!edgeLabelMap[label]) edgeLabelMap[label] = [];
        edgeLabelMap[label].push(edge);
        var sourceNode = nodeMap[edge.source];
        if (sourceNode) {
          sourceNode.degree++;
          sourceNode.outDegree++;
        }
        var targetNode = nodeMap[edge.target];
        if (targetNode) {
          targetNode.degree++;
          targetNode.inDegree++;
        }
      });
      return {
        edgeMap,
        edgeLabelMap
      };
    };
    var getSpmMap3 = function getSpmMap4(nodes, spm, directed) {
      var length6 = spm.length;
      var map6 = {};
      spm.forEach(function(row, i2) {
        var start = directed ? 0 : i2 + 1;
        var iId = nodes[i2].id;
        for (var j2 = start; j2 < length6; j2++) {
          if (i2 === j2) continue;
          var jId = nodes[j2].id;
          var dist4 = row[j2];
          map6["".concat(iId, "-").concat(jId)] = dist4;
          if (!directed) map6["".concat(jId, "-").concat(iId)] = dist4;
        }
      });
      return map6;
    };
    var getNDSDist3 = function getNDSDist4(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {
      var _a2;
      var key = "".concat(node1.id, "-").concat(node2.id);
      if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];
      var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : void 0;
      if (!interInducedGraph) {
        var pairMap = (_a2 = {}, _a2[key] = {
          start: nodeMap[node1.id].idx,
          end: nodeMap[node2.id].idx,
          distance: spDist
        }, _a2);
        cachedInterInducedGraph = getIntersectNeighborInducedGraph3(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);
        interInducedGraph = cachedInterInducedGraph[key];
      }
      return getMatchedCount3(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);
    };
    var stashPatternNodeLabelDegreeMap3 = function stashPatternNodeLabelDegreeMap4(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {
      var _a2, _b, _c;
      var minPatternNodeLabelDegree = (_a2 = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a2 === void 0 ? void 0 : _a2.degree;
      var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;
      var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;
      if (minPatternNodeLabelDegreeMap[neighborLabel] === void 0) {
        minPatternNodeLabelDegree = Infinity;
        minPatternNodeLabelInDegree = Infinity;
        minPatternNodeLabelOutDegree = Infinity;
        patternNodeLabelMap[neighborLabel].forEach(function(patternNodeWithLabel) {
          var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;
          if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;
          var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;
          if (minPatternNodeLabelInDegree > patternNodeInDegree) minPatternNodeLabelInDegree = patternNodeInDegree;
          var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;
          if (minPatternNodeLabelOutDegree > patternNodeOutDegree) minPatternNodeLabelOutDegree = patternNodeOutDegree;
        });
        minPatternNodeLabelDegreeMap[neighborLabel] = {
          degree: minPatternNodeLabelDegree,
          inDegree: minPatternNodeLabelInDegree,
          outDegree: minPatternNodeLabelOutDegree
        };
      }
      return {
        minPatternNodeLabelDegree,
        minPatternNodeLabelInDegree,
        minPatternNodeLabelOutDegree
      };
    };
    var GADDI3 = function GADDI4(graphData, pattern, directed, k2, length6, nodeLabelProp, edgeLabelProp) {
      var _a2;
      if (directed === void 0) {
        directed = false;
      }
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (edgeLabelProp === void 0) {
        edgeLabelProp = "cluster";
      }
      if (!graphData || !graphData.nodes) return;
      var nodeNum = graphData.nodes.length;
      if (!nodeNum) return;
      var spm = (0, _floydWarshall.default)(graphData, directed);
      var patternSpm = (0, _floydWarshall.default)(pattern, directed);
      var spmMap = getSpmMap3(graphData.nodes, spm, directed);
      var patternSpmMap = getSpmMap3(pattern.nodes, patternSpm, directed);
      var _b = getNodeMaps3(graphData.nodes, nodeLabelProp), nodeMap = _b.nodeMap, nodeLabelMap = _b.nodeLabelMap;
      var _c = getNodeMaps3(pattern.nodes, nodeLabelProp), patternNodeMap = _c.nodeMap, patternNodeLabelMap = _c.nodeLabelMap;
      getEdgeMaps3(graphData.edges, edgeLabelProp, nodeMap);
      var patternEdgeLabelMap = getEdgeMaps3(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;
      var patternSpmSpread = [];
      patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function(row) {
        patternSpmSpread = patternSpmSpread.concat(row);
      });
      if (!length6) length6 = Math.max.apply(Math, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], patternSpmSpread, false), [2], false));
      if (!k2) k2 = length6;
      var kNeighborUnits = findKNeighborUnits3(graphData, spm, nodeLabelProp, k2);
      var patternKNeighborUnits = findKNeighborUnits3(pattern, patternSpm, nodeLabelProp, k2);
      var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);
      var nodePairsMap = findNodePairsRandomly3(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm);
      var intGMap = getIntersectNeighborInducedGraph3(nodePairsMap, kNeighborUnits, graphData);
      var top = 10, minSupport = 1, minNodeNum = 1, maxNodeNum = 4;
      var params = {
        graphs: intGMap,
        nodeLabelProp,
        edgeLabelProp,
        minSupport,
        minNodeNum,
        maxNodeNum,
        directed
      };
      var freStructures = (0, _gSpan.default)(params).slice(0, top);
      var structureNum = freStructures.length;
      var matchedCountMap = [];
      freStructures.forEach(function(structure, i3) {
        matchedCountMap[i3] = {};
        Object.keys(intGMap).forEach(function(key) {
          var graph = intGMap[key];
          var subStructureCount = getMatchedCount3(graph, structure, nodeLabelProp, edgeLabelProp);
          matchedCountMap[i3][key] = subStructureCount;
        });
      });
      var _d = findRepresentStructure3(matchedCountMap, structureNum, freStructures), dsG = _d.structure, ndsDist = _d.structureCountMap;
      var beginPNode = pattern.nodes[0], candidates = [], label = (_a2 = pattern.nodes[0]) === null || _a2 === void 0 ? void 0 : _a2[nodeLabelProp], maxNodeNumWithSameLabel = -Infinity;
      pattern.nodes.forEach(function(node) {
        var pLabel = node[nodeLabelProp];
        var nodesWithSameLabel = nodeLabelMap[pLabel];
        if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {
          maxNodeNumWithSameLabel = nodesWithSameLabel.length;
          candidates = nodesWithSameLabel;
          label = pLabel;
          beginPNode = node;
        }
      });
      var minPatternNodeLabelDegreeMap = {};
      var patternIntGraphMap = {}, patternNDSDist = {}, patternNDSDistMap = {};
      var patternSpDist = {};
      var patternSpDistBack = {};
      Object.keys(patternNodeLabelMap).forEach(function(label2, j2) {
        patternSpDist[label2] = [];
        if (directed) {
          patternSpDistBack[label2] = [];
        }
        var maxDist = -Infinity;
        var patternNodesWithLabel2 = patternNodeLabelMap[label2];
        var patternNodePairMap = {};
        patternNodesWithLabel2.forEach(function(nodeWithLabel2) {
          var dist4 = patternSpmMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)];
          dist4 && patternSpDist[label2].push(dist4);
          if (maxDist < dist4) maxDist = dist4;
          patternNodePairMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)] = {
            start: 0,
            end: patternNodeMap[nodeWithLabel2.id].idx,
            distance: dist4
          };
          if (directed) {
            var distBack = patternSpmMap["".concat(nodeWithLabel2.id, "-").concat(beginPNode.id)];
            distBack && patternSpDistBack[label2].push(distBack);
          }
        });
        patternSpDist[label2] = patternSpDist[label2].sort(function(a3, b10) {
          return a3 - b10;
        });
        if (directed) patternSpDistBack[label2] = patternSpDistBack[label2].sort(function(a3, b10) {
          return a3 - b10;
        });
        patternIntGraphMap = getIntersectNeighborInducedGraph3(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);
        var currentPatternNDSDistArray = [];
        Object.keys(patternNodePairMap).forEach(function(key) {
          if (patternNDSDist[key]) {
            currentPatternNDSDistArray.push(patternNDSDist[key]);
            return;
          }
          var patternIntGraph = patternIntGraphMap[key];
          patternNDSDist[key] = getMatchedCount3(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);
          currentPatternNDSDistArray.push(patternNDSDist[key]);
        });
        currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function(a3, b10) {
          return b10 - a3;
        });
        patternNDSDistMap["".concat(beginPNode.id, "-").concat(label2)] = currentPatternNDSDistArray;
        if (label2 === label) return;
        var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;
        var _loop_4 = function _loop_42(m4) {
          var cNode = candidates[m4];
          var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];
          var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];
          var patternLabel2Num = patternNodeLabelMap[label2].length;
          if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {
            candidates.splice(m4, 1);
            return "continue";
          }
          var prune2Invalid = false;
          for (var n2 = 0; n2 < patternLabel2Num; n2++) {
            if (graphNeighborUnitCountMap.dists[n2] > patternSpDist[label2][n2]) {
              prune2Invalid = true;
              break;
            }
          }
          if (prune2Invalid) {
            candidates.splice(m4, 1);
            return "continue";
          }
          var cNodePairMap = {};
          graphNeighborUnit.neighbors.forEach(function(neighborNode) {
            var dist4 = spmMap["".concat(cNode.id, "-").concat(neighborNode.id)];
            cNodePairMap["".concat(cNode.id, "-").concat(neighborNode.id)] = {
              start: nodeMap[cNode.id].idx,
              end: nodeMap[neighborNode.id].idx,
              distance: dist4
            };
          });
          intGMap = getIntersectNeighborInducedGraph3(cNodePairMap, kNeighborUnits, graphData, intGMap);
          var currentNDSDistArray = [];
          Object.keys(cNodePairMap).forEach(function(key) {
            if (ndsDist[key]) {
              currentNDSDistArray.push(ndsDist[key]);
              return;
            }
            var intGraph = intGMap[key];
            ndsDist[key] = getMatchedCount3(intGraph, dsG, nodeLabelProp, edgeLabelProp);
            currentNDSDistArray.push(ndsDist[key]);
          });
          currentNDSDistArray = currentNDSDistArray.sort(function(a3, b10) {
            return b10 - a3;
          });
          var prune3Invalid = false;
          for (var n2 = 0; n2 < patternLabel2Num; n2++) {
            if (currentNDSDistArray[n2] < currentPatternNDSDistArray[n2]) {
              prune3Invalid = true;
              break;
            }
          }
          if (prune3Invalid) {
            candidates.splice(m4, 1);
            return "continue";
          }
        };
        for (var m3 = candidatesNum - 1; m3 >= 0; m3--) {
          _loop_4(m3);
        }
      });
      var candidateGraphs = [];
      candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function(candidate) {
        var nodeIdx = nodeMap[candidate.id].idx;
        var lengthNeighborUnit = findKNeighborUnit3(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length6);
        var neighborNodes = lengthNeighborUnit.neighbors;
        var neighborNum = neighborNodes.length;
        var unmatched = false;
        for (var i3 = neighborNum - 1; i3 >= 0; i3--) {
          if (neighborNodes.length + 1 < pattern.nodes.length) {
            unmatched = true;
            return;
          }
          var neighborNode = neighborNodes[i3];
          var neighborLabel = neighborNode[nodeLabelProp];
          if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          var key = "".concat(candidate.id, "-").concat(neighborNode.id);
          var distToCandidate = spmMap[key];
          var idx = patternSpDist[neighborLabel].length - 1;
          var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx];
          if (distToCandidate > maxDistWithLabelInPattern) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          if (directed) {
            var keyBack = "".concat(neighborNode.id, "-").concat(candidate.id);
            var distFromCandidate = spmMap[keyBack];
            idx = patternSpDistBack[neighborLabel].length - 1;
            var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];
            if (distFromCandidate > maxBackDistWithLabelInPattern) {
              neighborNodes.splice(i3, 1);
              continue;
            }
          }
          var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist3(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);
          var patternKey = "".concat(beginPNode.id, "-").concat(neighborLabel);
          var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1];
          if (ndsToCandidate < minNdsWithLabelInPattern) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          var _a3 = stashPatternNodeLabelDegreeMap3(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _a3.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _a3.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _a3.minPatternNodeLabelOutDegree;
          if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {
            neighborNodes.splice(i3, 1);
            continue;
          }
        }
        if (!unmatched) {
          candidateGraphs.push({
            nodes: [candidate].concat(neighborNodes)
          });
        }
      });
      var undirectedLengthsToBeginPNode = (0, _dijkstra.default)(pattern, beginPNode.id, false).length;
      var undirectedLengthsToBeginPNodeLabelMap = {};
      if (directed) {
        Object.keys(undirectedLengthsToBeginPNode).forEach(function(nodeId) {
          var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];
          if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];
          else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);
        });
        Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function(pLabel) {
          undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function(a3, b10) {
            return a3 - b10;
          });
        });
      } else {
        undirectedLengthsToBeginPNodeLabelMap = patternSpDist;
      }
      var candidateGraphNum = candidateGraphs.length;
      var _loop_2 = function _loop_22(i3) {
        var candidateGraph = candidateGraphs[i3];
        var candidate = candidateGraph.nodes[0];
        var candidateNodeLabelCountMap = {};
        var candidateNodeMap = {};
        candidateGraph.nodes.forEach(function(node, q2) {
          candidateNodeMap[node.id] = {
            idx: q2,
            node,
            degree: 0,
            inDegree: 0,
            outDegree: 0
          };
          var cNodeLabel2 = node[nodeLabelProp];
          if (!candidateNodeLabelCountMap[cNodeLabel2]) candidateNodeLabelCountMap[cNodeLabel2] = 1;
          else candidateNodeLabelCountMap[cNodeLabel2]++;
        });
        var candidateEdges = [];
        var edgeLabelCountMap = {};
        graphData.edges.forEach(function(edge) {
          if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {
            candidateEdges.push(edge);
            if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;
            else edgeLabelCountMap[edge[edgeLabelProp]]++;
            candidateNodeMap[edge.source].degree++;
            candidateNodeMap[edge.target].degree++;
            candidateNodeMap[edge.source].outDegree++;
            candidateNodeMap[edge.target].inDegree++;
          }
        });
        var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;
        var prunedByEdgeLabel = false;
        for (var e8 = 0; e8 < pattenrEdgeLabelNum; e8++) {
          var label_1 = Object.keys(patternEdgeLabelMap)[e8];
          if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {
            prunedByEdgeLabel = true;
            break;
          }
        }
        if (prunedByEdgeLabel) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        var candidateEdgeNum = candidateEdges.length;
        if (candidateEdgeNum < pattern.edges.length) {
          candidateGraphs.splice(i3, 1);
          return "break";
        }
        var candidateGraphInvalid = false;
        var _loop_5 = function _loop_52(e9) {
          var edge = candidateEdges[e9];
          var edgeLabel2 = edge[edgeLabelProp];
          var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel2];
          if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {
            edgeLabelCountMap[edgeLabel2]--;
            if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
              candidateGraphInvalid = true;
              return "break";
            }
            candidateEdges.splice(e9, 1);
            candidateNodeMap[edge.source].degree--;
            candidateNodeMap[edge.target].degree--;
            candidateNodeMap[edge.source].outDegree--;
            candidateNodeMap[edge.target].inDegree--;
            return "continue";
          }
          var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];
          var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];
          var edgeMatched = false;
          patternEdgesWithLabel.forEach(function(patternEdge) {
            var patternSource = patternNodeMap[patternEdge.source].node;
            var patternTarget = patternNodeMap[patternEdge.target].node;
            if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;
            if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;
          });
          if (!edgeMatched) {
            edgeLabelCountMap[edgeLabel2]--;
            if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
              candidateGraphInvalid = true;
              return "break";
            }
            candidateEdges.splice(e9, 1);
            candidateNodeMap[edge.source].degree--;
            candidateNodeMap[edge.target].degree--;
            candidateNodeMap[edge.source].outDegree--;
            candidateNodeMap[edge.target].inDegree--;
            return "continue";
          }
        };
        for (var e8 = candidateEdgeNum - 1; e8 >= 0; e8--) {
          var state_2 = _loop_5(e8);
          if (state_2 === "break") break;
        }
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        candidateGraph.edges = candidateEdges;
        var lengthsToCandidate = (0, _dijkstra.default)(candidateGraph, candidateGraph.nodes[0].id, false).length;
        Object.keys(lengthsToCandidate).reverse().forEach(function(targetId) {
          if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return;
          if (lengthsToCandidate[targetId] === Infinity) {
            var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
            candidateNodeLabelCountMap[targetNodeLabel]--;
            if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
              candidateGraphInvalid = true;
              return;
            }
            var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
            candidateGraph.nodes.splice(idx, 1);
            candidateNodeMap[targetId] = void 0;
            return;
          }
          var nLabel = nodeMap[targetId].node[nodeLabelProp];
          if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {
            var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
            candidateNodeLabelCountMap[targetNodeLabel]--;
            if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
              candidateGraphInvalid = true;
              return;
            }
            var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
            candidateGraph.nodes.splice(idx, 1);
            candidateNodeMap[targetId] = void 0;
          }
        });
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        var degreeChanged = true;
        var loopCount = 0;
        while (degreeChanged && !candidateGraphInvalid) {
          degreeChanged = false;
          var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;
          if (condition) {
            candidateGraphInvalid = true;
            break;
          }
          if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {
            candidateGraphInvalid = true;
            break;
          }
          var currentCandidateNodeNum = candidateGraph.nodes.length;
          for (var o2 = currentCandidateNodeNum - 1; o2 >= 0; o2--) {
            var cgNode = candidateGraph.nodes[o2];
            var nodeDegree = candidateNodeMap[cgNode.id].degree;
            var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;
            var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;
            var cNodeLabel = cgNode[nodeLabelProp];
            var _e2 = stashPatternNodeLabelDegreeMap3(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _e2.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _e2.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _e2.minPatternNodeLabelOutDegree;
            var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;
            if (deleteCondition) {
              candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;
              if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {
                candidateGraphInvalid = true;
                break;
              }
              candidateGraph.nodes.splice(o2, 1);
              candidateNodeMap[cgNode.id] = void 0;
              degreeChanged = true;
            }
          }
          if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break;
          candidateEdgeNum = candidateEdges.length;
          for (var y4 = candidateEdgeNum - 1; y4 >= 0; y4--) {
            var cedge = candidateEdges[y4];
            if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {
              candidateEdges.splice(y4, 1);
              var edgeLabel = cedge[edgeLabelProp];
              edgeLabelCountMap[edgeLabel]--;
              if (candidateNodeMap[cedge.source]) {
                candidateNodeMap[cedge.source].degree--;
                candidateNodeMap[cedge.source].outDegree--;
              }
              if (candidateNodeMap[cedge.target]) {
                candidateNodeMap[cedge.target].degree--;
                candidateNodeMap[cedge.target].inDegree--;
              }
              if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {
                candidateGraphInvalid = true;
                break;
              }
              degreeChanged = true;
            }
          }
          loopCount++;
        }
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
      };
      for (var i2 = candidateGraphNum - 1; i2 >= 0; i2--) {
        var state_1 = _loop_2(i2);
        if (state_1 === "break") break;
      }
      var currentLength = candidateGraphs.length;
      var _loop_3 = function _loop_32(i3) {
        var cg1 = candidateGraphs[i3];
        var cg1EdgeMap = {};
        cg1.edges.forEach(function(edge) {
          var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
          if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;
          else cg1EdgeMap[key]++;
        });
        var _loop_6 = function _loop_62(j3) {
          var cg2 = candidateGraphs[j3];
          var cg2EdgeMap = {};
          cg2.edges.forEach(function(edge) {
            var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
            if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;
            else cg2EdgeMap[key]++;
          });
          var same = true;
          if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {
            same = false;
          } else {
            Object.keys(cg1EdgeMap).forEach(function(key) {
              if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;
            });
          }
          if (same) {
            candidateGraphs.splice(j3, 1);
          }
        };
        for (var j2 = currentLength - 1; j2 > i3; j2--) {
          _loop_6(j2);
        }
        currentLength = candidateGraphs.length;
      };
      for (var i2 = 0; i2 <= currentLength - 1; i2++) {
        _loop_3(i2);
      }
      return candidateGraphs;
    };
    var _default = GADDI3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/algorithm.js
var require_algorithm = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/algorithm.js"(exports) {
    "use strict";
    function _typeof9(obj) {
      "@babel/helpers - typeof";
      return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof9(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GADDI", {
      enumerable: true,
      get: function get3() {
        return _gaddi.default;
      }
    });
    Object.defineProperty(exports, "breadthFirstSearch", {
      enumerable: true,
      get: function get3() {
        return _bfs.default;
      }
    });
    Object.defineProperty(exports, "connectedComponent", {
      enumerable: true,
      get: function get3() {
        return _connectedComponent.default;
      }
    });
    Object.defineProperty(exports, "depthFirstSearch", {
      enumerable: true,
      get: function get3() {
        return _dfs.default;
      }
    });
    Object.defineProperty(exports, "detectCycle", {
      enumerable: true,
      get: function get3() {
        return _detectCycle.default;
      }
    });
    Object.defineProperty(exports, "dijkstra", {
      enumerable: true,
      get: function get3() {
        return _dijkstra.default;
      }
    });
    Object.defineProperty(exports, "findAllPath", {
      enumerable: true,
      get: function get3() {
        return _findPath.findAllPath;
      }
    });
    Object.defineProperty(exports, "findShortestPath", {
      enumerable: true,
      get: function get3() {
        return _findPath.findShortestPath;
      }
    });
    Object.defineProperty(exports, "floydWarshall", {
      enumerable: true,
      get: function get3() {
        return _floydWarshall.default;
      }
    });
    Object.defineProperty(exports, "getAdjMatrix", {
      enumerable: true,
      get: function get3() {
        return _adjacentMatrix.default;
      }
    });
    Object.defineProperty(exports, "getDegree", {
      enumerable: true,
      get: function get3() {
        return _degree.default;
      }
    });
    Object.defineProperty(exports, "getInDegree", {
      enumerable: true,
      get: function get3() {
        return _degree.getInDegree;
      }
    });
    Object.defineProperty(exports, "getNeighbors", {
      enumerable: true,
      get: function get3() {
        return _util.getNeighbors;
      }
    });
    Object.defineProperty(exports, "getOutDegree", {
      enumerable: true,
      get: function get3() {
        return _degree.getOutDegree;
      }
    });
    Object.defineProperty(exports, "labelPropagation", {
      enumerable: true,
      get: function get3() {
        return _labelPropagation.default;
      }
    });
    Object.defineProperty(exports, "louvain", {
      enumerable: true,
      get: function get3() {
        return _louvain.default;
      }
    });
    Object.defineProperty(exports, "minimumSpanningTree", {
      enumerable: true,
      get: function get3() {
        return _mts.default;
      }
    });
    Object.defineProperty(exports, "pageRank", {
      enumerable: true,
      get: function get3() {
        return _pageRank.default;
      }
    });
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _bfs = _interopRequireDefault(require_bfs());
    var _connectedComponent = _interopRequireDefault(require_connected_component());
    var _degree = _interopRequireWildcard(require_degree());
    var _detectCycle = _interopRequireDefault(require_detect_cycle());
    var _dfs = _interopRequireDefault(require_dfs());
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _findPath = require_find_path();
    var _floydWarshall = _interopRequireDefault(require_floydWarshall());
    var _labelPropagation = _interopRequireDefault(require_label_propagation());
    var _louvain = _interopRequireDefault(require_louvain());
    var _mts = _interopRequireDefault(require_mts());
    var _pageRank = _interopRequireDefault(require_pageRank());
    var _gaddi = _interopRequireDefault(require_gaddi());
    var _util = require_util();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof9(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache3 = _getRequireWildcardCache(nodeInterop);
      if (cache3 && cache3.has(obj)) {
        return cache3.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache3) {
        cache3.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@antv/algorithm/lib/workers/index.worker.js
var require_index_worker = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/index.worker.js"(exports) {
    "use strict";
    function _typeof9(obj) {
      "@babel/helpers - typeof";
      return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof9(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var algorithm = _interopRequireWildcard(require_algorithm());
    var _constant = require_constant();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof9(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache3 = _getRequireWildcardCache(nodeInterop);
      if (cache3 && cache3.has(obj)) {
        return cache3.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache3) {
        cache3.set(obj, newObj);
      }
      return newObj;
    }
    var ctx2 = typeof self !== "undefined" ? self : {};
    ctx2.onmessage = function(event) {
      var _a2 = event.data, _algorithmType = _a2._algorithmType, data = _a2.data;
      if (!_algorithmType) {
        return;
      }
      if (typeof algorithm[_algorithmType] === "function") {
        var result = algorithm[_algorithmType].apply(algorithm, data);
        ctx2.postMessage({
          _algorithmType: _constant.MESSAGE.SUCCESS,
          data: result
        });
        return;
      }
      ctx2.postMessage({
        _algorithmType: _constant.MESSAGE.FAILURE
      });
    };
    var _default = null;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/createWorker.js
var require_createWorker = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/createWorker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _constant = require_constant();
    var _index = _interopRequireDefault(require_index_worker());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var createWorker = function createWorker2(type) {
      return function() {
        var data = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          data[_i2] = arguments[_i2];
        }
        return new Promise(function(resolve, reject) {
          var worker = new _index.default();
          worker.postMessage({
            _algorithmType: type,
            data
          });
          worker.onmessage = function(event) {
            var _a2 = event.data, data2 = _a2.data, _algorithmType = _a2._algorithmType;
            if (_constant.MESSAGE.SUCCESS === _algorithmType) {
              resolve(data2);
            } else {
              reject();
            }
            worker.terminate();
          };
        });
      };
    };
    var _default = createWorker;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/index.js
var require_workers = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.getOutDegreeAsync = exports.getNeighborsAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.getAdjMatrixAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectCycleAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.connectedComponentAsync = exports.GADDIAsync = void 0;
    var _createWorker = _interopRequireDefault(require_createWorker());
    var _constant = require_constant();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getAdjMatrixAsync = function getAdjMatrixAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);
    };
    exports.getAdjMatrixAsync = getAdjMatrixAsync;
    var connectedComponentAsync = function connectedComponentAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);
    };
    exports.connectedComponentAsync = connectedComponentAsync;
    var getDegreeAsync = function getDegreeAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);
    };
    exports.getDegreeAsync = getDegreeAsync;
    var getInDegreeAsync = function getInDegreeAsync2(graphData, nodeId) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);
    };
    exports.getInDegreeAsync = getInDegreeAsync;
    var getOutDegreeAsync = function getOutDegreeAsync2(graphData, nodeId) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);
    };
    exports.getOutDegreeAsync = getOutDegreeAsync;
    var detectCycleAsync = function detectCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);
    };
    exports.detectCycleAsync = detectCycleAsync;
    var detectAllCyclesAsync = function detectAllCyclesAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);
    };
    exports.detectAllCyclesAsync = detectAllCyclesAsync;
    var detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);
    };
    exports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;
    var detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);
    };
    exports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;
    var dijkstraAsync = function dijkstraAsync2(graphData, source, directed, weightPropertyName) {
      return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);
    };
    exports.dijkstraAsync = dijkstraAsync;
    var findAllPathAsync = function findAllPathAsync2(graphData, start, end2, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end2, directed]);
    };
    exports.findAllPathAsync = findAllPathAsync;
    var findShortestPathAsync = function findShortestPathAsync2(graphData, start, end2, directed, weightPropertyName) {
      return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end2, directed, weightPropertyName]);
    };
    exports.findShortestPathAsync = findShortestPathAsync;
    var floydWarshallAsync = function floydWarshallAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);
    };
    exports.floydWarshallAsync = floydWarshallAsync;
    var labelPropagationAsync = function labelPropagationAsync2(graphData, directed, weightPropertyName, maxIteration) {
      if (maxIteration === void 0) {
        maxIteration = 1e3;
      }
      return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);
    };
    exports.labelPropagationAsync = labelPropagationAsync;
    var louvainAsync = function louvainAsync2(graphData, directed, weightPropertyName, threshold) {
      return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);
    };
    exports.louvainAsync = louvainAsync;
    var minimumSpanningTreeAsync = function minimumSpanningTreeAsync2(graphData, weight, algo) {
      return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);
    };
    exports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;
    var pageRankAsync = function pageRankAsync2(graphData, epsilon, linkProb) {
      return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);
    };
    exports.pageRankAsync = pageRankAsync;
    var getNeighborsAsync = function getNeighborsAsync2(nodeId, edges, type) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);
    };
    exports.getNeighborsAsync = getNeighborsAsync;
    var GADDIAsync = function GADDIAsync2(graphData, pattern, directed, k2, length6, nodeLabelProp, edgeLabelProp) {
      if (directed === void 0) {
        directed = false;
      }
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (edgeLabelProp === void 0) {
        edgeLabelProp = "cluster";
      }
      return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k2, length6, nodeLabelProp, edgeLabelProp]);
    };
    exports.GADDIAsync = GADDIAsync;
  }
});

// node_modules/@antv/algorithm/lib/asyncIndex.js
var require_asyncIndex = __commonJS({
  "node_modules/@antv/algorithm/lib/asyncIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GADDIAsync", {
      enumerable: true,
      get: function get3() {
        return _index.GADDIAsync;
      }
    });
    Object.defineProperty(exports, "connectedComponentAsync", {
      enumerable: true,
      get: function get3() {
        return _index.connectedComponentAsync;
      }
    });
    exports.default = void 0;
    Object.defineProperty(exports, "detectAllCyclesAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectAllCyclesAsync;
      }
    });
    Object.defineProperty(exports, "detectAllDirectedCycleAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectAllDirectedCycleAsync;
      }
    });
    Object.defineProperty(exports, "detectAllUndirectedCycleAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectAllUndirectedCycleAsync;
      }
    });
    Object.defineProperty(exports, "detectCycleAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectCycleAsync;
      }
    });
    exports.detectDirectedCycleAsync = void 0;
    Object.defineProperty(exports, "dijkstraAsync", {
      enumerable: true,
      get: function get3() {
        return _index.dijkstraAsync;
      }
    });
    Object.defineProperty(exports, "findAllPathAsync", {
      enumerable: true,
      get: function get3() {
        return _index.findAllPathAsync;
      }
    });
    Object.defineProperty(exports, "findShortestPathAsync", {
      enumerable: true,
      get: function get3() {
        return _index.findShortestPathAsync;
      }
    });
    Object.defineProperty(exports, "floydWarshallAsync", {
      enumerable: true,
      get: function get3() {
        return _index.floydWarshallAsync;
      }
    });
    Object.defineProperty(exports, "getAdjMatrixAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getAdjMatrixAsync;
      }
    });
    Object.defineProperty(exports, "getDegreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getDegreeAsync;
      }
    });
    Object.defineProperty(exports, "getInDegreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getInDegreeAsync;
      }
    });
    Object.defineProperty(exports, "getNeighborsAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getNeighborsAsync;
      }
    });
    Object.defineProperty(exports, "getOutDegreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getOutDegreeAsync;
      }
    });
    Object.defineProperty(exports, "labelPropagationAsync", {
      enumerable: true,
      get: function get3() {
        return _index.labelPropagationAsync;
      }
    });
    Object.defineProperty(exports, "louvainAsync", {
      enumerable: true,
      get: function get3() {
        return _index.louvainAsync;
      }
    });
    Object.defineProperty(exports, "minimumSpanningTreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.minimumSpanningTreeAsync;
      }
    });
    Object.defineProperty(exports, "pageRankAsync", {
      enumerable: true,
      get: function get3() {
        return _index.pageRankAsync;
      }
    });
    var _index = require_workers();
    var detectDirectedCycleAsync = _index.detectCycleAsync;
    exports.detectDirectedCycleAsync = detectDirectedCycleAsync;
    var _default = {
      getAdjMatrixAsync: _index.getAdjMatrixAsync,
      connectedComponentAsync: _index.connectedComponentAsync,
      getDegreeAsync: _index.getDegreeAsync,
      getInDegreeAsync: _index.getInDegreeAsync,
      getOutDegreeAsync: _index.getOutDegreeAsync,
      detectCycleAsync: _index.detectCycleAsync,
      detectDirectedCycleAsync,
      detectAllCyclesAsync: _index.detectAllCyclesAsync,
      detectAllDirectedCycleAsync: _index.detectAllDirectedCycleAsync,
      detectAllUndirectedCycleAsync: _index.detectAllUndirectedCycleAsync,
      dijkstraAsync: _index.dijkstraAsync,
      findAllPathAsync: _index.findAllPathAsync,
      findShortestPathAsync: _index.findShortestPathAsync,
      floydWarshallAsync: _index.floydWarshallAsync,
      labelPropagationAsync: _index.labelPropagationAsync,
      louvainAsync: _index.louvainAsync,
      minimumSpanningTreeAsync: _index.minimumSpanningTreeAsync,
      pageRankAsync: _index.pageRankAsync,
      getNeighborsAsync: _index.getNeighborsAsync,
      GADDIAsync: _index.GADDIAsync
    };
    exports.default = _default;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i2 = 0, len6 = args.length; i2 < len6; i2++) {
        var arg = args[i2];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn2) {
      return function() {
        return fn2(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty7 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty7.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb2 = [0, 0, 0, 1];
      var match;
      var i2;
      var hexAlpha;
      if (match = string.match(hex2)) {
        hexAlpha = match[2];
        match = match[1];
        for (i2 = 0; i2 < 3; i2++) {
          var i22 = i2 * 2;
          rgb2[i2] = parseInt(match.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb2[i2] = parseInt(match[i2] + match[i2], 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba2)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb2[i2] = parseInt(match[i2 + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb2[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty7.call(colorNames, match[1])) {
          return null;
        }
        rgb2 = colorNames[match[1]];
        rgb2[3] = 1;
        return rgb2;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb2[i2] = clamp3(rgb2[i2], 0, 255);
      }
      rgb2[3] = clamp3(rgb2[3], 0, 1);
      return rgb2;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl3 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl3);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp3(parseFloat(match[2]), 0, 100);
        var l2 = clamp3(parseFloat(match[3]), 0, 100);
        var a3 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a3];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w2 = clamp3(parseFloat(match[2]), 0, 100);
        var b10 = clamp3(parseFloat(match[3]), 0, 100);
        var a3 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w2, b10, a3];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba2 = swizzle(arguments);
      return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba2 = swizzle(arguments);
      return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba2 = swizzle(arguments);
      var r2 = Math.round(rgba2[0] / 255 * 100);
      var g2 = Math.round(rgba2[1] / 255 * 100);
      var b10 = Math.round(rgba2[2] / 255 * 100);
      return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b10 + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b10 + "%, " + rgba2[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla2 = swizzle(arguments);
      return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a3 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a3 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
    };
    cs.to.keyword = function(rgb2) {
      return reverseNames[rgb2.slice(0, 3)];
    };
    function clamp3(num, min6, max8) {
      return Math.min(Math.max(min6, num), max8);
    }
    function hexDouble(num) {
      var str10 = Math.round(num).toString(16).toUpperCase();
      return str10.length < 2 ? "0" + str10 : str10;
    }
  }
});

// node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color/node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var min6 = Math.min(r2, g2, b10);
      var max8 = Math.max(r2, g2, b10);
      var delta = max8 - min6;
      var h2;
      var s2;
      var l2;
      if (max8 === min6) {
        h2 = 0;
      } else if (r2 === max8) {
        h2 = (g2 - b10) / delta;
      } else if (g2 === max8) {
        h2 = 2 + (b10 - r2) / delta;
      } else if (b10 === max8) {
        h2 = 4 + (r2 - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      l2 = (min6 + max8) / 2;
      if (max8 === min6) {
        s2 = 0;
      } else if (l2 <= 0.5) {
        s2 = delta / (max8 + min6);
      } else {
        s2 = delta / (2 - max8 - min6);
      }
      return [h2, s2 * 100, l2 * 100];
    };
    convert.rgb.hsv = function(rgb2) {
      var rdif;
      var gdif;
      var bdif;
      var h2;
      var s2;
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var v2 = Math.max(r2, g2, b10);
      var diff = v2 - Math.min(r2, g2, b10);
      var diffc = function(c3) {
        return (v2 - c3) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h2 = s2 = 0;
      } else {
        s2 = diff / v2;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b10);
        if (r2 === v2) {
          h2 = bdif - gdif;
        } else if (g2 === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b10 === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s2 * 100,
        v2 * 100
      ];
    };
    convert.rgb.hwb = function(rgb2) {
      var r2 = rgb2[0];
      var g2 = rgb2[1];
      var b10 = rgb2[2];
      var h2 = convert.rgb.hsl(rgb2)[0];
      var w2 = 1 / 255 * Math.min(r2, Math.min(g2, b10));
      b10 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b10));
      return [h2, w2 * 100, b10 * 100];
    };
    convert.rgb.cmyk = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var c3;
      var m3;
      var y4;
      var k2;
      k2 = Math.min(1 - r2, 1 - g2, 1 - b10);
      c3 = (1 - r2 - k2) / (1 - k2) || 0;
      m3 = (1 - g2 - k2) / (1 - k2) || 0;
      y4 = (1 - b10 - k2) / (1 - k2) || 0;
      return [c3 * 100, m3 * 100, y4 * 100, k2 * 100];
    };
    function comparativeDistance(x4, y4) {
      return Math.pow(x4[0] - y4[0], 2) + Math.pow(x4[1] - y4[1], 2) + Math.pow(x4[2] - y4[2], 2);
    }
    convert.rgb.keyword = function(rgb2) {
      var reversed = reverseKeywords[rgb2];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance11 = comparativeDistance(rgb2, value);
          if (distance11 < currentClosestDistance) {
            currentClosestDistance = distance11;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
      g2 = g2 > 0.04045 ? Math.pow((g2 + 0.055) / 1.055, 2.4) : g2 / 12.92;
      b10 = b10 > 0.04045 ? Math.pow((b10 + 0.055) / 1.055, 2.4) : b10 / 12.92;
      var x4 = r2 * 0.4124 + g2 * 0.3576 + b10 * 0.1805;
      var y4 = r2 * 0.2126 + g2 * 0.7152 + b10 * 0.0722;
      var z2 = r2 * 0.0193 + g2 * 0.1192 + b10 * 0.9505;
      return [x4 * 100, y4 * 100, z2 * 100];
    };
    convert.rgb.lab = function(rgb2) {
      var xyz = convert.rgb.xyz(rgb2);
      var x4 = xyz[0];
      var y4 = xyz[1];
      var z2 = xyz[2];
      var l2;
      var a3;
      var b10;
      x4 /= 95.047;
      y4 /= 100;
      z2 /= 108.883;
      x4 = x4 > 8856e-6 ? Math.pow(x4, 1 / 3) : 7.787 * x4 + 16 / 116;
      y4 = y4 > 8856e-6 ? Math.pow(y4, 1 / 3) : 7.787 * y4 + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l2 = 116 * y4 - 16;
      a3 = 500 * (x4 - y4);
      b10 = 200 * (y4 - z2);
      return [l2, a3, b10];
    };
    convert.hsl.rgb = function(hsl3) {
      var h2 = hsl3[0] / 360;
      var s2 = hsl3[1] / 100;
      var l2 = hsl3[2] / 100;
      var t12;
      var t22;
      var t32;
      var rgb2;
      var val;
      if (s2 === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t22 = l2 * (1 + s2);
      } else {
        t22 = l2 + s2 - l2 * s2;
      }
      t12 = 2 * l2 - t22;
      rgb2 = [0, 0, 0];
      for (var i2 = 0; i2 < 3; i2++) {
        t32 = h2 + 1 / 3 * -(i2 - 1);
        if (t32 < 0) {
          t32++;
        }
        if (t32 > 1) {
          t32--;
        }
        if (6 * t32 < 1) {
          val = t12 + (t22 - t12) * 6 * t32;
        } else if (2 * t32 < 1) {
          val = t22;
        } else if (3 * t32 < 2) {
          val = t12 + (t22 - t12) * (2 / 3 - t32) * 6;
        } else {
          val = t12;
        }
        rgb2[i2] = val * 255;
      }
      return rgb2;
    };
    convert.hsl.hsv = function(hsl3) {
      var h2 = hsl3[0];
      var s2 = hsl3[1] / 100;
      var l2 = hsl3[2] / 100;
      var smin = s2;
      var lmin = Math.max(l2, 0.01);
      var sv;
      var v2;
      l2 *= 2;
      s2 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v2 = (l2 + s2) / 2;
      sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
      return [h2, sv * 100, v2 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h2 = hsv[0] / 60;
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var hi2 = Math.floor(h2) % 6;
      var f2 = h2 - Math.floor(h2);
      var p2 = 255 * v2 * (1 - s2);
      var q2 = 255 * v2 * (1 - s2 * f2);
      var t4 = 255 * v2 * (1 - s2 * (1 - f2));
      v2 *= 255;
      switch (hi2) {
        case 0:
          return [v2, t4, p2];
        case 1:
          return [q2, v2, p2];
        case 2:
          return [p2, v2, t4];
        case 3:
          return [p2, q2, v2];
        case 4:
          return [t4, p2, v2];
        case 5:
          return [v2, p2, q2];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h2 = hsv[0];
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var vmin = Math.max(v2, 0.01);
      var lmin;
      var sl;
      var l2;
      l2 = (2 - s2) * v2;
      lmin = (2 - s2) * vmin;
      sl = s2 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h2, sl * 100, l2 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h2 = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i2;
      var v2;
      var f2;
      var n2;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i2 = Math.floor(6 * h2);
      v2 = 1 - bl;
      f2 = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f2 = 1 - f2;
      }
      n2 = wh + f2 * (v2 - wh);
      var r2;
      var g2;
      var b10;
      switch (i2) {
        default:
        case 6:
        case 0:
          r2 = v2;
          g2 = n2;
          b10 = wh;
          break;
        case 1:
          r2 = n2;
          g2 = v2;
          b10 = wh;
          break;
        case 2:
          r2 = wh;
          g2 = v2;
          b10 = n2;
          break;
        case 3:
          r2 = wh;
          g2 = n2;
          b10 = v2;
          break;
        case 4:
          r2 = n2;
          g2 = wh;
          b10 = v2;
          break;
        case 5:
          r2 = v2;
          g2 = wh;
          b10 = n2;
          break;
      }
      return [r2 * 255, g2 * 255, b10 * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c3 = cmyk[0] / 100;
      var m3 = cmyk[1] / 100;
      var y4 = cmyk[2] / 100;
      var k2 = cmyk[3] / 100;
      var r2;
      var g2;
      var b10;
      r2 = 1 - Math.min(1, c3 * (1 - k2) + k2);
      g2 = 1 - Math.min(1, m3 * (1 - k2) + k2);
      b10 = 1 - Math.min(1, y4 * (1 - k2) + k2);
      return [r2 * 255, g2 * 255, b10 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x4 = xyz[0] / 100;
      var y4 = xyz[1] / 100;
      var z2 = xyz[2] / 100;
      var r2;
      var g2;
      var b10;
      r2 = x4 * 3.2406 + y4 * -1.5372 + z2 * -0.4986;
      g2 = x4 * -0.9689 + y4 * 1.8758 + z2 * 0.0415;
      b10 = x4 * 0.0557 + y4 * -0.204 + z2 * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * Math.pow(g2, 1 / 2.4) - 0.055 : g2 * 12.92;
      b10 = b10 > 31308e-7 ? 1.055 * Math.pow(b10, 1 / 2.4) - 0.055 : b10 * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b10 = Math.min(Math.max(0, b10), 1);
      return [r2 * 255, g2 * 255, b10 * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x4 = xyz[0];
      var y4 = xyz[1];
      var z2 = xyz[2];
      var l2;
      var a3;
      var b10;
      x4 /= 95.047;
      y4 /= 100;
      z2 /= 108.883;
      x4 = x4 > 8856e-6 ? Math.pow(x4, 1 / 3) : 7.787 * x4 + 16 / 116;
      y4 = y4 > 8856e-6 ? Math.pow(y4, 1 / 3) : 7.787 * y4 + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l2 = 116 * y4 - 16;
      a3 = 500 * (x4 - y4);
      b10 = 200 * (y4 - z2);
      return [l2, a3, b10];
    };
    convert.lab.xyz = function(lab3) {
      var l2 = lab3[0];
      var a3 = lab3[1];
      var b10 = lab3[2];
      var x4;
      var y4;
      var z2;
      y4 = (l2 + 16) / 116;
      x4 = a3 / 500 + y4;
      z2 = y4 - b10 / 200;
      var y22 = Math.pow(y4, 3);
      var x22 = Math.pow(x4, 3);
      var z22 = Math.pow(z2, 3);
      y4 = y22 > 8856e-6 ? y22 : (y4 - 16 / 116) / 7.787;
      x4 = x22 > 8856e-6 ? x22 : (x4 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x4 *= 95.047;
      y4 *= 100;
      z2 *= 108.883;
      return [x4, y4, z2];
    };
    convert.lab.lch = function(lab3) {
      var l2 = lab3[0];
      var a3 = lab3[1];
      var b10 = lab3[2];
      var hr2;
      var h2;
      var c3;
      hr2 = Math.atan2(b10, a3);
      h2 = hr2 * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      c3 = Math.sqrt(a3 * a3 + b10 * b10);
      return [l2, c3, h2];
    };
    convert.lch.lab = function(lch2) {
      var l2 = lch2[0];
      var c3 = lch2[1];
      var h2 = lch2[2];
      var a3;
      var b10;
      var hr2;
      hr2 = h2 / 360 * 2 * Math.PI;
      a3 = c3 * Math.cos(hr2);
      b10 = c3 * Math.sin(hr2);
      return [l2, a3, b10];
    };
    convert.rgb.ansi16 = function(args) {
      var r2 = args[0];
      var g2 = args[1];
      var b10 = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b10 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r2 = args[0];
      var g2 = args[1];
      var b10 = args[2];
      if (r2 === g2 && g2 === b10) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b10 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color3 = args % 10;
      if (color3 === 0 || color3 === 7) {
        if (args > 50) {
          color3 += 3.5;
        }
        color3 = color3 / 10.5 * 255;
        return [color3, color3, color3];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r2 = (color3 & 1) * mult * 255;
      var g2 = (color3 >> 1 & 1) * mult * 255;
      var b10 = (color3 >> 2 & 1) * mult * 255;
      return [r2, g2, b10];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c3 = (args - 232) * 10 + 8;
        return [c3, c3, c3];
      }
      args -= 16;
      var rem;
      var r2 = Math.floor(args / 36) / 5 * 255;
      var g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b10 = rem % 6 / 5 * 255;
      return [r2, g2, b10];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r2 = integer >> 16 & 255;
      var g2 = integer >> 8 & 255;
      var b10 = integer & 255;
      return [r2, g2, b10];
    };
    convert.rgb.hcg = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var max8 = Math.max(Math.max(r2, g2), b10);
      var min6 = Math.min(Math.min(r2, g2), b10);
      var chroma = max8 - min6;
      var grayscale;
      var hue2;
      if (chroma < 1) {
        grayscale = min6 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue2 = 0;
      } else if (max8 === r2) {
        hue2 = (g2 - b10) / chroma % 6;
      } else if (max8 === g2) {
        hue2 = 2 + (b10 - r2) / chroma;
      } else {
        hue2 = 4 + (r2 - g2) / chroma + 4;
      }
      hue2 /= 6;
      hue2 %= 1;
      return [hue2 * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl3) {
      var s2 = hsl3[1] / 100;
      var l2 = hsl3[2] / 100;
      var c3 = 1;
      var f2 = 0;
      if (l2 < 0.5) {
        c3 = 2 * s2 * l2;
      } else {
        c3 = 2 * s2 * (1 - l2);
      }
      if (c3 < 1) {
        f2 = (l2 - 0.5 * c3) / (1 - c3);
      }
      return [hsl3[0], c3 * 100, f2 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var c3 = s2 * v2;
      var f2 = 0;
      if (c3 < 1) {
        f2 = (v2 - c3) / (1 - c3);
      }
      return [hsv[0], c3 * 100, f2 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h2 = hcg[0] / 360;
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      if (c3 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      var pure = [0, 0, 0];
      var hi2 = h2 % 1 * 6;
      var v2 = hi2 % 1;
      var w2 = 1 - v2;
      var mg = 0;
      switch (Math.floor(hi2)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c3) * g2;
      return [
        (c3 * pure[0] + mg) * 255,
        (c3 * pure[1] + mg) * 255,
        (c3 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var v2 = c3 + g2 * (1 - c3);
      var f2 = 0;
      if (v2 > 0) {
        f2 = c3 / v2;
      }
      return [hcg[0], f2 * 100, v2 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var l2 = g2 * (1 - c3) + 0.5 * c3;
      var s2 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s2 = c3 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s2 = c3 / (2 * (1 - l2));
      }
      return [hcg[0], s2 * 100, l2 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var v2 = c3 + g2 * (1 - c3);
      return [hcg[0], (v2 - c3) * 100, (1 - v2) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w2 = hwb[1] / 100;
      var b10 = hwb[2] / 100;
      var v2 = 1 - b10;
      var c3 = v2 - w2;
      var g2 = 0;
      if (c3 < 1) {
        g2 = (v2 - c3) / (1 - c3);
      }
      return [hwb[0], c3 * 100, g2 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb2) {
      return [rgb2[0] / 255 * 65535, rgb2[1] / 255 * 65535, rgb2[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray2) {
      return [0, 100, gray2[0]];
    };
    convert.gray.cmyk = function(gray2) {
      return [0, 0, 0, gray2[0]];
    };
    convert.gray.lab = function(gray2) {
      return [gray2[0], 0, 0];
    };
    convert.gray.hex = function(gray2) {
      var val = Math.round(gray2[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb2) {
      var val = (rgb2[0] + rgb2[1] + rgb2[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color/node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len6 = models.length, i2 = 0; i2 < len6; i2++) {
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len6 = adjacents.length, i2 = 0; i2 < len6; i2++) {
          var adjacent = adjacents[i2];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to2) {
      return function(args) {
        return to2(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn2 = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn2 = link(conversions[graph[cur].parent][cur], fn2);
        cur = graph[cur].parent;
      }
      fn2.conversion = path;
      return fn2;
    }
    module.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len6 = models.length, i2 = 0; i2 < len6; i2++) {
        var toModel = models[i2];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color/node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn2) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn2(args);
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn2) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn2(args);
        if (typeof result === "object") {
          for (var len6 = result.length, i2 = 0; i2 < len6; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn2 = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn2);
        convert[fromModel][toModel].raw = wrapRaw(fn2);
      });
    });
    module.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports, module) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color2(obj, model) {
      if (!(this instanceof Color2)) {
        return new Color2(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i2;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color2) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys3 = Object.keys(obj);
        if ("alpha" in obj) {
          keys3.splice(keys3.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys3.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color3 = [];
        for (i2 = 0; i2 < labels.length; i2++) {
          color3.push(obj[labels[i2]]);
        }
        this.color = zeroArray(color3);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i2 = 0; i2 < channels; i2++) {
          var limit = limiters[this.model][i2];
          if (limit) {
            this.color[i2] = limit(this.color[i2]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color2.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i2 = 0; i2 < channels; i2++) {
          result[labels[i2]] = this.color[i2];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb2 = this.rgb().color;
        rgb2[0] /= 255;
        rgb2[1] /= 255;
        rgb2[2] /= 255;
        if (this.valpha !== 1) {
          rgb2.push(this.valpha);
        }
        return rgb2;
      },
      unitObject: function() {
        var rgb2 = this.rgb().object();
        rgb2.r /= 255;
        rgb2.g /= 255;
        rgb2.b /= 255;
        if (this.valpha !== 1) {
          rgb2.alpha = this.valpha;
        }
        return rgb2;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color2(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color2(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color2(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color2(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb2 = this.rgb().color;
        return (rgb2[0] & 255) << 16 | (rgb2[1] & 255) << 8 | rgb2[2] & 255;
      },
      luminosity: function() {
        var rgb2 = this.rgb().color;
        var lum = [];
        for (var i2 = 0; i2 < rgb2.length; i2++) {
          var chan = rgb2[i2] / 255;
          lum[i2] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color22) {
        var lum1 = this.luminosity();
        var lum2 = color22.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color22) {
        var contrastRatio = this.contrast(color22);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb2 = this.rgb().color;
        var yiq = (rgb2[0] * 299 + rgb2[1] * 587 + rgb2[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb2 = this.rgb();
        for (var i2 = 0; i2 < 3; i2++) {
          rgb2.color[i2] = 255 - rgb2.color[i2];
        }
        return rgb2;
      },
      lighten: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[2] += hsl3.color[2] * ratio;
        return hsl3;
      },
      darken: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[2] -= hsl3.color[2] * ratio;
        return hsl3;
      },
      saturate: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[1] += hsl3.color[1] * ratio;
        return hsl3;
      },
      desaturate: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[1] -= hsl3.color[1] * ratio;
        return hsl3;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb2 = this.rgb().color;
        var val = rgb2[0] * 0.3 + rgb2[1] * 0.59 + rgb2[2] * 0.11;
        return Color2.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees3) {
        var hsl3 = this.hsl();
        var hue2 = hsl3.color[0];
        hue2 = (hue2 + degrees3) % 360;
        hue2 = hue2 < 0 ? 360 + hue2 : hue2;
        hsl3.color[0] = hue2;
        return hsl3;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color22 = this.rgb();
        var p2 = weight === void 0 ? 0.5 : weight;
        var w2 = 2 * p2 - 1;
        var a3 = color1.alpha() - color22.alpha();
        var w1 = ((w2 * a3 === -1 ? w2 : (w2 + a3) / (1 + w2 * a3)) + 1) / 2;
        var w22 = 1 - w1;
        return Color2.rgb(
          w1 * color1.red() + w22 * color22.red(),
          w1 * color1.green() + w22 * color22.green(),
          w1 * color1.blue() + w22 * color22.blue(),
          color1.alpha() * p2 + color22.alpha() * (1 - p2)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color2.prototype[model] = function() {
        if (this.model === model) {
          return new Color2(this);
        }
        if (arguments.length) {
          return new Color2(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color2(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color2[model] = function(color3) {
        if (typeof color3 === "number") {
          color3 = zeroArray(_slice.call(arguments), channels);
        }
        return new Color2(color3, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m3) {
        (limiters[m3] || (limiters[m3] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max8) {
      return function(v2) {
        return Math.max(0, Math.min(max8, v2));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length6) {
      for (var i2 = 0; i2 < length6; i2++) {
        if (typeof arr[i2] !== "number") {
          arr[i2] = 0;
        }
      }
      return arr;
    }
    module.exports = Color2;
  }
});

// node_modules/@antv/layout/lib/layout/base.js
var require_base = __commonJS({
  "node_modules/@antv/layout/lib/layout/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base = void 0;
    var Base2 = (
      /** @class */
      function() {
        function Base3() {
          this.nodes = [];
          this.edges = [];
          this.combos = [];
          this.comboEdges = [];
          this.hiddenNodes = [];
          this.hiddenEdges = [];
          this.hiddenCombos = [];
          this.vedges = [];
          this.positions = [];
          this.destroyed = false;
          this.onLayoutEnd = function() {
          };
        }
        Base3.prototype.layout = function(data) {
          this.init(data);
          return this.execute(true);
        };
        Base3.prototype.init = function(data) {
          this.nodes = data.nodes || [];
          this.edges = data.edges || [];
          this.combos = data.combos || [];
          this.comboEdges = data.comboEdges || [];
          this.hiddenNodes = data.hiddenNodes || [];
          this.hiddenEdges = data.hiddenEdges || [];
          this.hiddenCombos = data.hiddenCombos || [];
          this.vedges = data.vedges || [];
        };
        Base3.prototype.execute = function(reloadData) {
        };
        Base3.prototype.executeWithWorker = function() {
        };
        Base3.prototype.getDefaultCfg = function() {
          return {};
        };
        Base3.prototype.updateCfg = function(cfg) {
          if (cfg) {
            Object.assign(this, cfg);
          }
        };
        Base3.prototype.getType = function() {
          return "base";
        };
        Base3.prototype.destroy = function() {
          this.nodes = null;
          this.edges = null;
          this.combos = null;
          this.positions = null;
          this.destroyed = true;
        };
        return Base3;
      }()
    );
    exports.Base = Base2;
  }
});

// node_modules/@antv/layout/lib/util/string.js
var require_string = __commonJS({
  "node_modules/@antv/layout/lib/util/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.camelize = exports.isString = void 0;
    var isString2 = function(val) {
      return typeof val === "string";
    };
    exports.isString = isString2;
    var cacheStringFunction = function(fn2) {
      var cache3 = /* @__PURE__ */ Object.create(null);
      return function(str10) {
        var hit = cache3[str10];
        return hit || (cache3[str10] = fn2(str10));
      };
    };
    var camelizeRE = /-(\w)/g;
    exports.camelize = cacheStringFunction(function(str10) {
      return str10.replace(camelizeRE, function(_2, c3) {
        return c3 ? c3.toUpperCase() : "";
      });
    });
  }
});

// node_modules/@antv/layout/lib/util/array.js
var require_array = __commonJS({
  "node_modules/@antv/layout/lib/util/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArray = void 0;
    exports.isArray = Array.isArray;
  }
});

// node_modules/@antv/layout/lib/util/number.js
var require_number = __commonJS({
  "node_modules/@antv/layout/lib/util/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toNumber = exports.isNaN = exports.isNumber = void 0;
    var isNumber3 = function(val) {
      return typeof val === "number";
    };
    exports.isNumber = isNumber3;
    var isNaN5 = function(num) {
      return Number.isNaN(Number(num));
    };
    exports.isNaN = isNaN5;
    var toNumber = function(val) {
      var n2 = parseFloat(val);
      return (0, exports.isNaN)(n2) ? val : n2;
    };
    exports.toNumber = toNumber;
  }
});

// node_modules/@antv/layout/lib/util/object.js
var require_object = __commonJS({
  "node_modules/@antv/layout/lib/util/object.js"(exports) {
    "use strict";
    var __assign18 = exports && exports.__assign || function() {
      __assign18 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign18.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = exports.isObject = void 0;
    var isObject = function(val) {
      return val !== null && typeof val === "object";
    };
    exports.isObject = isObject;
    var clone13 = function(target) {
      if (target === null) {
        return target;
      }
      if (target instanceof Date) {
        return new Date(target.getTime());
      }
      if (target instanceof Array) {
        var cp_1 = [];
        target.forEach(function(v2) {
          cp_1.push(v2);
        });
        return cp_1.map(function(n2) {
          return (0, exports.clone)(n2);
        });
      }
      if (typeof target === "object" && Object.keys(target).length) {
        var cp_2 = __assign18({}, target);
        Object.keys(cp_2).forEach(function(k2) {
          cp_2[k2] = (0, exports.clone)(cp_2[k2]);
        });
        return cp_2;
      }
      return target;
    };
    exports.clone = clone13;
  }
});

// node_modules/@antv/layout/lib/util/math.js
var require_math = __commonJS({
  "node_modules/@antv/layout/lib/util/math.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCoreNodeAndRelativeLeafNodes = exports.getAvgNodePosition = exports.getLayoutBBox = exports.traverseTreeUp = exports.scaleMatrix = exports.getAdjMatrix = exports.floydWarshall = exports.getDegreeMap = exports.getDegree = exports.getEdgeTerminal = void 0;
    var array_1 = require_array();
    var number_1 = require_number();
    var object_1 = require_object();
    var getEdgeTerminal = function(edge, type) {
      var terminal = edge[type];
      if ((0, object_1.isObject)(terminal)) {
        return terminal.cell;
      }
      return terminal;
    };
    exports.getEdgeTerminal = getEdgeTerminal;
    var getDegree3 = function(n2, nodeIdxMap, edges) {
      var degrees3 = [];
      for (var i2 = 0; i2 < n2; i2++) {
        degrees3[i2] = {
          in: 0,
          out: 0,
          all: 0
        };
      }
      if (!edges)
        return degrees3;
      edges.forEach(function(e8) {
        var source = (0, exports.getEdgeTerminal)(e8, "source");
        var target = (0, exports.getEdgeTerminal)(e8, "target");
        if (source && degrees3[nodeIdxMap[source]]) {
          degrees3[nodeIdxMap[source]].out += 1;
          degrees3[nodeIdxMap[source]].all += 1;
        }
        if (target && degrees3[nodeIdxMap[target]]) {
          degrees3[nodeIdxMap[target]].in += 1;
          degrees3[nodeIdxMap[target]].all += 1;
        }
      });
      return degrees3;
    };
    exports.getDegree = getDegree3;
    var getDegreeMap = function(nodes, edges) {
      var degreesMap = {};
      nodes.forEach(function(node) {
        degreesMap[node.id] = {
          in: 0,
          out: 0,
          all: 0
        };
      });
      if (!edges)
        return degreesMap;
      edges.forEach(function(e8) {
        var source = (0, exports.getEdgeTerminal)(e8, "source");
        var target = (0, exports.getEdgeTerminal)(e8, "target");
        if (source) {
          degreesMap[source].out += 1;
          degreesMap[source].all += 1;
        }
        if (target) {
          degreesMap[target].in += 1;
          degreesMap[target].all += 1;
        }
      });
      return degreesMap;
    };
    exports.getDegreeMap = getDegreeMap;
    var floydWarshall6 = function(adjMatrix3) {
      var dist4 = [];
      var size3 = adjMatrix3.length;
      for (var i2 = 0; i2 < size3; i2 += 1) {
        dist4[i2] = [];
        for (var j2 = 0; j2 < size3; j2 += 1) {
          if (i2 === j2) {
            dist4[i2][j2] = 0;
          } else if (adjMatrix3[i2][j2] === 0 || !adjMatrix3[i2][j2]) {
            dist4[i2][j2] = Infinity;
          } else {
            dist4[i2][j2] = adjMatrix3[i2][j2];
          }
        }
      }
      for (var k2 = 0; k2 < size3; k2 += 1) {
        for (var i2 = 0; i2 < size3; i2 += 1) {
          for (var j2 = 0; j2 < size3; j2 += 1) {
            if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
              dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
            }
          }
        }
      }
      return dist4;
    };
    exports.floydWarshall = floydWarshall6;
    var getAdjMatrix3 = function(data, directed) {
      var nodes = data.nodes, edges = data.edges;
      var matrix = [];
      var nodeMap = {};
      if (!nodes) {
        throw new Error("invalid nodes data!");
      }
      if (nodes) {
        nodes.forEach(function(node, i2) {
          nodeMap[node.id] = i2;
          var row = [];
          matrix.push(row);
        });
      }
      edges === null || edges === void 0 ? void 0 : edges.forEach(function(e8) {
        var source = (0, exports.getEdgeTerminal)(e8, "source");
        var target = (0, exports.getEdgeTerminal)(e8, "target");
        var sIndex = nodeMap[source];
        var tIndex = nodeMap[target];
        if (sIndex === void 0 || tIndex === void 0)
          return;
        matrix[sIndex][tIndex] = 1;
        if (!directed) {
          matrix[tIndex][sIndex] = 1;
        }
      });
      return matrix;
    };
    exports.getAdjMatrix = getAdjMatrix3;
    var scaleMatrix3 = function(matrix, ratio) {
      var result = [];
      matrix.forEach(function(row) {
        var newRow = [];
        row.forEach(function(v2) {
          newRow.push(v2 * ratio);
        });
        result.push(newRow);
      });
      return result;
    };
    exports.scaleMatrix = scaleMatrix3;
    var traverseUp3 = function(data, fn2) {
      if (data && data.children) {
        for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
          if (!traverseUp3(data.children[i2], fn2))
            return;
        }
      }
      if (!fn2(data)) {
        return false;
      }
      return true;
    };
    var traverseTreeUp3 = function(data, fn2) {
      if (typeof fn2 !== "function") {
        return;
      }
      traverseUp3(data, fn2);
    };
    exports.traverseTreeUp = traverseTreeUp3;
    var getLayoutBBox = function(nodes) {
      var minX = Infinity;
      var minY = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      nodes.forEach(function(node) {
        var size3 = node.size;
        if ((0, array_1.isArray)(size3)) {
          if (size3.length === 1)
            size3 = [size3[0], size3[0]];
        } else if ((0, number_1.isNumber)(size3)) {
          size3 = [size3, size3];
        } else if (size3 === void 0 || isNaN(size3)) {
          size3 = [30, 30];
        }
        var halfSize = [size3[0] / 2, size3[1] / 2];
        var left = node.x - halfSize[0];
        var right = node.x + halfSize[0];
        var top = node.y - halfSize[1];
        var bottom = node.y + halfSize[1];
        if (minX > left)
          minX = left;
        if (minY > top)
          minY = top;
        if (maxX < right)
          maxX = right;
        if (maxY < bottom)
          maxY = bottom;
      });
      return { minX, minY, maxX, maxY };
    };
    exports.getLayoutBBox = getLayoutBBox;
    var getAvgNodePosition = function(nodes) {
      var totalNodes = { x: 0, y: 0 };
      nodes.forEach(function(node) {
        totalNodes.x += node.x || 0;
        totalNodes.y += node.y || 0;
      });
      var length6 = nodes.length || 1;
      return {
        x: totalNodes.x / length6,
        y: totalNodes.y / length6
      };
    };
    exports.getAvgNodePosition = getAvgNodePosition;
    var getCoreNode = function(type, node, edges) {
      var _a2, _b;
      if (type === "source") {
        return ((_a2 = edges === null || edges === void 0 ? void 0 : edges.find(function(edge) {
          return edge.target === node.id;
        })) === null || _a2 === void 0 ? void 0 : _a2.source) || {};
      }
      return ((_b = edges === null || edges === void 0 ? void 0 : edges.find(function(edge) {
        return edge.source === node.id;
      })) === null || _b === void 0 ? void 0 : _b.target) || {};
    };
    var getRelativeNodeIds = function(type, coreNode, edges) {
      var relativeNodes = [];
      switch (type) {
        case "source":
          relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.source === coreNode.id;
          }).map(function(edge) {
            return edge.target;
          });
          break;
        case "target":
          relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.target === coreNode.id;
          }).map(function(edge) {
            return edge.source;
          });
          break;
        case "both":
          relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.source === coreNode.id;
          }).map(function(edge) {
            return edge.target;
          }).concat(edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.target === coreNode.id;
          }).map(function(edge) {
            return edge.source;
          }));
          break;
        default:
          break;
      }
      var set12 = new Set(relativeNodes);
      return Array.from(set12);
    };
    var getSameTypeNodes = function(type, nodeClusterBy, node, relativeNodes, degreesMap) {
      var typeName = node[nodeClusterBy] || "";
      var sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter(function(item) {
        return item[nodeClusterBy] === typeName;
      })) || [];
      if (type === "leaf") {
        sameTypeNodes = sameTypeNodes.filter(function(node2) {
          var _a2, _b;
          return ((_a2 = degreesMap[node2.id]) === null || _a2 === void 0 ? void 0 : _a2.in) === 0 || ((_b = degreesMap[node2.id]) === null || _b === void 0 ? void 0 : _b.out) === 0;
        });
      }
      return sameTypeNodes;
    };
    var getCoreNodeAndRelativeLeafNodes = function(type, node, edges, nodeClusterBy, degreesMap, nodeMap) {
      var _a2 = degreesMap[node.id], inDegree = _a2.in, outDegree = _a2.out;
      var coreNode = node;
      var relativeLeafNodes = [];
      if (inDegree === 0) {
        coreNode = getCoreNode("source", node, edges);
        relativeLeafNodes = getRelativeNodeIds("both", coreNode, edges).map(function(nodeId) {
          return nodeMap[nodeId];
        });
      } else if (outDegree === 0) {
        coreNode = getCoreNode("target", node, edges);
        relativeLeafNodes = getRelativeNodeIds("both", coreNode, edges).map(function(nodeId) {
          return nodeMap[nodeId];
        });
      }
      relativeLeafNodes = relativeLeafNodes.filter(function(node2) {
        return degreesMap[node2.id] && (degreesMap[node2.id].in === 0 || degreesMap[node2.id].out === 0);
      });
      var sameTypeLeafNodes = getSameTypeNodes(type, nodeClusterBy, node, relativeLeafNodes, degreesMap);
      return { coreNode, relativeLeafNodes, sameTypeLeafNodes };
    };
    exports.getCoreNodeAndRelativeLeafNodes = getCoreNodeAndRelativeLeafNodes;
  }
});

// node_modules/@antv/layout/lib/util/function.js
var require_function = __commonJS({
  "node_modules/@antv/layout/lib/util/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFuncByUnknownType = exports.getFunc = exports.isFunction = void 0;
    var _1 = require_util2();
    var number_1 = require_number();
    var isFunction3 = function(val) {
      return typeof val === "function";
    };
    exports.isFunction = isFunction3;
    var getFunc = function(value, defaultValue, func) {
      var resultFunc;
      if (func) {
        resultFunc = func;
      } else if ((0, number_1.isNumber)(value)) {
        resultFunc = function() {
          return value;
        };
      } else {
        resultFunc = function() {
          return defaultValue;
        };
      }
      return resultFunc;
    };
    exports.getFunc = getFunc;
    var getFuncByUnknownType = function(defaultValue, value, resultIsNumber) {
      if (resultIsNumber === void 0) {
        resultIsNumber = true;
      }
      if (!value && value !== 0) {
        return function(d2) {
          if (d2.size) {
            if ((0, _1.isArray)(d2.size))
              return d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
            if ((0, _1.isObject)(d2.size))
              return d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
            return d2.size;
          }
          return defaultValue;
        };
      }
      if ((0, exports.isFunction)(value)) {
        return value;
      }
      if ((0, number_1.isNumber)(value)) {
        return function() {
          return value;
        };
      }
      if ((0, _1.isArray)(value)) {
        return function() {
          if (resultIsNumber) {
            var max8 = Math.max.apply(Math, value);
            return isNaN(max8) ? defaultValue : max8;
          }
          return value;
        };
      }
      if ((0, _1.isObject)(value)) {
        return function() {
          if (resultIsNumber) {
            var max8 = Math.max(value.width, value.height);
            return isNaN(max8) ? defaultValue : max8;
          }
          return [value.width, value.height];
        };
      }
      return function() {
        return defaultValue;
      };
    };
    exports.getFuncByUnknownType = getFuncByUnknownType;
  }
});

// node_modules/@antv/layout/lib/util/index.js
var require_util2 = __commonJS({
  "node_modules/@antv/layout/lib/util/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding2(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_string(), exports);
    __exportStar2(require_array(), exports);
    __exportStar2(require_number(), exports);
    __exportStar2(require_math(), exports);
    __exportStar2(require_object(), exports);
    __exportStar2(require_function(), exports);
  }
});

// node_modules/@antv/layout/lib/registy/index.js
var require_registy = __commonJS({
  "node_modules/@antv/layout/lib/registy/index.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var map6 = /* @__PURE__ */ new Map();
    var registerLayout3 = function(name, layoutOverride) {
      if (map6.get(name)) {
        console.warn("The layout with the name ".concat(name, " exists already, it will be overridden"));
      }
      if ((0, util_1.isObject)(layoutOverride)) {
        var GLayout = (
          /** @class */
          function(_super) {
            __extends17(GLayout2, _super);
            function GLayout2(cfg) {
              var _this = this;
              var _a2;
              _this = _super.call(this) || this;
              var self2 = _this;
              var props = {};
              var defaultCfg2 = Object.assign({}, self2.getDefaultCfg(), ((_a2 = layoutOverride.getDefaultCfg) === null || _a2 === void 0 ? void 0 : _a2.call(layoutOverride)) || {});
              Object.assign(props, defaultCfg2, layoutOverride, cfg);
              Object.keys(props).forEach(function(key) {
                var value = props[key];
                self2[key] = value;
              });
              return _this;
            }
            return GLayout2;
          }(base_1.Base)
        );
        map6.set(name, GLayout);
      } else {
        map6.set(name, layoutOverride);
      }
      return map6.get(name);
    };
    exports.registerLayout = registerLayout3;
    var unRegisterLayout = function(name) {
      if (map6.has(name)) {
        map6.delete(name);
      }
    };
    exports.unRegisterLayout = unRegisterLayout;
    var getLayoutByName = function(name) {
      if (map6.has(name)) {
        return map6.get(name);
      }
      return null;
    };
    exports.getLayoutByName = getLayoutByName;
  }
});

// node_modules/@antv/layout/lib/layout/grid.js
var require_grid = __commonJS({
  "node_modules/@antv/layout/lib/layout/grid.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var GridLayout2 = (
      /** @class */
      function(_super) {
        __extends17(GridLayout3, _super);
        function GridLayout3(options) {
          var _this = _super.call(this) || this;
          _this.begin = [0, 0];
          _this.preventOverlap = true;
          _this.preventOverlapPadding = 10;
          _this.condense = false;
          _this.sortBy = "degree";
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.row = 0;
          _this.col = 0;
          _this.cellWidth = 0;
          _this.cellHeight = 0;
          _this.cellUsed = {};
          _this.id2manPos = {};
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        GridLayout3.prototype.getDefaultCfg = function() {
          return {
            begin: [0, 0],
            preventOverlap: true,
            preventOverlapPadding: 10,
            condense: false,
            rows: void 0,
            cols: void 0,
            position: void 0,
            sortBy: "degree",
            nodeSize: 30
          };
        };
        GridLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, begin = self2.begin;
          var n2 = nodes.length;
          if (n2 === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return {
              nodes,
              edges
            };
          }
          if (n2 === 1) {
            nodes[0].x = begin[0];
            nodes[0].y = begin[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return {
              nodes,
              edges
            };
          }
          var sortBy3 = self2.sortBy, width = self2.width, height = self2.height;
          var condense = self2.condense, preventOverlapPadding = self2.preventOverlapPadding, preventOverlap = self2.preventOverlap, paramNodeSpacing = self2.nodeSpacing, paramNodeSize = self2.nodeSize;
          var layoutNodes = [];
          nodes.forEach(function(node2) {
            layoutNodes.push(node2);
          });
          var nodeIdxMap = {};
          layoutNodes.forEach(function(node2, i3) {
            nodeIdxMap[node2.id] = i3;
          });
          if (sortBy3 === "degree" || !(0, util_1.isString)(sortBy3) || layoutNodes[0][sortBy3] === void 0) {
            sortBy3 = "degree";
            if ((0, util_1.isNaN)(nodes[0].degree)) {
              var values_1 = (0, util_1.getDegree)(layoutNodes.length, nodeIdxMap, edges);
              layoutNodes.forEach(function(node2, i3) {
                node2.degree = values_1[i3].all;
              });
            }
          }
          layoutNodes.sort(function(n1, n22) {
            return n22[sortBy3] - n1[sortBy3];
          });
          if (!width && typeof window !== "undefined") {
            width = window.innerWidth;
          }
          if (!height && typeof window !== "undefined") {
            height = window.innerHeight;
          }
          var oRows = self2.rows;
          var oCols = self2.cols != null ? self2.cols : self2.columns;
          self2.cells = n2;
          if (oRows != null && oCols != null) {
            self2.rows = oRows;
            self2.cols = oCols;
          } else if (oRows != null && oCols == null) {
            self2.rows = oRows;
            self2.cols = Math.ceil(self2.cells / self2.rows);
          } else if (oRows == null && oCols != null) {
            self2.cols = oCols;
            self2.rows = Math.ceil(self2.cells / self2.cols);
          } else {
            self2.splits = Math.sqrt(self2.cells * self2.height / self2.width);
            self2.rows = Math.round(self2.splits);
            self2.cols = Math.round(self2.width / self2.height * self2.splits);
          }
          self2.rows = Math.max(self2.rows, 1);
          self2.cols = Math.max(self2.cols, 1);
          if (self2.cols * self2.rows > self2.cells) {
            var sm = self2.small();
            var lg = self2.large();
            if ((sm - 1) * lg >= self2.cells) {
              self2.small(sm - 1);
            } else if ((lg - 1) * sm >= self2.cells) {
              self2.large(lg - 1);
            }
          } else {
            while (self2.cols * self2.rows < self2.cells) {
              var sm = self2.small();
              var lg = self2.large();
              if ((lg + 1) * sm >= self2.cells) {
                self2.large(lg + 1);
              } else {
                self2.small(sm + 1);
              }
            }
          }
          self2.cellWidth = width / self2.cols;
          self2.cellHeight = height / self2.rows;
          if (condense) {
            self2.cellWidth = 0;
            self2.cellHeight = 0;
          }
          if (preventOverlap || paramNodeSpacing) {
            var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);
            var nodeSize_1 = (0, util_1.getFuncByUnknownType)(30, paramNodeSize, false);
            layoutNodes.forEach(function(node2) {
              if (!node2.x || !node2.y) {
                node2.x = 0;
                node2.y = 0;
              }
              var res = nodeSize_1(node2) || 30;
              var nodeW;
              var nodeH;
              if ((0, util_1.isArray)(res)) {
                nodeW = res[0];
                nodeH = res[1];
              } else {
                nodeW = res;
                nodeH = res;
              }
              var p2 = nodeSpacing_1 !== void 0 ? nodeSpacing_1(node2) : preventOverlapPadding;
              var w2 = nodeW + p2;
              var h2 = nodeH + p2;
              self2.cellWidth = Math.max(self2.cellWidth, w2);
              self2.cellHeight = Math.max(self2.cellHeight, h2);
            });
          }
          self2.cellUsed = {};
          self2.row = 0;
          self2.col = 0;
          self2.id2manPos = {};
          for (var i2 = 0; i2 < layoutNodes.length; i2++) {
            var node = layoutNodes[i2];
            var rcPos = void 0;
            if (self2.position) {
              rcPos = self2.position(node);
            }
            if (rcPos && (rcPos.row !== void 0 || rcPos.col !== void 0)) {
              var pos = {
                row: rcPos.row,
                col: rcPos.col
              };
              if (pos.col === void 0) {
                pos.col = 0;
                while (self2.used(pos.row, pos.col)) {
                  pos.col++;
                }
              } else if (pos.row === void 0) {
                pos.row = 0;
                while (self2.used(pos.row, pos.col)) {
                  pos.row++;
                }
              }
              self2.id2manPos[node.id] = pos;
              self2.use(pos.row, pos.col);
            }
            self2.getPos(node);
          }
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            edges,
            nodes: layoutNodes
          };
        };
        GridLayout3.prototype.small = function(val) {
          var self2 = this;
          var res;
          var rows = self2.rows || 5;
          var cols = self2.cols || 5;
          if (val == null) {
            res = Math.min(rows, cols);
          } else {
            var min6 = Math.min(rows, cols);
            if (min6 === self2.rows) {
              self2.rows = val;
            } else {
              self2.cols = val;
            }
          }
          return res;
        };
        GridLayout3.prototype.large = function(val) {
          var self2 = this;
          var res;
          var rows = self2.rows || 5;
          var cols = self2.cols || 5;
          if (val == null) {
            res = Math.max(rows, cols);
          } else {
            var max8 = Math.max(rows, cols);
            if (max8 === self2.rows) {
              self2.rows = val;
            } else {
              self2.cols = val;
            }
          }
          return res;
        };
        GridLayout3.prototype.used = function(row, col) {
          var self2 = this;
          return self2.cellUsed["c-".concat(row, "-").concat(col)] || false;
        };
        GridLayout3.prototype.use = function(row, col) {
          var self2 = this;
          self2.cellUsed["c-".concat(row, "-").concat(col)] = true;
        };
        GridLayout3.prototype.moveToNextCell = function() {
          var self2 = this;
          var cols = self2.cols || 5;
          self2.col++;
          if (self2.col >= cols) {
            self2.col = 0;
            self2.row++;
          }
        };
        GridLayout3.prototype.getPos = function(node) {
          var self2 = this;
          var begin = self2.begin, cellWidth = self2.cellWidth, cellHeight = self2.cellHeight;
          var x4;
          var y4;
          var rcPos = self2.id2manPos[node.id];
          if (rcPos) {
            x4 = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
            y4 = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
          } else {
            while (self2.used(self2.row, self2.col)) {
              self2.moveToNextCell();
            }
            x4 = self2.col * cellWidth + cellWidth / 2 + begin[0];
            y4 = self2.row * cellHeight + cellHeight / 2 + begin[1];
            self2.use(self2.row, self2.col);
            self2.moveToNextCell();
          }
          node.x = x4;
          node.y = y4;
        };
        GridLayout3.prototype.getType = function() {
          return "grid";
        };
        return GridLayout3;
      }(base_1.Base)
    );
    exports.GridLayout = GridLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/random.js
var require_random = __commonJS({
  "node_modules/@antv/layout/lib/layout/random.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomLayout = void 0;
    var base_1 = require_base();
    var RandomLayout2 = (
      /** @class */
      function(_super) {
        __extends17(RandomLayout3, _super);
        function RandomLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.width = 300;
          _this.height = 300;
          _this.nodes = [];
          _this.edges = [];
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        RandomLayout3.prototype.getDefaultCfg = function() {
          return {
            center: [0, 0],
            width: 300,
            height: 300
          };
        };
        RandomLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var layoutScale = 0.9;
          var center = self2.center;
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (nodes) {
            nodes.forEach(function(node) {
              node.x = (Math.random() - 0.5) * layoutScale * self2.width + center[0];
              node.y = (Math.random() - 0.5) * layoutScale * self2.height + center[1];
            });
          }
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges: this.edges
          };
        };
        RandomLayout3.prototype.getType = function() {
          return "random";
        };
        return RandomLayout3;
      }(base_1.Base)
    );
    exports.RandomLayout = RandomLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/gForce.js
var require_gForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/gForce.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GForceLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function(d2) {
          return defaultV || 1;
        };
      } else if ((0, util_1.isNumber)(value)) {
        func = function(d2) {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    var GForceLayout2 = (
      /** @class */
      function(_super) {
        __extends17(GForceLayout3, _super);
        function GForceLayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 500;
          _this.workerEnabled = false;
          _this.edgeStrength = 200;
          _this.nodeStrength = 1e3;
          _this.coulombDisScale = 5e-3;
          _this.damping = 0.9;
          _this.maxSpeed = 1e3;
          _this.minMovement = 0.5;
          _this.interval = 0.02;
          _this.factor = 1;
          _this.linkDistance = 1;
          _this.gravity = 10;
          _this.preventOverlap = true;
          _this.collideStrength = 1;
          _this.tick = function() {
          };
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.animate = true;
          _this.updateCfg(options);
          return _this;
        }
        GForceLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 500,
            gravity: 10,
            enableTick: true,
            animate: true
          };
        };
        GForceLayout3.prototype.execute = function() {
          var _a2, _b;
          var self2 = this;
          var nodes = self2.nodes;
          if (self2.timeInterval !== void 0 && typeof window !== "undefined") {
            window.clearInterval(self2.timeInterval);
          }
          if (!nodes || nodes.length === 0) {
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
            return;
          }
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * self2.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * self2.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          self2.linkDistance = proccessToFunc3(self2.linkDistance, 1);
          self2.nodeStrength = proccessToFunc3(self2.nodeStrength, 1);
          self2.edgeStrength = proccessToFunc3(self2.edgeStrength, 1);
          var nodeSize = self2.nodeSize;
          var nodeSizeFunc;
          if (self2.preventOverlap) {
            var nodeSpacing_1 = self2.nodeSpacing;
            var nodeSpacingFunc_1;
            if ((0, util_1.isNumber)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = function() {
                return nodeSpacing_1;
              };
            } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = nodeSpacing_1;
            } else {
              nodeSpacingFunc_1 = function() {
                return 0;
              };
            }
            if (!nodeSize) {
              nodeSizeFunc = function(d2) {
                if (d2.size) {
                  if ((0, util_1.isArray)(d2.size)) {
                    return Math.max(d2.size[0], d2.size[1]) + nodeSpacingFunc_1(d2);
                  }
                  if ((0, util_1.isObject)(d2.size)) {
                    return Math.max(d2.size.width, d2.size.height) + nodeSpacingFunc_1(d2);
                  }
                  return d2.size + nodeSpacingFunc_1(d2);
                }
                return 10 + nodeSpacingFunc_1(d2);
              };
            } else if ((0, util_1.isArray)(nodeSize)) {
              nodeSizeFunc = function(d2) {
                return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc_1(d2);
              };
            } else {
              nodeSizeFunc = function(d2) {
                return nodeSize + nodeSpacingFunc_1(d2);
              };
            }
          }
          self2.nodeSize = nodeSizeFunc;
          var edges = self2.edges;
          self2.degrees = (0, util_1.getDegree)(nodes.length, self2.nodeIdxMap, edges);
          if (!self2.getMass) {
            self2.getMass = function(d2) {
              var mass = d2.mass || self2.degrees[self2.nodeIdxMap[d2.id]].all || 1;
              return mass;
            };
          }
          self2.run();
        };
        GForceLayout3.prototype.run = function() {
          var _a2;
          var self2 = this;
          var maxIteration = self2.maxIteration, nodes = self2.nodes, workerEnabled = self2.workerEnabled, minMovement = self2.minMovement, animate = self2.animate;
          if (!nodes)
            return;
          if (workerEnabled || !animate) {
            for (var i2 = 0; i2 < maxIteration; i2++) {
              var previousPos = self2.runOneStep(i2);
              if (self2.reachMoveThreshold(nodes, previousPos, minMovement)) {
                break;
              }
            }
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          } else {
            if (typeof window === "undefined")
              return;
            var iter_1 = 0;
            this.timeInterval = window.setInterval(function() {
              var _a3, _b;
              if (!nodes)
                return;
              var previousPos2 = self2.runOneStep(iter_1) || [];
              if (self2.reachMoveThreshold(nodes, previousPos2, minMovement)) {
                (_a3 = self2.onLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(self2);
                window.clearInterval(self2.timeInterval);
              }
              iter_1++;
              if (iter_1 >= maxIteration) {
                (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
                window.clearInterval(self2.timeInterval);
              }
            }, 0);
          }
        };
        GForceLayout3.prototype.reachMoveThreshold = function(nodes, previousPos, minMovement) {
          var movement = 0;
          nodes.forEach(function(node, j2) {
            var vx = node.x - previousPos[j2].x;
            var vy = node.y - previousPos[j2].y;
            movement += Math.sqrt(vx * vx + vy * vy);
          });
          movement /= nodes.length;
          return movement < minMovement;
        };
        GForceLayout3.prototype.runOneStep = function(iter) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges;
          var accArray = [];
          var velArray = [];
          if (!nodes)
            return;
          nodes.forEach(function(_2, i2) {
            accArray[2 * i2] = 0;
            accArray[2 * i2 + 1] = 0;
            velArray[2 * i2] = 0;
            velArray[2 * i2 + 1] = 0;
          });
          self2.calRepulsive(accArray, nodes);
          if (edges)
            self2.calAttractive(accArray, edges);
          self2.calGravity(accArray, nodes);
          var stepInterval = Math.max(0.02, self2.interval - iter * 2e-3);
          self2.updateVelocity(accArray, velArray, stepInterval, nodes);
          var previousPos = [];
          nodes.forEach(function(node) {
            previousPos.push({
              x: node.x,
              y: node.y
            });
          });
          self2.updatePosition(velArray, stepInterval, nodes);
          (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          return previousPos;
        };
        GForceLayout3.prototype.calRepulsive = function(accArray, nodes) {
          var self2 = this;
          var getMass = self2.getMass, factor = self2.factor, coulombDisScale = self2.coulombDisScale, preventOverlap = self2.preventOverlap, _a2 = self2.collideStrength, collideStrength = _a2 === void 0 ? 1 : _a2;
          var nodeStrength = self2.nodeStrength;
          var nodeSize = self2.nodeSize;
          nodes.forEach(function(ni2, i2) {
            var massi = getMass ? getMass(ni2) : 1;
            nodes.forEach(function(nj, j2) {
              if (i2 >= j2)
                return;
              var vecX = ni2.x - nj.x;
              var vecY = ni2.y - nj.y;
              if (vecX === 0 && vecY === 0) {
                vecX = Math.random() * 0.01;
                vecY = Math.random() * 0.01;
              }
              var lengthSqr = vecX * vecX + vecY * vecY;
              var vecLength = Math.sqrt(lengthSqr);
              var nVecLength = (vecLength + 0.1) * coulombDisScale;
              var direX = vecX / vecLength;
              var direY = vecY / vecLength;
              var param = (nodeStrength(ni2) + nodeStrength(nj)) * 0.5 * factor / (nVecLength * nVecLength);
              var massj = getMass ? getMass(nj) : 1;
              accArray[2 * i2] += direX * param;
              accArray[2 * i2 + 1] += direY * param;
              accArray[2 * j2] -= direX * param;
              accArray[2 * j2 + 1] -= direY * param;
              if (preventOverlap && (nodeSize(ni2) + nodeSize(nj)) / 2 > vecLength) {
                var paramOverlap = collideStrength * (nodeStrength(ni2) + nodeStrength(nj)) * 0.5 / lengthSqr;
                accArray[2 * i2] += direX * paramOverlap / massi;
                accArray[2 * i2 + 1] += direY * paramOverlap / massi;
                accArray[2 * j2] -= direX * paramOverlap / massj;
                accArray[2 * j2 + 1] -= direY * paramOverlap / massj;
              }
            });
          });
        };
        GForceLayout3.prototype.calAttractive = function(accArray, edges) {
          var self2 = this;
          var nodeMap = self2.nodeMap, nodeIdxMap = self2.nodeIdxMap, linkDistance = self2.linkDistance, edgeStrength = self2.edgeStrength;
          var nodeSize = self2.nodeSize;
          var getMass = self2.getMass;
          edges.forEach(function(edge, i2) {
            var source = (0, util_1.getEdgeTerminal)(edge, "source");
            var target = (0, util_1.getEdgeTerminal)(edge, "target");
            var sourceNode = nodeMap[source];
            var targetNode = nodeMap[target];
            var vecX = targetNode.x - sourceNode.x;
            var vecY = targetNode.y - sourceNode.y;
            if (vecX === 0 && vecY === 0) {
              vecX = Math.random() * 0.01;
              vecY = Math.random() * 0.01;
            }
            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            var direX = vecX / vecLength;
            var direY = vecY / vecLength;
            var length6 = linkDistance(edge, sourceNode, targetNode) || 1 + (nodeSize(sourceNode) + nodeSize(targetNode) || 0) / 2;
            var diff = length6 - vecLength;
            var param = diff * edgeStrength(edge);
            var sourceIdx = nodeIdxMap[source];
            var targetIdx = nodeIdxMap[target];
            var massSource = getMass ? getMass(sourceNode) : 1;
            var massTarget = getMass ? getMass(targetNode) : 1;
            accArray[2 * sourceIdx] -= direX * param / massSource;
            accArray[2 * sourceIdx + 1] -= direY * param / massSource;
            accArray[2 * targetIdx] += direX * param / massTarget;
            accArray[2 * targetIdx + 1] += direY * param / massTarget;
          });
        };
        GForceLayout3.prototype.calGravity = function(accArray, nodes) {
          var self2 = this;
          var center = self2.center;
          var defaultGravity = self2.gravity;
          var degrees3 = self2.degrees;
          var nodeLength = nodes.length;
          for (var i2 = 0; i2 < nodeLength; i2++) {
            var node = nodes[i2];
            var vecX = node.x - center[0];
            var vecY = node.y - center[1];
            var gravity = defaultGravity;
            if (self2.getCenter) {
              var customCenterOpt = self2.getCenter(node, degrees3[i2].all);
              if (customCenterOpt && (0, util_1.isNumber)(customCenterOpt[0]) && (0, util_1.isNumber)(customCenterOpt[1]) && (0, util_1.isNumber)(customCenterOpt[2])) {
                vecX = node.x - customCenterOpt[0];
                vecY = node.y - customCenterOpt[1];
                gravity = customCenterOpt[2];
              }
            }
            if (!gravity)
              continue;
            accArray[2 * i2] -= gravity * vecX;
            accArray[2 * i2 + 1] -= gravity * vecY;
          }
        };
        GForceLayout3.prototype.updateVelocity = function(accArray, velArray, stepInterval, nodes) {
          var self2 = this;
          var param = stepInterval * self2.damping;
          nodes.forEach(function(node, i2) {
            var vx = accArray[2 * i2] * param || 0.01;
            var vy = accArray[2 * i2 + 1] * param || 0.01;
            var vLength = Math.sqrt(vx * vx + vy * vy);
            if (vLength > self2.maxSpeed) {
              var param2 = self2.maxSpeed / vLength;
              vx = param2 * vx;
              vy = param2 * vy;
            }
            velArray[2 * i2] = vx;
            velArray[2 * i2 + 1] = vy;
          });
        };
        GForceLayout3.prototype.updatePosition = function(velArray, stepInterval, nodes) {
          nodes.forEach(function(node, i2) {
            if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
              node.x = node.fx;
              node.y = node.fy;
              return;
            }
            var distX = velArray[2 * i2] * stepInterval;
            var distY = velArray[2 * i2 + 1] * stepInterval;
            node.x += distX;
            node.y += distY;
          });
        };
        GForceLayout3.prototype.stop = function() {
          if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
          }
        };
        GForceLayout3.prototype.destroy = function() {
          var self2 = this;
          self2.stop();
          self2.tick = null;
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        GForceLayout3.prototype.getType = function() {
          return "gForce";
        };
        return GForceLayout3;
      }(base_1.Base)
    );
    exports.GForceLayout = GForceLayout2;
  }
});

// node_modules/d3-quadtree/src/add.js
function add_default(d2) {
  const x4 = +this._x.call(null, d2), y4 = +this._y.call(null, d2);
  return add10(this.cover(x4, y4), x4, y4, d2);
}
function add10(tree, x4, y4, d2) {
  if (isNaN(x4) || isNaN(y4)) return tree;
  var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j2;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (parent = node, !(node = node[i2 = bottom << 1 | right])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x4 === xp && y4 === yp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
  } while ((i2 = bottom << 1 | right) === (j2 = (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll(data) {
  var d2, i2, n2 = data.length, x4, y4, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x4 = +this._x.call(null, d2 = data[i2])) || isNaN(y4 = +this._y.call(null, d2))) continue;
    xz[i2] = x4;
    yz[i2] = y4;
    if (x4 < x0) x0 = x4;
    if (x4 > x1) x1 = x4;
    if (y4 < y0) y0 = y4;
    if (y4 > y1) y1 = y4;
  }
  if (x0 > x1 || y0 > y1) return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add10(this, xz[i2], yz[i2], data[i2]);
  }
  return this;
}
var init_add = __esm({
  "node_modules/d3-quadtree/src/add.js"() {
  }
});

// node_modules/d3-quadtree/src/cover.js
function cover_default(x4, y4) {
  if (isNaN(x4 = +x4) || isNaN(y4 = +y4)) return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x4)) + 1;
    y1 = (y0 = Math.floor(y4)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x4 || x4 >= x1 || y0 > y4 || y4 >= y1) {
      i2 = (y4 < y0) << 1 | x4 < x0;
      parent = new Array(4), parent[i2] = node, node = parent, z2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z2, y1 = y0 + z2;
          break;
        case 1:
          x0 = x1 - z2, y1 = y0 + z2;
          break;
        case 2:
          x1 = x0 + z2, y0 = y1 - z2;
          break;
        case 3:
          x0 = x1 - z2, y0 = y1 - z2;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}
var init_cover = __esm({
  "node_modules/d3-quadtree/src/cover.js"() {
  }
});

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}
var init_data = __esm({
  "node_modules/d3-quadtree/src/data.js"() {
  }
});

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
var init_extent = __esm({
  "node_modules/d3-quadtree/src/extent.js"() {
  }
});

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}
var init_quad = __esm({
  "node_modules/d3-quadtree/src/quad.js"() {
  }
});

// node_modules/d3-quadtree/src/find.js
function find_default2(x4, y4, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q2, i2;
  if (node) quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x4 - radius, y0 = y4 - radius;
    x32 = x4 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q2 = quads.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (y1 = q2.y0) > y32 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i2 = (y4 >= ym) << 1 | x4 >= xm) {
        q2 = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q2;
      }
    } else {
      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d3 = Math.sqrt(radius = d2);
        x0 = x4 - d3, y0 = y4 - d3;
        x32 = x4 + d3, y32 = y4 + d3;
        data = node.data;
      }
    }
  }
  return data;
}
var init_find2 = __esm({
  "node_modules/d3-quadtree/src/find.js"() {
    init_quad();
  }
});

// node_modules/d3-quadtree/src/remove.js
function remove_default2(d2) {
  if (isNaN(x4 = +this._x.call(null, d2)) || isNaN(y4 = +this._y.call(null, d2))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x4, y4, xm, ym, right, bottom, i2, j2;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (!(parent = node, node = node[i2 = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3]) retainer = parent, j2 = i2;
  }
  while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j2] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}
var init_remove2 = __esm({
  "node_modules/d3-quadtree/src/remove.js"() {
  }
});

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}
var init_root = __esm({
  "node_modules/d3-quadtree/src/root.js"() {
  }
});

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size3 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size3;
    while (node = node.next);
  });
  return size3;
}
var init_size2 = __esm({
  "node_modules/d3-quadtree/src/size.js"() {
  }
});

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}
var init_visit = __esm({
  "node_modules/d3-quadtree/src/visit.js"() {
    init_quad();
  }
});

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q2;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
  }
  return this;
}
var init_visitAfter = __esm({
  "node_modules/d3-quadtree/src/visitAfter.js"() {
    init_quad();
  }
});

// node_modules/d3-quadtree/src/x.js
function defaultX(d2) {
  return d2[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
var init_x = __esm({
  "node_modules/d3-quadtree/src/x.js"() {
  }
});

// node_modules/d3-quadtree/src/y.js
function defaultY(d2) {
  return d2[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
var init_y = __esm({
  "node_modules/d3-quadtree/src/y.js"() {
  }
});

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x4, y4) {
  var tree = new Quadtree(x4 == null ? defaultX : x4, y4 == null ? defaultY : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x4, y4, x0, y0, x1, y1) {
  this._x = x4;
  this._y = y4;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy10 = { data: leaf.data }, next = copy10;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy10;
}
var treeProto;
var init_quadtree = __esm({
  "node_modules/d3-quadtree/src/quadtree.js"() {
    init_add();
    init_cover();
    init_data();
    init_extent();
    init_find2();
    init_remove2();
    init_root();
    init_size2();
    init_visit();
    init_visitAfter();
    init_x();
    init_y();
    treeProto = quadtree.prototype = Quadtree.prototype;
    treeProto.copy = function() {
      var copy10 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
      if (!node) return copy10;
      if (!node.length) return copy10._root = leaf_copy(node), copy10;
      nodes = [{ source: node, target: copy10._root = new Array(4) }];
      while (node = nodes.pop()) {
        for (var i2 = 0; i2 < 4; ++i2) {
          if (child = node.source[i2]) {
            if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(4) });
            else node.target[i2] = leaf_copy(child);
          }
        }
      }
      return copy10;
    };
    treeProto.add = add_default;
    treeProto.addAll = addAll;
    treeProto.cover = cover_default;
    treeProto.data = data_default;
    treeProto.extent = extent_default;
    treeProto.find = find_default2;
    treeProto.remove = remove_default2;
    treeProto.removeAll = removeAll;
    treeProto.root = root_default;
    treeProto.size = size_default;
    treeProto.visit = visit_default;
    treeProto.visitAfter = visitAfter_default;
    treeProto.x = x_default;
    treeProto.y = y_default;
  }
});

// node_modules/d3-quadtree/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  quadtree: () => quadtree
});
var init_src2 = __esm({
  "node_modules/d3-quadtree/src/index.js"() {
    init_quadtree();
  }
});

// node_modules/@antv/layout/lib/layout/force2/ForceNBody.js
var require_ForceNBody = __commonJS({
  "node_modules/@antv/layout/lib/layout/force2/ForceNBody.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forceNBody = void 0;
    var d3_quadtree_1 = (init_src2(), __toCommonJS(src_exports3));
    var theta2 = 0.81;
    var epsilon = 0.1;
    function forceNBody(nodes, nodeMap, factor, coulombDisScale2, accArray) {
      var weightParam = factor / coulombDisScale2;
      var data = nodes.map(function(n2, i2) {
        var mappedNode = nodeMap[n2.id];
        var nodeData = mappedNode.data, x4 = mappedNode.x, y4 = mappedNode.y, size3 = mappedNode.size;
        var nodeStrength = nodeData.layout.force.nodeStrength;
        return {
          x: x4,
          y: y4,
          size: size3,
          index: i2,
          vx: 0,
          vy: 0,
          weight: weightParam * nodeStrength
        };
      });
      var tree = (0, d3_quadtree_1.quadtree)(data, function(d2) {
        return d2.x;
      }, function(d2) {
        return d2.y;
      }).visitAfter(accumulate);
      data.forEach(function(n2) {
        computeForce(n2, tree);
      });
      data.map(function(n2, i2) {
        var mappedNode = nodeMap[nodes[i2].id];
        var _a2 = mappedNode.data.layout.force.mass, mass = _a2 === void 0 ? 1 : _a2;
        accArray[2 * i2] = n2.vx / mass;
        accArray[2 * i2 + 1] = n2.vy / mass;
      });
      return accArray;
    }
    exports.forceNBody = forceNBody;
    function accumulate(quad) {
      var accWeight = 0;
      var accX = 0;
      var accY = 0;
      if (quad.length) {
        for (var i2 = 0; i2 < 4; i2++) {
          var q2 = quad[i2];
          if (q2 && q2.weight) {
            accWeight += q2.weight;
            accX += q2.x * q2.weight;
            accY += q2.y * q2.weight;
          }
        }
        quad.x = accX / accWeight;
        quad.y = accY / accWeight;
        quad.weight = accWeight;
      } else {
        var q2 = quad;
        quad.x = q2.data.x;
        quad.y = q2.data.y;
        quad.weight = q2.data.weight;
      }
    }
    var apply = function(quad, x1, y1, x22, y22, node) {
      var dx = node.x - quad.x || epsilon;
      var dy = node.y - quad.y || epsilon;
      var width = x22 - x1;
      var len22 = dx * dx + dy * dy;
      var len32 = Math.sqrt(len22) * len22;
      if (width * width * theta2 < len22) {
        var param = quad.weight / len32;
        node.vx += dx * param;
        node.vy += dy * param;
        return true;
      }
      if (quad.length)
        return false;
      if (quad.data !== node) {
        var param = quad.data.weight / len32;
        node.vx += dx * param;
        node.vy += dy * param;
      }
    };
    function computeForce(node, tree) {
      tree.visit(function(quad, x1, y1, x22, y22) {
        return apply(quad, x1, y1, x22, y22, node);
      });
    }
  }
});

// node_modules/@antv/layout/lib/layout/force2/index.js
var require_force2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/force2/index.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __assign18 = exports && exports.__assign || function() {
      __assign18 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign18.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Force2Layout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var ForceNBody_1 = require_ForceNBody();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function(d2) {
          return defaultV || 1;
        };
      } else if ((0, util_1.isNumber)(value)) {
        func = function(d2) {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    var Force2Layout2 = (
      /** @class */
      function(_super) {
        __extends17(Force2Layout3, _super);
        function Force2Layout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.workerEnabled = false;
          _this.edgeStrength = 200;
          _this.nodeStrength = 1e3;
          _this.coulombDisScale = 5e-3;
          _this.damping = 0.9;
          _this.maxSpeed = 500;
          _this.minMovement = 0.4;
          _this.interval = 0.02;
          _this.factor = 1;
          _this.linkDistance = 200;
          _this.gravity = 0;
          _this.clusterNodeStrength = 20;
          _this.preventOverlap = true;
          _this.distanceThresholdMode = "mean";
          _this.tick = function() {
          };
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.judgingDistance = 0;
          _this.centripetalOptions = {
            leaf: 2,
            single: 2,
            others: 1,
            // eslint-disable-next-line
            center: function(n2) {
              return {
                x: _this.width / 2,
                y: _this.height / 2
              };
            }
          };
          var getMass = options.getMass;
          _this.propsGetMass = getMass;
          _this.updateCfg(options);
          return _this;
        }
        Force2Layout3.prototype.getCentripetalOptions = function() {
          var _a2 = this, leafCluster = _a2.leafCluster, clustering = _a2.clustering, nodeClusterBy = _a2.nodeClusterBy, nodes = _a2.nodes, nodeMap = _a2.nodeMap, propsClusterNodeStrength = _a2.clusterNodeStrength;
          var getClusterNodeStrength = function(node) {
            return typeof propsClusterNodeStrength === "function" ? propsClusterNodeStrength(node) : propsClusterNodeStrength;
          };
          var centripetalOptions = {};
          var sameTypeLeafMap;
          if (leafCluster) {
            sameTypeLeafMap = this.getSameTypeLeafMap() || {};
            var relativeNodesType_1 = Array.from(new Set(nodes === null || nodes === void 0 ? void 0 : nodes.map(function(node) {
              return node[nodeClusterBy];
            }))) || [];
            centripetalOptions = {
              single: 100,
              leaf: function(node, nodes2, edges) {
                var _a3 = sameTypeLeafMap[node.id] || {}, relativeLeafNodes = _a3.relativeLeafNodes, sameTypeLeafNodes = _a3.sameTypeLeafNodes;
                if ((sameTypeLeafNodes === null || sameTypeLeafNodes === void 0 ? void 0 : sameTypeLeafNodes.length) === (relativeLeafNodes === null || relativeLeafNodes === void 0 ? void 0 : relativeLeafNodes.length) || (relativeNodesType_1 === null || relativeNodesType_1 === void 0 ? void 0 : relativeNodesType_1.length) === 1) {
                  return 1;
                }
                return getClusterNodeStrength(node);
              },
              others: 1,
              center: function(node, nodes2, edges) {
                var _a3;
                var degree4 = (((_a3 = node.data) === null || _a3 === void 0 ? void 0 : _a3.layout) || {}).degree;
                if (!degree4) {
                  return {
                    x: 100,
                    y: 100
                  };
                }
                var centerNode;
                if (degree4 === 1) {
                  var _b2 = (sameTypeLeafMap[node.id] || {}).sameTypeLeafNodes, sameTypeLeafNodes = _b2 === void 0 ? [] : _b2;
                  if (sameTypeLeafNodes.length === 1) {
                    centerNode = void 0;
                  } else if (sameTypeLeafNodes.length > 1) {
                    centerNode = (0, util_1.getAvgNodePosition)(sameTypeLeafNodes);
                  }
                } else {
                  centerNode = void 0;
                }
                return {
                  x: centerNode === null || centerNode === void 0 ? void 0 : centerNode.x,
                  y: centerNode === null || centerNode === void 0 ? void 0 : centerNode.y
                };
              }
            };
          }
          if (clustering) {
            if (!sameTypeLeafMap)
              sameTypeLeafMap = this.getSameTypeLeafMap();
            var clusters = Array.from(new Set(nodes.map(function(node, i2) {
              return node[nodeClusterBy];
            }))).filter(function(item) {
              return item !== void 0;
            });
            var centerNodeInfo_1 = {};
            clusters.forEach(function(cluster) {
              var sameTypeNodes = nodes.filter(function(item) {
                return item[nodeClusterBy] === cluster;
              }).map(function(node) {
                return nodeMap[node.id];
              });
              centerNodeInfo_1[cluster] = (0, util_1.getAvgNodePosition)(sameTypeNodes);
            });
            centripetalOptions = {
              single: function(node) {
                return getClusterNodeStrength(node);
              },
              leaf: function(node) {
                return getClusterNodeStrength(node);
              },
              others: function(node) {
                return getClusterNodeStrength(node);
              },
              center: function(node, nodes2, edges) {
                var centerNode = centerNodeInfo_1[node[nodeClusterBy]];
                return {
                  x: centerNode === null || centerNode === void 0 ? void 0 : centerNode.x,
                  y: centerNode === null || centerNode === void 0 ? void 0 : centerNode.y
                };
              }
            };
          }
          this.centripetalOptions = __assign18(__assign18({}, this.centripetalOptions), centripetalOptions);
          var _b = this.centripetalOptions, leaf = _b.leaf, single = _b.single, others = _b.others;
          if (leaf && typeof leaf !== "function")
            this.centripetalOptions.leaf = function() {
              return leaf;
            };
          if (single && typeof single !== "function")
            this.centripetalOptions.single = function() {
              return single;
            };
          if (others && typeof others !== "function")
            this.centripetalOptions.others = function() {
              return others;
            };
        };
        Force2Layout3.prototype.updateCfg = function(cfg) {
          if (cfg)
            Object.assign(this, cfg);
        };
        Force2Layout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 500,
            gravity: 10,
            enableTick: true,
            animate: true
          };
        };
        Force2Layout3.prototype.execute = function() {
          var self2 = this;
          self2.stop();
          var nodes = self2.nodes, edges = self2.edges, defSpringLen = self2.defSpringLen;
          self2.judgingDistance = 0;
          if (!nodes || nodes.length === 0) {
            self2.onLayoutEnd([]);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            self2.onLayoutEnd([__assign18({}, nodes[0])]);
            return;
          }
          self2.degreesMap = (0, util_1.getDegreeMap)(nodes, edges);
          if (self2.propsGetMass) {
            self2.getMass = self2.propsGetMass;
          } else {
            self2.getMass = function(d2) {
              var massWeight = 1;
              if ((0, util_1.isNumber)(d2.mass))
                massWeight = d2.mass;
              var degree4 = self2.degreesMap[d2.id].all;
              return !degree4 || degree4 < 5 ? massWeight : degree4 * 5 * massWeight;
            };
          }
          var nodeSize = self2.nodeSize;
          var nodeSizeFunc;
          if (self2.preventOverlap) {
            var nodeSpacing_1 = self2.nodeSpacing;
            var nodeSpacingFunc_1;
            if ((0, util_1.isNumber)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = function() {
                return nodeSpacing_1;
              };
            } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = nodeSpacing_1;
            } else {
              nodeSpacingFunc_1 = function() {
                return 0;
              };
            }
            if (!nodeSize) {
              nodeSizeFunc = function(d2) {
                if (d2.size) {
                  if ((0, util_1.isArray)(d2.size)) {
                    return Math.max(d2.size[0], d2.size[1]) + nodeSpacingFunc_1(d2);
                  } else if ((0, util_1.isObject)(d2.size)) {
                    return Math.max(d2.size.width, d2.size.height) + nodeSpacingFunc_1(d2);
                  }
                  return d2.size + nodeSpacingFunc_1(d2);
                }
                return 10 + nodeSpacingFunc_1(d2);
              };
            } else if ((0, util_1.isArray)(nodeSize)) {
              nodeSizeFunc = function(d2) {
                return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc_1(d2);
              };
            } else {
              nodeSizeFunc = function(d2) {
                return nodeSize + nodeSpacingFunc_1(d2);
              };
            }
          }
          self2.nodeSize = nodeSizeFunc;
          self2.linkDistance = proccessToFunc3(self2.linkDistance, 1);
          self2.nodeStrength = proccessToFunc3(self2.nodeStrength, 1);
          self2.edgeStrength = proccessToFunc3(self2.edgeStrength, 1);
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * self2.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * self2.height;
            var degree4 = self2.degreesMap[node.id];
            nodeMap[node.id] = __assign18(__assign18({}, node), { data: __assign18(__assign18({}, node.data), { size: self2.nodeSize(node) || 30, layout: {
              inDegree: degree4.in,
              outDegree: degree4.out,
              degree: degree4.all,
              tDegree: degree4.in,
              sDegree: degree4.out,
              force: {
                mass: self2.getMass(node),
                nodeStrength: self2.nodeStrength(node, edges)
              }
            } }) });
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          self2.edgeInfos = [];
          edges === null || edges === void 0 ? void 0 : edges.forEach(function(edge) {
            var sourceNode = nodeMap[edge.source];
            var targetNode = nodeMap[edge.target];
            if (!sourceNode || !targetNode) {
              elf.edgeInfos.push({});
            } else {
              self2.edgeInfos.push({
                edgeStrength: self2.edgeStrength(edge),
                linkDistance: defSpringLen ? defSpringLen(__assign18(__assign18({}, edge), { source: sourceNode, target: targetNode }), sourceNode, targetNode) : self2.linkDistance(edge, sourceNode, targetNode) || 1 + (nodeSize(sourceNode) + nodeSize(sourceNode) || 0) / 2
              });
            }
          });
          this.getCentripetalOptions();
          self2.onLayoutEnd = self2.onLayoutEnd || function() {
          };
          self2.run();
        };
        Force2Layout3.prototype.run = function() {
          var self2 = this;
          var maxIteration = self2.maxIteration, nodes = self2.nodes, edges = self2.edges, workerEnabled = self2.workerEnabled, minMovement = self2.minMovement, animate = self2.animate, nodeMap = self2.nodeMap, height = self2.height;
          self2.currentMinY = 0;
          self2.currentMaxY = height;
          if (!nodes)
            return;
          var velArray = [];
          nodes.forEach(function(_2, i3) {
            velArray[2 * i3] = 0;
            velArray[2 * i3 + 1] = 0;
          });
          if (this.defSideCoe && typeof this.defSideCoe === "function") {
            var relatedEdges_1 = {};
            edges.forEach(function(edge) {
              var source = edge.source, target = edge.target;
              relatedEdges_1[source] = relatedEdges_1[source] || [];
              relatedEdges_1[source].push(edge);
              relatedEdges_1[target] = relatedEdges_1[target] || [];
              relatedEdges_1[target].push(edge);
            });
            this.relatedEdges = relatedEdges_1;
          }
          var maxIter = maxIteration;
          var silence = !animate;
          if (workerEnabled || silence) {
            var usedIter = 0;
            for (var i2 = 0; (self2.judgingDistance > minMovement || i2 < 1) && i2 < maxIter; i2++) {
              usedIter = i2;
              self2.runOneStep(i2, velArray);
            }
            self2.onLayoutEnd(Object.values(nodeMap));
          } else {
            if (typeof window === "undefined")
              return;
            var iter_1 = 0;
            this.timeInterval = window.setInterval(function() {
              if (!nodes)
                return;
              self2.runOneStep(iter_1, velArray);
              iter_1++;
              if (iter_1 >= maxIter || self2.judgingDistance < minMovement) {
                self2.onLayoutEnd(Object.values(nodeMap));
                window.clearInterval(self2.timeInterval);
              }
            }, 0);
          }
        };
        Force2Layout3.prototype.runOneStep = function(iter, velArray) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, nodeMap = self2.nodeMap, monitor = self2.monitor;
          var accArray = [];
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          self2.calRepulsive(accArray);
          if (edges)
            self2.calAttractive(accArray);
          self2.calGravity(accArray);
          self2.attractToSide(accArray);
          var stepInterval = self2.interval;
          self2.updateVelocity(accArray, velArray, stepInterval);
          self2.updatePosition(velArray, stepInterval);
          (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          if (monitor) {
            var energy = this.calTotalEnergy(accArray);
            monitor({ energy, nodes, edges, iterations: iter });
          }
        };
        Force2Layout3.prototype.calTotalEnergy = function(accArray) {
          var _a2 = this, nodes = _a2.nodes, nodeMap = _a2.nodeMap;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return 0;
          var energy = 0;
          nodes.forEach(function(node, i2) {
            var vx = accArray[2 * i2];
            var vy = accArray[2 * i2 + 1];
            var speed2 = vx * vx + vy * vy;
            var _a3 = nodeMap[node.id].data.layout.force.mass, mass = _a3 === void 0 ? 1 : _a3;
            energy += mass * speed2 * 0.5;
          });
          return energy;
        };
        Force2Layout3.prototype.calRepulsive = function(accArray) {
          var self2 = this;
          var nodes = self2.nodes, nodeMap = self2.nodeMap, factor = self2.factor, coulombDisScale = self2.coulombDisScale;
          var nodeSize = self2.nodeSize;
          (0, ForceNBody_1.forceNBody)(nodes, nodeMap, factor, coulombDisScale * coulombDisScale, accArray);
        };
        Force2Layout3.prototype.calAttractive = function(accArray) {
          var self2 = this;
          var edges = self2.edges, nodeMap = self2.nodeMap, nodeIdxMap = self2.nodeIdxMap, edgeInfos = self2.edgeInfos;
          var nodeSize = self2.nodeSize;
          edges.forEach(function(edge, i2) {
            var source = (0, util_1.getEdgeTerminal)(edge, "source");
            var target = (0, util_1.getEdgeTerminal)(edge, "target");
            var sourceNode = nodeMap[source];
            var targetNode = nodeMap[target];
            if (!sourceNode || !targetNode)
              return;
            var vecX = targetNode.x - sourceNode.x;
            var vecY = targetNode.y - sourceNode.y;
            if (!vecX && !vecY) {
              vecX = Math.random() * 0.01;
              vecY = Math.random() * 0.01;
            }
            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            var direX = vecX / vecLength;
            var direY = vecY / vecLength;
            var _a2 = edgeInfos[i2] || {}, _b = _a2.linkDistance, linkDistance = _b === void 0 ? 200 : _b, _c = _a2.edgeStrength, edgeStrength = _c === void 0 ? 200 : _c;
            var diff = linkDistance - vecLength;
            var param = diff * edgeStrength;
            var massSource = sourceNode.data.layout.force.mass || 1;
            var massTarget = targetNode.data.layout.force.mass || 1;
            var sourceMassRatio = 1 / massSource;
            var targetMassRatio = 1 / massTarget;
            var disX = direX * param;
            var disY = direY * param;
            var sourceIdx = 2 * nodeIdxMap[source];
            var targetIdx = 2 * nodeIdxMap[target];
            accArray[sourceIdx] -= disX * sourceMassRatio;
            accArray[sourceIdx + 1] -= disY * sourceMassRatio;
            accArray[targetIdx] += disX * targetMassRatio;
            accArray[targetIdx + 1] += disY * targetMassRatio;
          });
        };
        Force2Layout3.prototype.calGravity = function(accArray) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, _b = self2.edges, edges = _b === void 0 ? [] : _b, nodeMap = self2.nodeMap, width = self2.width, height = self2.height, center = self2.center, defaultGravity = self2.gravity, degreesMap = self2.degreesMap, centripetalOptions = self2.centripetalOptions;
          if (!nodes)
            return;
          var nodeLength = nodes.length;
          for (var i2 = 0; i2 < nodeLength; i2++) {
            var idx = 2 * i2;
            var node = nodeMap[nodes[i2].id];
            var _c = node.data.layout.force.mass, mass = _c === void 0 ? 1 : _c;
            var vecX = 0;
            var vecY = 0;
            var gravity = defaultGravity;
            var _d = degreesMap[node.id], inDegree = _d.in, outDegree = _d.out, degree4 = _d.all;
            var forceCenter = (_a2 = self2.getCenter) === null || _a2 === void 0 ? void 0 : _a2.call(self2, node, degree4);
            if (forceCenter) {
              var centerX = forceCenter[0], centerY = forceCenter[1], strength = forceCenter[2];
              vecX = node.x - centerX;
              vecY = node.y - centerY;
              gravity = strength;
            } else {
              vecX = node.x - center[0];
              vecY = node.y - center[1];
            }
            if (gravity) {
              accArray[idx] -= gravity * vecX / mass;
              accArray[idx + 1] -= gravity * vecY / mass;
            }
            if (centripetalOptions) {
              var leaf = centripetalOptions.leaf, single = centripetalOptions.single, others = centripetalOptions.others, centriCenter = centripetalOptions.center;
              var _e2 = (centriCenter === null || centriCenter === void 0 ? void 0 : centriCenter(node, nodes, edges, width, height)) || {
                x: 0,
                y: 0,
                centerStrength: 0
              }, centriX = _e2.x, centriY = _e2.y, centerStrength = _e2.centerStrength;
              if (!(0, util_1.isNumber)(centriX) || !(0, util_1.isNumber)(centriY))
                continue;
              var vx = (node.x - centriX) / mass;
              var vy = (node.y - centriY) / mass;
              if (centerStrength) {
                accArray[idx] -= centerStrength * vx;
                accArray[idx + 1] -= centerStrength * vy;
              }
              if (degree4 === 0) {
                var singleStrength = single(node);
                if (!singleStrength)
                  continue;
                accArray[idx] -= singleStrength * vx;
                accArray[idx + 1] -= singleStrength * vy;
                continue;
              }
              if (inDegree === 0 || outDegree === 0) {
                var leafStrength = leaf(node, nodes, edges);
                if (!leafStrength)
                  continue;
                accArray[idx] -= leafStrength * vx;
                accArray[idx + 1] -= leafStrength * vy;
                continue;
              }
              var othersStrength = others(node);
              if (!othersStrength)
                continue;
              accArray[idx] -= othersStrength * vx;
              accArray[idx + 1] -= othersStrength * vy;
            }
          }
        };
        Force2Layout3.prototype.attractToSide = function(accArray) {
          var _a2 = this, defSideCoe = _a2.defSideCoe, height = _a2.height, nodes = _a2.nodes, relatedEdges = _a2.relatedEdges, _b = _a2.currentMinY, currentMinY = _b === void 0 ? 0 : _b, _c = _a2.currentMaxY, currentMaxY = _c === void 0 ? this.height : _c;
          if (!defSideCoe || typeof defSideCoe !== "function" || !(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          nodes.forEach(function(node, i2) {
            var sideCoe = defSideCoe(node, relatedEdges[node.id] || []);
            if (sideCoe === 0)
              return;
            var targetY = sideCoe < 0 ? currentMinY : currentMaxY;
            var strength = Math.abs(sideCoe);
            accArray[2 * i2 + 1] -= strength * (node.y - targetY);
          });
        };
        Force2Layout3.prototype.updateVelocity = function(accArray, velArray, stepInterval) {
          var self2 = this;
          var nodes = self2.nodes, damping = self2.damping, maxSpeed = self2.maxSpeed;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          nodes.forEach(function(_2, i2) {
            var vx = (velArray[2 * i2] + accArray[2 * i2] * stepInterval) * damping || 0.01;
            var vy = (velArray[2 * i2 + 1] + accArray[2 * i2 + 1] * stepInterval) * damping || 0.01;
            var vLength = Math.sqrt(vx * vx + vy * vy);
            if (vLength > maxSpeed) {
              var param2 = maxSpeed / vLength;
              vx = param2 * vx;
              vy = param2 * vy;
            }
            velArray[2 * i2] = vx;
            velArray[2 * i2 + 1] = vy;
          });
        };
        Force2Layout3.prototype.updatePosition = function(velArray, stepInterval) {
          var self2 = this;
          var nodes = self2.nodes, distanceThresholdMode = self2.distanceThresholdMode, nodeMap = self2.nodeMap;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
            this.judgingDistance = 0;
            return;
          }
          var sum = 0;
          if (distanceThresholdMode === "max")
            self2.judgingDistance = -Infinity;
          else if (distanceThresholdMode === "min")
            self2.judgingDistance = Infinity;
          var currentMinY = Infinity;
          var currentMaxY = -Infinity;
          nodes.forEach(function(node, i2) {
            var mappedNode = nodeMap[node.id];
            if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
              node.x = node.fx;
              node.y = node.fy;
              mappedNode.x = node.x;
              mappedNode.y = node.y;
              return;
            }
            var distX = velArray[2 * i2] * stepInterval;
            var distY = velArray[2 * i2 + 1] * stepInterval;
            node.x += distX;
            node.y += distY;
            mappedNode.x = node.x;
            mappedNode.y = node.y;
            if (node.y < currentMinY)
              currentMinY = node.y;
            if (node.y > currentMaxY)
              currentMaxY = node.y;
            var distanceMagnitude = Math.sqrt(distX * distX + distY * distY);
            switch (distanceThresholdMode) {
              case "max":
                if (self2.judgingDistance < distanceMagnitude)
                  self2.judgingDistance = distanceMagnitude;
                break;
              case "min":
                if (self2.judgingDistance > distanceMagnitude)
                  self2.judgingDistance = distanceMagnitude;
                break;
              default:
                sum = sum + distanceMagnitude;
                break;
            }
          });
          this.currentMinY = currentMinY;
          this.currentMaxY = currentMaxY;
          if (!distanceThresholdMode || distanceThresholdMode === "mean")
            self2.judgingDistance = sum / nodes.length;
        };
        Force2Layout3.prototype.stop = function() {
          if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
          }
        };
        Force2Layout3.prototype.destroy = function() {
          var self2 = this;
          self2.stop();
          self2.tick = null;
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        Force2Layout3.prototype.getType = function() {
          return "force2";
        };
        Force2Layout3.prototype.getSameTypeLeafMap = function() {
          var _a2 = this, nodeClusterBy = _a2.nodeClusterBy, nodes = _a2.nodes, edges = _a2.edges, nodeMap = _a2.nodeMap, degreesMap = _a2.degreesMap;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          var sameTypeLeafMap = {};
          nodes.forEach(function(node, i2) {
            var degree4 = degreesMap[node.id].all;
            if (degree4 === 1) {
              sameTypeLeafMap[node.id] = (0, util_1.getCoreNodeAndRelativeLeafNodes)("leaf", node, edges, nodeClusterBy, degreesMap, nodeMap);
            }
          });
          return sameTypeLeafMap;
        };
        return Force2Layout3;
      }(base_1.Base)
    );
    exports.Force2Layout = Force2Layout2;
  }
});

// node_modules/d3-force/src/center.js
function center_default(x4, y4) {
  var nodes, strength = 1;
  if (x4 == null) x4 = 0;
  if (y4 == null) y4 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n2 - x4) * strength, sy = (sy / n2 - y4) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x4 = +_2, force) : x4;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = +_2, force) : y4;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}
var init_center = __esm({
  "node_modules/d3-force/src/center.js"() {
  }
});

// node_modules/d3-force/src/constant.js
function constant_default2(x4) {
  return function() {
    return x4;
  };
}
var init_constant = __esm({
  "node_modules/d3-force/src/constant.js"() {
  }
});

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random5) {
  return (random5() - 0.5) * 1e-6;
}
var init_jiggle = __esm({
  "node_modules/d3-force/src/jiggle.js"() {
  }
});

// node_modules/d3-force/src/collide.js
function x(d2) {
  return d2.x + d2.vx;
}
function y(d2) {
  return d2.y + d2.vy;
}
function collide_default(radius) {
  var nodes, radii, random5, strength = 1, iterations = 1;
  if (typeof radius !== "function") radius = constant_default2(radius == null ? 1 : +radius);
  function force() {
    var i2, n2 = nodes.length, tree, node, xi2, yi2, ri2, ri22;
    for (var k2 = 0; k2 < iterations; ++k2) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        ri2 = radii[node.index], ri22 = ri2 * ri2;
        xi2 = node.x + node.vx;
        yi2 = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r2 = ri2 + rj;
      if (data) {
        if (data.index > node.index) {
          var x4 = xi2 - data.x - data.vx, y4 = yi2 - data.y - data.vy, l2 = x4 * x4 + y4 * y4;
          if (l2 < r2 * r2) {
            if (x4 === 0) x4 = jiggle_default(random5), l2 += x4 * x4;
            if (y4 === 0) y4 = jiggle_default(random5), l2 += y4 * y4;
            l2 = (r2 - (l2 = Math.sqrt(l2))) / l2 * strength;
            node.vx += (x4 *= l2) * (r2 = (rj *= rj) / (ri22 + rj));
            node.vy += (y4 *= l2) * r2;
            data.vx -= x4 * (r2 = 1 - r2);
            data.vy -= y4 * r2;
          }
        }
        return;
      }
      return x0 > xi2 + r2 || x1 < xi2 - r2 || y0 > yi2 + r2 || y1 < yi2 - r2;
    }
  }
  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i2 = quad.r = 0; i2 < 4; ++i2) {
      if (quad[i2] && quad[i2].r > quad.r) {
        quad.r = quad[i2].r;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node;
    radii = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node = nodes[i2], radii[node.index] = +radius(node, i2, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : radius;
  };
  return force;
}
var init_collide = __esm({
  "node_modules/d3-force/src/collide.js"() {
    init_src2();
    init_constant();
    init_jiggle();
  }
});

// node_modules/d3-force/src/link.js
function index(d2) {
  return d2.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id = index, strength = defaultStrength, strengths, distance11 = constant_default2(30), distances, nodes, count, bias, random5, iterations = 1;
  if (links == null) links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n2 = links.length; k2 < iterations; ++k2) {
      for (var i2 = 0, link, source, target, x4, y4, l2, b10; i2 < n2; ++i2) {
        link = links[i2], source = link.source, target = link.target;
        x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random5);
        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random5);
        l2 = Math.sqrt(x4 * x4 + y4 * y4);
        l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
        x4 *= l2, y4 *= l2;
        target.vx -= x4 * (b10 = bias[i2]);
        target.vy -= y4 * b10;
        source.vx += x4 * (b10 = 1 - b10);
        source.vy += y4 * b10;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d2, i3) => [id(d2, i3, nodes), d2])), link;
    for (i2 = 0, count = new Array(n2); i2 < m3; ++i2) {
      link = links[i2], link.index = i2;
      if (typeof link.source !== "object") link.source = find2(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find2(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m3); i2 < m3; ++i2) {
      link = links[i2], bias[i2] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance11(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id = _2, force) : id;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default2(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance11 = typeof _2 === "function" ? _2 : constant_default2(+_2), initializeDistance(), force) : distance11;
  };
  return force;
}
var init_link = __esm({
  "node_modules/d3-force/src/link.js"() {
    init_constant();
    init_jiggle();
  }
});

// node_modules/d3-dispatch/src/dispatch.js
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t4; i2 < n2; ++i2) {
    if (!(t4 = arguments[i2] + "") || t4 in _2 || /[\s.]/.test(t4)) throw new Error("illegal type: " + t4);
    _2[t4] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i2 = t4.indexOf(".");
    if (i2 >= 0) name = t4.slice(i2 + 1), t4 = t4.slice(0, i2);
    if (t4 && !types.hasOwnProperty(t4)) throw new Error("unknown type: " + t4);
    return { type: t4, name };
  });
}
function get2(type, name) {
  for (var i2 = 0, n2 = type.length, c3; i2 < n2; ++i2) {
    if ((c3 = type[i2]).name === name) {
      return c3.value;
    }
  }
}
function set11(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var noop, dispatch_default;
var init_dispatch = __esm({
  "node_modules/d3-dispatch/src/dispatch.js"() {
    noop = { value: () => {
    } };
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _2 = this._, T2 = parseTypenames(typename + "", _2), t4, i2 = -1, n2 = T2.length;
        if (arguments.length < 2) {
          while (++i2 < n2) if ((t4 = (typename = T2[i2]).type) && (t4 = get2(_2[t4], typename.name))) return t4;
          return;
        }
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i2 < n2) {
          if (t4 = (typename = T2[i2]).type) _2[t4] = set11(_2[t4], typename.name, callback);
          else if (callback == null) for (t4 in _2) _2[t4] = set11(_2[t4], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy10 = {}, _2 = this._;
        for (var t4 in _2) copy10[t4] = _2[t4].slice();
        return new Dispatch(copy10);
      },
      call: function(type, that) {
        if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t4; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t4 = this._[type], i2 = 0, n2 = t4.length; i2 < n2; ++i2) t4[i2].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t4 = this._[type], i2 = 0, n2 = t4.length; i2 < n2; ++i2) t4[i2].value.apply(that, args);
      }
    };
    dispatch_default = dispatch;
  }
});

// node_modules/d3-dispatch/src/index.js
var init_src3 = __esm({
  "node_modules/d3-dispatch/src/index.js"() {
    init_dispatch();
  }
});

// node_modules/d3-force/src/lcg.js
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a * s2 + c) % m) / m;
}
var a, c, m;
var init_lcg = __esm({
  "node_modules/d3-force/src/lcg.js"() {
    a = 1664525;
    c = 1013904223;
    m = 4294967296;
  }
});

// node_modules/d3-force/src/simulation.js
function x2(d2) {
  return d2.x;
}
function y2(d2) {
  return d2.y;
}
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random5 = lcg_default();
  if (nodes == null) nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0) iterations = 1;
    for (var k2 = 0; k2 < iterations; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i2), angle3 = i2 * initialAngle;
        node.x = radius * Math.cos(angle3);
        node.y = radius * Math.sin(angle3);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random5);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random5 = _2, forces.forEach(initializeForce), simulation) : random5;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function(x4, y4, radius) {
      var i2 = 0, n2 = nodes.length, dx, dy, d2, node, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x4 - node.x;
        dy = y4 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}
var initialRadius, initialAngle;
var init_simulation = __esm({
  "node_modules/d3-force/src/simulation.js"() {
    init_src3();
    init_src();
    init_lcg();
    initialRadius = 10;
    initialAngle = Math.PI * (3 - Math.sqrt(5));
  }
});

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random5, alpha, strength = constant_default2(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _2, i2 = 0; i2 < n2; ++i2) node = nodes[i2], tree.visit(apply);
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q2, c3, weight = 0, x4, y4, i2;
    if (quad.length) {
      for (x4 = y4 = i2 = 0; i2 < 4; ++i2) {
        if ((q2 = quad[i2]) && (c3 = Math.abs(q2.value))) {
          strength2 += q2.value, weight += c3, x4 += c3 * q2.x, y4 += c3 * q2.y;
        }
      }
      quad.x = x4 / weight;
      quad.y = y4 / weight;
    } else {
      q2 = quad;
      q2.x = q2.data.x;
      q2.y = q2.data.y;
      do
        strength2 += strengths[q2.data.index];
      while (q2 = q2.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x1, _2, x22) {
    if (!quad.value) return true;
    var x4 = quad.x - node.x, y4 = quad.y - node.y, w2 = x22 - x1, l2 = x4 * x4 + y4 * y4;
    if (w2 * w2 / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x4 === 0) x4 = jiggle_default(random5), l2 += x4 * x4;
        if (y4 === 0) y4 = jiggle_default(random5), l2 += y4 * y4;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x4 * quad.value * alpha / l2;
        node.vy += y4 * quad.value * alpha / l2;
      }
      return true;
    } else if (quad.length || l2 >= distanceMax2) return;
    if (quad.data !== node || quad.next) {
      if (x4 === 0) x4 = jiggle_default(random5), l2 += x4 * x4;
      if (y4 === 0) y4 = jiggle_default(random5), l2 += y4 * y4;
      if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (quad.data !== node) {
        w2 = strengths[quad.data.index] * alpha / l2;
        node.vx += x4 * w2;
        node.vy += y4 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}
var init_manyBody = __esm({
  "node_modules/d3-force/src/manyBody.js"() {
    init_src2();
    init_constant();
    init_jiggle();
    init_simulation();
  }
});

// node_modules/d3-force/src/radial.js
function radial_default(radius, x4, y4) {
  var nodes, strength = constant_default2(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant_default2(+radius);
  if (x4 == null) x4 = 0;
  if (y4 == null) y4 = 0;
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      var node = nodes[i2], dx = node.x - x4 || 1e-6, dy = node.y - y4 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
      node.vx += dx * k2;
      node.vy += dy * k2;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    radiuses = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2, initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x4 = +_2, force) : x4;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = +_2, force) : y4;
  };
  return force;
}
var init_radial = __esm({
  "node_modules/d3-force/src/radial.js"() {
    init_constant();
  }
});

// node_modules/d3-force/src/x.js
function x_default2(x4) {
  var strength = constant_default2(0.1), nodes, strengths, xz;
  if (typeof x4 !== "function") x4 = constant_default2(x4 == null ? 0 : +x4);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vx += (xz[i2] - node.x) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    xz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(xz[i2] = +x4(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x4 = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : x4;
  };
  return force;
}
var init_x2 = __esm({
  "node_modules/d3-force/src/x.js"() {
    init_constant();
  }
});

// node_modules/d3-force/src/y.js
function y_default2(y4) {
  var strength = constant_default2(0.1), nodes, strengths, yz;
  if (typeof y4 !== "function") y4 = constant_default2(y4 == null ? 0 : +y4);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vy += (yz[i2] - node.y) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    yz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(yz[i2] = +y4(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default2(+_2), initialize(), force) : y4;
  };
  return force;
}
var init_y2 = __esm({
  "node_modules/d3-force/src/y.js"() {
    init_constant();
  }
});

// node_modules/d3-force/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  forceCenter: () => center_default,
  forceCollide: () => collide_default,
  forceLink: () => link_default,
  forceManyBody: () => manyBody_default,
  forceRadial: () => radial_default,
  forceSimulation: () => simulation_default,
  forceX: () => x_default2,
  forceY: () => y_default2
});
var init_src4 = __esm({
  "node_modules/d3-force/src/index.js"() {
    init_center();
    init_collide();
    init_link();
    init_manyBody();
    init_radial();
    init_simulation();
    init_x2();
    init_y2();
  }
});

// node_modules/@antv/layout/lib/layout/force/force-in-a-box.js
var require_force_in_a_box = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/force-in-a-box.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k2 in mod4) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod4, k2)) __createBinding2(result, mod4, k2);
      }
      __setModuleDefault2(result, mod4);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3Force = __importStar2((init_src4(), __toCommonJS(src_exports4)));
    var util_1 = require_util2();
    function forceInABox() {
      function constant(_2) {
        return function() {
          return _2;
        };
      }
      var groupBy3 = function(d2) {
        return d2.cluster;
      };
      var forceNodeSize = constant(1);
      var forceCharge = constant(-1);
      var forceLinkDistance = constant(100);
      var forceLinkStrength = constant(0.1);
      var offset = [0, 0];
      var nodes = [];
      var nodesMap = {};
      var links = [];
      var centerX = 100;
      var centerY = 100;
      var foci = {
        none: {
          x: 0,
          y: 0
        }
      };
      var templateNodes = [];
      var templateForce;
      var template = "force";
      var enableGrouping = true;
      var strength = 0.1;
      function force(alpha) {
        if (!enableGrouping) {
          return force;
        }
        templateForce.tick();
        getFocisFromTemplate();
        for (var i2 = 0, n2 = nodes.length, node = void 0, k2 = alpha * strength; i2 < n2; ++i2) {
          node = nodes[i2];
          node.vx += (foci[groupBy3(node)].x - node.x) * k2;
          node.vy += (foci[groupBy3(node)].y - node.y) * k2;
        }
      }
      function initialize() {
        if (!nodes)
          return;
        initializeWithForce();
      }
      function initializeWithForce() {
        if (!nodes || !nodes.length) {
          return;
        }
        if (groupBy3(nodes[0]) === void 0) {
          throw Error("Couldnt find the grouping attribute for the nodes. Make sure to set it up with forceInABox.groupBy('clusterAttr') before calling .links()");
        }
        var net = getGroupsGraph();
        templateForce = d3Force.forceSimulation(net.nodes).force("x", d3Force.forceX(centerX).strength(0.1)).force("y", d3Force.forceY(centerY).strength(0.1)).force("collide", d3Force.forceCollide(function(d2) {
          return d2.r;
        }).iterations(4)).force("charge", d3Force.forceManyBody().strength(forceCharge)).force("links", d3Force.forceLink(net.nodes.length ? net.links : []).distance(forceLinkDistance).strength(forceLinkStrength));
        templateNodes = templateForce.nodes();
        getFocisFromTemplate();
      }
      function getGroupsGraph() {
        var gnodes = [];
        var glinks = [];
        var dNodes = {};
        var clustersList = [];
        var clustersCounts = {};
        var clustersLinks = [];
        clustersCounts = computeClustersNodeCounts(nodes);
        clustersLinks = computeClustersLinkCounts(links);
        clustersList = Object.keys(clustersCounts);
        clustersList.forEach(function(key, index2) {
          var val = clustersCounts[key];
          gnodes.push({
            id: key,
            size: val.count,
            r: Math.sqrt(val.sumforceNodeSize / Math.PI)
          });
          dNodes[key] = index2;
        });
        clustersLinks.forEach(function(l2) {
          var sourceTerminal = (0, util_1.getEdgeTerminal)(l2, "source");
          var targetTerminal = (0, util_1.getEdgeTerminal)(l2, "target");
          var source = dNodes[sourceTerminal];
          var target = dNodes[targetTerminal];
          if (source !== void 0 && target !== void 0) {
            glinks.push({
              source,
              target,
              count: l2.count
            });
          }
        });
        return {
          nodes: gnodes,
          links: glinks
        };
      }
      function computeClustersNodeCounts(nodes2) {
        var clustersCounts = {};
        nodes2.forEach(function(d2) {
          var key = groupBy3(d2);
          if (!clustersCounts[key]) {
            clustersCounts[key] = {
              count: 0,
              sumforceNodeSize: 0
            };
          }
        });
        nodes2.forEach(function(d2) {
          var key = groupBy3(d2);
          var nodeSize = forceNodeSize(d2);
          var tmpCount = clustersCounts[key];
          tmpCount.count = tmpCount.count + 1;
          tmpCount.sumforceNodeSize = tmpCount.sumforceNodeSize + Math.PI * (nodeSize * nodeSize) * 1.3;
          clustersCounts[key] = tmpCount;
        });
        return clustersCounts;
      }
      function computeClustersLinkCounts(links2) {
        var dClusterLinks = {};
        var clusterLinks = [];
        links2.forEach(function(l2) {
          var key = getLinkKey(l2);
          var count = 0;
          if (dClusterLinks[key] !== void 0) {
            count = dClusterLinks[key];
          }
          count += 1;
          dClusterLinks[key] = count;
        });
        var entries = Object.entries(dClusterLinks);
        entries.forEach(function(_a2) {
          var key = _a2[0], count = _a2[1];
          var source = key.split("~")[0];
          var target = key.split("~")[1];
          if (source !== void 0 && target !== void 0) {
            clusterLinks.push({
              source,
              target,
              count
            });
          }
        });
        return clusterLinks;
      }
      function getFocisFromTemplate() {
        foci = {
          none: {
            x: 0,
            y: 0
          }
        };
        templateNodes.forEach(function(d2) {
          foci[d2.id] = {
            x: d2.x - offset[0],
            y: d2.y - offset[1]
          };
        });
        return foci;
      }
      function getLinkKey(l2) {
        var source = (0, util_1.getEdgeTerminal)(l2, "source");
        var target = (0, util_1.getEdgeTerminal)(l2, "target");
        var sourceID = groupBy3(nodesMap[source]);
        var targetID = groupBy3(nodesMap[target]);
        return sourceID <= targetID ? "".concat(sourceID, "~").concat(targetID) : "".concat(targetID, "~").concat(sourceID);
      }
      function genNodesMap(nodes2) {
        nodesMap = {};
        nodes2.forEach(function(node) {
          nodesMap[node.id] = node;
        });
      }
      function setTemplate(x4) {
        if (!arguments.length)
          return template;
        template = x4;
        initialize();
        return force;
      }
      function setGroupBy(x4) {
        if (!arguments.length)
          return groupBy3;
        if (typeof x4 === "string") {
          groupBy3 = function(d2) {
            return d2[x4];
          };
          return force;
        }
        groupBy3 = x4;
        return force;
      }
      function setEnableGrouping(x4) {
        if (!arguments.length)
          return enableGrouping;
        enableGrouping = x4;
        return force;
      }
      function setStrength(x4) {
        if (!arguments.length)
          return strength;
        strength = x4;
        return force;
      }
      function setCenterX(_2) {
        if (arguments.length) {
          centerX = _2;
          return force;
        }
        return centerX;
      }
      function setCenterY(_2) {
        if (arguments.length) {
          centerY = _2;
          return force;
        }
        return centerY;
      }
      function setNodes(_2) {
        if (arguments.length) {
          genNodesMap(_2 || []);
          nodes = _2 || [];
          return force;
        }
        return nodes;
      }
      function setLinks(_2) {
        if (arguments.length) {
          links = _2 || [];
          initialize();
          return force;
        }
        return links;
      }
      function setForceNodeSize(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceNodeSize = _2;
          } else {
            forceNodeSize = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceNodeSize;
      }
      function setForceCharge(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceCharge = _2;
          } else {
            forceCharge = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceCharge;
      }
      function setForceLinkDistance(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceLinkDistance = _2;
          } else {
            forceLinkDistance = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceLinkDistance;
      }
      function setForceLinkStrength(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceLinkStrength = _2;
          } else {
            forceLinkStrength = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceLinkStrength;
      }
      function setOffset(_2) {
        if (arguments.length) {
          offset = _2;
          return force;
        }
        return offset;
      }
      force.initialize = function(_2) {
        nodes = _2;
        initialize();
      };
      force.template = setTemplate;
      force.groupBy = setGroupBy;
      force.enableGrouping = setEnableGrouping;
      force.strength = setStrength;
      force.centerX = setCenterX;
      force.centerY = setCenterY;
      force.nodes = setNodes;
      force.links = setLinks;
      force.forceNodeSize = setForceNodeSize;
      force.nodeSize = force.forceNodeSize;
      force.forceCharge = setForceCharge;
      force.forceLinkDistance = setForceLinkDistance;
      force.forceLinkStrength = setForceLinkStrength;
      force.offset = setOffset;
      force.getFocis = getFocisFromTemplate;
      return force;
    }
    exports.default = forceInABox;
  }
});

// node_modules/@antv/layout/lib/layout/constants.js
var require_constants = __commonJS({
  "node_modules/@antv/layout/lib/layout/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FORCE_LAYOUT_TYPE_MAP = exports.LAYOUT_MESSAGE = void 0;
    exports.LAYOUT_MESSAGE = {
      // run layout
      RUN: "LAYOUT_RUN",
      // layout ended with success
      END: "LAYOUT_END",
      // layout error
      ERROR: "LAYOUT_ERROR",
      // layout tick, used in force directed layout
      TICK: "LAYOUT_TICK",
      GPURUN: "GPU_LAYOUT_RUN",
      GPUEND: "GPU_LAYOUT_END"
    };
    exports.FORCE_LAYOUT_TYPE_MAP = {
      "gForce": true,
      "force2": true,
      "fruchterman": true,
      "forceAtlas2": true,
      "force": true,
      "graphin-force": true
    };
  }
});

// node_modules/@antv/layout/lib/layout/force/force.js
var require_force = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/force.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k2 in mod4) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod4, k2)) __createBinding2(result, mod4, k2);
      }
      __setModuleDefault2(result, mod4);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForceLayout = void 0;
    var d3Force = __importStar2((init_src4(), __toCommonJS(src_exports4)));
    var force_in_a_box_1 = __importDefault2(require_force_in_a_box());
    var util_1 = require_util2();
    var base_1 = require_base();
    var constants_1 = require_constants();
    var ForceLayout2 = (
      /** @class */
      function(_super) {
        __extends17(ForceLayout3, _super);
        function ForceLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.nodeStrength = null;
          _this.edgeStrength = null;
          _this.preventOverlap = false;
          _this.clusterNodeStrength = null;
          _this.clusterEdgeStrength = null;
          _this.clusterEdgeDistance = null;
          _this.clusterNodeSize = null;
          _this.clusterFociStrength = null;
          _this.linkDistance = 50;
          _this.alphaDecay = 0.028;
          _this.alphaMin = 1e-3;
          _this.alpha = 0.3;
          _this.collideStrength = 1;
          _this.workerEnabled = false;
          _this.tick = function() {
          };
          _this.onLayoutEnd = function() {
          };
          _this.ticking = void 0;
          if (options) {
            _this.updateCfg(options);
          }
          return _this;
        }
        ForceLayout3.prototype.getDefaultCfg = function() {
          return {
            center: [0, 0],
            nodeStrength: null,
            edgeStrength: null,
            preventOverlap: false,
            nodeSize: void 0,
            nodeSpacing: void 0,
            linkDistance: 50,
            forceSimulation: null,
            alphaDecay: 0.028,
            alphaMin: 1e-3,
            alpha: 0.3,
            collideStrength: 1,
            clustering: false,
            clusterNodeStrength: -1,
            clusterEdgeStrength: 0.1,
            clusterEdgeDistance: 100,
            clusterFociStrength: 0.8,
            clusterNodeSize: 10,
            tick: function() {
            },
            onLayoutEnd: function() {
            },
            // 是否启用web worker。前提是在web worker里执行布局，否则无效
            workerEnabled: false
          };
        };
        ForceLayout3.prototype.init = function(data) {
          var self2 = this;
          self2.nodes = data.nodes || [];
          var edges = data.edges || [];
          self2.edges = edges.map(function(edge) {
            var res = {};
            var expectKeys = ["targetNode", "sourceNode", "startPoint", "endPoint"];
            Object.keys(edge).forEach(function(key) {
              if (!(expectKeys.indexOf(key) > -1)) {
                res[key] = edge[key];
              }
            });
            return res;
          });
          self2.ticking = false;
        };
        ForceLayout3.prototype.execute = function(reloadData) {
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges;
          if (self2.ticking) {
            return;
          }
          var simulation = self2.forceSimulation;
          var alphaMin = self2.alphaMin;
          var alphaDecay = self2.alphaDecay;
          var alpha = self2.alpha;
          if (!simulation) {
            try {
              var nodeForce = d3Force.forceManyBody();
              if (self2.nodeStrength) {
                nodeForce.strength(self2.nodeStrength);
              }
              simulation = d3Force.forceSimulation().nodes(nodes);
              if (self2.clustering) {
                var clusterForce = (0, force_in_a_box_1.default)();
                clusterForce.centerX(self2.center[0]).centerY(self2.center[1]).template("force").strength(self2.clusterFociStrength);
                if (edges) {
                  clusterForce.links(edges);
                }
                if (nodes) {
                  clusterForce.nodes(nodes);
                }
                clusterForce.forceLinkDistance(self2.clusterEdgeDistance).forceLinkStrength(self2.clusterEdgeStrength).forceCharge(self2.clusterNodeStrength).forceNodeSize(self2.clusterNodeSize);
                self2.clusterForce = clusterForce;
                simulation.force("group", clusterForce);
              }
              simulation.force("center", d3Force.forceCenter(self2.center[0], self2.center[1])).force("charge", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);
              if (self2.preventOverlap) {
                self2.overlapProcess(simulation);
              }
              if (edges) {
                var edgeForce = d3Force.forceLink().id(function(d2) {
                  return d2.id;
                }).links(edges);
                if (self2.edgeStrength) {
                  edgeForce.strength(self2.edgeStrength);
                }
                if (self2.linkDistance) {
                  edgeForce.distance(self2.linkDistance);
                }
                self2.edgeForce = edgeForce;
                simulation.force("link", edgeForce);
              }
              if (self2.workerEnabled && !isInWorker()) {
                self2.workerEnabled = false;
                console.warn("workerEnabled option is only supported when running in web worker.");
              }
              if (!self2.workerEnabled) {
                simulation.on("tick", function() {
                  self2.tick();
                }).on("end", function() {
                  self2.ticking = false;
                  if (self2.onLayoutEnd)
                    self2.onLayoutEnd();
                });
                self2.ticking = true;
              } else {
                simulation.stop();
                var totalTicks = getSimulationTicks(simulation);
                for (var currentTick = 1; currentTick <= totalTicks; currentTick++) {
                  simulation.tick();
                  postMessage({
                    nodes,
                    currentTick,
                    totalTicks,
                    type: constants_1.LAYOUT_MESSAGE.TICK
                  }, void 0);
                }
                self2.ticking = false;
              }
              self2.forceSimulation = simulation;
              self2.ticking = true;
            } catch (e8) {
              self2.ticking = false;
              console.warn(e8);
            }
          } else {
            if (reloadData) {
              if (self2.clustering && self2.clusterForce) {
                self2.clusterForce.nodes(nodes);
                self2.clusterForce.links(edges);
              }
              simulation.nodes(nodes);
              if (edges && self2.edgeForce)
                self2.edgeForce.links(edges);
              else if (edges && !self2.edgeForce) {
                var edgeForce = d3Force.forceLink().id(function(d2) {
                  return d2.id;
                }).links(edges);
                if (self2.edgeStrength) {
                  edgeForce.strength(self2.edgeStrength);
                }
                if (self2.linkDistance) {
                  edgeForce.distance(self2.linkDistance);
                }
                self2.edgeForce = edgeForce;
                simulation.force("link", edgeForce);
              }
            }
            if (self2.preventOverlap) {
              self2.overlapProcess(simulation);
            }
            simulation.alpha(alpha).restart();
            this.ticking = true;
          }
        };
        ForceLayout3.prototype.overlapProcess = function(simulation) {
          var self2 = this;
          var nodeSize = self2.nodeSize;
          var nodeSpacing = self2.nodeSpacing;
          var nodeSizeFunc;
          var nodeSpacingFunc;
          var collideStrength = self2.collideStrength;
          if ((0, util_1.isNumber)(nodeSpacing)) {
            nodeSpacingFunc = function() {
              return nodeSpacing;
            };
          } else if ((0, util_1.isFunction)(nodeSpacing)) {
            nodeSpacingFunc = nodeSpacing;
          } else {
            nodeSpacingFunc = function() {
              return 0;
            };
          }
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                  return res / 2 + nodeSpacingFunc(d2);
                }
                if ((0, util_1.isObject)(d2.size)) {
                  var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                  return res / 2 + nodeSpacingFunc(d2);
                }
                return d2.size / 2 + nodeSpacingFunc(d2);
              }
              return 10 + nodeSpacingFunc(d2);
            };
          } else if ((0, util_1.isFunction)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              var size3 = nodeSize(d2);
              return size3 + nodeSpacingFunc(d2);
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            var radius_1 = larger / 2;
            nodeSizeFunc = function(d2) {
              return radius_1 + nodeSpacingFunc(d2);
            };
          } else if ((0, util_1.isNumber)(nodeSize)) {
            var radius_2 = nodeSize / 2;
            nodeSizeFunc = function(d2) {
              return radius_2 + nodeSpacingFunc(d2);
            };
          } else {
            nodeSizeFunc = function() {
              return 10;
            };
          }
          simulation.force("collisionForce", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));
        };
        ForceLayout3.prototype.updateCfg = function(cfg) {
          var self2 = this;
          if (self2.ticking) {
            self2.forceSimulation.stop();
            self2.ticking = false;
          }
          self2.forceSimulation = null;
          Object.assign(self2, cfg);
        };
        ForceLayout3.prototype.destroy = function() {
          var self2 = this;
          if (self2.ticking) {
            self2.forceSimulation.stop();
            self2.ticking = false;
          }
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        return ForceLayout3;
      }(base_1.Base)
    );
    exports.ForceLayout = ForceLayout2;
    function getSimulationTicks(simulation) {
      var alphaMin = simulation.alphaMin();
      var alphaTarget = simulation.alphaTarget();
      var alpha = simulation.alpha();
      var totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());
      var totalTicks = Math.ceil(totalTicksFloat);
      return totalTicks;
    }
    function isInWorker() {
      return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    }
  }
});

// node_modules/@antv/layout/lib/layout/force/index.js
var require_force3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding2(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_force(), exports);
  }
});

// node_modules/@antv/layout/lib/layout/circular.js
var require_circular = __commonJS({
  "node_modules/@antv/layout/lib/layout/circular.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    function initHierarchy(nodes, edges, nodeMap, directed) {
      nodes.forEach(function(_2, i2) {
        nodes[i2].children = [];
        nodes[i2].parent = [];
      });
      if (directed) {
        edges.forEach(function(e8) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          var sourceIdx = 0;
          if (source) {
            sourceIdx = nodeMap[source];
          }
          var targetIdx = 0;
          if (target) {
            targetIdx = nodeMap[target];
          }
          var child = nodes[sourceIdx].children;
          var parent = nodes[targetIdx].parent;
          child.push(nodes[targetIdx].id);
          parent.push(nodes[sourceIdx].id);
        });
      } else {
        edges.forEach(function(e8) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          var sourceIdx = 0;
          if (source) {
            sourceIdx = nodeMap[source];
          }
          var targetIdx = 0;
          if (target) {
            targetIdx = nodeMap[target];
          }
          var sourceChildren = nodes[sourceIdx].children;
          var targetChildren = nodes[targetIdx].children;
          sourceChildren.push(nodes[targetIdx].id);
          targetChildren.push(nodes[sourceIdx].id);
        });
      }
    }
    function connect(a3, b10, edges) {
      var m3 = edges.length;
      for (var i2 = 0; i2 < m3; i2++) {
        var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
        var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
        if (a3.id === source && b10.id === target || b10.id === source && a3.id === target) {
          return true;
        }
      }
      return false;
    }
    function compareDegree(a3, b10) {
      var aDegree = a3.degree;
      var bDegree = b10.degree;
      if (aDegree < bDegree) {
        return -1;
      }
      if (aDegree > bDegree) {
        return 1;
      }
      return 0;
    }
    var CircularLayout2 = (
      /** @class */
      function(_super) {
        __extends17(CircularLayout3, _super);
        function CircularLayout3(options) {
          var _this = _super.call(this) || this;
          _this.radius = null;
          _this.nodeSize = void 0;
          _this.startRadius = null;
          _this.endRadius = null;
          _this.startAngle = 0;
          _this.endAngle = 2 * Math.PI;
          _this.clockwise = true;
          _this.divisions = 1;
          _this.ordering = null;
          _this.angleRatio = 1;
          _this.nodes = [];
          _this.edges = [];
          _this.nodeMap = {};
          _this.degrees = [];
          _this.width = 300;
          _this.height = 300;
          _this.updateCfg(options);
          return _this;
        }
        CircularLayout3.prototype.getDefaultCfg = function() {
          return {
            radius: null,
            startRadius: null,
            endRadius: null,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            clockwise: true,
            divisions: 1,
            ordering: null,
            angleRatio: 1
          };
        };
        CircularLayout3.prototype.execute = function() {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges;
          var n2 = nodes.length;
          if (n2 === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (n2 === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          var radius = self2.radius, startRadius = self2.startRadius, endRadius = self2.endRadius;
          var divisions = self2.divisions, startAngle = self2.startAngle, endAngle = self2.endAngle, angleRatio = self2.angleRatio, ordering = self2.ordering, clockwise = self2.clockwise, paramNodeSpacing = self2.nodeSpacing, paramNodeSize = self2.nodeSize;
          var angleStep = (endAngle - startAngle) / n2;
          var nodeMap = {};
          nodes.forEach(function(node, i3) {
            nodeMap[node.id] = i3;
          });
          self2.nodeMap = nodeMap;
          var degrees3 = (0, util_1.getDegree)(nodes.length, nodeMap, edges);
          self2.degrees = degrees3;
          if (paramNodeSpacing) {
            var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);
            var nodeSize_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSize);
            var maxNodeSize_1 = -Infinity;
            nodes.forEach(function(node) {
              var nSize = nodeSize_1(node);
              if (maxNodeSize_1 < nSize)
                maxNodeSize_1 = nSize;
            });
            var length_1 = 0;
            nodes.forEach(function(node, i3) {
              if (i3 === 0)
                length_1 += maxNodeSize_1 || 10;
              else
                length_1 += (nodeSpacing_1(node) || 0) + (maxNodeSize_1 || 10);
            });
            radius = length_1 / (2 * Math.PI);
          } else if (!radius && !startRadius && !endRadius) {
            radius = self2.height > self2.width ? self2.width / 2 : self2.height / 2;
          } else if (!startRadius && endRadius) {
            startRadius = endRadius;
          } else if (startRadius && !endRadius) {
            endRadius = startRadius;
          }
          var astep = angleStep * angleRatio;
          var layoutNodes = [];
          if (ordering === "topology") {
            layoutNodes = self2.topologyOrdering();
          } else if (ordering === "topology-directed") {
            layoutNodes = self2.topologyOrdering(true);
          } else if (ordering === "degree") {
            layoutNodes = self2.degreeOrdering();
          } else {
            layoutNodes = nodes;
          }
          var divN = Math.ceil(n2 / divisions);
          for (var i2 = 0; i2 < n2; ++i2) {
            var r2 = radius;
            if (!r2 && startRadius !== null && endRadius !== null) {
              r2 = startRadius + i2 * (endRadius - startRadius) / (n2 - 1);
            }
            if (!r2) {
              r2 = 10 + i2 * 100 / (n2 - 1);
            }
            var angle3 = startAngle + i2 % divN * astep + 2 * Math.PI / divisions * Math.floor(i2 / divN);
            if (!clockwise) {
              angle3 = endAngle - i2 % divN * astep - 2 * Math.PI / divisions * Math.floor(i2 / divN);
            }
            layoutNodes[i2].x = center[0] + Math.cos(angle3) * r2;
            layoutNodes[i2].y = center[1] + Math.sin(angle3) * r2;
            layoutNodes[i2].weight = degrees3[i2].all;
          }
          (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          return {
            nodes: layoutNodes,
            edges: this.edges
          };
        };
        CircularLayout3.prototype.topologyOrdering = function(directed) {
          if (directed === void 0) {
            directed = false;
          }
          var self2 = this;
          var degrees3 = self2.degrees;
          var edges = self2.edges;
          var nodes = self2.nodes;
          var cnodes = (0, util_1.clone)(nodes);
          var nodeMap = self2.nodeMap;
          var orderedCNodes = [cnodes[0]];
          var resNodes = [nodes[0]];
          var pickFlags = [];
          var n2 = nodes.length;
          pickFlags[0] = true;
          initHierarchy(cnodes, edges, nodeMap, directed);
          var k2 = 0;
          cnodes.forEach(function(cnode, i2) {
            if (i2 !== 0) {
              if ((i2 === n2 - 1 || degrees3[i2].all !== degrees3[i2 + 1].all || connect(orderedCNodes[k2], cnode, edges)) && !pickFlags[i2]) {
                orderedCNodes.push(cnode);
                resNodes.push(nodes[nodeMap[cnode.id]]);
                pickFlags[i2] = true;
                k2++;
              } else {
                var children = orderedCNodes[k2].children;
                var foundChild = false;
                for (var j2 = 0; j2 < children.length; j2++) {
                  var childIdx = nodeMap[children[j2]];
                  if (degrees3[childIdx].all === degrees3[i2].all && !pickFlags[childIdx]) {
                    orderedCNodes.push(cnodes[childIdx]);
                    resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);
                    pickFlags[childIdx] = true;
                    foundChild = true;
                    break;
                  }
                }
                var ii2 = 0;
                while (!foundChild) {
                  if (!pickFlags[ii2]) {
                    orderedCNodes.push(cnodes[ii2]);
                    resNodes.push(nodes[nodeMap[cnodes[ii2].id]]);
                    pickFlags[ii2] = true;
                    foundChild = true;
                  }
                  ii2++;
                  if (ii2 === n2) {
                    break;
                  }
                }
              }
            }
          });
          return resNodes;
        };
        CircularLayout3.prototype.degreeOrdering = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var orderedNodes = [];
          var degrees3 = self2.degrees;
          nodes.forEach(function(node, i2) {
            node.degree = degrees3[i2].all;
            orderedNodes.push(node);
          });
          orderedNodes.sort(compareDegree);
          return orderedNodes;
        };
        CircularLayout3.prototype.getType = function() {
          return "circular";
        };
        return CircularLayout3;
      }(base_1.Base)
    );
    exports.CircularLayout = CircularLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/data/list.js
var require_list = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/data/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var filterOutLinks = function(k2, v2) {
      if (k2 !== "next" && k2 !== "prev") {
        return v2;
      }
    };
    var unlink = function(entry) {
      entry.prev.next = entry.next;
      entry.next.prev = entry.prev;
      delete entry.next;
      delete entry.prev;
    };
    var List = (
      /** @class */
      function() {
        function List2() {
          var shortcut = {};
          shortcut.prev = shortcut;
          shortcut.next = shortcut.prev;
          this.shortcut = shortcut;
        }
        List2.prototype.dequeue = function() {
          var shortcut = this.shortcut;
          var entry = shortcut.prev;
          if (entry && entry !== shortcut) {
            unlink(entry);
            return entry;
          }
        };
        List2.prototype.enqueue = function(entry) {
          var shortcut = this.shortcut;
          if (entry.prev && entry.next) {
            unlink(entry);
          }
          entry.next = shortcut.next;
          shortcut.next.prev = entry;
          shortcut.next = entry;
          entry.prev = shortcut;
        };
        List2.prototype.toString = function() {
          var strs = [];
          var sentinel = this.shortcut;
          var curr = sentinel.prev;
          while (curr !== sentinel) {
            strs.push(JSON.stringify(curr, filterOutLinks));
            curr = curr === null || curr === void 0 ? void 0 : curr.prev;
          }
          return "[".concat(strs.join(", "), "]");
        };
        return List2;
      }()
    );
    exports.default = List;
  }
});

// node_modules/@antv/graphlib/es/Graph/enum.js
var GraphEnum;
var init_enum = __esm({
  "node_modules/@antv/graphlib/es/Graph/enum.js"() {
    (function(GraphEnum2) {
      GraphEnum2["DEFAULT_EDGE_NAME"] = "\0";
      GraphEnum2["GRAPH_NODE"] = "\0";
      GraphEnum2["EDGE_KEY_DELIM"] = "";
    })(GraphEnum || (GraphEnum = {}));
  }
});

// node_modules/@antv/graphlib/es/util.js
function incrementOrInitEntry(map6, key) {
  var val = map6.get(key) || 0;
  map6.set(key, val + 1);
}
function decrementOrRemoveEntry(map6, key) {
  var val = map6.get(key);
  if (val !== void 0) {
    val = val - 1;
    if (val > 0) {
      map6.set(key, val);
    } else {
      map6.delete(key);
    }
  }
}
function edgeArgsToId(isDirected, v_, w_, name) {
  var v2 = String(v_);
  var w2 = String(w_);
  if (!isDirected && v2 > w2) {
    var tmp = v2;
    v2 = w2;
    w2 = tmp;
  }
  return v2 + GraphEnum.EDGE_KEY_DELIM + w2 + GraphEnum.EDGE_KEY_DELIM + (name === void 0 ? GraphEnum.DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v2, w2, name) {
  var strV = String(v2);
  var strW = String(w2);
  var edgeObj = {
    v: v2,
    w: w2
  };
  if (!isDirected && strV > strW) {
    var tmp = edgeObj.v;
    edgeObj.v = edgeObj.w;
    edgeObj.w = tmp;
  }
  if (name !== void 0) {
    edgeObj.name = name;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
function isFunction(obj) {
  return typeof obj === "function";
}
var init_util = __esm({
  "node_modules/@antv/graphlib/es/util.js"() {
    init_enum();
  }
});

// node_modules/@antv/graphlib/es/Graph/toJSON.js
var nodeToJSON, edgeToJSON, write, read;
var init_toJSON = __esm({
  "node_modules/@antv/graphlib/es/Graph/toJSON.js"() {
    init_Graph();
    nodeToJSON = function nodeToJSON2(graph) {
      return graph.nodes().map(function(n2) {
        var value = graph.node(n2);
        var parent = graph.parent(n2);
        var node = {
          id: n2,
          value,
          parent
        };
        if (node.value === void 0) {
          delete node.value;
        }
        if (node.parent === void 0) {
          delete node.parent;
        }
        return node;
      });
    };
    edgeToJSON = function edgeToJSON2(graph) {
      return graph.edges().map(function(edge) {
        var value = graph.edge(edge);
        var e8 = {
          v: edge.v,
          w: edge.w,
          value,
          name: edge.name
        };
        if (e8.name === void 0) {
          delete e8.name;
        }
        if (e8.value === void 0) {
          delete e8.value;
        }
        return e8;
      });
    };
    write = function write2(graph) {
      var json = {
        options: {
          directed: graph.isDirected(),
          multigraph: graph.isMultigraph(),
          compound: graph.isCompound()
        },
        nodes: nodeToJSON(graph),
        edges: edgeToJSON(graph),
        value: graph.graph()
      };
      if (json.value === void 0) {
        delete json.value;
      }
      return json;
    };
    read = function read2(json) {
      var graph = new Graph2(json.options);
      if (json.value !== void 0) {
        graph.setGraph(json.value);
      }
      json.nodes.forEach(function(entry) {
        graph.setNode(entry.id, entry.value);
        if (entry.parent) {
          graph.setParent(entry.id, entry.parent);
        }
      });
      json.edges.forEach(function(entry) {
        graph.setEdge(entry.v, entry.w, entry.value, entry.name);
      });
      return graph;
    };
  }
});

// node_modules/@antv/graphlib/es/Graph/index.js
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var defaultOption, Graph2;
var init_Graph = __esm({
  "node_modules/@antv/graphlib/es/Graph/index.js"() {
    init_util();
    init_enum();
    init_util();
    init_toJSON();
    defaultOption = {
      compound: false,
      multigraph: false,
      directed: true
    };
    Graph2 = function() {
      function Graph4() {
        var _this = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Graph4);
        this.directed = true;
        this.multigraph = false;
        this.compound = false;
        this.GRAPH_NODE = GraphEnum.GRAPH_NODE;
        this.label = void 0;
        this.nodeCountNum = 0;
        this.edgeCountNum = 0;
        this.defaultNodeLabelFn = function() {
          return void 0;
        };
        this.defaultEdgeLabelFn = function() {
          return void 0;
        };
        this.parentMap = void 0;
        this.childrenMap = void 0;
        this.nodesLabelMap = /* @__PURE__ */ new Map();
        this.inEdgesMap = /* @__PURE__ */ new Map();
        this.outEdgesMap = /* @__PURE__ */ new Map();
        this.predecessorsMap = /* @__PURE__ */ new Map();
        this.successorsMap = /* @__PURE__ */ new Map();
        this.edgesMap = /* @__PURE__ */ new Map();
        this.edgesLabelsMap = /* @__PURE__ */ new Map();
        this.isDirected = function() {
          return _this.directed;
        };
        this.isMultigraph = function() {
          return _this.multigraph;
        };
        this.isCompound = function() {
          return _this.compound;
        };
        this.setGraph = function(label) {
          _this.label = label;
          return _this;
        };
        this.graph = function() {
          return _this.label;
        };
        this.setDefaultNodeLabel = function(newDefault) {
          if (isFunction(newDefault)) {
            _this.defaultNodeLabelFn = newDefault;
          } else {
            _this.defaultNodeLabelFn = function() {
              return newDefault;
            };
          }
          return _this;
        };
        this.nodeCount = function() {
          return _this.nodeCountNum;
        };
        this.node = function(n2) {
          return _this.nodesLabelMap.get(n2);
        };
        this.nodes = function() {
          return Array.from(_this.nodesLabelMap.keys());
        };
        this.sources = function() {
          return _this.nodes().filter(function(n2) {
            var _this$inEdgesMap$get;
            return !((_this$inEdgesMap$get = _this.inEdgesMap.get(n2)) === null || _this$inEdgesMap$get === void 0 ? void 0 : _this$inEdgesMap$get.size);
          });
        };
        this.sinks = function() {
          return _this.nodes().filter(function(n2) {
            var _this$outEdgesMap$get;
            return !((_this$outEdgesMap$get = _this.outEdgesMap.get(n2)) === null || _this$outEdgesMap$get === void 0 ? void 0 : _this$outEdgesMap$get.size);
          });
        };
        this.setNodes = function(nodes, value) {
          nodes.map(function(node) {
            return _this.setNode(node, value);
          });
          return _this;
        };
        this.hasNode = function(node) {
          return _this.nodesLabelMap.has(node);
        };
        this.checkCompound = function() {
          if (!_this.isCompound()) {
            throw new Error("Cannot construct parent-children relations in a non-compound graph");
          }
        };
        this.parent = function(node) {
          if (_this.isCompound()) {
            var _this$parentMap;
            var parent = (_this$parentMap = _this.parentMap) === null || _this$parentMap === void 0 ? void 0 : _this$parentMap.get(node);
            if (parent !== _this.GRAPH_NODE) {
              return parent;
            }
          }
        };
        this.removeFromParentsChildList = function(node) {
          var targetParent = _this.parentMap.get(node);
          _this.childrenMap.get(targetParent).delete(node);
        };
        this.setParent = function(node, parent) {
          var _this$parentMap2, _this$childrenMap;
          _this.checkCompound();
          var realParent = parent === void 0 ? _this.GRAPH_NODE : parent;
          var checkNode = _this.parent(realParent);
          while (checkNode) {
            if (node === checkNode) {
              throw new Error("Setting " + parent + " as parent of " + node + " would create a cycle");
            }
            checkNode = _this.parent(checkNode);
          }
          if (parent) {
            _this.setNode(parent);
          }
          _this.setNode(node);
          _this.removeFromParentsChildList(node);
          (_this$parentMap2 = _this.parentMap) === null || _this$parentMap2 === void 0 ? void 0 : _this$parentMap2.set(node, realParent);
          var realParentChilren = _this.childrenMap.get(realParent);
          realParentChilren.set(node, true);
          (_this$childrenMap = _this.childrenMap) === null || _this$childrenMap === void 0 ? void 0 : _this$childrenMap.set(realParent, realParentChilren);
          return _this;
        };
        this.children = function(node) {
          var targetNode = node === void 0 ? _this.GRAPH_NODE : node;
          if (_this.isCompound()) {
            var _this$childrenMap2;
            var target = (_this$childrenMap2 = _this.childrenMap) === null || _this$childrenMap2 === void 0 ? void 0 : _this$childrenMap2.get(targetNode);
            if (target) {
              return Array.from(target.keys());
            }
            return void 0;
          }
          if (targetNode === _this.GRAPH_NODE) {
            return _this.nodes();
          }
          if (node && _this.hasNode(node)) {
            return [];
          }
        };
        this.predecessors = function(node) {
          var preds = _this.predecessorsMap.get(node);
          return preds ? Array.from(preds.keys()) : void 0;
        };
        this.successors = function(node) {
          var succs = _this.successorsMap.get(node);
          return succs ? Array.from(succs.keys()) : void 0;
        };
        this.neighbors = function(node) {
          var _this$predecessors;
          if (!_this.hasNode(node)) {
            return void 0;
          }
          return Array.from(new Set((_this$predecessors = _this.predecessors(node)) === null || _this$predecessors === void 0 ? void 0 : _this$predecessors.concat(_this.successors(node))));
        };
        this.isLeaf = function(node) {
          var _this$neighbors;
          if (_this.isDirected()) {
            var _this$successors;
            return !((_this$successors = _this.successors(node)) === null || _this$successors === void 0 ? void 0 : _this$successors.length);
          }
          return !((_this$neighbors = _this.neighbors(node)) === null || _this$neighbors === void 0 ? void 0 : _this$neighbors.length);
        };
        this.filterNodes = function(filter3) {
          var directed = _this.directed, multigraph = _this.multigraph, compound = _this.compound;
          var copyGraph = new Graph4({
            directed,
            multigraph,
            compound
          });
          copyGraph.setGraph(_this.graph());
          _this.nodes().forEach(function(n2) {
            if (filter3(n2)) {
              copyGraph.setNode(n2, _this.node(n2));
            }
          });
          _this.edges().forEach(function(edgeObj) {
            if (copyGraph.hasNode(edgeObj.v) && copyGraph.hasNode(edgeObj.w)) {
              copyGraph.setEdgeObj(edgeObj, _this.edge(edgeObj));
            }
          });
          if (compound) {
            var findParent = function findParent2(node) {
              var parent = _this.parent(node);
              while (parent !== void 0 && !copyGraph.hasNode(parent)) {
                parent = _this.parent(parent);
              }
              return parent;
            };
            copyGraph.nodes().forEach(function(node) {
              copyGraph.setParent(node, findParent(node));
            });
          }
          return copyGraph;
        };
        this.setDefaultEdgeLabel = function(newDefault) {
          if (isFunction(newDefault)) {
            _this.defaultEdgeLabelFn = newDefault;
          } else {
            _this.defaultEdgeLabelFn = function() {
              return newDefault;
            };
          }
          return _this;
        };
        this.edgeCount = function() {
          return _this.edgeCountNum;
        };
        this.setEdgeObj = function(edgeObj, value) {
          return _this.setEdge(edgeObj.v, edgeObj.w, value, edgeObj.name);
        };
        this.setPath = function(edges, value) {
          edges.reduce(function(v2, w2) {
            _this.setEdge(v2, w2, value);
            return w2;
          });
          return _this;
        };
        this.edgeFromArgs = function(v2, w2, name) {
          return _this.edge({
            v: v2,
            w: w2,
            name
          });
        };
        this.edge = function(edgeObj) {
          return _this.edgesLabelsMap.get(edgeObjToId(_this.isDirected(), edgeObj));
        };
        this.hasEdge = function(v2, w2, name) {
          return _this.edgesLabelsMap.has(edgeObjToId(_this.isDirected(), {
            v: v2,
            w: w2,
            name
          }));
        };
        this.removeEdgeObj = function(_ref) {
          var v2 = _ref.v, w2 = _ref.w, name = _ref.name;
          return _this.removeEdge(v2, w2, name);
        };
        this.edges = function() {
          return Array.from(_this.edgesMap.values());
        };
        this.inEdges = function(v2, u2) {
          var inV = _this.inEdgesMap.get(v2);
          if (inV) {
            return Array.from(inV.values()).filter(function(e8) {
              return !u2 || e8.v === u2;
            });
          }
          return void 0;
        };
        this.outEdges = function(w2, u2) {
          var outW = _this.outEdgesMap.get(w2);
          if (outW) {
            return Array.from(outW.values()).filter(function(e8) {
              return !u2 || e8.w === u2;
            });
          }
          return void 0;
        };
        this.nodeEdges = function(v2, w2) {
          var _this$inEdges;
          if (!_this.hasNode(v2)) {
            return void 0;
          }
          return (_this$inEdges = _this.inEdges(v2, w2)) === null || _this$inEdges === void 0 ? void 0 : _this$inEdges.concat(_this.outEdges(v2, w2));
        };
        this.toJSON = function() {
          return write(_this);
        };
        this.nodeInDegree = function(node) {
          var inEdges = _this.inEdgesMap.get(node);
          if (inEdges) {
            return inEdges.size;
          }
          return 0;
        };
        this.nodeOutDegree = function(node) {
          var outEdges = _this.outEdgesMap.get(node);
          if (outEdges) {
            return outEdges.size;
          }
          return 0;
        };
        this.nodeDegree = function(node) {
          return _this.nodeInDegree(node) + _this.nodeOutDegree(node);
        };
        this.source = function(edge) {
          return edge.v;
        };
        this.target = function(edge) {
          return edge.w;
        };
        var resultOptions = _objectSpread(_objectSpread({}, defaultOption), options);
        this.compound = resultOptions.compound;
        this.directed = resultOptions.directed;
        this.multigraph = resultOptions.multigraph;
        if (this.compound) {
          this.parentMap = /* @__PURE__ */ new Map();
          this.childrenMap = /* @__PURE__ */ new Map();
        }
      }
      _createClass(Graph4, [{
        key: "setNode",
        value: (
          /**
           * @description Set Node label in graph if node not in graph then create it
           * @description.zh-CN 设置节点的label，如果这个节点不在图中，则在图中创建这个节点
           * @param node
           * @param value
           * @returns
           */
          function setNode(node, value) {
            var nodesLabelMap = this.nodesLabelMap, defaultNodeLabelFn = this.defaultNodeLabelFn, isCompound = this.isCompound, parentMap = this.parentMap, childrenMap = this.childrenMap, inEdgesMap = this.inEdgesMap, outEdgesMap = this.outEdgesMap, predecessorsMap = this.predecessorsMap, successorsMap = this.successorsMap;
            if (nodesLabelMap.has(node)) {
              if (value !== void 0) {
                nodesLabelMap.set(node, value);
              }
              return this;
            }
            nodesLabelMap.set(node, value || defaultNodeLabelFn(node));
            if (isCompound()) {
              var _childrenMap$get;
              parentMap === null || parentMap === void 0 ? void 0 : parentMap.set(node, this.GRAPH_NODE);
              childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(node, /* @__PURE__ */ new Map());
              if (!(childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.has(this.GRAPH_NODE))) {
                childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(this.GRAPH_NODE, /* @__PURE__ */ new Map());
              }
              childrenMap === null || childrenMap === void 0 ? void 0 : (_childrenMap$get = childrenMap.get(this.GRAPH_NODE)) === null || _childrenMap$get === void 0 ? void 0 : _childrenMap$get.set(node, true);
            }
            [inEdgesMap, outEdgesMap, predecessorsMap, successorsMap].forEach(function(map6) {
              return map6.set(node, /* @__PURE__ */ new Map());
            });
            this.nodeCountNum += 1;
            return this;
          }
        )
        /**
         * @description Set nodes or add nodes in batch
         * @description.zh-CN 批量设置或者创建节点
         * @param nodes
         * @param value
         * @returns
         */
      }, {
        key: "removeNode",
        value: (
          /**
           * @description Remove node from graph
           * @description.zh-CN 将节点从图中移除
           * @param node
           * @returns
           */
          function removeNode(node) {
            var _this2 = this;
            if (this.hasNode(node)) {
              var cleanEdge = function cleanEdge2(edgeObj) {
                _this2.removeEdge(edgeObj.v, edgeObj.w, edgeObj.name);
              };
              var inEdgesMap = this.inEdgesMap, outEdgesMap = this.outEdgesMap, predecessorsMap = this.predecessorsMap, successorsMap = this.successorsMap, nodesLabelMap = this.nodesLabelMap;
              if (this.isCompound()) {
                var _this$parentMap3, _this$children, _this$childrenMap3;
                this.removeFromParentsChildList(node);
                (_this$parentMap3 = this.parentMap) === null || _this$parentMap3 === void 0 ? void 0 : _this$parentMap3.delete(node);
                (_this$children = this.children(node)) === null || _this$children === void 0 ? void 0 : _this$children.forEach(function(n2) {
                  return _this2.setParent(n2);
                });
                (_this$childrenMap3 = this.childrenMap) === null || _this$childrenMap3 === void 0 ? void 0 : _this$childrenMap3.delete(node);
              }
              var inE = inEdgesMap.get(node);
              var outE = outEdgesMap.get(node);
              Array.from(inE.values()).forEach(function(edge) {
                return cleanEdge(edge);
              });
              Array.from(outE.values()).forEach(function(edge) {
                return cleanEdge(edge);
              });
              nodesLabelMap.delete(node);
              inEdgesMap.delete(node);
              outEdgesMap.delete(node);
              predecessorsMap.delete(node);
              successorsMap.delete(node);
              this.nodeCountNum -= 1;
            }
            return this;
          }
        )
        /**
         * @description Set function that generate default label for edge, if param is non-function value then default label will always be this value;
         * @description.zh-CN 设置默认获取边Label的方法，如果传入不是函数的，那么默认label 的值只会是传入值
         * @param newDefault
         * @returns
         */
      }, {
        key: "setEdge",
        value: (
          /**
           * @description set edge value, if nodes or edges not exsit then add to graph
           * @description.zh-CN 设置边的属性，如果边或节点不存在，那么将他们加入这个图
           * @param v
           * @param w
           * @param value
           * @param name
           * @returns
           */
          function setEdge(v_, w_, value, name) {
            var _this$inEdgesMap$get2, _this$outEdgesMap$get2;
            var edgeObj = edgeArgsToObj(this.isDirected(), v_, w_, name);
            var edgeId = edgeObjToId(this.isDirected(), edgeObj);
            var v2 = edgeObj.v, w2 = edgeObj.w;
            if (this.edgesLabelsMap.has(edgeId)) {
              this.edgesLabelsMap.set(edgeId, value);
              return this;
            }
            if (name !== void 0 && !this.isMultigraph()) {
              throw new Error("Cannot set a named edge when isMultigraph = false");
            }
            this.setNode(v2);
            this.setNode(w2);
            this.edgesLabelsMap.set(edgeId, value || this.defaultEdgeLabelFn(v2, w2, name));
            Object.freeze(edgeObj);
            this.edgesMap.set(edgeId, edgeObj);
            var preds = this.predecessorsMap.get(w2);
            var succs = this.successorsMap.get(v2);
            incrementOrInitEntry(preds, v2);
            incrementOrInitEntry(succs, w2);
            (_this$inEdgesMap$get2 = this.inEdgesMap.get(w2)) === null || _this$inEdgesMap$get2 === void 0 ? void 0 : _this$inEdgesMap$get2.set(edgeId, edgeObj);
            (_this$outEdgesMap$get2 = this.outEdgesMap.get(v2)) === null || _this$outEdgesMap$get2 === void 0 ? void 0 : _this$outEdgesMap$get2.set(edgeId, edgeObj);
            this.edgeCountNum += 1;
            return this;
          }
        )
      }, {
        key: "removeEdge",
        value: (
          /**
           * @description remove a specific edge
           * @description.zh-CN 删除一条边
           * @param v
           * @param w
           * @param name
           * @returns
           */
          function removeEdge(v_, w_, name) {
            var edgeId = edgeArgsToId(this.isDirected(), v_, w_, name);
            var edgeObj = this.edgesMap.get(edgeId);
            if (edgeObj) {
              var _edgeArgsToObj = edgeArgsToObj(this.isDirected(), v_, w_, name), v2 = _edgeArgsToObj.v, w2 = _edgeArgsToObj.w;
              this.edgesLabelsMap.delete(edgeId);
              this.edgesMap.delete(edgeId);
              var preds = this.predecessorsMap.get(w2);
              var succs = this.successorsMap.get(v2);
              decrementOrRemoveEntry(preds, v2);
              decrementOrRemoveEntry(succs, w2);
              this.inEdgesMap.get(w2).delete(edgeId);
              this.outEdgesMap.get(v2).delete(edgeId);
              this.edgeCountNum -= 1;
            }
            return this;
          }
        )
        /**
         * @description remove a specific edge by edge object
         * @description.zh-CN 删除一条边
         */
      }]);
      return Graph4;
    }();
    Graph2.fromJSON = read;
  }
});

// node_modules/@antv/graphlib/es/Graph/event.js
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var GraphWithEvent;
var init_event = __esm({
  "node_modules/@antv/graphlib/es/Graph/event.js"() {
    init_Graph();
    GraphWithEvent = function(_Graph) {
      _inherits(GraphWithEvent2, _Graph);
      var _super = _createSuper(GraphWithEvent2);
      function GraphWithEvent2() {
        var _this;
        _classCallCheck2(this, GraphWithEvent2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.eventPool = {};
        return _this;
      }
      _createClass2(GraphWithEvent2, [{
        key: "appendEvent",
        value: (
          /**
           * @description Add an event listener.
           * @description.zh-CN 添加事件监听器。
           */
          function appendEvent(type, callback) {
            if (!this.eventPool[type]) {
              this.eventPool[type] = [];
            }
            this.eventPool[type].push(callback);
          }
        )
        /**
         * @description remove an event listener.
         * @description.zh-CN 移除事件监听器。
         */
      }, {
        key: "removeEvent",
        value: function removeEvent(type, callback) {
          if (!this.eventPool[type]) {
            return;
          }
          var index2 = this.eventPool[type].indexOf(callback);
          if (index2 > -1) {
            this.eventPool[type].splice(index2, 1);
          }
        }
        /**
         * @description trigger an event.
         * @description.zh-CN 触发事件。
         */
      }, {
        key: "emitEvent",
        value: function emitEvent(type) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          if (!this.eventPool[type]) {
            return;
          }
          this.eventPool[type].forEach(function(callback) {
            callback.apply(void 0, args);
          });
        }
      }, {
        key: "setNode",
        value: function setNode(node, value) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "setNode", this).call(this, node, value);
          this.emitEvent("nodeAdd", node, value);
          return this;
        }
      }, {
        key: "removeNode",
        value: function removeNode(node) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "removeNode", this).call(this, node);
          this.emitEvent("nodeRemove", node);
          return this;
        }
      }, {
        key: "setEdge",
        value: function setEdge(v_, w_, value, name) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "setEdge", this).call(this, v_, w_, value, name);
          this.emitEvent("edgeAdd", v_, w_, value, name);
          return this;
        }
      }, {
        key: "removeEdge",
        value: function removeEdge(v_, w_, name) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "removeEdge", this).call(this, v_, w_, name);
          this.emitEvent("edgeRemove", v_, w_, name);
          return this;
        }
      }]);
      return GraphWithEvent2;
    }(Graph2);
  }
});

// node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js
function _defineProperties3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var PriorityQueue;
var init_PriorityQueue = __esm({
  "node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js"() {
    PriorityQueue = _createClass3(function PriorityQueue2() {
      var _this = this;
      _classCallCheck3(this, PriorityQueue2);
      this.arr = [];
      this.keyIndice = /* @__PURE__ */ new Map();
      this.size = function() {
        return _this.arr.length;
      };
      this.keys = function() {
        return _this.arr.map(function(e8) {
          return e8.key;
        });
      };
      this.has = function(key) {
        return _this.keyIndice.has(key);
      };
      this.priority = function(key) {
        var index2 = _this.keyIndice.get(key);
        if (index2 !== void 0) {
          return _this.arr[index2].priority;
        }
      };
      this.swap = function(i2, j2) {
        var arr = _this.arr, keyIndice = _this.keyIndice;
        var _ref = [arr[i2], arr[j2]], originI = _ref[0], originJ = _ref[1];
        arr[i2] = originJ;
        arr[j2] = originI;
        keyIndice.set(originI.key, j2);
        keyIndice.set(originJ.key, i2);
      };
      this.innerDecrease = function(index2) {
        var arr = _this.arr;
        var priority = arr[index2].priority;
        var parent;
        var i2 = index2;
        while (i2 !== 0) {
          var _arr$parent;
          parent = i2 >> 1;
          if (((_arr$parent = arr[parent]) === null || _arr$parent === void 0 ? void 0 : _arr$parent.priority) < priority) {
            break;
          }
          _this.swap(i2, parent);
          i2 = parent;
        }
      };
      this.heapify = function(i2) {
        var arr = _this.arr;
        var l2 = i2 << 1;
        var r2 = l2 + 1;
        var largest = i2;
        if (l2 < arr.length) {
          largest = arr[l2].priority < arr[largest].priority ? l2 : largest;
          if (r2 < arr.length) {
            largest = arr[r2].priority < arr[largest].priority ? r2 : largest;
          }
          if (largest !== i2) {
            _this.swap(i2, largest);
            _this.heapify(largest);
          }
        }
      };
      this.min = function() {
        if (_this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return _this.arr[0].key;
      };
      this.add = function(key, priority) {
        var keyIndice = _this.keyIndice, arr = _this.arr;
        if (!keyIndice.has(key)) {
          var index2 = arr.length;
          keyIndice.set(key, index2);
          arr.push({
            key,
            priority
          });
          _this.innerDecrease(index2);
          return true;
        }
        return false;
      };
      this.removeMin = function() {
        _this.swap(0, _this.arr.length - 1);
        var min6 = _this.arr.pop();
        _this.keyIndice.delete(min6.key);
        _this.heapify(0);
        return min6.key;
      };
      this.decrease = function(key, priority) {
        if (!_this.has(key)) {
          throw new Error("There's no key named ".concat(key));
        }
        var index2 = _this.keyIndice.get(key);
        if (priority > _this.arr[index2].priority) {
          throw new Error("New priority is greater than current priority.Key: ".concat(key, " Old: + ").concat(_this.arr[index2].priority, " New: ").concat(priority));
        }
        _this.arr[index2].priority = priority;
        _this.innerDecrease(index2);
      };
    });
  }
});

// node_modules/@antv/graphlib/es/algorithm/prim.js
var prim, prim_default;
var init_prim = __esm({
  "node_modules/@antv/graphlib/es/algorithm/prim.js"() {
    init_Graph();
    init_PriorityQueue();
    prim = function prim2(graph, weightFn) {
      var result = new Graph2();
      var parents = /* @__PURE__ */ new Map();
      var pq = new PriorityQueue();
      var v2;
      function updateNeighbors(edge) {
        var w2 = edge.v === v2 ? edge.w : edge.v;
        var pri = pq.priority(w2);
        if (pri !== void 0) {
          var edgeWeight = weightFn(edge);
          if (edgeWeight < pri) {
            parents.set(w2, v2);
            pq.decrease(w2, edgeWeight);
          }
        }
      }
      if (graph.nodeCount() === 0) {
        return result;
      }
      graph.nodes().forEach(function(node) {
        pq.add(node, Number.POSITIVE_INFINITY);
        result.setNode(node);
      });
      pq.decrease(graph.nodes()[0], 0);
      var init = false;
      while (pq.size() > 0) {
        var _graph$nodeEdges;
        v2 = pq.removeMin();
        if (parents.has(v2)) {
          result.setEdge(v2, parents.get(v2));
        } else if (init) {
          throw new Error("Input graph is not connected: " + graph.graph());
        } else {
          init = true;
        }
        (_graph$nodeEdges = graph.nodeEdges(v2)) === null || _graph$nodeEdges === void 0 ? void 0 : _graph$nodeEdges.forEach(updateNeighbors);
      }
      return result;
    };
    prim_default = prim;
  }
});

// node_modules/@antv/graphlib/es/algorithm/components.js
var components, components_default;
var init_components = __esm({
  "node_modules/@antv/graphlib/es/algorithm/components.js"() {
    components = function components2(graph) {
      var visited = /* @__PURE__ */ new Set();
      var resultComponents = [];
      var nodes = graph.nodes();
      nodes.forEach(function(n2) {
        var componentsArr = [];
        var waitingList = [n2];
        while (waitingList.length > 0) {
          var node = waitingList.pop();
          if (!visited.has(node)) {
            var _graph$successors, _graph$predecessors;
            visited.add(node);
            componentsArr.push(node);
            (_graph$successors = graph.successors(node)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function(n3) {
              return waitingList.push(n3);
            });
            (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(function(n3) {
              return waitingList.push(n3);
            });
          }
        }
        if (componentsArr.length) {
          resultComponents.push(componentsArr);
        }
      });
      return resultComponents;
    };
    components_default = components;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dfs.js
var doDFS, dfs, dfs_default;
var init_dfs = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dfs.js"() {
    doDFS = function doDFS2(graph, node, postorder3, visited, navigator2, result) {
      if (!visited.includes(node)) {
        visited.push(node);
        if (!postorder3) {
          result.push(node);
        }
        navigator2(node).forEach(function(n2) {
          return doDFS2(graph, n2, postorder3, visited, navigator2, result);
        });
        if (postorder3) {
          result.push(node);
        }
      }
    };
    dfs = function dfs2(graph, node, order) {
      var nodes = Array.isArray(node) ? node : [node];
      var navigator2 = function navigator3(n2) {
        return graph.isDirected() ? graph.successors(n2) : graph.neighbors(n2);
      };
      var results = [];
      var visited = [];
      nodes.forEach(function(node2) {
        if (!graph.hasNode(node2)) {
          throw new Error("Graph does not have node: " + node2);
        } else {
          doDFS(graph, node2, order === "post", visited, navigator2, results);
        }
      });
      return results;
    };
    dfs_default = dfs;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dijkstra.js
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len6) {
  if (len6 == null || len6 > arr.length) len6 = arr.length;
  for (var i2 = 0, arr2 = new Array(len6); i2 < len6; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i2) {
  var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i2 == null) return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i2 = _i2.call(arr); !(_n2 = (_s = _i2.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null) _i2["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
var DEFAULT_WEIGHT_FUNC, dijkstra3, runDijkstra, dijkstra_default2;
var init_dijkstra = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dijkstra.js"() {
    init_PriorityQueue();
    DEFAULT_WEIGHT_FUNC = function DEFAULT_WEIGHT_FUNC2() {
      return 1;
    };
    dijkstra3 = function dijkstra4(graph, source, weightFn, edgeFn) {
      return runDijkstra(graph, source, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v2) {
        return graph.outEdges(v2);
      });
    };
    runDijkstra = function runDijkstra2(graph, source, weightFn, edgeFn) {
      var results = /* @__PURE__ */ new Map();
      var pq = new PriorityQueue();
      var v2;
      var vEntry;
      var updateNeighbors = function updateNeighbors2(edge) {
        var w2 = edge.v !== v2 ? edge.v : edge.w;
        var wEntry = results.get(w2);
        var weight = weightFn(edge);
        var distance11 = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance11 < wEntry.distance) {
          wEntry.distance = distance11;
          wEntry.predecessor = v2;
          pq.decrease(w2, distance11);
        }
      };
      graph.nodes().forEach(function(v3) {
        var distance11 = v3 === source ? 0 : Number.POSITIVE_INFINITY;
        results.set(v3, {
          distance: distance11
        });
        pq.add(v3, distance11);
      });
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        vEntry = results.get(v2);
        if (vEntry && vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v2).forEach(updateNeighbors);
      }
      var obj = {};
      Array.from(results.entries()).forEach(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), node = _ref2[0], e8 = _ref2[1];
        obj[String(node)] = e8;
        return obj;
      });
      return obj;
    };
    dijkstra_default2 = dijkstra3;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js
var dijkstraAll, dijkstra_all_default;
var init_dijkstra_all = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js"() {
    init_dijkstra();
    dijkstraAll = function dijkstraAll2(graph, weightFn, edgeFn) {
      var map6 = {};
      graph.nodes().forEach(function(node) {
        map6[String(node)] = dijkstra_default2(graph, node, weightFn, edgeFn);
        return map6;
      });
      return map6;
    };
    dijkstra_all_default = dijkstraAll;
  }
});

// node_modules/@antv/graphlib/es/algorithm/tarjan.js
var tarjan, tarjan_default;
var init_tarjan = __esm({
  "node_modules/@antv/graphlib/es/algorithm/tarjan.js"() {
    tarjan = function tarjan2(graph) {
      var index2 = 0;
      var stack = [];
      var visited = /* @__PURE__ */ new Map();
      var results = [];
      function dfs3(v2) {
        var _graph$successors;
        var entry = {
          onStack: true,
          lowlink: index2,
          index: index2
        };
        visited.set(v2, entry);
        index2 += 1;
        stack.push(v2);
        (_graph$successors = graph.successors(v2)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function(w3) {
          var _visited$get;
          if (!visited.has(w3)) {
            dfs3(w3);
            var wEntry2 = visited.get(w3);
            entry.lowlink = Math.min(entry.lowlink, wEntry2.lowlink);
          } else if ((_visited$get = visited.get(w3)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {
            var _wEntry = visited.get(w3);
            entry.lowlink = Math.min(entry.lowlink, _wEntry.index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w2;
          do {
            w2 = stack.pop();
            var wEntry = visited.get(w2);
            wEntry.onStack = false;
            cmpt.push(w2);
          } while (v2 !== w2);
          results.push(cmpt);
        }
      }
      graph.nodes().forEach(function(v2) {
        if (!visited.has(v2)) {
          dfs3(v2);
        }
      });
      return results;
    };
    tarjan_default = tarjan;
  }
});

// node_modules/@antv/graphlib/es/algorithm/find-cycles.js
var findCycles, find_cycles_default;
var init_find_cycles = __esm({
  "node_modules/@antv/graphlib/es/algorithm/find-cycles.js"() {
    init_tarjan();
    findCycles = function findCycles2(graph) {
      return tarjan_default(graph).filter(function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && graph.hasEdge(cmpt[0], cmpt[0]);
      });
    };
    find_cycles_default = findCycles;
  }
});

// node_modules/@antv/graphlib/es/algorithm/topsort.js
function _typeof5(obj) {
  "@babel/helpers - typeof";
  return _typeof5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof5(obj);
}
function _defineProperties4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf2(subClass, superClass);
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _possibleConstructorReturn2(self2, call) {
  if (call && (_typeof5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized2(self2);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf2(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf2(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a3 = [null];
      a3.push.apply(a3, args2);
      var Constructor = Function.bind.apply(Parent2, a3);
      var instance = new Constructor();
      if (Class2) _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _setPrototypeOf2(o2, p2) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf2(o2, p2);
}
function _getPrototypeOf2(o2) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf2(o2);
}
function topsort(graph) {
  var visited = /* @__PURE__ */ new Set();
  var stack = /* @__PURE__ */ new Set();
  var results = [];
  function visit(node) {
    if (stack.has(node)) {
      throw new CycleException();
    }
    if (!visited.has(node)) {
      var _graph$predecessors;
      stack.add(node);
      visited.add(node);
      (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(visit);
      stack.delete(node);
      results.push(node);
    }
  }
  graph.sinks().forEach(visit);
  if (visited.size !== graph.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
var CycleException, topsort_default;
var init_topsort = __esm({
  "node_modules/@antv/graphlib/es/algorithm/topsort.js"() {
    CycleException = function(_Error) {
      _inherits2(CycleException2, _Error);
      var _super = _createSuper2(CycleException2);
      function CycleException2() {
        _classCallCheck4(this, CycleException2);
        return _super.apply(this, arguments);
      }
      return _createClass4(CycleException2);
    }(_wrapNativeSuper(Error));
    topsort_default = topsort;
  }
});

// node_modules/@antv/graphlib/es/algorithm/is-acyclic.js
var isAcyclic, is_acyclic_default;
var init_is_acyclic = __esm({
  "node_modules/@antv/graphlib/es/algorithm/is-acyclic.js"() {
    init_topsort();
    isAcyclic = function isAcyclic2(graph) {
      try {
        topsort_default(graph);
      } catch (e8) {
        if (e8 instanceof CycleException) {
          return false;
        }
        throw e8;
      }
      return true;
    };
    is_acyclic_default = isAcyclic;
  }
});

// node_modules/@antv/graphlib/es/algorithm/postorder.js
var postorder, postorder_default;
var init_postorder = __esm({
  "node_modules/@antv/graphlib/es/algorithm/postorder.js"() {
    init_dfs();
    postorder = function postorder2(graph, nodes) {
      return dfs_default(graph, nodes, "post");
    };
    postorder_default = postorder;
  }
});

// node_modules/@antv/graphlib/es/algorithm/preorder.js
var preorder, preorder_default;
var init_preorder = __esm({
  "node_modules/@antv/graphlib/es/algorithm/preorder.js"() {
    init_dfs();
    preorder = function preorder2(graph, nodes) {
      return dfs_default(graph, nodes, "pre");
    };
    preorder_default = preorder;
  }
});

// node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js
function floydWarshall5(graph, weightFn, edgeFn) {
  return runFloydWarshall(graph, weightFn || DEFAULT_WEIGHT_FUNC3, edgeFn || function(v2) {
    return graph.outEdges(v2);
  });
}
function runFloydWarshall(graph, weightFn, edgeFn) {
  var results = {};
  var nodes = graph.nodes();
  nodes.forEach(function(node) {
    var v2 = String(node);
    results[v2] = {};
    results[v2][v2] = {
      distance: 0
    };
    nodes.forEach(function(w2) {
      if (node !== w2) {
        results[v2][String(w2)] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(node).forEach(function(edge) {
      var w2 = edge.v === node ? edge.w : edge.v;
      var d2 = weightFn(edge);
      results[v2][String(w2)] = {
        distance: d2,
        predecessor: node
      };
    });
  });
  nodes.forEach(function(nodek) {
    var k2 = String(nodek);
    var rowK = results[k2];
    nodes.forEach(function(nodei) {
      var i2 = String(nodei);
      var rowI = results[i2];
      nodes.forEach(function(nodej) {
        var j2 = String(nodej);
        var ik = rowI[k2];
        var kj = rowK[j2];
        var ij = rowI[j2];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}
var DEFAULT_WEIGHT_FUNC3, floyd_warshall_default;
var init_floyd_warshall = __esm({
  "node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js"() {
    DEFAULT_WEIGHT_FUNC3 = function DEFAULT_WEIGHT_FUNC4() {
      return 1;
    };
    floyd_warshall_default = floydWarshall5;
  }
});

// node_modules/@antv/graphlib/es/algorithm/index.js
var algorithm_exports = {};
__export(algorithm_exports, {
  components: () => components_default,
  dfs: () => dfs_default,
  dijkstra: () => dijkstra_default2,
  dijkstraAll: () => dijkstra_all_default,
  findCycles: () => find_cycles_default,
  floydWarshall: () => floyd_warshall_default,
  isAcyclic: () => is_acyclic_default,
  postorder: () => postorder_default,
  preorder: () => preorder_default,
  prim: () => prim_default,
  tarjan: () => tarjan_default,
  topsort: () => topsort_default
});
var init_algorithm = __esm({
  "node_modules/@antv/graphlib/es/algorithm/index.js"() {
    init_prim();
    init_components();
    init_dfs();
    init_dijkstra();
    init_dijkstra_all();
    init_find_cycles();
    init_is_acyclic();
    init_postorder();
    init_preorder();
    init_tarjan();
    init_topsort();
    init_floyd_warshall();
  }
});

// node_modules/@antv/graphlib/es/comparision/contain.js
var containSameNodes, containSameEdges, getSameNodes, getSameEdges, isGraphOptionSame, containAllSameNodes, containAllSameEdges, isGraphSame, isGraphContainsAnother;
var init_contain = __esm({
  "node_modules/@antv/graphlib/es/comparision/contain.js"() {
    containSameNodes = function containSameNodes2(aGraph, bGraph) {
      var aNodes = aGraph.nodes();
      for (var i2 = 0; i2 < aNodes.length; i2++) {
        var aNode = aNodes[i2];
        if (bGraph.hasNode(aNode)) {
          return true;
        }
      }
      return false;
    };
    containSameEdges = function containSameEdges2(aGraph, bGraph) {
      var aEdges = aGraph.edges();
      for (var i2 = 0; i2 < aEdges.length; i2++) {
        var aEdge = aEdges[i2];
        if (bGraph.hasEdge(aEdge.v, aEdge.w, aEdge.name)) {
          return true;
        }
      }
      return false;
    };
    getSameNodes = function getSameNodes2(aGraph, bGraph) {
      var aNodes = aGraph.nodes();
      var sameNodes = aNodes.filter(function(aNode) {
        return bGraph.hasNode(aNode);
      });
      return sameNodes;
    };
    getSameEdges = function getSameEdges2(aGraph, bGraph) {
      var aEdges = aGraph.edges();
      var sameEdges = aEdges.filter(function(aEdge) {
        return bGraph.hasEdge(aEdge.v, aEdge.w, aEdge.name);
      });
      return sameEdges;
    };
    isGraphOptionSame = function isGraphOptionSame2(aGraph, bGraph) {
      return aGraph.isCompound() === bGraph.isCompound() && aGraph.isDirected() === bGraph.isDirected() && aGraph.isMultigraph() === bGraph.isMultigraph();
    };
    containAllSameNodes = function containAllSameNodes2(aGraph, bGraph) {
      var sameNodes = getSameNodes(aGraph, bGraph);
      return sameNodes.length === aGraph.nodes().length;
    };
    containAllSameEdges = function containAllSameEdges2(aGraph, bGraph) {
      var sameEdges = getSameEdges(aGraph, bGraph);
      return sameEdges.length === aGraph.edges().length;
    };
    isGraphSame = function isGraphSame2(aGraph, bGraph) {
      return isGraphOptionSame(aGraph, bGraph) && aGraph.nodeCount() === bGraph.nodeCount() && containAllSameNodes(aGraph, bGraph) && aGraph.edgeCount() === bGraph.edgeCount() && containAllSameEdges(aGraph, bGraph);
    };
    isGraphContainsAnother = function isGraphContainsAnother2(originGraph, targetGraph) {
      return containAllSameNodes(originGraph, targetGraph) && containAllSameEdges(originGraph, targetGraph);
    };
  }
});

// node_modules/@antv/graphlib/es/essence/index.js
var essence_exports = {};
__export(essence_exports, {
  hasSelfLoop: () => hasSelfLoop,
  isGraph: () => isGraph,
  isNullGraph: () => isNullGraph,
  isSimpleGraph: () => isSimpleGraph
});
function _slicedToArray2(arr, i2) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray2(o2, minLen);
}
function _arrayLikeToArray2(arr, len6) {
  if (len6 == null || len6 > arr.length) len6 = arr.length;
  for (var i2 = 0, arr2 = new Array(len6); i2 < len6; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i2) {
  var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i2 == null) return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i2 = _i2.call(arr); !(_n2 = (_s = _i2.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null) _i2["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr)) return arr;
}
function isGraph(obj) {
  return obj instanceof Graph2;
}
function isSimpleGraph(graph) {
  if (graph.isMultigraph()) {
    return false;
  }
  var edges = graph.edges();
  var edgeStack = /* @__PURE__ */ new Map();
  for (var i2 = 0; i2 < edges.length; i2++) {
    var edge = edges[i2];
    if (edge.v === edge.w) {
      return false;
    }
    var _sort = [edge.v, edge.w].sort(), _sort2 = _slicedToArray2(_sort, 2), v2 = _sort2[0], w2 = _sort2[1];
    var key = "".concat(v2, "-").concat(w2);
    if (edgeStack.has(key)) {
      return false;
    }
    edgeStack.set(key, true);
  }
  return true;
}
function isNullGraph(graph) {
  return graph.nodes().length === 0;
}
function hasSelfLoop(graph) {
  var edges = graph.edges();
  for (var i2 = 0; i2 < edges.length; i2++) {
    var edge = edges[i2];
    if (edge.v === edge.w) {
      return true;
    }
  }
  return false;
}
var init_essence = __esm({
  "node_modules/@antv/graphlib/es/essence/index.js"() {
    init_Graph();
  }
});

// node_modules/@antv/graphlib/es/comparision/complement.js
var isGraphComplement;
var init_complement = __esm({
  "node_modules/@antv/graphlib/es/comparision/complement.js"() {
    init_essence();
    init_contain();
    isGraphComplement = function isGraphComplement2(originGraph, targetGraph) {
      if (!isSimpleGraph(originGraph) || !isSimpleGraph(targetGraph)) {
        return false;
      }
      if (!containAllSameNodes(originGraph, targetGraph)) {
        return false;
      }
      if (containSameEdges(originGraph, targetGraph)) {
        return false;
      }
      var nodeCount = originGraph.nodeCount();
      return originGraph.edgeCount() + targetGraph.edgeCount() === nodeCount * (nodeCount - 1) / 2;
    };
  }
});

// node_modules/@antv/graphlib/es/comparision/index.js
var comparision_exports = {};
__export(comparision_exports, {
  containAllSameEdges: () => containAllSameEdges,
  containAllSameNodes: () => containAllSameNodes,
  containSameEdges: () => containSameEdges,
  containSameNodes: () => containSameNodes,
  getSameEdges: () => getSameEdges,
  getSameNodes: () => getSameNodes,
  isGraphComplement: () => isGraphComplement,
  isGraphContainsAnother: () => isGraphContainsAnother,
  isGraphOptionSame: () => isGraphOptionSame,
  isGraphSame: () => isGraphSame
});
var init_comparision = __esm({
  "node_modules/@antv/graphlib/es/comparision/index.js"() {
    init_contain();
    init_complement();
  }
});

// node_modules/@antv/graphlib/es/generate/compelement.js
var getGraphComplement;
var init_compelement = __esm({
  "node_modules/@antv/graphlib/es/generate/compelement.js"() {
    init_essence();
    init_Graph();
    getGraphComplement = function getGraphComplement2(originGraph) {
      if (!isSimpleGraph(originGraph)) {
        return null;
      }
      var nodeCount = originGraph.nodeCount();
      var complementGraph = new Graph2({
        compound: originGraph.isCompound(),
        directed: originGraph.isDirected(),
        multigraph: originGraph.isMultigraph()
      });
      var nodes = originGraph.nodes();
      for (var i2 = 0; i2 < nodeCount; i2++) {
        var nodei = nodes[i2];
        complementGraph.setNode(nodei, originGraph.node(nodei));
        for (var j2 = i2 + 1; j2 < nodeCount; j2++) {
          var nodej = nodes[j2];
          if (!originGraph.hasEdge(nodei, nodej)) {
            complementGraph.setEdge(nodei, nodej);
          }
        }
      }
      return complementGraph;
    };
  }
});

// node_modules/@antv/graphlib/es/generate/index.js
var generate_exports = {};
__export(generate_exports, {
  getGraphComplement: () => getGraphComplement
});
var init_generate = __esm({
  "node_modules/@antv/graphlib/es/generate/index.js"() {
    init_compelement();
  }
});

// node_modules/@antv/graphlib/es/index.js
var es_exports2 = {};
__export(es_exports2, {
  Graph: () => Graph2,
  GraphWithEvent: () => GraphWithEvent,
  algorithm: () => algorithm_exports,
  comparision: () => comparision_exports,
  essence: () => essence_exports,
  generate: () => generate_exports
});
var init_es = __esm({
  "node_modules/@antv/graphlib/es/index.js"() {
    init_Graph();
    init_event();
    init_algorithm();
    init_comparision();
    init_essence();
    init_generate();
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/greedy-fas.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var list_1 = __importDefault2(require_list());
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var List = (
      /** @class */
      function(_super) {
        __extends17(List2, _super);
        function List2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return List2;
      }(list_1.default)
    );
    var StateGraph = (
      /** @class */
      function(_super) {
        __extends17(StateGraph2, _super);
        function StateGraph2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return StateGraph2;
      }(graphlib_1.Graph)
    );
    var DEFAULT_WEIGHT_FN = function() {
      return 1;
    };
    var greedyFAS = function(g2, weightFn) {
      var _a2;
      if (g2.nodeCount() <= 1)
        return [];
      var state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
      var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return (_a2 = results.map(function(e8) {
        return g2.outEdges(e8.v, e8.w);
      })) === null || _a2 === void 0 ? void 0 : _a2.flat();
    };
    var doGreedyFAS = function(g2, buckets, zeroIdx) {
      var results = [];
      var sources = buckets[buckets.length - 1];
      var sinks = buckets[0];
      var entry;
      while (g2.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        if (g2.nodeCount()) {
          for (var i2 = buckets.length - 2; i2 > 0; --i2) {
            entry = buckets[i2].dequeue();
            if (entry) {
              results = results.concat(removeNode(g2, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    };
    var removeNode = function(g2, buckets, zeroIdx, entry, collectPredecessors) {
      var _a2, _b;
      var results = [];
      (_a2 = g2.inEdges(entry.v)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(edge) {
        var weight = g2.edge(edge);
        var uEntry = g2.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w, in: 0, out: 0 });
        }
        if (uEntry.out === void 0)
          uEntry.out = 0;
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      (_b = g2.outEdges(entry.v)) === null || _b === void 0 ? void 0 : _b.forEach(function(edge) {
        var weight = g2.edge(edge);
        var w2 = edge.w;
        var wEntry = g2.node(w2);
        if (wEntry.in === void 0)
          wEntry.in = 0;
        wEntry.in -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g2.removeNode(entry.v);
      return collectPredecessors ? results : void 0;
    };
    var buildState = function(g2, weightFn) {
      var fasGraph = new StateGraph();
      var maxIn = 0;
      var maxOut = 0;
      g2.nodes().forEach(function(v2) {
        fasGraph.setNode(v2, { v: v2, in: 0, out: 0 });
      });
      g2.edges().forEach(function(e8) {
        var prevWeight = fasGraph.edge(e8) || 0;
        var weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e8)) || 1;
        var edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e8.v, e8.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e8.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e8.w).in += weight);
      });
      var buckets = [];
      var rangeMax = maxOut + maxIn + 3;
      for (var i2 = 0; i2 < rangeMax; i2++) {
        buckets.push(new List());
      }
      var zeroIdx = maxIn + 1;
      fasGraph.nodes().forEach(function(v2) {
        assignBucket(buckets, zeroIdx, fasGraph.node(v2));
      });
      return { buckets, zeroIdx, graph: fasGraph };
    };
    var assignBucket = function(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    };
    exports.default = greedyFAS;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/acyclic.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var greedy_fas_1 = __importDefault2(require_greedy_fas());
    var run = function(g2) {
      var weightFn = function(g3) {
        return function(e8) {
          var _a2;
          return ((_a2 = g3.edge(e8)) === null || _a2 === void 0 ? void 0 : _a2.weight) || 1;
        };
      };
      var fas = g2.graph().acyclicer === "greedy" ? (0, greedy_fas_1.default)(g2, weightFn(g2)) : dfsFAS(g2);
      fas === null || fas === void 0 ? void 0 : fas.forEach(function(e8) {
        var label = g2.edge(e8);
        g2.removeEdgeObj(e8);
        label.forwardName = e8.name;
        label.reversed = true;
        g2.setEdge(e8.w, e8.v, label, "rev-".concat(Math.random()));
      });
    };
    var dfsFAS = function(g2) {
      var fas = [];
      var stack = {};
      var visited = {};
      var dfs3 = function(v2) {
        var _a2;
        if (visited[v2]) {
          return;
        }
        visited[v2] = true;
        stack[v2] = true;
        (_a2 = g2.outEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          if (stack[e8.w]) {
            fas.push(e8);
          } else {
            dfs3(e8.w);
          }
        });
        delete stack[v2];
      };
      g2.nodes().forEach(dfs3);
      return fas;
    };
    var undo = function(g2) {
      g2.edges().forEach(function(e8) {
        var label = g2.edge(e8);
        if (label.reversed) {
          g2.removeEdgeObj(e8);
          var forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g2.setEdge(e8.w, e8.v, label, forwardName);
        }
      });
    };
    exports.default = { run, undo };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/graph.js
var require_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/graph.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Graph = void 0;
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var Graph4 = (
      /** @class */
      function(_super) {
        __extends17(Graph5, _super);
        function Graph5() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return Graph5;
      }(graphlib_1.Graph)
    );
    exports.Graph = Graph4;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/util.js
var require_util3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minBy = exports.notime = exports.time = exports.partition = exports.maxRank = exports.addBorderNode = exports.removeEmptyRanks = exports.normalizeRanks = exports.buildLayerMatrix = exports.intersectRect = exports.predecessorWeights = exports.successorWeights = exports.zipObject = exports.asNonCompoundGraph = exports.simplify = exports.addDummyNode = void 0;
    var util_1 = require_util2();
    var graph_1 = require_graph();
    var safeSort = function(valueA, valueB) {
      return Number(valueA) - Number(valueB);
    };
    var addDummyNode = function(g2, type, attrs, name) {
      var v2;
      do {
        v2 = "".concat(name).concat(Math.random());
      } while (g2.hasNode(v2));
      attrs.dummy = type;
      g2.setNode(v2, attrs);
      return v2;
    };
    exports.addDummyNode = addDummyNode;
    var simplify = function(g2) {
      var simplified = new graph_1.Graph().setGraph(g2.graph());
      g2.nodes().forEach(function(v2) {
        simplified.setNode(v2, g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var simpleLabel = simplified.edgeFromArgs(e8.v, e8.w) || { weight: 0, minlen: 1 };
        var label = g2.edge(e8);
        simplified.setEdge(e8.v, e8.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    };
    exports.simplify = simplify;
    var asNonCompoundGraph = function(g2) {
      var simplified = new graph_1.Graph({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
      g2.nodes().forEach(function(node) {
        var _a2;
        if (!((_a2 = g2.children(node)) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          simplified.setNode(node, g2.node(node));
        }
      });
      g2.edges().forEach(function(edge) {
        simplified.setEdgeObj(edge, g2.edge(edge));
      });
      return simplified;
    };
    exports.asNonCompoundGraph = asNonCompoundGraph;
    var zipObject = function(keys3, values3) {
      return keys3 === null || keys3 === void 0 ? void 0 : keys3.reduce(function(obj, key, i2) {
        obj[key] = values3[i2];
        return obj;
      }, {});
    };
    exports.zipObject = zipObject;
    var successorWeights = function(g2) {
      var weightsMap = {};
      g2.nodes().forEach(function(node) {
        var _a2;
        var sucs = {};
        (_a2 = g2.outEdges(node)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          var _a3;
          sucs[e8.w] = (sucs[e8.w] || 0) + (((_a3 = g2.edge(e8)) === null || _a3 === void 0 ? void 0 : _a3.weight) || 0);
        });
        weightsMap[node] = sucs;
      });
      return weightsMap;
    };
    exports.successorWeights = successorWeights;
    var predecessorWeights = function(g2) {
      var nodes = g2.nodes();
      var weightMap = nodes.map(function(v2) {
        var _a2;
        var preds = {};
        (_a2 = g2.inEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          preds[e8.v] = (preds[e8.v] || 0) + g2.edge(e8).weight;
        });
        return preds;
      });
      return (0, exports.zipObject)(nodes, weightMap);
    };
    exports.predecessorWeights = predecessorWeights;
    var intersectRect2 = function(rect2, point) {
      var x4 = Number(rect2.x);
      var y4 = Number(rect2.y);
      var dx = Number(point.x) - x4;
      var dy = Number(point.y) - y4;
      var w2 = Number(rect2.width) / 2;
      var h2 = Number(rect2.height) / 2;
      if (!dx && !dy) {
        return { x: 0, y: 0 };
      }
      var sx;
      var sy;
      if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
        if (dy < 0) {
          h2 = -h2;
        }
        sx = h2 * dx / dy;
        sy = h2;
      } else {
        if (dx < 0) {
          w2 = -w2;
        }
        sx = w2;
        sy = w2 * dy / dx;
      }
      return { x: x4 + sx, y: y4 + sy };
    };
    exports.intersectRect = intersectRect2;
    var buildLayerMatrix = function(g2) {
      var layeringNodes = [];
      var rankMax = (0, exports.maxRank)(g2) + 1;
      for (var i2 = 0; i2 < rankMax; i2++) {
        layeringNodes.push([]);
      }
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (!node)
          return;
        var rank = node.rank;
        if (rank !== void 0 && layeringNodes[rank]) {
          layeringNodes[rank].push(v2);
        }
      });
      for (var i2 = 0; i2 < rankMax; i2++) {
        layeringNodes[i2] = layeringNodes[i2].sort(function(va2, vb) {
          var _a2, _b;
          return safeSort((_a2 = g2.node(va2)) === null || _a2 === void 0 ? void 0 : _a2.order, (_b = g2.node(vb)) === null || _b === void 0 ? void 0 : _b.order);
        });
      }
      return layeringNodes;
    };
    exports.buildLayerMatrix = buildLayerMatrix;
    var normalizeRanks = function(g2) {
      var nodeRanks = g2.nodes().filter(function(v2) {
        var _a2;
        return ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) !== void 0;
      }).map(function(v2) {
        return g2.node(v2).rank;
      });
      var min6 = Math.min.apply(Math, nodeRanks);
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.hasOwnProperty("rank") && min6 !== Infinity) {
          node.rank -= min6;
        }
      });
    };
    exports.normalizeRanks = normalizeRanks;
    var removeEmptyRanks = function(g2) {
      var nodes = g2.nodes();
      var nodeRanks = nodes.filter(function(v2) {
        var _a2;
        return ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) !== void 0;
      }).map(function(v2) {
        return g2.node(v2).rank;
      });
      var offset = Math.min.apply(Math, nodeRanks);
      var layers = [];
      nodes.forEach(function(v2) {
        var _a2;
        var rank = (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) || 0) - offset;
        if (!layers[rank]) {
          layers[rank] = [];
        }
        layers[rank].push(v2);
      });
      var delta = 0;
      var nodeRankFactor = g2.graph().nodeRankFactor || 0;
      for (var i2 = 0; i2 < layers.length; i2++) {
        var vs = layers[i2];
        if (vs === void 0) {
          if (i2 % nodeRankFactor !== 0) {
            delta -= 1;
          }
        } else if (delta) {
          vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
            var node = g2.node(v2);
            if (node) {
              node.rank = node.rank || 0;
              node.rank += delta;
            }
          });
        }
      }
    };
    exports.removeEmptyRanks = removeEmptyRanks;
    var addBorderNode = function(g2, prefix, rank, order) {
      var node = {
        width: 0,
        height: 0
      };
      if ((0, util_1.isNumber)(rank) && (0, util_1.isNumber)(order)) {
        node.rank = rank;
        node.order = order;
      }
      return (0, exports.addDummyNode)(g2, "border", node, prefix);
    };
    exports.addBorderNode = addBorderNode;
    var maxRank = function(g2) {
      var maxRank2;
      g2.nodes().forEach(function(v2) {
        var _a2;
        var rank = (_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank;
        if (rank !== void 0) {
          if (maxRank2 === void 0 || rank > maxRank2) {
            maxRank2 = rank;
          }
        }
      });
      if (!maxRank2) {
        maxRank2 = 0;
      }
      return maxRank2;
    };
    exports.maxRank = maxRank;
    var partition = function(collection, fn2) {
      var result = { lhs: [], rhs: [] };
      collection === null || collection === void 0 ? void 0 : collection.forEach(function(value) {
        if (fn2(value)) {
          result.lhs.push(value);
        } else {
          result.rhs.push(value);
        }
      });
      return result;
    };
    exports.partition = partition;
    var time = function(name, fn2) {
      var start = Date.now();
      try {
        return fn2();
      } finally {
        console.log("".concat(name, " time: ").concat(Date.now() - start, "ms"));
      }
    };
    exports.time = time;
    var notime = function(name, fn2) {
      return fn2();
    };
    exports.notime = notime;
    var minBy = function(array, func) {
      return array.reduce(function(a3, b10) {
        var valA = func(a3);
        var valB = func(b10);
        return valA > valB ? b10 : a3;
      });
    };
    exports.minBy = minBy;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/normalize.js
var require_normalize = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/normalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var run = function(g2) {
      g2.graph().dummyChains = [];
      g2.edges().forEach(function(edge) {
        return normalizeEdge(g2, edge);
      });
    };
    var normalizeEdge = function(g2, e8) {
      var v2 = e8.v;
      var vRank = g2.node(v2).rank;
      var w2 = e8.w;
      var wRank = g2.node(w2).rank;
      var name = e8.name;
      var edgeLabel = g2.edge(e8);
      var labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1)
        return;
      g2.removeEdgeObj(e8);
      var graph = g2.graph();
      var dummy;
      var attrs;
      var i2;
      for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          edgeLabel,
          width: 0,
          height: 0,
          edgeObj: e8,
          rank: vRank
        };
        dummy = (0, util_1.addDummyNode)(g2, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g2.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
        if (i2 === 0) {
          if (!graph.dummyChains)
            graph.dummyChains = [];
          graph.dummyChains.push(dummy);
        }
        v2 = dummy;
      }
      g2.setEdge(v2, w2, { weight: edgeLabel.weight }, name);
    };
    var undo = function(g2) {
      var _a2;
      (_a2 = g2.graph().dummyChains) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        var node = g2.node(v2);
        var origLabel = node.edgeLabel;
        var w2;
        if (node.edgeObj) {
          g2.setEdgeObj(node.edgeObj, origLabel);
        }
        var currentV = v2;
        while (node.dummy) {
          w2 = g2.successors(currentV)[0];
          g2.removeNode(currentV);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          currentV = w2;
          node = g2.node(currentV);
        }
      });
    };
    exports.default = { run, undo };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/util.js
var require_util4 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.slack = exports.longestPathWithLayer = exports.longestPath = void 0;
    var longestPath = function(g2) {
      var _a2;
      var visited = {};
      var dfs3 = function(v2) {
        var _a3;
        var label = g2.node(v2);
        if (!label)
          return 0;
        if (visited[v2]) {
          return label.rank;
        }
        visited[v2] = true;
        var rank;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(edgeObj) {
          var wRank = dfs3(edgeObj.w);
          var minLen = g2.edge(edgeObj).minlen;
          var r2 = wRank - minLen;
          if (r2) {
            if (rank === void 0 || r2 < rank) {
              rank = r2;
            }
          }
        });
        if (!rank) {
          rank = 0;
        }
        label.rank = rank;
        return rank;
      };
      (_a2 = g2.sources()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(source) {
        return dfs3(source);
      });
    };
    exports.longestPath = longestPath;
    var longestPathWithLayer = function(g2) {
      var _a2;
      var visited = {};
      var minRank;
      var dfs3 = function(v2) {
        var _a3;
        var label = g2.node(v2);
        if (!label)
          return 0;
        if (visited[v2]) {
          return label.rank;
        }
        visited[v2] = true;
        var rank;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(edgeObj) {
          var wRank = dfs3(edgeObj.w);
          var minLen = g2.edge(edgeObj).minlen;
          var r2 = wRank - minLen;
          if (r2) {
            if (rank === void 0 || r2 < rank) {
              rank = r2;
            }
          }
        });
        if (!rank) {
          rank = 0;
        }
        if (minRank === void 0 || rank < minRank) {
          minRank = rank;
        }
        label.rank = rank;
        return rank;
      };
      (_a2 = g2.sources()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(source) {
        if (g2.node(source))
          dfs3(source);
      });
      if (minRank === void 0) {
        minRank = 0;
      }
      var forwardVisited = {};
      var dfsForward = function(v2, nextRank) {
        var _a3;
        var label = g2.node(v2);
        var currRank = !isNaN(label.layer) ? label.layer : nextRank;
        if (label.rank === void 0 || label.rank < currRank) {
          label.rank = currRank;
        }
        if (forwardVisited[v2])
          return;
        forwardVisited[v2] = true;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.map(function(e8) {
          dfsForward(e8.w, currRank + g2.edge(e8).minlen);
        });
      };
      g2.nodes().forEach(function(n2) {
        var label = g2.node(n2);
        if (!label)
          return;
        if (!isNaN(label.layer)) {
          dfsForward(n2, label.layer);
        } else {
          label.rank -= minRank;
        }
      });
    };
    exports.longestPathWithLayer = longestPathWithLayer;
    var slack = function(g2, e8) {
      return g2.node(e8.w).rank - g2.node(e8.v).rank - g2.edge(e8).minlen;
    };
    exports.slack = slack;
    exports.default = {
      longestPath,
      longestPathWithLayer,
      slack
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/feasible-tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feasibleTreeWithLayer = exports.feasibleTree = void 0;
    var util_1 = require_util4();
    var util_2 = require_util3();
    var graph_1 = require_graph();
    var feasibleTree = function(g2) {
      var t4 = new graph_1.Graph({ directed: false });
      var start = g2.nodes()[0];
      var size3 = g2.nodeCount();
      t4.setNode(start, {});
      var edge;
      var delta;
      while (tightTree(t4, g2) < size3) {
        edge = findMinSlackEdge(t4, g2);
        delta = t4.hasNode(edge.v) ? (0, util_1.slack)(g2, edge) : -(0, util_1.slack)(g2, edge);
        shiftRanks(t4, g2, delta);
      }
      return t4;
    };
    exports.feasibleTree = feasibleTree;
    var tightTree = function(t4, g2) {
      var dfs3 = function(v2) {
        g2.nodeEdges(v2).forEach(function(e8) {
          var edgeV = e8.v;
          var w2 = v2 === edgeV ? e8.w : edgeV;
          if (!t4.hasNode(w2) && !(0, util_1.slack)(g2, e8)) {
            t4.setNode(w2, {});
            t4.setEdge(v2, w2, {});
            dfs3(w2);
          }
        });
      };
      t4.nodes().forEach(dfs3);
      return t4.nodeCount();
    };
    var feasibleTreeWithLayer = function(g2) {
      var t4 = new graph_1.Graph({ directed: false });
      var start = g2.nodes()[0];
      var size3 = g2.nodes().filter(function(n2) {
        return !!g2.node(n2);
      }).length;
      t4.setNode(start, {});
      var edge;
      var delta;
      while (tightTreeWithLayer(t4, g2) < size3) {
        edge = findMinSlackEdge(t4, g2);
        delta = t4.hasNode(edge.v) ? (0, util_1.slack)(g2, edge) : -(0, util_1.slack)(g2, edge);
        shiftRanks(t4, g2, delta);
      }
      return t4;
    };
    exports.feasibleTreeWithLayer = feasibleTreeWithLayer;
    var tightTreeWithLayer = function(t4, g2) {
      var dfs3 = function(v2) {
        var _a2;
        (_a2 = g2.nodeEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          var edgeV = e8.v;
          var w2 = v2 === edgeV ? e8.w : edgeV;
          if (!t4.hasNode(w2) && (g2.node(w2).layer !== void 0 || !(0, util_1.slack)(g2, e8))) {
            t4.setNode(w2, {});
            t4.setEdge(v2, w2, {});
            dfs3(w2);
          }
        });
      };
      t4.nodes().forEach(dfs3);
      return t4.nodeCount();
    };
    var findMinSlackEdge = function(t4, g2) {
      return (0, util_2.minBy)(g2.edges(), function(e8) {
        if (t4.hasNode(e8.v) !== t4.hasNode(e8.w)) {
          return (0, util_1.slack)(g2, e8);
        }
        return Infinity;
      });
    };
    var shiftRanks = function(t4, g2, delta) {
      t4.nodes().forEach(function(v2) {
        if (!g2.node(v2).rank)
          g2.node(v2).rank = 0;
        g2.node(v2).rank += delta;
      });
    };
    exports.default = {
      feasibleTree,
      feasibleTreeWithLayer
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/network-simplex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exchangeEdges = exports.enterEdge = exports.leaveEdge = exports.initLowLimValues = exports.calcCutValue = exports.initCutValues = void 0;
    var feasible_tree_1 = require_feasible_tree();
    var util_1 = require_util4();
    var util_2 = require_util3();
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var preorder3 = graphlib_1.algorithm.preorder;
    var postorder3 = graphlib_1.algorithm.postorder;
    var networkSimplex = function(og) {
      var g2 = (0, util_2.simplify)(og);
      (0, util_1.longestPath)(g2);
      var t4 = (0, feasible_tree_1.feasibleTree)(g2);
      (0, exports.initLowLimValues)(t4);
      (0, exports.initCutValues)(t4, g2);
      var e8;
      var f2;
      while (e8 = (0, exports.leaveEdge)(t4)) {
        f2 = (0, exports.enterEdge)(t4, g2, e8);
        (0, exports.exchangeEdges)(t4, g2, e8, f2);
      }
    };
    var initCutValues = function(t4, g2) {
      var vs = postorder3(t4, t4.nodes());
      vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        assignCutValue(t4, g2, v2);
      });
    };
    exports.initCutValues = initCutValues;
    var assignCutValue = function(t4, g2, child) {
      var childLab = t4.node(child);
      var parent = childLab.parent;
      t4.edgeFromArgs(child, parent).cutvalue = (0, exports.calcCutValue)(t4, g2, child);
    };
    var calcCutValue = function(t4, g2, child) {
      var _a2;
      var childLab = t4.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g2.edgeFromArgs(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g2.edgeFromArgs(parent, child);
      }
      cutValue = graphEdge.weight;
      (_a2 = g2.nodeEdges(child)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var isOutEdge = e8.v === child;
        var other = isOutEdge ? e8.w : e8.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail;
          var otherWeight = g2.edge(e8).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t4, child, other)) {
            var otherCutValue = t4.edgeFromArgs(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    };
    exports.calcCutValue = calcCutValue;
    var initLowLimValues = function(tree, root) {
      if (root === void 0) {
        root = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root);
    };
    exports.initLowLimValues = initLowLimValues;
    var dfsAssignLowLim = function(tree, visited, nextLim, v2, parent) {
      var _a2;
      var low = nextLim;
      var useNextLim = nextLim;
      var label = tree.node(v2);
      visited[v2] = true;
      (_a2 = tree.neighbors(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(w2) {
        if (!visited[w2]) {
          useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w2, v2);
        }
      });
      label.low = low;
      label.lim = useNextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return useNextLim;
    };
    var leaveEdge = function(tree) {
      return tree.edges().find(function(e8) {
        return tree.edge(e8).cutvalue < 0;
      });
    };
    exports.leaveEdge = leaveEdge;
    var enterEdge = function(t4, g2, edge) {
      var v2 = edge.v;
      var w2 = edge.w;
      if (!g2.hasEdge(v2, w2)) {
        v2 = edge.w;
        w2 = edge.v;
      }
      var vLabel = t4.node(v2);
      var wLabel = t4.node(w2);
      var tailLabel = vLabel;
      var flip2 = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip2 = true;
      }
      var candidates = g2.edges().filter(function(edge2) {
        return flip2 === isDescendant(t4, t4.node(edge2.v), tailLabel) && flip2 !== isDescendant(t4, t4.node(edge2.w), tailLabel);
      });
      return (0, util_2.minBy)(candidates, function(edge2) {
        return (0, util_1.slack)(g2, edge2);
      });
    };
    exports.enterEdge = enterEdge;
    var exchangeEdges = function(t4, g2, e8, f2) {
      var v2 = e8.v;
      var w2 = e8.w;
      t4.removeEdge(v2, w2);
      t4.setEdge(f2.v, f2.w, {});
      (0, exports.initLowLimValues)(t4);
      (0, exports.initCutValues)(t4, g2);
      updateRanks(t4, g2);
    };
    exports.exchangeEdges = exchangeEdges;
    var updateRanks = function(t4, g2) {
      var root = t4.nodes().find(function(v2) {
        var _a2;
        return !((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.parent);
      });
      var vs = preorder3(t4, root);
      vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        var parent = t4.node(v2).parent;
        var edge = g2.edgeFromArgs(v2, parent);
        var flipped = false;
        if (!edge) {
          edge = g2.edgeFromArgs(parent, v2);
          flipped = true;
        }
        g2.node(v2).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    };
    var isTreeEdge = function(tree, u2, v2) {
      return tree.hasEdge(u2, v2);
    };
    var isDescendant = function(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    };
    exports.default = networkSimplex;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/index.js
var require_rank = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util4();
    var feasible_tree_1 = require_feasible_tree();
    var network_simplex_1 = __importDefault2(require_network_simplex());
    var rank = function(g2) {
      switch (g2.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g2);
          break;
        case "tight-tree":
          tightTreeRanker(g2);
          break;
        case "longest-path":
          longestPathRanker(g2);
          break;
        default:
          tightTreeRanker(g2);
      }
    };
    var longestPathRanker = util_1.longestPath;
    var tightTreeRanker = function(g2) {
      (0, util_1.longestPathWithLayer)(g2);
      (0, feasible_tree_1.feasibleTreeWithLayer)(g2);
    };
    var networkSimplexRanker = function(g2) {
      (0, network_simplex_1.default)(g2);
    };
    exports.default = rank;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/parent-dummy-chains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dfsBothOrder = function(g2) {
      var _a2;
      var result = {};
      var lim = 0;
      var dfs3 = function(v2) {
        var _a3;
        var low = lim;
        (_a3 = g2.children(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(dfs3);
        result[v2] = { low, lim: lim++ };
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(dfs3);
      return result;
    };
    var findPath = function(g2, postorderNums, v2, w2) {
      var vPath = [];
      var wPath = [];
      var low = Math.min(postorderNums[v2].low, postorderNums[w2].low);
      var lim = Math.max(postorderNums[v2].lim, postorderNums[w2].lim);
      var parent;
      var lca;
      parent = v2;
      do {
        parent = g2.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w2;
      while (parent && parent !== lca) {
        wPath.push(parent);
        parent = g2.parent(parent);
      }
      return { lca, path: vPath.concat(wPath.reverse()) };
    };
    var parentDummyChains = function(g2) {
      var _a2;
      var postorderNums = dfsBothOrder(g2);
      (_a2 = g2.graph().dummyChains) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(startV) {
        var _a3, _b;
        var v2 = startV;
        var node = g2.node(v2);
        var edgeObj = node.edgeObj;
        if (!edgeObj)
          return;
        var pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w);
        var path = pathData.path;
        var lca = pathData.lca;
        var pathIdx = 0;
        var pathV = path[pathIdx];
        var ascending = true;
        while (v2 !== edgeObj.w) {
          node = g2.node(v2);
          if (ascending) {
            while (pathV !== lca && ((_a3 = g2.node(pathV)) === null || _a3 === void 0 ? void 0 : _a3.maxRank) < node.rank) {
              pathIdx++;
              pathV = path[pathIdx];
            }
            if (pathV === lca) {
              ascending = false;
            }
          }
          if (!ascending) {
            while (pathIdx < path.length - 1 && ((_b = g2.node(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.minRank) <= node.rank) {
              pathIdx++;
            }
            pathV = path[pathIdx];
          }
          g2.setParent(v2, pathV);
          v2 = g2.successors(v2)[0];
        }
      });
    };
    exports.default = parentDummyChains;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/nesting-graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var run = function(g2) {
      var _a2;
      var root = (0, util_1.addDummyNode)(g2, "root", {}, "_root");
      var depths = treeDepths(g2);
      var maxDepth = Math.max.apply(Math, Object.values(depths));
      if (Math.abs(maxDepth) === Infinity) {
        maxDepth = 1;
      }
      var height = maxDepth - 1;
      var nodeSep = 2 * height + 1;
      g2.graph().nestingRoot = root;
      g2.edges().forEach(function(e8) {
        g2.edge(e8).minlen *= nodeSep;
      });
      var weight = sumWeights(g2) + 1;
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
        dfs3(g2, root, nodeSep, weight, height, depths, child);
      });
      g2.graph().nodeRankFactor = nodeSep;
    };
    var dfs3 = function(g2, root, nodeSep, weight, height, depths, v2) {
      var children = g2.children(v2);
      if (!(children === null || children === void 0 ? void 0 : children.length)) {
        if (v2 !== root) {
          g2.setEdge(root, v2, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      var top = (0, util_1.addBorderNode)(g2, "_bt");
      var bottom = (0, util_1.addBorderNode)(g2, "_bb");
      var label = g2.node(v2);
      g2.setParent(top, v2);
      label.borderTop = top;
      g2.setParent(bottom, v2);
      label.borderBottom = bottom;
      children === null || children === void 0 ? void 0 : children.forEach(function(child) {
        dfs3(g2, root, nodeSep, weight, height, depths, child);
        var childNode = g2.node(child);
        var childTop = childNode.borderTop ? childNode.borderTop : child;
        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        var thisWeight = childNode.borderTop ? weight : 2 * weight;
        var minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
        g2.setEdge(top, childTop, {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        });
        g2.setEdge(childBottom, bottom, {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        });
      });
      if (!g2.parent(v2)) {
        g2.setEdge(root, top, { weight: 0, minlen: height + depths[v2] });
      }
    };
    var treeDepths = function(g2) {
      var _a2;
      var depths = {};
      var dfs4 = function(v2, depth) {
        var children = g2.children(v2);
        children === null || children === void 0 ? void 0 : children.forEach(function(child) {
          return dfs4(child, depth + 1);
        });
        depths[v2] = depth;
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        return dfs4(v2, 1);
      });
      return depths;
    };
    var sumWeights = function(g2) {
      var result = 0;
      g2.edges().forEach(function(e8) {
        result += g2.edge(e8).weight;
      });
      return result;
    };
    var cleanup = function(g2) {
      var graphLabel = g2.graph();
      graphLabel.nestingRoot && g2.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge.nestingEdge) {
          g2.removeEdgeObj(e8);
        }
      });
    };
    exports.default = { run, cleanup };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/add-border-segments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var addBorderSegments = function(g2) {
      var _a2;
      var dfs3 = function(v2) {
        var children = g2.children(v2);
        var node = g2.node(v2);
        if (children === null || children === void 0 ? void 0 : children.length) {
          children.forEach(function(child) {
            return dfs3(child);
          });
        }
        if (node.hasOwnProperty("minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; rank += 1) {
            addBorderNode(g2, "borderLeft", "_bl", v2, node, rank);
            addBorderNode(g2, "borderRight", "_br", v2, node, rank);
          }
        }
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
        return dfs3(child);
      });
    };
    var addBorderNode = function(g2, prop, prefix, sg, sgNode, rank) {
      var label = { rank, borderType: prop, width: 0, height: 0 };
      var prev = sgNode[prop][rank - 1];
      var curr = (0, util_1.addDummyNode)(g2, "border", label, prefix);
      sgNode[prop][rank] = curr;
      g2.setParent(curr, sg);
      if (prev) {
        g2.setEdge(prev, curr, { weight: 1 });
      }
    };
    exports.default = addBorderSegments;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/coordinate-system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var adjust = function(g2) {
      var _a2;
      var rankDir = (_a2 = g2.graph().rankdir) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g2);
      }
    };
    var undo = function(g2) {
      var _a2;
      var rankDir = (_a2 = g2.graph().rankdir) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g2);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g2);
        swapWidthHeight(g2);
      }
    };
    var swapWidthHeight = function(g2) {
      g2.nodes().forEach(function(v2) {
        swapWidthHeightOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        swapWidthHeightOne(g2.edge(e8));
      });
    };
    var swapWidthHeightOne = function(attrs) {
      var w2 = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w2;
    };
    var reverseY = function(g2) {
      g2.nodes().forEach(function(v2) {
        reverseYOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(point) {
          return reverseYOne(point);
        });
        if (edge.hasOwnProperty("y")) {
          reverseYOne(edge);
        }
      });
    };
    var reverseYOne = function(attrs) {
      if (attrs === null || attrs === void 0 ? void 0 : attrs.y) {
        attrs.y = -attrs.y;
      }
    };
    var swapXY = function(g2) {
      g2.nodes().forEach(function(v2) {
        swapXYOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(point) {
          return swapXYOne(point);
        });
        if (edge.hasOwnProperty("x")) {
          swapXYOne(edge);
        }
      });
    };
    var swapXYOne = function(attrs) {
      var x4 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x4;
    };
    exports.default = { adjust, undo };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/rgb2arr.js
function rgb2arr(str10) {
  return [parseInt(str10.substr(1, 2), 16), parseInt(str10.substr(3, 2), 16), parseInt(str10.substr(5, 2), 16)];
}
var init_rgb2arr = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/rgb2arr.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/arr2rgb.js
function toHex2(value) {
  var x16Value = Math.round(value).toString(16);
  return x16Value.length === 1 ? "0".concat(x16Value) : x16Value;
}
function arr2rgb(arr) {
  return "#".concat(toHex2(arr[0])).concat(toHex2(arr[1])).concat(toHex2(arr[2]));
}
var init_arr2rgb = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/arr2rgb.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array-like.js
var isArrayLike2, is_array_like_default2;
var init_is_array_like2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array-like.js"() {
    isArrayLike2 = function(value) {
      return value !== null && typeof value !== "function" && isFinite(value.length);
    };
    is_array_like_default2 = isArrayLike2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/contains.js
var contains2, contains_default2;
var init_contains2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/contains.js"() {
    init_is_array_like2();
    contains2 = function(arr, value) {
      if (!is_array_like_default2(arr)) {
        return false;
      }
      return arr.indexOf(value) > -1;
    };
    contains_default2 = contains2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/filter.js
var filter2, filter_default2;
var init_filter2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/filter.js"() {
    init_is_array_like2();
    filter2 = function(arr, func) {
      if (!is_array_like_default2(arr)) {
        return arr;
      }
      var result = [];
      for (var index2 = 0; index2 < arr.length; index2++) {
        var value = arr[index2];
        if (func(value, index2)) {
          result.push(value);
        }
      }
      return result;
    };
    filter_default2 = filter2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/difference.js
var difference2, difference_default2;
var init_difference2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/difference.js"() {
    init_filter2();
    init_contains2();
    difference2 = function(arr, values3) {
      if (values3 === void 0) {
        values3 = [];
      }
      return filter_default2(arr, function(value) {
        return !contains_default2(values3, value);
      });
    };
    difference_default2 = difference2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-function.js
function isFunction2(value) {
  return typeof value === "function";
}
var init_is_function2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-function.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-nil.js
function isNil2(value) {
  return value === null || value === void 0;
}
var init_is_nil2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-nil.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array.js
function isArray(value) {
  return Array.isArray(value);
}
var init_is_array2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default2;
var init_is_object2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object.js"() {
    is_object_default2 = function(value) {
      var type = typeof value;
      return value !== null && type === "object" || type === "function";
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/each.js
function each2(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray(elements)) {
    for (var i2 = 0, len6 = elements.length; i2 < len6; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default2(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default2;
var init_each2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/each.js"() {
    init_is_array2();
    init_is_object2();
    each_default2 = each2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/keys.js
var keys2, keys_default2;
var init_keys2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/keys.js"() {
    init_each2();
    init_is_function2();
    keys2 = Object.keys ? function(obj) {
      return Object.keys(obj);
    } : function(obj) {
      var result = [];
      each_default2(obj, function(value, key) {
        if (!(isFunction2(obj) && key === "prototype")) {
          result.push(key);
        }
      });
      return result;
    };
    keys_default2 = keys2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-match.js
function isMatch2(obj, attrs) {
  var _keys = keys_default2(attrs);
  var length6 = _keys.length;
  if (isNil2(obj))
    return !length6;
  for (var i2 = 0; i2 < length6; i2 += 1) {
    var key = _keys[i2];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default2;
var init_is_match2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-match.js"() {
    init_is_nil2();
    init_keys2();
    is_match_default2 = isMatch2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike2, is_object_like_default2;
var init_is_object_like2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object-like.js"() {
    isObjectLike2 = function(value) {
      return typeof value === "object" && value !== null;
    };
    is_object_like_default2 = isObjectLike2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-type.js
var toString4, isType2, is_type_default2;
var init_is_type2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-type.js"() {
    toString4 = {}.toString;
    isType2 = function(value, type) {
      return toString4.call(value) === "[object " + type + "]";
    };
    is_type_default2 = isType2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject2, is_plain_object_default2;
var init_is_plain_object2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-plain-object.js"() {
    init_is_object_like2();
    init_is_type2();
    isPlainObject2 = function(value) {
      if (!is_object_like_default2(value) || !is_type_default2(value, "Object")) {
        return false;
      }
      if (Object.getPrototypeOf(value) === null) {
        return true;
      }
      var proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    };
    is_plain_object_default2 = isPlainObject2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find.js
function find3(arr, predicate) {
  if (!isArray(arr))
    return null;
  var _predicate;
  if (isFunction2(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default2(predicate)) {
    _predicate = function(a3) {
      return is_match_default2(a3, predicate);
    };
  }
  if (_predicate) {
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      if (_predicate(arr[i2])) {
        return arr[i2];
      }
    }
  }
  return null;
}
var find_default3;
var init_find3 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find.js"() {
    init_is_function2();
    init_is_match2();
    init_is_array2();
    init_is_plain_object2();
    find_default3 = find3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find-index.js
function findIndex2(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i2 = fromIndex; i2 < arr.length; i2++) {
    if (predicate(arr[i2], i2)) {
      return i2;
    }
  }
  return -1;
}
var find_index_default2;
var init_find_index2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find-index.js"() {
    find_index_default2 = findIndex2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/first-value.js
var firstValue2, first_value_default2;
var init_first_value2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/first-value.js"() {
    init_is_nil2();
    init_is_array2();
    firstValue2 = function(data, name) {
      var rst = null;
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!isNil2(value)) {
          if (isArray(value)) {
            rst = value[0];
          } else {
            rst = value;
          }
          break;
        }
      }
      return rst;
    };
    first_value_default2 = firstValue2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten.js
var flatten2, flatten_default2;
var init_flatten2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten.js"() {
    init_is_array2();
    flatten2 = function(arr) {
      if (!isArray(arr)) {
        return [];
      }
      var rst = [];
      for (var i2 = 0; i2 < arr.length; i2++) {
        rst = rst.concat(arr[i2]);
      }
      return rst;
    };
    flatten_default2 = flatten2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten-deep.js
var flattenDeep2, flatten_deep_default2;
var init_flatten_deep2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten-deep.js"() {
    init_is_array2();
    flattenDeep2 = function(arr, result) {
      if (result === void 0) {
        result = [];
      }
      if (!isArray(arr)) {
        result.push(arr);
      } else {
        for (var i2 = 0; i2 < arr.length; i2 += 1) {
          flattenDeep2(arr[i2], result);
        }
      }
      return result;
    };
    flatten_deep_default2 = flattenDeep2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max.js
function max4(arr) {
  if (!Array.isArray(arr))
    return -Infinity;
  var length6 = arr.length;
  if (!length6)
    return -Infinity;
  var max8 = arr[0];
  for (var i2 = 1; i2 < length6; i2++) {
    max8 = Math.max(max8, arr[i2]);
  }
  return max8;
}
var init_max2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min.js
var min_default2;
var init_min2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min.js"() {
    init_is_array2();
    min_default2 = function(arr) {
      if (!isArray(arr)) {
        return void 0;
      }
      return arr.reduce(function(prev, curr) {
        return Math.min(prev, curr);
      }, arr[0]);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-range.js
var getRange2, get_range_default2;
var init_get_range2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-range.js"() {
    init_is_array2();
    init_max2();
    init_min2();
    getRange2 = function(values3) {
      var filterValues = values3.filter(function(v2) {
        return !isNaN(v2);
      });
      if (!filterValues.length) {
        return {
          min: 0,
          max: 0
        };
      }
      if (isArray(values3[0])) {
        var tmp = [];
        for (var i2 = 0; i2 < values3.length; i2++) {
          tmp = tmp.concat(values3[i2]);
        }
        filterValues = tmp;
      }
      var max8 = max4(filterValues);
      var min6 = min_default2(filterValues);
      return {
        min: min6,
        max: max8
      };
    };
    get_range_default2 = getRange2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype2, splice3, indexOf3, pull2, pull_default2;
var init_pull2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull.js"() {
    arrPrototype2 = Array.prototype;
    splice3 = arrPrototype2.splice;
    indexOf3 = arrPrototype2.indexOf;
    pull2 = function(arr) {
      var values3 = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        values3[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < values3.length; i2++) {
        var value = values3[i2];
        var fromIndex = -1;
        while ((fromIndex = indexOf3.call(arr, value)) > -1) {
          splice3.call(arr, fromIndex, 1);
        }
      }
      return arr;
    };
    pull_default2 = pull2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull-at.js
var splice4, pullAt3, pull_at_default2;
var init_pull_at2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull-at.js"() {
    init_is_array_like2();
    splice4 = Array.prototype.splice;
    pullAt3 = function pullAt4(arr, indexes) {
      if (!is_array_like_default2(arr)) {
        return [];
      }
      var length6 = arr ? indexes.length : 0;
      var last3 = length6 - 1;
      while (length6--) {
        var previous = void 0;
        var index2 = indexes[length6];
        if (length6 === last3 || index2 !== previous) {
          previous = index2;
          splice4.call(arr, index2, 1);
        }
      }
      return arr;
    };
    pull_at_default2 = pullAt3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/reduce.js
var reduce2, reduce_default2;
var init_reduce2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/reduce.js"() {
    init_each2();
    init_is_array2();
    init_is_plain_object2();
    reduce2 = function(arr, fn2, init) {
      if (!isArray(arr) && !is_plain_object_default2(arr)) {
        return arr;
      }
      var result = init;
      each_default2(arr, function(data, i2) {
        result = fn2(result, data, i2);
      });
      return result;
    };
    reduce_default2 = reduce2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/remove.js
var remove2, remove_default3;
var init_remove3 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/remove.js"() {
    init_is_array_like2();
    init_pull_at2();
    remove2 = function(arr, predicate) {
      var result = [];
      if (!is_array_like_default2(arr)) {
        return result;
      }
      var i2 = -1;
      var indexes = [];
      var length6 = arr.length;
      while (++i2 < length6) {
        var value = arr[i2];
        if (predicate(value, i2, arr)) {
          result.push(value);
          indexes.push(i2);
        }
      }
      pull_at_default2(arr, indexes);
      return result;
    };
    remove_default3 = remove2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-string.js
function isString(value) {
  return typeof value === "string";
}
var init_is_string2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-string.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/sort-by.js
function sortBy2(arr, key) {
  var comparer;
  if (isFunction2(key)) {
    comparer = function(a3, b10) {
      return key(a3) - key(b10);
    };
  } else {
    var keys_1 = [];
    if (isString(key)) {
      keys_1.push(key);
    } else if (isArray(key)) {
      keys_1 = key;
    }
    comparer = function(a3, b10) {
      for (var i2 = 0; i2 < keys_1.length; i2 += 1) {
        var prop = keys_1[i2];
        if (a3[prop] > b10[prop]) {
          return 1;
        }
        if (a3[prop] < b10[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
var sort_by_default2;
var init_sort_by2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/sort-by.js"() {
    init_is_array2();
    init_is_string2();
    init_is_function2();
    sort_by_default2 = sortBy2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/uniq.js
function uniq2(arr, cache3) {
  if (cache3 === void 0) {
    cache3 = /* @__PURE__ */ new Map();
  }
  var r2 = [];
  if (Array.isArray(arr)) {
    for (var i2 = 0, len6 = arr.length; i2 < len6; i2++) {
      var item = arr[i2];
      if (!cache3.has(item)) {
        r2.push(item);
        cache3.set(item, true);
      }
    }
  }
  return r2;
}
var init_uniq2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/uniq.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/union.js
var union2, union_default2;
var init_union2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/union.js"() {
    init_uniq2();
    union2 = function() {
      var sources = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        sources[_i2] = arguments[_i2];
      }
      return uniq2([].concat.apply([], sources));
    };
    union_default2 = union2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values-of-key.js
var values_of_key_default2;
var init_values_of_key2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values-of-key.js"() {
    init_is_array2();
    init_is_nil2();
    values_of_key_default2 = function(data, name) {
      var rst = [];
      var tmpMap = {};
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!isNil2(value)) {
          if (!isArray(value)) {
            value = [value];
          }
          for (var j2 = 0; j2 < value.length; j2++) {
            var val = value[j2];
            if (!tmpMap[val]) {
              rst.push(val);
              tmpMap[val] = true;
            }
          }
        }
      }
      return rst;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/head.js
function head2(o2) {
  if (is_array_like_default2(o2)) {
    return o2[0];
  }
  return void 0;
}
var init_head2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/head.js"() {
    init_is_array_like2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/last.js
function last2(o2) {
  if (is_array_like_default2(o2)) {
    var arr = o2;
    return arr[arr.length - 1];
  }
  return void 0;
}
var init_last2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/last.js"() {
    init_is_array_like2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/starts-with.js
function startsWith2(arr, e8) {
  return isArray(arr) || isString(arr) ? arr[0] === e8 : false;
}
var starts_with_default2;
var init_starts_with2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/starts-with.js"() {
    init_is_array2();
    init_is_string2();
    starts_with_default2 = startsWith2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/ends-with.js
function endsWith2(arr, e8) {
  return isArray(arr) || isString(arr) ? arr[arr.length - 1] === e8 : false;
}
var ends_with_default2;
var init_ends_with2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/ends-with.js"() {
    init_is_array2();
    init_is_string2();
    ends_with_default2 = endsWith2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/every.js
var every2, every_default2;
var init_every2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/every.js"() {
    every2 = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (!func(arr[i2], i2))
          return false;
      }
      return true;
    };
    every_default2 = every2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/some.js
var some2, some_default2;
var init_some2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/some.js"() {
    some2 = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (func(arr[i2], i2))
          return true;
      }
      return false;
    };
    some_default2 = some2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-by.js
function groupBy2(data, condition) {
  if (!condition || !isArray(data)) {
    return {};
  }
  var result = {};
  var predicate = isFunction2(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i2 = 0; i2 < data.length; i2++) {
    var item = data[i2];
    key = predicate(item);
    if (hasOwnProperty4.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var hasOwnProperty4, group_by_default2;
var init_group_by2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-by.js"() {
    init_is_array2();
    init_is_function2();
    hasOwnProperty4 = Object.prototype.hasOwnProperty;
    group_by_default2 = groupBy2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-to-map.js
function groupToMap2(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }
  if (!isFunction2(condition)) {
    var paramscondition_1 = isArray(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i2 = 0, l2 = paramscondition_1.length; i2 < l2; i2++) {
        unique += row[paramscondition_1[i2]] && row[paramscondition_1[i2]].toString();
      }
      return unique;
    };
  }
  return group_by_default2(data, condition);
}
var init_group_to_map2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-to-map.js"() {
    init_is_array2();
    init_is_function2();
    init_group_by2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group.js
var group_default5;
var init_group2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group.js"() {
    init_group_to_map2();
    group_default5 = function(data, condition) {
      if (!condition) {
        return [data];
      }
      var groups = groupToMap2(data, condition);
      var array = [];
      for (var i2 in groups) {
        array.push(groups[i2]);
      }
      return array;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-wrap-behavior.js
function getWrapBehavior2(obj, action) {
  return obj["_wrap_" + action];
}
var get_wrap_behavior_default2;
var init_get_wrap_behavior2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-wrap-behavior.js"() {
    get_wrap_behavior_default2 = getWrapBehavior2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/wrap-behavior.js
function wrapBehavior2(obj, action) {
  if (obj["_wrap_" + action]) {
    return obj["_wrap_" + action];
  }
  var method = function(e8) {
    obj[action](e8);
  };
  obj["_wrap_" + action] = method;
  return method;
}
var wrap_behavior_default2;
var init_wrap_behavior2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/wrap-behavior.js"() {
    wrap_behavior_default2 = wrapBehavior2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/number2color.js
function numberToColor2(num) {
  var color3 = numColorCache2[num];
  if (!color3) {
    var str10 = num.toString(16);
    for (var i2 = str10.length; i2 < 6; i2++) {
      str10 = "0" + str10;
    }
    color3 = "#" + str10;
    numColorCache2[num] = color3;
  }
  return color3;
}
var numColorCache2, number2color_default2;
var init_number2color2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/number2color.js"() {
    numColorCache2 = {};
    number2color_default2 = numberToColor2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/parse-radius.js
function parseRadius4(radius) {
  var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
  if (isArray(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}
var parse_radius_default2;
var init_parse_radius2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/parse-radius.js"() {
    init_is_array2();
    parse_radius_default2 = parseRadius4;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clamp.js
var clamp2, clamp_default2;
var init_clamp2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clamp.js"() {
    clamp2 = function(a3, min6, max8) {
      if (a3 < min6) {
        return min6;
      } else if (a3 > max8) {
        return max8;
      }
      return a3;
    };
    clamp_default2 = clamp2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/fixed-base.js
var fixedBase2, fixed_base_default2;
var init_fixed_base2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/fixed-base.js"() {
    fixedBase2 = function(v2, base) {
      var str10 = base.toString();
      var index2 = str10.indexOf(".");
      if (index2 === -1) {
        return Math.round(v2);
      }
      var length6 = str10.substr(index2 + 1).length;
      if (length6 > 20) {
        length6 = 20;
      }
      return parseFloat(v2.toFixed(length6));
    };
    fixed_base_default2 = fixedBase2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number.js
function isNumber2(value) {
  return typeof value === "number";
}
var init_is_number2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-decimal.js
function isDecimal2(num) {
  return isNumber2(num) && num % 1 !== 0;
}
var init_is_decimal2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-decimal.js"() {
    init_is_number2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-even.js
function isEven2(num) {
  return isNumber2(num) && num % 2 === 0;
}
var init_is_even2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-even.js"() {
    init_is_number2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-integer.js
function isInteger2(value) {
  return isNumber2(value) && value % 1 === 0;
}
var init_is_integer2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-integer.js"() {
    init_is_number2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-negative.js
function isNegative2(num) {
  return isNumber2(num) && num < 0;
}
var init_is_negative2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-negative.js"() {
    init_is_number2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number-equal.js
function isNumberEqual3(a3, b10, precision) {
  if (precision === void 0) {
    precision = PRECISION2;
  }
  return a3 === b10 || Math.abs(a3 - b10) < precision;
}
var PRECISION2;
var init_is_number_equal2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number-equal.js"() {
    PRECISION2 = 1e-5;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-odd.js
function isOdd2(num) {
  return isNumber2(num) && num % 2 !== 0;
}
var init_is_odd2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-odd.js"() {
    init_is_number2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-positive.js
var isPositive2, is_positive_default2;
var init_is_positive2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-positive.js"() {
    init_is_number2();
    isPositive2 = function(num) {
      return isNumber2(num) && num > 0;
    };
    is_positive_default2 = isPositive2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max-by.js
var max_by_default2;
var init_max_by2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max-by.js"() {
    init_is_array2();
    init_is_function2();
    max_by_default2 = function(arr, fn2) {
      if (!isArray(arr)) {
        return void 0;
      }
      var maxItem;
      var max8 = -Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = isFunction2(fn2) ? fn2(item) : item[fn2];
        if (v2 > max8) {
          maxItem = item;
          max8 = v2;
        }
      }
      return maxItem;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min-by.js
var min_by_default2;
var init_min_by2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min-by.js"() {
    init_is_array2();
    init_is_function2();
    min_by_default2 = function(arr, fn2) {
      if (!isArray(arr)) {
        return void 0;
      }
      var minItem;
      var min6 = Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = isFunction2(fn2) ? fn2(item) : item[fn2];
        if (v2 < min6) {
          minItem = item;
          min6 = v2;
        }
      }
      return minItem;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mod.js
var mod2, mod_default2;
var init_mod2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mod.js"() {
    mod2 = function(n2, m3) {
      return (n2 % m3 + m3) % m3;
    };
    mod_default2 = mod2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE2, toDegree3, to_degree_default2;
var init_to_degree2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-degree.js"() {
    DEGREE2 = 180 / Math.PI;
    toDegree3 = function(radian2) {
      return DEGREE2 * radian2;
    };
    to_degree_default2 = toDegree3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-integer.js
var to_integer_default2;
var init_to_integer2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-integer.js"() {
    to_integer_default2 = parseInt;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN2, toRadian3, to_radian_default2;
var init_to_radian2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-radian.js"() {
    RADIAN2 = Math.PI / 180;
    toRadian3 = function(degree4) {
      return RADIAN2 * degree4;
    };
    to_radian_default2 = toRadian3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/for-in.js
var for_in_default2;
var init_for_in2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/for-in.js"() {
    init_each2();
    for_in_default2 = each_default2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has.js
var has_default2;
var init_has2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has.js"() {
    has_default2 = function(obj, key) {
      return obj.hasOwnProperty(key);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-key.js
var has_key_default2;
var init_has_key2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-key.js"() {
    init_has2();
    has_key_default2 = has_default2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values.js
var values2, values_default2;
var init_values2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values.js"() {
    init_each2();
    init_is_function2();
    values2 = Object.values ? function(obj) {
      return Object.values(obj);
    } : function(obj) {
      var result = [];
      each_default2(obj, function(value, key) {
        if (!(isFunction2(obj) && key === "prototype")) {
          result.push(value);
        }
      });
      return result;
    };
    values_default2 = values2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-value.js
var has_value_default2;
var init_has_value2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-value.js"() {
    init_contains2();
    init_values2();
    has_value_default2 = function(obj, value) {
      return contains_default2(values_default2(obj), value);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-string.js
var to_string_default2;
var init_to_string2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-string.js"() {
    init_is_nil2();
    to_string_default2 = function(value) {
      if (isNil2(value))
        return "";
      return value.toString();
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-case.js
var lowerCase2, lower_case_default2;
var init_lower_case2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-case.js"() {
    init_to_string2();
    lowerCase2 = function(str10) {
      return to_string_default2(str10).toLowerCase();
    };
    lower_case_default2 = lowerCase2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-first.js
var lowerFirst2, lower_first_default2;
var init_lower_first2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-first.js"() {
    init_to_string2();
    lowerFirst2 = function(value) {
      var str10 = to_string_default2(value);
      return str10.charAt(0).toLowerCase() + str10.substring(1);
    };
    lower_first_default2 = lowerFirst2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/substitute.js
function substitute4(str10, o2) {
  if (!str10 || !o2) {
    return str10;
  }
  return str10.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o2[name] === void 0 ? "" : o2[name];
  });
}
var substitute_default2;
var init_substitute2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/substitute.js"() {
    substitute_default2 = substitute4;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-case.js
var upperCase2, upper_case_default2;
var init_upper_case2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-case.js"() {
    init_to_string2();
    upperCase2 = function(str10) {
      return to_string_default2(str10).toUpperCase();
    };
    upper_case_default2 = upperCase2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-first.js
var upperFirst2, upper_first_default2;
var init_upper_first2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-first.js"() {
    init_to_string2();
    upperFirst2 = function(value) {
      var str10 = to_string_default2(value);
      return str10.charAt(0).toUpperCase() + str10.substring(1);
    };
    upper_first_default2 = upperFirst2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-type.js
var toString5, getType2, get_type_default2;
var init_get_type2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-type.js"() {
    toString5 = {}.toString;
    getType2 = function(value) {
      return toString5.call(value).replace(/^\[object /, "").replace(/]$/, "");
    };
    get_type_default2 = getType2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-arguments.js
var isArguments2, is_arguments_default2;
var init_is_arguments2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-arguments.js"() {
    init_is_type2();
    isArguments2 = function(value) {
      return is_type_default2(value, "Arguments");
    };
    is_arguments_default2 = isArguments2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean2, is_boolean_default2;
var init_is_boolean2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-boolean.js"() {
    init_is_type2();
    isBoolean2 = function(value) {
      return is_type_default2(value, "Boolean");
    };
    is_boolean_default2 = isBoolean2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-date.js
function isDate2(value) {
  return value instanceof Date;
}
var init_is_date2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-date.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-error.js
var isError2, is_error_default2;
var init_is_error2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-error.js"() {
    init_is_type2();
    isError2 = function(value) {
      return is_type_default2(value, "Error");
    };
    is_error_default2 = isError2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-finite.js
function is_finite_default2(value) {
  return isNumber2(value) && isFinite(value);
}
var init_is_finite2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-finite.js"() {
    init_is_number2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-null.js
function isNull2(value) {
  return value === null;
}
var init_is_null2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-null.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto2, isPrototype2, is_prototype_default2;
var init_is_prototype2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-prototype.js"() {
    objectProto2 = Object.prototype;
    isPrototype2 = function(value) {
      var Ctor = value && value.constructor;
      var proto = typeof Ctor === "function" && Ctor.prototype || objectProto2;
      return value === proto;
    };
    is_prototype_default2 = isPrototype2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-reg-exp.js
var isRegExp2, is_reg_exp_default2;
var init_is_reg_exp2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-reg-exp.js"() {
    init_is_type2();
    isRegExp2 = function(str10) {
      return is_type_default2(str10, "RegExp");
    };
    is_reg_exp_default2 = isRegExp2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined2, is_undefined_default2;
var init_is_undefined2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-undefined.js"() {
    isUndefined2 = function(value) {
      return value === void 0;
    };
    is_undefined_default2 = isUndefined2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-element.js
function isElement2(value) {
  return value instanceof Element || value instanceof Document;
}
var init_is_element2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-element.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/request-animation-frame.js
function requestAnimationFrame3(fn2) {
  var method = window.requestAnimationFrame || // @ts-ignore
  window.webkitRequestAnimationFrame || // @ts-ignore
  window.mozRequestAnimationFrame || // @ts-ignore
  window.msRequestAnimationFrame || function(f2) {
    return setTimeout(f2, 16);
  };
  return method(fn2);
}
var init_request_animation_frame2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/request-animation-frame.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clear-animation-frame.js
function cancelAnimationFrame3(handler) {
  var method = window.cancelAnimationFrame || // @ts-ignore
  window.webkitCancelAnimationFrame || // @ts-ignore
  window.mozCancelAnimationFrame || // @ts-ignore
  window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}
var init_clear_animation_frame2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clear-animation-frame.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mix.js
function _mix2(dist4, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist4[key] = obj[key];
    }
  }
}
function mix2(dist4, src1, src2, src3) {
  if (src1)
    _mix2(dist4, src1);
  if (src2)
    _mix2(dist4, src2);
  if (src3)
    _mix2(dist4, src3);
  return dist4;
}
var init_mix2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mix.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/augment.js
var augment2, augment_default2;
var init_augment2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/augment.js"() {
    init_mix2();
    init_is_function2();
    augment2 = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var c3 = args[0];
      for (var i2 = 1; i2 < args.length; i2++) {
        var obj = args[i2];
        if (isFunction2(obj)) {
          obj = obj.prototype;
        }
        mix2(c3.prototype, obj);
      }
    };
    augment_default2 = augment2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clone.js
var clone12, clone_default2;
var init_clone2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clone.js"() {
    init_is_array2();
    clone12 = function(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var rst;
      if (isArray(obj)) {
        rst = [];
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          if (typeof obj[i2] === "object" && obj[i2] != null) {
            rst[i2] = clone12(obj[i2]);
          } else {
            rst[i2] = obj[i2];
          }
        }
      } else {
        rst = {};
        for (var k2 in obj) {
          if (typeof obj[k2] === "object" && obj[k2] != null) {
            rst[k2] = clone12(obj[k2]);
          } else {
            rst[k2] = obj[k2];
          }
        }
      }
      return rst;
    };
    clone_default2 = clone12;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/debounce.js
function debounce2(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default2;
var init_debounce2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/debounce.js"() {
    debounce_default2 = debounce2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/memoize.js
function flru(max8) {
  var num, curr, prev;
  var limit = max8 || 1;
  function keep(key, value) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value) {
      if (curr[key] !== void 0) {
        curr[key] = value;
      } else {
        keep(key, value);
      }
    }
  };
}
function memoize(fn2, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  var memoized = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    if (!CacheMap.has(fn2))
      CacheMap.set(fn2, flru(maxSize));
    var cache3 = CacheMap.get(fn2);
    if (cache3.has(key))
      return cache3.get(key);
    var result = fn2.apply(this, args);
    cache3.set(key, result);
    return result;
  };
  return memoized;
}
var CacheMap;
var init_memoize2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/memoize.js"() {
    CacheMap = /* @__PURE__ */ new Map();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/deep-mix.js
function hasOwn(object, property) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix2(dist4, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL2;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value = src[key];
      if (value !== null && is_plain_object_default2(value)) {
        if (!is_plain_object_default2(dist4[key])) {
          dist4[key] = {};
        }
        if (level < maxLevel) {
          _deepMix2(dist4[key], value, level + 1, maxLevel);
        } else {
          dist4[key] = src[key];
        }
      } else if (isArray(value)) {
        dist4[key] = [];
        dist4[key] = dist4[key].concat(value);
      } else if (value !== void 0) {
        dist4[key] = value;
      }
    }
  }
}
var MAX_MIX_LEVEL2, deepMix2, deep_mix_default2;
var init_deep_mix2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/deep-mix.js"() {
    init_is_array2();
    init_is_plain_object2();
    MAX_MIX_LEVEL2 = 5;
    deepMix2 = function(rst) {
      var args = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        args[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < args.length; i2 += 1) {
        _deepMix2(rst, args[i2]);
      }
      return rst;
    };
    deep_mix_default2 = deepMix2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/extend.js
var extend3, extend_default2;
var init_extend2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/extend.js"() {
    init_mix2();
    init_is_function2();
    extend3 = function(subclass, superclass, overrides, staticOverrides) {
      if (!isFunction2(superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = function() {
        };
      }
      var create10 = Object.create ? function(proto, c3) {
        return Object.create(proto, {
          constructor: {
            value: c3
          }
        });
      } : function(proto, c3) {
        function Tmp() {
        }
        Tmp.prototype = proto;
        var o2 = new Tmp();
        o2.constructor = c3;
        return o2;
      };
      var superObj = create10(superclass.prototype, subclass);
      subclass.prototype = mix2(superObj, subclass.prototype);
      subclass.superclass = create10(superclass.prototype, superclass);
      mix2(superObj, overrides);
      mix2(subclass, staticOverrides);
      return subclass;
    };
    extend_default2 = extend3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index-of.js
var indexOf4, index_of_default2;
var init_index_of2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index-of.js"() {
    init_is_array_like2();
    indexOf4 = function(arr, obj) {
      if (!is_array_like_default2(arr)) {
        return -1;
      }
      var m3 = Array.prototype.indexOf;
      if (m3) {
        return m3.call(arr, obj);
      }
      var index2 = -1;
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2] === obj) {
          index2 = i2;
          break;
        }
      }
      return index2;
    };
    index_of_default2 = indexOf4;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-empty.js
function isEmpty2(value) {
  if (isNil2(value)) {
    return true;
  }
  if (is_array_like_default2(value)) {
    return !value.length;
  }
  var type = get_type_default2(value);
  if (type === "Map" || type === "Set") {
    return !value.size;
  }
  if (is_prototype_default2(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty5.call(value, key)) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty5, is_empty_default2;
var init_is_empty2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-empty.js"() {
    init_is_nil2();
    init_is_array_like2();
    init_get_type2();
    init_is_prototype2();
    hasOwnProperty5 = Object.prototype.hasOwnProperty;
    is_empty_default2 = isEmpty2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal.js
var isEqual3, is_equal_default2;
var init_is_equal2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal.js"() {
    init_is_object_like2();
    init_is_array_like2();
    init_is_string2();
    isEqual3 = function(value, other) {
      if (value === other) {
        return true;
      }
      if (!value || !other) {
        return false;
      }
      if (isString(value) || isString(other)) {
        return false;
      }
      if (is_array_like_default2(value) || is_array_like_default2(other)) {
        if (value.length !== other.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < value.length; i2++) {
          rst = isEqual3(value[i2], other[i2]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      if (is_object_like_default2(value) || is_object_like_default2(other)) {
        var valueKeys = Object.keys(value);
        var otherKeys = Object.keys(other);
        if (valueKeys.length !== otherKeys.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < valueKeys.length; i2++) {
          rst = isEqual3(value[valueKeys[i2]], other[valueKeys[i2]]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      return false;
    };
    is_equal_default2 = isEqual3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal-with.js
var is_equal_with_default2;
var init_is_equal_with2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal-with.js"() {
    init_is_function2();
    init_is_equal2();
    is_equal_with_default2 = function(value, other, fn2) {
      if (!isFunction2(fn2)) {
        return is_equal_default2(value, other);
      }
      return !!fn2(value, other);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map.js
var map3, map_default2;
var init_map2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map.js"() {
    init_is_array_like2();
    map3 = function(arr, func) {
      if (!is_array_like_default2(arr)) {
        return arr;
      }
      var result = [];
      for (var index2 = 0; index2 < arr.length; index2++) {
        var value = arr[index2];
        result.push(func(value, index2));
      }
      return result;
    };
    map_default2 = map3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map-values.js
var identity9, map_values_default2;
var init_map_values2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map-values.js"() {
    init_is_nil2();
    init_is_object2();
    identity9 = function(v2) {
      return v2;
    };
    map_values_default2 = function(object, func) {
      if (func === void 0) {
        func = identity9;
      }
      var r2 = {};
      if (is_object_default2(object) && !isNil2(object)) {
        Object.keys(object).forEach(function(key) {
          r2[key] = func(object[key], key);
        });
      }
      return r2;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get.js
var get_default2;
var init_get2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get.js"() {
    init_is_string2();
    get_default2 = function(obj, key, defaultValue) {
      var p2 = 0;
      var keyArr = isString(key) ? key.split(".") : key;
      while (obj && p2 < keyArr.length) {
        obj = obj[keyArr[p2++]];
      }
      return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/set.js
var set_default2;
var init_set2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/set.js"() {
    init_is_object2();
    init_is_string2();
    init_is_number2();
    set_default2 = function(obj, path, value) {
      var o2 = obj;
      var keyArr = isString(path) ? path.split(".") : path;
      keyArr.forEach(function(key, idx) {
        if (idx < keyArr.length - 1) {
          if (!is_object_default2(o2[key])) {
            o2[key] = isNumber2(keyArr[idx + 1]) ? [] : {};
          }
          o2 = o2[key];
        } else {
          o2[key] = value;
        }
      });
      return obj;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty6, pick_default2;
var init_pick2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pick.js"() {
    init_each2();
    init_is_plain_object2();
    hasOwnProperty6 = Object.prototype.hasOwnProperty;
    pick_default2 = function(object, keys3) {
      if (object === null || !is_plain_object_default2(object)) {
        return {};
      }
      var result = {};
      each_default2(keys3, function(key) {
        if (hasOwnProperty6.call(object, key)) {
          result[key] = object[key];
        }
      });
      return result;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/omit.js
var omit_default2;
var init_omit2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/omit.js"() {
    init_reduce2();
    omit_default2 = function(obj, keys3) {
      return reduce_default2(obj, function(r2, curr, key) {
        if (!keys3.includes(key)) {
          r2[key] = curr;
        }
        return r2;
      }, {});
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/throttle.js
var throttle_default2;
var init_throttle2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/throttle.js"() {
    throttle_default2 = function(func, wait, options) {
      var timeout2, context, args, result;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : Date.now();
        timeout2 = null;
        result = func.apply(context, args);
        if (!timeout2)
          context = args = null;
      };
      var throttled = function() {
        var now2 = Date.now();
        if (!previous && options.leading === false)
          previous = now2;
        var remaining = wait - (now2 - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout2) {
            clearTimeout(timeout2);
            timeout2 = null;
          }
          previous = now2;
          result = func.apply(context, args);
          if (!timeout2)
            context = args = null;
        } else if (!timeout2 && options.trailing !== false) {
          timeout2 = setTimeout(later, remaining);
        }
        return result;
      };
      throttled.cancel = function() {
        clearTimeout(timeout2);
        previous = 0;
        timeout2 = context = args = null;
      };
      return throttled;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-array.js
var to_array_default2;
var init_to_array2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-array.js"() {
    init_is_array_like2();
    to_array_default2 = function(value) {
      return is_array_like_default2(value) ? Array.prototype.slice.call(value) : [];
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/unique-id.js
var map4, unique_id_default2;
var init_unique_id2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/unique-id.js"() {
    map4 = {};
    unique_id_default2 = function(prefix) {
      prefix = prefix || "g";
      if (!map4[prefix]) {
        map4[prefix] = 1;
      } else {
        map4[prefix] += 1;
      }
      return prefix + map4[prefix];
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/noop.js
var noop_default2;
var init_noop2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/noop.js"() {
    noop_default2 = function() {
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/identity.js
var identity_default2;
var init_identity2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/identity.js"() {
    identity_default2 = function(v2) {
      return v2;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/size.js
function size2(o2) {
  if (isNil2(o2)) {
    return 0;
  }
  if (is_array_like_default2(o2)) {
    return o2.length;
  }
  return Object.keys(o2).length;
}
var init_size3 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/size.js"() {
    init_is_nil2();
    init_is_array_like2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/cache.js
var default_12, cache_default2;
var init_cache2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/cache.js"() {
    default_12 = /** @class */
    function() {
      function default_13() {
        this.map = {};
      }
      default_13.prototype.has = function(key) {
        return this.map[key] !== void 0;
      };
      default_13.prototype.get = function(key, def) {
        var v2 = this.map[key];
        return v2 === void 0 ? def : v2;
      };
      default_13.prototype.set = function(key, value) {
        this.map[key] = value;
      };
      default_13.prototype.clear = function() {
        this.map = {};
      };
      default_13.prototype.delete = function(key) {
        delete this.map[key];
      };
      default_13.prototype.size = function() {
        return Object.keys(this.map).length;
      };
      return default_13;
    }();
    cache_default2 = default_12;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index.js
var init_lodash = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index.js"() {
    init_contains2();
    init_difference2();
    init_find3();
    init_find_index2();
    init_first_value2();
    init_flatten2();
    init_flatten_deep2();
    init_get_range2();
    init_pull2();
    init_pull_at2();
    init_reduce2();
    init_remove3();
    init_sort_by2();
    init_union2();
    init_uniq2();
    init_values_of_key2();
    init_head2();
    init_last2();
    init_starts_with2();
    init_ends_with2();
    init_filter2();
    init_every2();
    init_some2();
    init_group2();
    init_group_by2();
    init_group_to_map2();
    init_get_wrap_behavior2();
    init_wrap_behavior2();
    init_number2color2();
    init_parse_radius2();
    init_clamp2();
    init_fixed_base2();
    init_is_decimal2();
    init_is_even2();
    init_is_integer2();
    init_is_negative2();
    init_is_number_equal2();
    init_is_odd2();
    init_is_positive2();
    init_max2();
    init_max_by2();
    init_min2();
    init_min_by2();
    init_mod2();
    init_to_degree2();
    init_to_integer2();
    init_to_radian2();
    init_for_in2();
    init_has2();
    init_has_key2();
    init_has_value2();
    init_keys2();
    init_is_match2();
    init_values2();
    init_lower_case2();
    init_lower_first2();
    init_substitute2();
    init_upper_case2();
    init_upper_first2();
    init_get_type2();
    init_is_arguments2();
    init_is_array2();
    init_is_array_like2();
    init_is_boolean2();
    init_is_date2();
    init_is_error2();
    init_is_function2();
    init_is_finite2();
    init_is_nil2();
    init_is_null2();
    init_is_number2();
    init_is_object2();
    init_is_object_like2();
    init_is_plain_object2();
    init_is_prototype2();
    init_is_reg_exp2();
    init_is_string2();
    init_is_type2();
    init_is_undefined2();
    init_is_element2();
    init_request_animation_frame2();
    init_clear_animation_frame2();
    init_augment2();
    init_clone2();
    init_debounce2();
    init_memoize2();
    init_deep_mix2();
    init_each2();
    init_extend2();
    init_index_of2();
    init_is_empty2();
    init_is_equal2();
    init_is_equal_with2();
    init_map2();
    init_map_values2();
    init_mix2();
    init_get2();
    init_set2();
    init_pick2();
    init_omit2();
    init_throttle2();
    init_to_array2();
    init_to_string2();
    init_unique_id2();
    init_noop2();
    init_identity2();
    init_size3();
    init_cache2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/torgb.js
function getTmp() {
  var i2 = document.getElementById("antv-web-colour-picker");
  if (i2) {
    return i2;
  }
  i2 = document.createElement("i");
  i2.id = "antv-web-colour-picker";
  i2.title = "Web Colour Picker";
  i2.style.display = "none";
  document.body.appendChild(i2);
  return i2;
}
function toRGBString(color3) {
  if (color3[0] === "#" && color3.length === 7) {
    return color3;
  }
  var iEl = getTmp();
  iEl.style.color = color3;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s2) {
    return Number(s2);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var RGB_REG, toRGB;
var init_torgb = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/torgb.js"() {
    init_lodash();
    init_arr2rgb();
    RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
    toRGB = memoize(toRGBString, function(color3) {
      return color3;
    }, 256);
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/gradient.js
function getValue2(start, end2, percent, index2) {
  return start[index2] + (end2[index2] - start[index2]) * percent;
}
function calColor(points, percent) {
  var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
  var steps = points.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left = steps * fixedPercent - step;
  var start = points[step];
  var end2 = step === steps ? start : points[step + 1];
  return arr2rgb([getValue2(start, end2, left, 0), getValue2(start, end2, left, 1), getValue2(start, end2, left, 2)]);
}
function gradient(colors) {
  var colorArray = typeof colors === "string" ? colors.split("-") : colors;
  var points = colorArray.map(function(color3) {
    return rgb2arr(color3.indexOf("#") === -1 ? toRGB(color3) : color3);
  });
  return function(percent) {
    return calColor(points, percent);
  };
}
var init_gradient = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/gradient.js"() {
    init_rgb2arr();
    init_arr2rgb();
    init_torgb();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/tocssgradient.js
function isGradientColor2(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
}
function toCSSGradient(gradientColor) {
  if (isGradientColor2(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === "l") {
      var arr = regexLG3.exec(gradientColor);
      var angle3 = +arr[1] + 90;
      steps = arr[2];
      cssColor_1 = "linear-gradient(".concat(angle3, "deg, ");
    } else if (gradientColor[0] === "r") {
      cssColor_1 = "radial-gradient(";
      var arr = regexRG3.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop3);
    colorStops_1.forEach(function(item, index2) {
      var itemArr = item.split(":");
      cssColor_1 += "".concat(itemArr[1], " ").concat(Number(itemArr[0]) * 100, "%");
      if (index2 !== colorStops_1.length - 1) {
        cssColor_1 += ", ";
      }
    });
    cssColor_1 += ")";
    return cssColor_1;
  }
  return gradientColor;
}
var regexLG3, regexRG3, regexColorStop3;
var init_tocssgradient = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/tocssgradient.js"() {
    regexLG3 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
    regexRG3 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
    regexColorStop3 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/index.js
var init_color = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/index.js"() {
    init_rgb2arr();
    init_gradient();
    init_torgb();
    init_tocssgradient();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/transform.js
function leftTranslate2(out, a3, v2) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v2);
  return mat3_exports.multiply(out, transMat, a3);
}
function leftRotate2(out, a3, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a3);
}
function leftScale2(out, a3, v2) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v2);
  return mat3_exports.multiply(out, scaleMat, a3);
}
function leftMultiply2(out, a3, a1) {
  return mat3_exports.multiply(out, a1, a3);
}
function transform9(m3, actions) {
  var matrix = m3 ? [].concat(m3) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0, len6 = actions.length; i2 < len6; i2++) {
    var action = actions[i2];
    switch (action[0]) {
      case "t":
        leftTranslate2(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale2(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate2(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply2(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
var init_transform = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/transform.js"() {
    init_esm2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/direction.js
function direction2(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
var init_direction = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/direction.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/angle-to.js
function angleTo2(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction2(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
var init_angle_to = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/angle-to.js"() {
    init_esm2();
    init_direction();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/vertical.js
function vertical2(out, v2, flag) {
  if (flag) {
    out[0] = v2[1];
    out[1] = -1 * v2[0];
  } else {
    out[0] = -1 * v2[1];
    out[1] = v2[0];
  }
  return out;
}
var init_vertical = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/vertical.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/index.js
var init_matrix = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/index.js"() {
    init_transform();
    init_angle_to();
    init_direction();
    init_vertical();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/round-path.js
function roundPath(path, round6) {
  if (round6 === "off")
    return [].concat(path);
  var pow2 = typeof round6 === "number" && round6 >= 1 ? Math.pow(10, round6) : 1;
  return path.map(function(pi3) {
    var values3 = pi3.slice(1).map(Number).map(function(n2) {
      return round6 ? Math.round(n2 * pow2) / pow2 : Math.round(n2);
    });
    return [pi3[0]].concat(values3);
  });
}
var init_round_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/round-path.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-string.js
function path2String(path, round6) {
  if (round6 === void 0) {
    round6 = "off";
  }
  return roundPath(path, round6).map(function(x4) {
    return x4[0] + x4.slice(1).join(" ");
  }).join("");
}
var init_path_2_string = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-string.js"() {
    init_round_path();
  }
});

// node_modules/@antv/layout/node_modules/tslib/tslib.es6.mjs
function __spreadArray4(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
    if (ar2 || !(i2 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
      ar2[i2] = from[i2];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}
var __assign4;
var init_tslib_es62 = __esm({
  "node_modules/@antv/layout/node_modules/tslib/tslib.es6.mjs"() {
    __assign4 = function() {
      __assign4 = Object.assign || function __assign18(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign4.apply(this, arguments);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser;
var init_params_parser = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-parser.js"() {
    paramsParser = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      x: 0,
      y: 0,
      qx: null,
      qy: null
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i2) {
  if (pathArray[i2].length > 7) {
    pathArray[i2].shift();
    var pi3 = pathArray[i2];
    var ni2 = i2;
    while (pi3.length) {
      allPathCommands[i2] = "A";
      pathArray.splice(ni2 += 1, 0, ["C"].concat(pi3.splice(0, 6)));
    }
    pathArray.splice(i2, 1);
  }
}
var init_fix_arc = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/fix-arc.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount;
var init_params_count = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-count.js"() {
    paramsCount = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path) {
  return Array.isArray(path) && path.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}
var init_is_path_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-path-array.js"() {
    init_params_count();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path) {
  return isPathArray(path) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path.every(function(_a2) {
    var x4 = _a2[0];
    return x4 === x4.toUpperCase();
  });
}
var init_is_absolute_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-absolute-array.js"() {
    init_is_path_array();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path) {
  return isAbsoluteArray(path) && path.every(function(_a2) {
    var pc = _a2[0];
    return "ACLMQZ".includes(pc);
  });
}
var init_is_normalized_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-normalized-array.js"() {
    init_is_absolute_array();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path) {
  var pathCommand = path.pathValue[path.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data = path.data;
  while (data.length >= paramsCount[LK]) {
    if (LK === "m" && data.length > 2) {
      path.segments.push([pathCommand].concat(data.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path.segments.push([pathCommand].concat(data.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}
var init_finalize_segment = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/finalize-segment.js"() {
    init_params_count();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path) {
  var index2 = path.index, pathValue = path.pathValue;
  var code = pathValue.charCodeAt(index2);
  if (code === 48) {
    path.param = 0;
    path.index += 1;
    return;
  }
  if (code === 49) {
    path.param = 1;
    path.index += 1;
    return;
  }
  path.err = '[path-util]: invalid Arc flag "'.concat(pathValue[index2], '", expecting 0 or 1 at index ').concat(index2);
}
var init_scan_flag = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-flag.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
var init_is_digit_start = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-digit-start.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path) {
  var max8 = path.max, pathValue = path.pathValue, start = path.index;
  var index2 = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch;
  if (index2 >= max8) {
    path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "pathValue" is missing param');
    return;
  }
  ch = pathValue.charCodeAt(index2);
  if (ch === 43 || ch === 45) {
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
  }
  if (!isDigit(ch) && ch !== 46) {
    path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" is not a number');
    return;
  }
  if (ch !== 46) {
    zeroFirst = ch === 48;
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (zeroFirst && index2 < max8) {
      if (ch && isDigit(ch)) {
        path.err = "[path-util]: Invalid path value at index ".concat(start, ', "').concat(pathValue[start], '" illegal number');
        return;
      }
    }
    while (index2 < max8 && isDigit(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasCeiling = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 46) {
    hasDot = true;
    index2 += 1;
    while (isDigit(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasDecimal = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 101 || ch === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid float exponent');
      return;
    }
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (ch === 43 || ch === 45) {
      index2 += 1;
    }
    if (index2 < max8 && isDigit(pathValue.charCodeAt(index2))) {
      while (index2 < max8 && isDigit(pathValue.charCodeAt(index2))) {
        index2 += 1;
      }
    } else {
      path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid integer exponent');
      return;
    }
  }
  path.index = index2;
  path.param = +path.pathValue.slice(start, index2);
}
var init_scan_param = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-param.js"() {
    init_is_digit_start();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
  // White spaces
  ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
}
var init_is_space = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-space.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path) {
  var pathValue = path.pathValue, max8 = path.max;
  while (path.index < max8 && isSpace(pathValue.charCodeAt(path.index))) {
    path.index += 1;
  }
}
var init_skip_spaces = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/skip-spaces.js"() {
    init_is_space();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}
var init_is_path_command = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-path-command.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}
var init_is_arc_command = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-arc-command.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path) {
  var max8 = path.max, pathValue = path.pathValue, index2 = path.index;
  var cmdCode = pathValue.charCodeAt(index2);
  var reqParams = paramsCount[pathValue[index2].toLowerCase()];
  path.segmentStart = index2;
  if (!isPathCommand(cmdCode)) {
    path.err = '[path-util]: Invalid path value "'.concat(pathValue[index2], '" is not a path command');
    return;
  }
  path.index += 1;
  skipSpaces(path);
  path.data = [];
  if (!reqParams) {
    finalizeSegment(path);
    return;
  }
  for (; ; ) {
    for (var i2 = reqParams; i2 > 0; i2 -= 1) {
      if (isArcCommand(cmdCode) && (i2 === 3 || i2 === 4))
        scanFlag(path);
      else
        scanParam(path);
      if (path.err.length) {
        return;
      }
      path.data.push(path.param);
      skipSpaces(path);
      if (path.index < max8 && pathValue.charCodeAt(path.index) === 44) {
        path.index += 1;
        skipSpaces(path);
      }
    }
    if (path.index >= path.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }
  finalizeSegment(path);
}
var init_scan_segment = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-segment.js"() {
    init_finalize_segment();
    init_params_count();
    init_scan_flag();
    init_scan_param();
    init_skip_spaces();
    init_is_path_command();
    init_is_digit_start();
    init_is_arc_command();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser;
var init_path_parser = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/path-parser.js"() {
    PathParser = /** @class */
    /* @__PURE__ */ function() {
      function PathParser2(pathString) {
        this.pathValue = pathString;
        this.segments = [];
        this.max = pathString.length;
        this.index = 0;
        this.param = 0;
        this.segmentStart = 0;
        this.data = [];
        this.err = "";
      }
      return PathParser2;
    }();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString3(pathInput) {
  if (isPathArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = new PathParser(pathInput);
  skipSpaces(path);
  while (path.index < path.max && !path.err.length) {
    scanSegment(path);
  }
  return path.err ? path.err : path.segments;
}
var init_parse_path_string = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/parse-path-string.js"() {
    init_is_path_array();
    init_scan_segment();
    init_skip_spaces();
    init_path_parser();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = parsePathString3(pathInput);
  var x4 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  return path.map(function(segment) {
    var values3 = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x4 = values3[0], y4 = values3[1];
      mx = x4;
      my = y4;
      return ["M", x4, y4];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values3[0],
            values3[1],
            values3[2],
            values3[3],
            values3[4],
            values3[5] + x4,
            values3[6] + y4
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values3[0] + y4];
          break;
        case "H":
          absoluteSegment = [absCommand, values3[0] + x4];
          break;
        default: {
          var absValues = values3.map(function(n2, j2) {
            return n2 + (j2 % 2 ? y4 : x4);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values3);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x4 = mx;
        y4 = my;
        break;
      case "H":
        x4 = absoluteSegment[1];
        break;
      case "V":
        y4 = absoluteSegment[1];
        break;
      default:
        x4 = absoluteSegment[segLength - 2];
        y4 = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x4;
          my = y4;
        }
    }
    return absoluteSegment;
  });
}
var init_path_2_absolute = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-absolute.js"() {
    init_is_absolute_array();
    init_parse_path_string();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values3 = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x1 = px1 * 2 - px2;
    var y1 = py1 * 2 - py2;
    params.x1 = x1;
    params.y1 = y1;
    result = ["C", x1, y1].concat(values3);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values3);
  } else if (pathCommand === "Q") {
    var nqx = values3[0], nqy = values3[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}
var init_normalize_segment = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-segment.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = path2Absolute(pathInput);
  var params = __assign4({}, paramsParser);
  for (var i2 = 0; i2 < path.length; i2 += 1) {
    path[i2] = normalizeSegment(path[i2], params);
    var segment = path[i2];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}
var init_normalize_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-path.js"() {
    init_tslib_es62();
    init_is_normalized_array();
    init_params_parser();
    init_path_2_absolute();
    init_normalize_segment();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path) {
  return isNormalizedArray(path) && path.every(function(_a2) {
    var pc = _a2[0];
    return "MC".includes(pc);
  });
}
var init_is_curve_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-curve-array.js"() {
    init_is_normalized_array();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x4, y4, rad) {
  var X2 = x4 * Math.cos(rad) - y4 * Math.sin(rad);
  var Y2 = x4 * Math.sin(rad) + y4 * Math.cos(rad);
  return { x: X2, y: Y2 };
}
var init_rotate_vector = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/rotate-vector.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic2(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, recursive) {
  var x1 = X1;
  var y1 = Y1;
  var rx = RX;
  var ry = RY;
  var x22 = X2;
  var y22 = Y2;
  var d120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle3 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotateVector(x22, y22, -rad);
    x22 = xy.x;
    y22 = xy.y;
    var x4 = (x1 - x22) / 2;
    var y4 = (y1 - y22) / 2;
    var h2 = x4 * x4 / (rx * rx) + y4 * y4 / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx *= h2;
      ry *= h2;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y4 * y4 - ry2 * x4 * x4) / (rx2 * y4 * y4 + ry2 * x4 * x4)));
    cx = k2 * rx * y4 / ry + (x1 + x22) / 2;
    cy = k2 * -ry * x4 / rx + (y1 + y22) / 2;
    f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x22 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x22;
    var y2old = y22;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x22 = cx + rx * Math.cos(f2);
    y22 = cy + ry * Math.sin(f2);
    res = arcToCubic2(x22, y22, rx, ry, angle3, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c22 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t4 = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t4;
  var hy = 4 / 3 * ry * t4;
  var m1 = [x1, y1];
  var m22 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x22 + hx * s2, y22 - hy * c22];
  var m4 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return m22.concat(m3, m4, res);
  }
  res = m22.concat(m3, m4, res);
  var newres = [];
  for (var i2 = 0, ii2 = res.length; i2 < ii2; i2 += 1) {
    newres[i2] = i2 % 2 ? rotateVector(res[i2 - 1], res[i2], rad).y : rotateVector(res[i2], res[i2 + 1], rad).x;
  }
  return newres;
}
var init_arc_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/arc-2-cubic.js"() {
    init_rotate_vector();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic2(x1, y1, qx, qy, x22, y22) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x1 + r23 * qx,
    // cpx1
    r13 * y1 + r23 * qy,
    // cpy1
    r13 * x22 + r23 * qx,
    // cpx2
    r13 * y22 + r23 * qy,
    // cpy2
    x22,
    y22
    // x,y
  ];
}
var init_quad_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/quad-2-cubic.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a3, b10, t4) {
  var ax = a3[0];
  var ay = a3[1];
  var bx = b10[0];
  var by = b10[1];
  return [ax + (bx - ax) * t4, ay + (by - ay) * t4];
}
var init_mid_point = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/mid-point.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/line-2-cubic.js
var lineToCubic2;
var init_line_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/line-2-cubic.js"() {
    init_tslib_es62();
    init_mid_point();
    lineToCubic2 = function(x1, y1, x22, y22) {
      var t4 = 0.5;
      var mid = midPoint([x1, y1], [x22, y22], t4);
      return __spreadArray4(__spreadArray4([], mid, true), [x22, y22, x22, y22], false);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic2(segment, params) {
  var pathCommand = segment[0];
  var values3 = segment.slice(1).map(Number);
  var x4 = values3[0], y4 = values3[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x4;
      params.y = y4;
      return segment;
    case "A":
      args = [px1, py1].concat(values3);
      return ["C"].concat(arcToCubic2(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x4;
      params.qy = y4;
      args = [px1, py1].concat(values3);
      return ["C"].concat(quadToCubic2(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic2(px1, py1, x4, y4));
    case "Z":
      if (px1 === px && py1 === py) {
        return ["C", px1, py1, px, py, px, py];
      }
      return ["C"].concat(lineToCubic2(px1, py1, px, py));
    default:
  }
  return segment;
}
var init_segment_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/segment-2-cubic.js"() {
    init_arc_2_cubic();
    init_quad_2_cubic();
    init_line_2_cubic();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = [].concat(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path = normalizePath(pathInput);
  var params = __assign4({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii2 = path.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i2 = 0; i2 < ii2; i2 += 1) {
    if (path[i2])
      pathCommand = path[i2][0];
    allPathCommands[i2] = pathCommand;
    var curveSegment = segmentToCubic2(path[i2], params);
    path[i2] = curveSegment;
    fixArc(path, allPathCommands, i2);
    ii2 = path.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i2);
    }
    segment = path[i2];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path, zCommandIndexes];
  } else {
    return path;
  }
}
var init_path_2_curve = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-curve.js"() {
    init_tslib_es62();
    init_params_parser();
    init_fix_arc();
    init_normalize_path();
    init_is_curve_array();
    init_segment_2_cubic();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-array.js
function path2Array(pathInput) {
  return parsePathString3(pathInput);
}
var init_path_2_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-array.js"() {
    init_parse_path_string();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path) {
  return path.map(function(x4) {
    return Array.isArray(x4) ? [].concat(x4) : x4;
  });
}
var init_clone_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/clone-path.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x4, i2, curveOnly) {
    return !i2 ? pathArray[0].slice(1).concat(x4.slice(1)) : curveOnly[i2 - 1].slice(-2).concat(x4.slice(1));
  }).map(function(x4) {
    return x4.map(function(y4, i2) {
      return x4[x4.length - i2 - 2 * (1 - i2 % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x4) {
    return ["C"].concat(x4.slice(2));
  }));
}
var init_reverse_curve = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/reverse-curve.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a3, b10) {
  return Math.sqrt((a3[0] - b10[0]) * (a3[0] - b10[0]) + (a3[1] - b10[1]) * (a3[1] - b10[1]));
}
var init_distance_square_root = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/distance-square-root.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x1, y1, x22, y22, distance11) {
  var length6 = distanceSquareRoot([x1, y1], [x22, y22]);
  var point = { x: 0, y: 0 };
  if (typeof distance11 === "number") {
    if (distance11 <= 0) {
      point = { x: x1, y: y1 };
    } else if (distance11 >= length6) {
      point = { x: x22, y: y22 };
    } else {
      var _a2 = midPoint([x1, y1], [x22, y22], distance11 / length6), x4 = _a2[0], y4 = _a2[1];
      point = { x: x4, y: y4 };
    }
  }
  return {
    length: length6,
    point,
    min: {
      x: Math.min(x1, x22),
      y: Math.min(y1, y22)
    },
    max: {
      x: Math.max(x1, x22),
      y: Math.max(y1, y22)
    }
  };
}
var init_segment_line_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-line-factory.js"() {
    init_mid_point();
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p2 = v0x * v1x + v0y * v1y;
  var n2 = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle3 = sign * Math.acos(p2 / n2);
  return angle3;
}
function getPointAtArcSegmentLength(x1, y1, RX, RY, angle3, LAF, SF, x4, y4, t4) {
  var abs3 = Math.abs, sin3 = Math.sin, cos3 = Math.cos, sqrt = Math.sqrt, PI3 = Math.PI;
  var rx = abs3(RX);
  var ry = abs3(RY);
  var xRot = (angle3 % 360 + 360) % 360;
  var xRotRad = xRot * (PI3 / 180);
  if (x1 === x4 && y1 === y4) {
    return { x: x1, y: y1 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x1, y1, x4, y4, t4).point;
  }
  var dx = (x1 - x4) / 2;
  var dy = (y1 - y4) / 2;
  var transformedPoint = {
    x: cos3(xRotRad) * dx + sin3(xRotRad) * dy,
    y: -sin3(xRotRad) * dx + cos3(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt(radiiCheck);
    ry *= sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: cos3(xRotRad) * transformedCenter.x - sin3(xRotRad) * transformedCenter.y + (x1 + x4) / 2,
    y: sin3(xRotRad) * transformedCenter.x + cos3(xRotRad) * transformedCenter.y + (y1 + y4) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI3;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI3;
  }
  sweepAngle %= 2 * PI3;
  var alpha = startAngle + sweepAngle * t4;
  var ellipseComponentX = rx * cos3(alpha);
  var ellipseComponentY = ry * sin3(alpha);
  var point = {
    x: cos3(xRotRad) * ellipseComponentX - sin3(xRotRad) * ellipseComponentY + center.x,
    y: sin3(xRotRad) * ellipseComponentX + cos3(xRotRad) * ellipseComponentY + center.y
  };
  return point;
}
function segmentArcFactory(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, distance11, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length6 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance11 === "number";
  var x4 = X1;
  var y4 = Y1;
  var LENGTH = 0;
  var prev = [x4, y4, LENGTH];
  var cur = [x4, y4];
  var t4 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x4, y: y4 }];
  if (distanceIsNumber && distance11 <= 0) {
    POINT = { x: x4, y: y4 };
  }
  for (var j2 = 0; j2 <= sampleSize; j2 += 1) {
    t4 = j2 / sampleSize;
    _a2 = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, t4), x4 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x4, y: y4 });
    }
    if (length6) {
      LENGTH += distanceSquareRoot(cur, [x4, y4]);
    }
    cur = [x4, y4];
    if (distanceIsNumber && LENGTH >= distance11 && distance11 > prev[2]) {
      var dv = (LENGTH - distance11) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x4, y4, LENGTH];
  }
  if (distanceIsNumber && distance11 >= LENGTH) {
    POINT = { x: X2, y: Y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_segment_arc_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-arc-factory.js"() {
    init_segment_line_factory();
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t4) {
  var t12 = 1 - t4;
  return {
    x: Math.pow(t12, 3) * x1 + 3 * Math.pow(t12, 2) * t4 * c1x + 3 * t12 * Math.pow(t4, 2) * c2x + Math.pow(t4, 3) * x22,
    y: Math.pow(t12, 3) * y1 + 3 * Math.pow(t12, 2) * t4 * c1y + 3 * t12 * Math.pow(t4, 2) * c2y + Math.pow(t4, 3) * y22
  };
}
function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x22, y22, distance11, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length6 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance11 === "number";
  var x4 = x1;
  var y4 = y1;
  var LENGTH = 0;
  var prev = [x4, y4, LENGTH];
  var cur = [x4, y4];
  var t4 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x4, y: y4 }];
  if (distanceIsNumber && distance11 <= 0) {
    POINT = { x: x4, y: y4 };
  }
  for (var j2 = 0; j2 <= sampleSize; j2 += 1) {
    t4 = j2 / sampleSize;
    _a2 = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t4), x4 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x4, y: y4 });
    }
    if (length6) {
      LENGTH += distanceSquareRoot(cur, [x4, y4]);
    }
    cur = [x4, y4];
    if (distanceIsNumber && LENGTH >= distance11 && distance11 > prev[2]) {
      var dv = (LENGTH - distance11) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x4, y4, LENGTH];
  }
  if (distanceIsNumber && distance11 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_segment_cubic_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-cubic-factory.js"() {
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x1, y1, cx, cy, x22, y22, t4) {
  var t12 = 1 - t4;
  return {
    x: Math.pow(t12, 2) * x1 + 2 * t12 * t4 * cx + Math.pow(t4, 2) * x22,
    y: Math.pow(t12, 2) * y1 + 2 * t12 * t4 * cy + Math.pow(t4, 2) * y22
  };
}
function segmentQuadFactory(x1, y1, qx, qy, x22, y22, distance11, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length6 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance11 === "number";
  var x4 = x1;
  var y4 = y1;
  var LENGTH = 0;
  var prev = [x4, y4, LENGTH];
  var cur = [x4, y4];
  var t4 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x4, y: y4 }];
  if (distanceIsNumber && distance11 <= 0) {
    POINT = { x: x4, y: y4 };
  }
  for (var j2 = 0; j2 <= sampleSize; j2 += 1) {
    t4 = j2 / sampleSize;
    _a2 = getPointAtQuadSegmentLength(x1, y1, qx, qy, x22, y22, t4), x4 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x4, y: y4 });
    }
    if (length6) {
      LENGTH += distanceSquareRoot(cur, [x4, y4]);
    }
    cur = [x4, y4];
    if (distanceIsNumber && LENGTH >= distance11 && distance11 > prev[2]) {
      var dv = (LENGTH - distance11) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x4, y4, LENGTH];
  }
  if (distanceIsNumber && distance11 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_segment_quad_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-quad-factory.js"() {
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance11, options) {
  var _a2, _b, _c, _d, _e2, _f;
  var path = normalizePath(pathInput);
  var distanceIsNumber = typeof distance11 === "number";
  var isM;
  var data = [];
  var pathCommand;
  var x4 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length6 = 0;
  var min6 = { x: 0, y: 0 };
  var max8 = min6;
  var point = min6;
  var POINT = min6;
  var LENGTH = 0;
  for (var i2 = 0, ll = path.length; i2 < ll; i2 += 1) {
    seg = path[i2];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data = !isM ? [x4, y4].concat(seg.slice(1)) : data;
    if (isM) {
      mx = seg[1], my = seg[2];
      min6 = { x: mx, y: my };
      max8 = min6;
      length6 = 0;
      if (distanceIsNumber && distance11 < 1e-3) {
        POINT = min6;
      }
    } else if (pathCommand === "L") {
      _a2 = segmentLineFactory(data[0], data[1], data[2], data[3], (distance11 || 0) - LENGTH), length6 = _a2.length, min6 = _a2.min, max8 = _a2.max, point = _a2.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], (distance11 || 0) - LENGTH, options || {}), length6 = _b.length, min6 = _b.min, max8 = _b.max, point = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], (distance11 || 0) - LENGTH, options || {}), length6 = _c.length, min6 = _c.min, max8 = _c.max, point = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data[0], data[1], data[2], data[3], data[4], data[5], (distance11 || 0) - LENGTH, options || {}), length6 = _d.length, min6 = _d.min, max8 = _d.max, point = _d.point;
    } else if (pathCommand === "Z") {
      data = [x4, y4, mx, my];
      _e2 = segmentLineFactory(data[0], data[1], data[2], data[3], (distance11 || 0) - LENGTH), length6 = _e2.length, min6 = _e2.min, max8 = _e2.max, point = _e2.point;
    }
    if (distanceIsNumber && LENGTH < distance11 && LENGTH + length6 >= distance11) {
      POINT = point;
    }
    MAX.push(max8);
    MIN.push(min6);
    LENGTH += length6;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x4 = _f[0], y4 = _f[1];
  }
  if (distanceIsNumber && distance11 >= LENGTH) {
    POINT = { x: x4, y: y4 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_path_length_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/path-length-factory.js"() {
    init_normalize_path();
    init_segment_line_factory();
    init_segment_arc_factory();
    init_segment_cubic_factory();
    init_segment_quad_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox.js
function getPathBBox(path, options) {
  if (!path) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      x2: 0,
      y2: 0,
      cx: 0,
      cy: 0,
      cz: 0
    };
  }
  var _a2 = pathLengthFactory(path, void 0, __assign4(__assign4({}, options), { length: false })), _b = _a2.min, xMin = _b.x, yMin = _b.y, _c = _a2.max, xMax = _c.x, yMax = _c.y;
  var width = xMax - xMin;
  var height = yMax - yMin;
  return {
    width,
    height,
    x: xMin,
    y: yMin,
    x2: xMax,
    y2: yMax,
    cx: xMin + width / 2,
    cy: yMin + height / 2,
    // an estimted guess
    cz: Math.max(width, height) + Math.min(width, height) / 2
  };
}
var init_get_path_bbox = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox.js"() {
    init_tslib_es62();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign4(__assign4({}, options), { bbox: false, length: true })).length;
}
var init_get_total_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-total-length.js"() {
    init_tslib_es62();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox-total-length.js
function getPathBBoxTotalLength(path, options) {
  if (!path) {
    return {
      length: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      x2: 0,
      y2: 0,
      cx: 0,
      cy: 0,
      cz: 0
    };
  }
  var _a2 = pathLengthFactory(path, void 0, __assign4(__assign4({}, options), { bbox: true, length: true })), length6 = _a2.length, _b = _a2.min, xMin = _b.x, yMin = _b.y, _c = _a2.max, xMax = _c.x, yMax = _c.y;
  var width = xMax - xMin;
  var height = yMax - yMin;
  return {
    length: length6,
    width,
    height,
    x: xMin,
    y: yMin,
    x2: xMax,
    y2: yMax,
    cx: xMin + width / 2,
    cy: yMin + height / 2,
    // an estimted guess
    cz: Math.max(width, height) + Math.min(width, height) / 2
  };
}
var init_get_path_bbox_total_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox-total-length.js"() {
    init_tslib_es62();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a3) {
  var segCount = a3.length;
  var pointCount = segCount - 1;
  return a3.map(function(f2, idx) {
    return a3.map(function(p2, i2) {
      var oldSegIdx = idx + i2;
      var seg;
      if (i2 === 0 || a3[oldSegIdx] && a3[oldSegIdx][0] === "M") {
        seg = a3[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a3[oldSegIdx];
    });
  });
}
function getRotatedCurve(a3, b10) {
  var segCount = a3.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a3);
  rotations.forEach(function(r2, i2) {
    a3.slice(1).forEach(function(s2, j2) {
      sumLensSqrd += distanceSquareRoot(a3[(i2 + j2) % segCount].slice(-2), b10[j2 % segCount].slice(-2));
    });
    lineLengths[i2] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}
var init_get_rotated_curve = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-rotated-curve.js"() {
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x22, y22) {
  return 3 * ((y22 - y1) * (c1x + c2x) - (x22 - x1) * (c1y + c2y) + c1y * (x1 - c2x) - c1x * (y1 - c2y) + y22 * (c2x + x1 / 3) - x22 * (c2y + y1 / 3)) / 20;
}
function getPathArea(path) {
  var x4 = 0;
  var y4 = 0;
  var len6 = 0;
  return path2Curve(path).map(function(seg) {
    var _a2;
    switch (seg[0]) {
      case "M":
        x4 = seg[1], y4 = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
        len6 = getCubicSegArea(x4, y4, c1x, c1y, c2x, c2y, x22, y22);
        _a2 = seg.slice(-2), x4 = _a2[0], y4 = _a2[1];
        return len6;
    }
  }).reduce(function(a3, b10) {
    return a3 + b10;
  }, 0);
}
var init_get_path_area = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-area.js"() {
    init_path_2_curve();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}
var init_get_draw_direction = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-draw-direction.js"() {
    init_get_path_area();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance11, options) {
  return pathLengthFactory(pathInput, distance11, __assign4(__assign4({}, options), { bbox: false, length: true })).point;
}
var init_get_point_at_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-point-at-length.js"() {
    init_tslib_es62();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-length.js
function getPropertiesAtLength(pathInput, distance11) {
  var pathArray = parsePathString3(pathInput);
  if (typeof pathArray === "string") {
    throw TypeError(pathArray);
  }
  var pathTemp = pathArray.slice();
  var pathLength = getTotalLength(pathTemp);
  var index2 = pathTemp.length - 1;
  var lengthAtSegment = 0;
  var length6 = 0;
  var segment = pathArray[0];
  var _a2 = segment.slice(-2), x4 = _a2[0], y4 = _a2[1];
  var point = { x: x4, y: y4 };
  if (index2 <= 0 || !distance11 || !Number.isFinite(distance11)) {
    return {
      segment,
      index: 0,
      length: length6,
      point,
      lengthAtSegment
    };
  }
  if (distance11 >= pathLength) {
    pathTemp = pathArray.slice(0, -1);
    lengthAtSegment = getTotalLength(pathTemp);
    length6 = pathLength - lengthAtSegment;
    return {
      segment: pathArray[index2],
      index: index2,
      length: length6,
      lengthAtSegment
    };
  }
  var segments = [];
  while (index2 > 0) {
    segment = pathTemp[index2];
    pathTemp = pathTemp.slice(0, -1);
    lengthAtSegment = getTotalLength(pathTemp);
    length6 = pathLength - lengthAtSegment;
    pathLength = lengthAtSegment;
    segments.push({
      segment,
      index: index2,
      length: length6,
      lengthAtSegment
    });
    index2 -= 1;
  }
  return segments.find(function(_a3) {
    var l2 = _a3.lengthAtSegment;
    return l2 <= distance11;
  });
}
var init_get_properties_at_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-length.js"() {
    init_parse_path_string();
    init_get_total_length();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-point.js
function getPropertiesAtPoint(pathInput, point) {
  var path = parsePathString3(pathInput);
  var normalPath = normalizePath(path);
  var pathLength = getTotalLength(path);
  var distanceTo = function(p2) {
    var dx = p2.x - point.x;
    var dy = p2.y - point.y;
    return dx * dx + dy * dy;
  };
  var precision = 8;
  var scan;
  var scanDistance = 0;
  var closest;
  var bestLength = 0;
  var bestDistance = Infinity;
  for (var scanLength = 0; scanLength <= pathLength; scanLength += precision) {
    scan = getPointAtLength(normalPath, scanLength);
    scanDistance = distanceTo(scan);
    if (scanDistance < bestDistance) {
      closest = scan;
      bestLength = scanLength;
      bestDistance = scanDistance;
    }
  }
  precision /= 2;
  var before;
  var after;
  var beforeLength = 0;
  var afterLength = 0;
  var beforeDistance = 0;
  var afterDistance = 0;
  while (precision > 0.5) {
    beforeLength = bestLength - precision;
    before = getPointAtLength(normalPath, beforeLength);
    beforeDistance = distanceTo(before);
    afterLength = bestLength + precision;
    after = getPointAtLength(normalPath, afterLength);
    afterDistance = distanceTo(after);
    if (beforeLength >= 0 && beforeDistance < bestDistance) {
      closest = before;
      bestLength = beforeLength;
      bestDistance = beforeDistance;
    } else if (afterLength <= pathLength && afterDistance < bestDistance) {
      closest = after;
      bestLength = afterLength;
      bestDistance = afterDistance;
    } else {
      precision /= 2;
    }
  }
  var segment = getPropertiesAtLength(path, bestLength);
  var distance11 = Math.sqrt(bestDistance);
  return { closest, distance: distance11, segment };
}
var init_get_properties_at_point = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-point.js"() {
    init_parse_path_string();
    init_normalize_path();
    init_get_point_at_length();
    init_get_properties_at_length();
    init_get_total_length();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-point-in-stroke.js
function isPointInStroke2(pathInput, point) {
  var distance11 = getPropertiesAtPoint(pathInput, point).distance;
  return Math.abs(distance11) < 1e-3;
}
var init_is_point_in_stroke = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-point-in-stroke.js"() {
    init_get_properties_at_point();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/equalize-segments.js
function splitCubic(pts, t4) {
  if (t4 === void 0) {
    t4 = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t4);
  var p5 = midPoint(p1, p2, t4);
  var p6 = midPoint(p2, p3, t4);
  var p7 = midPoint(p4, p5, t4);
  var p8 = midPoint(p5, p6, t4);
  var p9 = midPoint(p7, p8, t4);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i2, pathArray) {
    var segmentData = i2 && pathArray[i2 - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i2 ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i2) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL, depth) {
  if (depth === void 0) {
    depth = 0;
  }
  if (depth > MAX_RECURSION_DEPTH) {
    console.warn("Maximum recursion depth reached in equalizeSegments");
    return [path1, path2];
  }
  var c1 = getCurveArray(path1);
  var c22 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c22.length;
  var l1 = c1.filter(function(x4) {
    return x4.l;
  }).length;
  var l2 = c22.filter(function(x4) {
    return x4.l;
  }).length;
  var m1 = c1.filter(function(x4) {
    return x4.l;
  }).reduce(function(a3, _a2) {
    var l3 = _a2.l;
    return a3 + l3;
  }, 0) / l1 || 0;
  var m22 = c22.filter(function(x4) {
    return x4.l;
  }).reduce(function(a3, _a2) {
    var l3 = _a2.l;
    return a3 + l3;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m22];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c22].map(function(x4, i2) {
    return x4.l === tl ? x4.map(function(y4) {
      return y4.s;
    }) : x4.map(function(y4, j2) {
      canSplit = j2 && dif[i2] && y4.l >= mm[i2];
      dif[i2] -= canSplit ? 1 : 0;
      return canSplit ? y4.ss : [y4.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl, depth + 1);
}
var MAX_RECURSION_DEPTH;
var init_equalize_segments = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/equalize-segments.js"() {
    init_mid_point();
    init_segment_cubic_factory();
    MAX_RECURSION_DEPTH = 50;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/types.js
var init_types = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/types.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/index.js
var init_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/index.js"() {
    init_path_2_string();
    init_path_2_curve();
    init_path_2_absolute();
    init_path_2_array();
    init_clone_path();
    init_normalize_path();
    init_reverse_curve();
    init_arc_2_cubic();
    init_get_path_bbox();
    init_get_total_length();
    init_get_path_bbox_total_length();
    init_get_rotated_curve();
    init_get_path_area();
    init_get_draw_direction();
    init_get_point_at_length();
    init_is_point_in_stroke();
    init_distance_square_root();
    init_equalize_segments();
    init_types();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-point-in-polygon.js
function dcmp2(x4) {
  if (Math.abs(x4) < tolerance2) {
    return 0;
  }
  return x4 < 0 ? -1 : 1;
}
function onSegment3(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isPointInPolygon3(points, x4, y4) {
  var isHit = false;
  var n2 = points.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment3(p1, p2, [x4, y4])) {
      return true;
    }
    if (dcmp2(p1[1] - y4) > 0 !== dcmp2(p2[1] - y4) > 0 && dcmp2(x4 - (y4 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
var tolerance2;
var init_is_point_in_polygon = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-point-in-polygon.js"() {
    tolerance2 = 1e-6;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-polygons-intersect.js
function getLineIntersect4(p0, p1, p2, p3) {
  var tolerance3 = 1e-3;
  var E3 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point = null;
  if (sqrKross > tolerance3 * sqrLen0 * sqrLen1) {
    var s2 = (E3.x * D1.y - E3.y * D1.x) / kross;
    var t4 = (E3.x * D0.y - E3.y * D0.x) / kross;
    if (isBetween3(s2, 0, 1) && isBetween3(t4, 0, 1)) {
      point = {
        x: p0.x + s2 * D0.x,
        y: p0.y + s2 * D0.y
      };
    }
  }
  return point;
}
function parseToLines(points) {
  var lines = [];
  var count = points.length;
  for (var i2 = 0; i2 < count - 1; i2++) {
    var point = points[i2];
    var next = points[i2 + 1];
    lines.push({
      from: {
        x: point[0],
        y: point[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points[0];
    var last3 = points[count - 1];
    lines.push({
      from: {
        x: last3[0],
        y: last3[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon3(lines, line) {
  var isIntersect = false;
  lines.forEach(function(l2) {
    if (getLineIntersect4(l2.from, l2.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getBBox4(points) {
  var xArr = points.map(function(p2) {
    return p2[0];
  });
  var yArr = points.map(function(p2) {
    return p2[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox3(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect4(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox4(points1);
  var bbox2 = getBBox4(points2);
  if (!intersectBBox3(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  points2.forEach(function(point) {
    if (isPointInPolygon3(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  points1.forEach(function(point) {
    if (isPointInPolygon3(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  lines2.forEach(function(line) {
    if (lineIntersectPolygon3(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
var isBetween3;
var init_is_polygons_intersect = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-polygons-intersect.js"() {
    init_is_point_in_polygon();
    isBetween3 = function(value, min6, max8) {
      return value >= min6 && value <= max8;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/math/index.js
var init_math = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/math/index.js"() {
    init_is_point_in_polygon();
    init_is_polygons_intersect();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/dom/create-dom.js
function createDOM(str10) {
  var container = document.createElement("div");
  container.innerHTML = str10;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}
var init_create_dom = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/dom/create-dom.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/dom/modify-css.js
function modifyCSS2(dom, css) {
  if (!dom)
    return;
  Object.keys(css).forEach(function(key) {
    dom.style[key] = css[key];
  });
  return dom;
}
var init_modify_css = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/dom/modify-css.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/dom/index.js
var init_dom = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/dom/index.js"() {
    init_create_dom();
    init_modify_css();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  Cache: () => cache_default2,
  angleTo: () => angleTo2,
  arcToCubic: () => arcToCubic2,
  assign: () => mix2,
  augment: () => augment_default2,
  clamp: () => clamp_default2,
  clearAnimationFrame: () => cancelAnimationFrame3,
  clone: () => clone_default2,
  clonePath: () => clonePath,
  contains: () => contains_default2,
  createDOM: () => createDOM,
  debounce: () => debounce_default2,
  deepMix: () => deep_mix_default2,
  difference: () => difference_default2,
  direction: () => direction2,
  distanceSquareRoot: () => distanceSquareRoot,
  each: () => each_default2,
  endsWith: () => ends_with_default2,
  equalizeSegments: () => equalizeSegments,
  every: () => every_default2,
  extend: () => extend_default2,
  filter: () => filter_default2,
  find: () => find_default3,
  findIndex: () => find_index_default2,
  firstValue: () => first_value_default2,
  fixedBase: () => fixed_base_default2,
  flatten: () => flatten_default2,
  flattenDeep: () => flatten_deep_default2,
  forIn: () => for_in_default2,
  get: () => get_default2,
  getDrawDirection: () => getDrawDirection,
  getPathArea: () => getPathArea,
  getPathBBox: () => getPathBBox,
  getPathBBoxTotalLength: () => getPathBBoxTotalLength,
  getPointAtLength: () => getPointAtLength,
  getRange: () => get_range_default2,
  getRotatedCurve: () => getRotatedCurve,
  getTotalLength: () => getTotalLength,
  getType: () => get_type_default2,
  getWrapBehavior: () => get_wrap_behavior_default2,
  gradient: () => gradient,
  group: () => group_default5,
  groupBy: () => group_by_default2,
  groupToMap: () => groupToMap2,
  has: () => has_default2,
  hasKey: () => has_key_default2,
  hasValue: () => has_value_default2,
  head: () => head2,
  identity: () => identity_default2,
  includes: () => contains_default2,
  indexOf: () => index_of_default2,
  isArguments: () => is_arguments_default2,
  isArray: () => isArray,
  isArrayLike: () => is_array_like_default2,
  isBoolean: () => is_boolean_default2,
  isDate: () => isDate2,
  isDecimal: () => isDecimal2,
  isElement: () => isElement2,
  isEmpty: () => is_empty_default2,
  isEqual: () => is_equal_default2,
  isEqualWith: () => is_equal_with_default2,
  isError: () => is_error_default2,
  isEven: () => isEven2,
  isFinite: () => is_finite_default2,
  isFunction: () => isFunction2,
  isInteger: () => isInteger2,
  isMatch: () => is_match_default2,
  isNegative: () => isNegative2,
  isNil: () => isNil2,
  isNull: () => isNull2,
  isNumber: () => isNumber2,
  isNumberEqual: () => isNumberEqual3,
  isObject: () => is_object_default2,
  isObjectLike: () => is_object_like_default2,
  isOdd: () => isOdd2,
  isPlainObject: () => is_plain_object_default2,
  isPointInPolygon: () => isPointInPolygon3,
  isPointInStroke: () => isPointInStroke2,
  isPolygonsIntersect: () => isPolygonsIntersect4,
  isPositive: () => is_positive_default2,
  isPrototype: () => is_prototype_default2,
  isRegExp: () => is_reg_exp_default2,
  isString: () => isString,
  isType: () => is_type_default2,
  isUndefined: () => is_undefined_default2,
  keys: () => keys_default2,
  last: () => last2,
  lowerCase: () => lower_case_default2,
  lowerFirst: () => lower_first_default2,
  map: () => map_default2,
  mapValues: () => map_values_default2,
  max: () => max4,
  maxBy: () => max_by_default2,
  memoize: () => memoize,
  min: () => min_default2,
  minBy: () => min_by_default2,
  mix: () => mix2,
  mod: () => mod_default2,
  modifyCSS: () => modifyCSS2,
  noop: () => noop_default2,
  normalizePath: () => normalizePath,
  number2color: () => number2color_default2,
  omit: () => omit_default2,
  parseRadius: () => parse_radius_default2,
  path2Absolute: () => path2Absolute,
  path2Array: () => path2Array,
  path2Curve: () => path2Curve,
  path2String: () => path2String,
  pick: () => pick_default2,
  pull: () => pull_default2,
  pullAt: () => pull_at_default2,
  reduce: () => reduce_default2,
  remove: () => remove_default3,
  requestAnimationFrame: () => requestAnimationFrame3,
  reverseCurve: () => reverseCurve,
  rgb2arr: () => rgb2arr,
  set: () => set_default2,
  size: () => size2,
  some: () => some_default2,
  sortBy: () => sort_by_default2,
  startsWith: () => starts_with_default2,
  substitute: () => substitute_default2,
  throttle: () => throttle_default2,
  toArray: () => to_array_default2,
  toCSSGradient: () => toCSSGradient,
  toDegree: () => to_degree_default2,
  toInteger: () => to_integer_default2,
  toRGB: () => toRGB,
  toRadian: () => to_radian_default2,
  toString: () => to_string_default2,
  transform: () => transform9,
  union: () => union_default2,
  uniq: () => uniq2,
  uniqueId: () => unique_id_default2,
  upperCase: () => upper_case_default2,
  upperFirst: () => upper_first_default2,
  values: () => values_default2,
  valuesOfKey: () => values_of_key_default2,
  vertical: () => vertical2,
  wrapBehavior: () => wrap_behavior_default2
});
var init_esm3 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/index.js"() {
    init_color();
    init_matrix();
    init_path();
    init_lodash();
    init_math();
    init_dom();
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/init-order.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var initOrder = function(g2) {
      var visited = {};
      var simpleNodes = g2.nodes().filter(function(v2) {
        var _a2;
        return !((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length);
      });
      var nodeRanks = simpleNodes.map(function(v2) {
        return g2.node(v2).rank;
      });
      var maxRank = (0, util_1.max)(nodeRanks);
      var layers = [];
      for (var i2 = 0; i2 < maxRank + 1; i2++) {
        layers.push([]);
      }
      var dfs3 = function(v2) {
        var _a2;
        if (visited.hasOwnProperty(v2))
          return;
        visited[v2] = true;
        var node = g2.node(v2);
        if (!isNaN(node.rank)) {
          layers[node.rank].push(v2);
        }
        (_a2 = g2.successors(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          return dfs3(child);
        });
      };
      var orderedVs = simpleNodes.sort(function(a3, b10) {
        return g2.node(a3).rank - g2.node(b10).rank;
      });
      var beforeSort = orderedVs.filter(function(n2) {
        return g2.node(n2).fixorder !== void 0;
      });
      var fixOrderNodes = beforeSort.sort(function(a3, b10) {
        return g2.node(a3).fixorder - g2.node(b10).fixorder;
      });
      fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach(function(n2) {
        if (!isNaN(g2.node(n2).rank)) {
          layers[g2.node(n2).rank].push(n2);
        }
        visited[n2] = true;
      });
      orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach(dfs3);
      return layers;
    };
    exports.default = initOrder;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/cross-count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var twoLayerCrossCount = function(g2, northLayer, southLayer) {
      var southPos = (0, util_1.zipObject)(southLayer, southLayer.map(function(v2, i2) {
        return i2;
      }));
      var unflat = northLayer.map(function(v2) {
        var _a2;
        var unsort = (_a2 = g2.outEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.map(function(e8) {
          return { pos: southPos[e8.w] || 0, weight: g2.edge(e8).weight };
        });
        return unsort === null || unsort === void 0 ? void 0 : unsort.sort(function(a3, b10) {
          return a3.pos - b10.pos;
        });
      });
      var southEntries = unflat.flat().filter(function(entry) {
        return entry !== void 0;
      });
      var firstIndex = 1;
      while (firstIndex < southLayer.length)
        firstIndex <<= 1;
      var treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      var tree = Array(treeSize).fill(0, 0, treeSize);
      var cc2 = 0;
      southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(function(entry) {
        if (entry) {
          var index2 = entry.pos + firstIndex;
          tree[index2] += entry.weight;
          var weightSum = 0;
          while (index2 > 0) {
            if (index2 % 2) {
              weightSum += tree[index2 + 1];
            }
            index2 = index2 - 1 >> 1;
            tree[index2] += entry.weight;
          }
          cc2 += entry.weight * weightSum;
        }
      });
      return cc2;
    };
    var crossCount = function(g2, layering) {
      var cc2 = 0;
      for (var i2 = 1; i2 < (layering === null || layering === void 0 ? void 0 : layering.length); i2 += 1) {
        cc2 += twoLayerCrossCount(g2, layering[i2 - 1], layering[i2]);
      }
      return cc2;
    };
    exports.default = crossCount;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/build-layer-graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var graph_1 = require_graph();
    var buildLayerGraph = function(g2, rank, relationship) {
      var root = createRootNode(g2);
      var result = new graph_1.Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel(function(v2) {
        return g2.node(v2);
      });
      g2.nodes().forEach(function(v2) {
        var _a2;
        var node = g2.node(v2);
        var parent = g2.parent(v2);
        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
          result.setNode(v2);
          result.setParent(v2, parent || root);
          (_a2 = g2[relationship](v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
            var u2 = e8.v === v2 ? e8.w : e8.v;
            var edge = result.edgeFromArgs(u2, v2);
            var weight = edge !== void 0 ? edge.weight : 0;
            result.setEdge(u2, v2, { weight: g2.edge(e8).weight + weight });
          });
          if (node.hasOwnProperty("minRank")) {
            result.setNode(v2, {
              borderLeft: node.borderLeft[rank],
              borderRight: node.borderRight[rank]
            });
          }
        }
      });
      return result;
    };
    var createRootNode = function(g2) {
      var v2;
      while (g2.hasNode(v2 = "_root".concat(Math.random())))
        ;
      return v2;
    };
    exports.default = buildLayerGraph;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/add-subgraph-constraints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var addSubgraphConstraints = function(g2, cg, vs) {
      var prev = {};
      var rootPrev;
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        var child = g2.parent(v2);
        var parent;
        var prevChild;
        while (child) {
          parent = g2.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    };
    exports.default = addSubgraphConstraints;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/barycenter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var barycenter = function(g2, movable) {
      return movable.map(function(v2) {
        var inV = g2.inEdges(v2);
        if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
          return { v: v2 };
        }
        {
          var result_1 = { sum: 0, weight: 0 };
          inV === null || inV === void 0 ? void 0 : inV.forEach(function(e8) {
            var edge = g2.edge(e8);
            var nodeU = g2.node(e8.v);
            result_1.sum += edge.weight * nodeU.order;
            result_1.weight += edge.weight;
          });
          return {
            v: v2,
            barycenter: result_1.sum / result_1.weight,
            weight: result_1.weight
          };
        }
      });
    };
    exports.default = barycenter;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/resolve-conflicts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolveConflicts = function(entries, cg) {
      var _a2, _b, _c;
      var mappedEntries = {};
      entries === null || entries === void 0 ? void 0 : entries.forEach(function(entry, i2) {
        mappedEntries[entry.v] = {
          i: i2,
          indegree: 0,
          in: [],
          out: [],
          vs: [entry.v]
        };
        var tmp = mappedEntries[entry.v];
        if (entry.barycenter !== void 0) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      (_a2 = cg.edges()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var entryV = mappedEntries[e8.v];
        var entryW = mappedEntries[e8.w];
        if (entryV !== void 0 && entryW !== void 0) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e8.w]);
        }
      });
      var sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, function(entry) {
        return !entry.indegree;
      });
      return doResolveConflicts(sourceSet);
    };
    var doResolveConflicts = function(sourceSet) {
      var _a2, _b;
      var entries = [];
      var handleIn = function(vEntry) {
        return function(uEntry) {
          if (uEntry.merged)
            return;
          if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      };
      var handleOut = function(vEntry) {
        return function(wEntry) {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      };
      var _loop_1 = function() {
        var entry = sourceSet.pop();
        entries.push(entry);
        (_a2 = entry["in"].reverse()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          return handleIn(entry)(e8);
        });
        (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach(function(e8) {
          return handleOut(entry)(e8);
        });
      };
      while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
        _loop_1();
      }
      var filtered = entries.filter(function(entry) {
        return !entry.merged;
      });
      var keys3 = [
        "vs",
        "i",
        "barycenter",
        "weight"
      ];
      return filtered.map(function(entry) {
        var picked = {};
        keys3 === null || keys3 === void 0 ? void 0 : keys3.forEach(function(key) {
          if (entry[key] === void 0)
            return;
          picked[key] = entry[key];
        });
        return picked;
      });
    };
    var mergeEntries = function(target, source) {
      var _a2;
      var sum = 0;
      var weight = 0;
      if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = (_a2 = source.vs) === null || _a2 === void 0 ? void 0 : _a2.concat(target.vs);
      target.barycenter = sum / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    };
    exports.default = resolveConflicts;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/sort.js
var require_sort = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var sort = function(entries, biasRight, usePrev, keepNodeOrder) {
      var parts = (0, util_1.partition)(entries, function(entry) {
        var hasFixOrder = entry.hasOwnProperty("fixorder") && !isNaN(entry.fixorder);
        if (keepNodeOrder)
          return !hasFixOrder && entry.hasOwnProperty("barycenter");
        return hasFixOrder || entry.hasOwnProperty("barycenter");
      });
      var sortable = parts.lhs;
      var unsortable = parts.rhs.sort(function(a3, b10) {
        return -a3.i - -b10.i;
      });
      var vs = [];
      var sum = 0;
      var weight = 0;
      var vsIndex = 0;
      sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      sortable === null || sortable === void 0 ? void 0 : sortable.forEach(function(entry) {
        var _a2;
        vsIndex += (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      var result = { vs: vs.flat() };
      if (weight) {
        result.barycenter = sum / weight;
        result.weight = weight;
      }
      return result;
    };
    var consumeUnsortable = function(vs, unsortable, index2) {
      var iindex = index2;
      var last3;
      while (unsortable.length && (last3 = unsortable[unsortable.length - 1]).i <= iindex) {
        unsortable.pop();
        vs === null || vs === void 0 ? void 0 : vs.push(last3.vs);
        iindex++;
      }
      return iindex;
    };
    var compareWithBias = function(bias, usePrev) {
      return function(entryV, entryW) {
        if (entryV.fixorder !== void 0 && entryW.fixorder !== void 0) {
          return entryV.fixorder - entryW.fixorder;
        }
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        }
        if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        if (usePrev && entryV.order !== void 0 && entryW.order !== void 0) {
          if (entryV.order < entryW.order) {
            return -1;
          }
          if (entryV.order > entryW.order) {
            return 1;
          }
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    };
    exports.default = sort;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/sort-subgraph.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var barycenter_1 = __importDefault2(require_barycenter());
    var resolve_conflicts_1 = __importDefault2(require_resolve_conflicts());
    var sort_1 = __importDefault2(require_sort());
    var sortSubgraph = function(g2, v2, cg, biasRight, usePrev, keepNodeOrder) {
      var _a2, _b, _c, _d;
      var movable = g2.children(v2);
      var node = g2.node(v2);
      var bl = node ? node.borderLeft : void 0;
      var br2 = node ? node.borderRight : void 0;
      var subgraphs = {};
      if (bl) {
        movable = movable === null || movable === void 0 ? void 0 : movable.filter(function(w2) {
          return w2 !== bl && w2 !== br2;
        });
      }
      var barycenters = (0, barycenter_1.default)(g2, movable || []);
      barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach(function(entry) {
        var _a3;
        if ((_a3 = g2.children(entry.v)) === null || _a3 === void 0 ? void 0 : _a3.length) {
          var subgraphResult = sortSubgraph(g2, entry.v, cg, biasRight, keepNodeOrder);
          subgraphs[entry.v] = subgraphResult;
          if (subgraphResult.hasOwnProperty("barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      var entries = (0, resolve_conflicts_1.default)(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      (_a2 = entries.filter(function(e8) {
        return e8.vs.length > 0;
      })) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var node2 = g2.node(e8.vs[0]);
        if (node2) {
          e8.fixorder = node2.fixorder;
          e8.order = node2.order;
        }
      });
      var result = (0, sort_1.default)(entries, biasRight, usePrev, keepNodeOrder);
      if (bl) {
        result.vs = [bl, result.vs, br2].flat();
        if ((_b = g2.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
          var blPred = g2.node(((_c = g2.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || "");
          var brPred = g2.node(((_d = g2.predecessors(br2)) === null || _d === void 0 ? void 0 : _d[0]) || "");
          if (!result.hasOwnProperty("barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    };
    var expandSubgraphs = function(entries, subgraphs) {
      entries === null || entries === void 0 ? void 0 : entries.forEach(function(entry) {
        var _a2;
        var vss = (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.map(function(v2) {
          if (subgraphs[v2]) {
            return subgraphs[v2].vs;
          }
          return v2;
        });
        entry.vs = vss.flat();
      });
    };
    var mergeBarycenters = function(target, other) {
      if (target.barycenter !== void 0) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    };
    exports.default = sortSubgraph;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/index.js
var require_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var init_order_1 = __importDefault2(require_init_order());
    var cross_count_1 = __importDefault2(require_cross_count());
    var build_layer_graph_1 = __importDefault2(require_build_layer_graph());
    var add_subgraph_constraints_1 = __importDefault2(require_add_subgraph_constraints());
    var sort_subgraph_1 = __importDefault2(require_sort_subgraph());
    var util_1 = require_util2();
    var graph_1 = require_graph();
    var util_2 = require_util3();
    var order = function(g2, keepNodeOrder) {
      var mxRank = (0, util_2.maxRank)(g2);
      var range1 = [];
      var range2 = [];
      for (var i2 = 1; i2 < mxRank + 1; i2++)
        range1.push(i2);
      for (var i2 = mxRank - 1; i2 > -1; i2--)
        range2.push(i2);
      var downLayerGraphs = buildLayerGraphs(g2, range1, "inEdges");
      var upLayerGraphs = buildLayerGraphs(g2, range2, "outEdges");
      var layering = (0, init_order_1.default)(g2);
      assignOrder(g2, layering);
      var bestCC = Number.POSITIVE_INFINITY;
      var best;
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, false, keepNodeOrder);
        layering = (0, util_2.buildLayerMatrix)(g2);
        var cc2 = (0, cross_count_1.default)(g2, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = (0, util_1.clone)(layering);
          bestCC = cc2;
        }
      }
      layering = (0, init_order_1.default)(g2);
      assignOrder(g2, layering);
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, true, keepNodeOrder);
        layering = (0, util_2.buildLayerMatrix)(g2);
        var cc2 = (0, cross_count_1.default)(g2, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = (0, util_1.clone)(layering);
          bestCC = cc2;
        }
      }
      assignOrder(g2, best);
    };
    var buildLayerGraphs = function(g2, ranks, relationship) {
      return ranks.map(function(rank) {
        return (0, build_layer_graph_1.default)(g2, rank, relationship);
      });
    };
    var sweepLayerGraphs = function(layerGraphs, biasRight, usePrev, keepNodeOrder) {
      var cg = new graph_1.Graph();
      layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach(function(lg) {
        var _a2;
        var root = lg.graph().root;
        var sorted = (0, sort_subgraph_1.default)(lg, root, cg, biasRight, usePrev, keepNodeOrder);
        for (var i2 = 0; i2 < ((_a2 = sorted.vs) === null || _a2 === void 0 ? void 0 : _a2.length) || 0; i2++) {
          var lnode = lg.node(sorted.vs[i2]);
          if (lnode) {
            lnode.order = i2;
          }
        }
        (0, add_subgraph_constraints_1.default)(lg, cg, sorted.vs);
      });
    };
    var assignOrder = function(g2, layering) {
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          g2.node(v2).order = i2;
        });
      });
    };
    exports.default = order;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/position/bk.js
var require_bk = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/position/bk.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.width = exports.sep = exports.positionX = exports.balance = exports.alignCoordinates = exports.findSmallestWidthAlignment = exports.buildBlockGraph = exports.horizontalCompaction = exports.verticalAlignment = exports.hasConflict = exports.addConflict = exports.findOtherInnerSegmentNode = exports.findType2Conflicts = exports.findType1Conflicts = void 0;
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var util_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var util_2 = require_util3();
    var BlockGraph = (
      /** @class */
      function(_super) {
        __extends17(BlockGraph2, _super);
        function BlockGraph2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return BlockGraph2;
      }(graphlib_1.Graph)
    );
    var findType1Conflicts = function(g2, layering) {
      var conflicts = {};
      var visitLayer = function(prevLayer, layer) {
        var k0 = 0;
        var scanPos = 0;
        var prevLayerLength = prevLayer.length;
        var lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          var _a2;
          var w2 = (0, exports.findOtherInnerSegmentNode)(g2, v2);
          var k1 = w2 ? g2.node(w2).order : prevLayerLength;
          if (w2 || v2 === lastNode) {
            (_a2 = layer.slice(scanPos, i2 + 1)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(scanNode) {
              var _a3;
              (_a3 = g2.predecessors(scanNode)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(u2) {
                var _a4;
                var uLabel = g2.node(u2);
                var uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && ((_a4 = g2.node(scanNode)) === null || _a4 === void 0 ? void 0 : _a4.dummy))) {
                  (0, exports.addConflict)(conflicts, u2, scanNode);
                }
              });
            });
            scanPos = i2 + 1;
            k0 = k1;
          }
        });
        return layer;
      };
      if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
      }
      return conflicts;
    };
    exports.findType1Conflicts = findType1Conflicts;
    var findType2Conflicts = function(g2, layering) {
      var conflicts = {};
      function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var _a2, _b;
        var v2;
        for (var i2 = southPos; i2 < southEnd; i2++) {
          v2 = south[i2];
          if ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) {
            (_b = g2.predecessors(v2)) === null || _b === void 0 ? void 0 : _b.forEach(function(u2) {
              var uNode = g2.node(u2);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                (0, exports.addConflict)(conflicts, u2, v2);
              }
            });
          }
        }
      }
      ;
      function getScannedKey(params) {
        return JSON.stringify(params.slice(1));
      }
      function scanIfNeeded(params, scanCache) {
        var cacheKey = getScannedKey(params);
        if (scanCache.get(cacheKey))
          return;
        scan.apply(void 0, params);
        scanCache.set(cacheKey, true);
      }
      var visitLayer = function(north, south) {
        var prevNorthPos = -1;
        var nextNorthPos;
        var southPos = 0;
        var scanned = /* @__PURE__ */ new Map();
        south === null || south === void 0 ? void 0 : south.forEach(function(v2, southLookahead) {
          var _a2;
          if (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) === "border") {
            var predecessors = g2.predecessors(v2) || [];
            if (predecessors.length) {
              nextNorthPos = g2.node(predecessors[0]).order;
              scanIfNeeded([south, southPos, southLookahead, prevNorthPos, nextNorthPos], scanned);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scanIfNeeded([south, southPos, south.length, nextNorthPos, north.length], scanned);
        });
        return south;
      };
      if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
      }
      return conflicts;
    };
    exports.findType2Conflicts = findType2Conflicts;
    var findOtherInnerSegmentNode = function(g2, v2) {
      var _a2, _b;
      if ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) {
        return (_b = g2.predecessors(v2)) === null || _b === void 0 ? void 0 : _b.find(function(u2) {
          return g2.node(u2).dummy;
        });
      }
    };
    exports.findOtherInnerSegmentNode = findOtherInnerSegmentNode;
    var addConflict = function(conflicts, v2, w2) {
      var vv = v2;
      var ww = w2;
      if (vv > ww) {
        var tmp = vv;
        vv = ww;
        ww = tmp;
      }
      var conflictsV = conflicts[vv];
      if (!conflictsV) {
        conflicts[vv] = conflictsV = {};
      }
      conflictsV[ww] = true;
    };
    exports.addConflict = addConflict;
    var hasConflict = function(conflicts, v2, w2) {
      var vv = v2;
      var ww = w2;
      if (vv > ww) {
        var tmp = v2;
        vv = ww;
        ww = tmp;
      }
      return !!conflicts[vv];
    };
    exports.hasConflict = hasConflict;
    var verticalAlignment = function(g2, layering, conflicts, neighborFn) {
      var root = {};
      var align = {};
      var pos = {};
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, order) {
          root[v2] = v2;
          align[v2] = v2;
          pos[v2] = order;
        });
      });
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var prevIdx = -1;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          var ws = neighborFn(v2);
          if (ws.length) {
            ws = ws.sort(function(a3, b10) {
              return pos[a3] - pos[b10];
            });
            var mp = (ws.length - 1) / 2;
            for (var i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
              var w2 = ws[i2];
              if (align[v2] === v2 && prevIdx < pos[w2] && !(0, exports.hasConflict)(conflicts, v2, w2)) {
                align[w2] = v2;
                align[v2] = root[v2] = root[w2];
                prevIdx = pos[w2];
              }
            }
          }
        });
      });
      return { root, align };
    };
    exports.verticalAlignment = verticalAlignment;
    var horizontalCompaction = function(g2, layering, root, align, reverseSep) {
      var _a2;
      var xs = {};
      var blockG = (0, exports.buildBlockGraph)(g2, layering, root, reverseSep);
      var borderType = reverseSep ? "borderLeft" : "borderRight";
      var iterate = function(setXsFunc, nextNodesFunc) {
        var stack = blockG.nodes();
        var elem = stack.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      };
      var pass1 = function(elem) {
        xs[elem] = (blockG.inEdges(elem) || []).reduce(function(acc, e8) {
          return Math.max(acc, (xs[e8.v] || 0) + blockG.edge(e8));
        }, 0);
      };
      var pass2 = function(elem) {
        var min6 = (blockG.outEdges(elem) || []).reduce(function(acc, e8) {
          return Math.min(acc, (xs[e8.w] || 0) - blockG.edge(e8));
        }, Number.POSITIVE_INFINITY);
        var node = g2.node(elem);
        if (min6 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min6);
        }
      };
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      (_a2 = Object.values(align)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        xs[v2] = xs[root[v2]];
      });
      return xs;
    };
    exports.horizontalCompaction = horizontalCompaction;
    var buildBlockGraph = function(g2, layering, root, reverseSep) {
      var blockGraph = new BlockGraph();
      var graphLabel = g2.graph();
      var sepFn = (0, exports.sep)(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var u2;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          var vRoot = root[v2];
          blockGraph.setNode(vRoot);
          if (u2) {
            var uRoot = root[u2];
            var prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v2, u2), prevMax || 0));
          }
          u2 = v2;
        });
      });
      return blockGraph;
    };
    exports.buildBlockGraph = buildBlockGraph;
    var findSmallestWidthAlignment = function(g2, xss) {
      return (0, util_2.minBy)(Object.values(xss), function(xs) {
        var _a2;
        var max8 = Number.NEGATIVE_INFINITY;
        var min6 = Number.POSITIVE_INFINITY;
        (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
          var x4 = xs[v2];
          var halfWidth = (0, exports.width)(g2, v2) / 2;
          max8 = Math.max(x4 + halfWidth, max8);
          min6 = Math.min(x4 - halfWidth, min6);
        });
        return max8 - min6;
      });
    };
    exports.findSmallestWidthAlignment = findSmallestWidthAlignment;
    function alignCoordinates(xss, alignTo) {
      var alignToVals = Object.values(alignTo);
      var alignToMin = (0, util_1.min)(alignToVals);
      var alignToMax = (0, util_1.max)(alignToVals);
      ["u", "d"].forEach(function(vert) {
        ["l", "r"].forEach(function(horiz) {
          var alignment = vert + horiz;
          var xs = xss[alignment];
          var delta;
          if (xs === alignTo)
            return;
          var xsVals = Object.values(xs);
          delta = horiz === "l" ? alignToMin - (0, util_1.min)(xsVals) : alignToMax - (0, util_1.max)(xsVals);
          if (delta) {
            xss[alignment] = {};
            Object.keys(xs).forEach(function(key) {
              xss[alignment][key] = xs[key] + delta;
            });
          }
        });
      });
    }
    exports.alignCoordinates = alignCoordinates;
    var balance = function(xss, align) {
      var result = {};
      Object.keys(xss.ul).forEach(function(key) {
        if (align) {
          result[key] = xss[align.toLowerCase()][key];
        } else {
          var values3 = Object.values(xss).map(function(x4) {
            return x4[key];
          });
          result[key] = (values3[0] + values3[1]) / 2;
        }
      });
      return result;
    };
    exports.balance = balance;
    var positionX = function(g2) {
      var layering = (0, util_2.buildLayerMatrix)(g2);
      var conflicts = Object.assign((0, exports.findType1Conflicts)(g2, layering), (0, exports.findType2Conflicts)(g2, layering));
      var xss = {};
      var adjustedLayering;
      ["u", "d"].forEach(function(vert) {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach(function(horiz) {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map(function(inner) {
              return Object.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
          var align = (0, exports.verticalAlignment)(g2, adjustedLayering, conflicts, neighborFn);
          var xs = (0, exports.horizontalCompaction)(g2, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            Object.keys(xs).forEach(function(key) {
              xs[key] = -xs[key];
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = (0, exports.findSmallestWidthAlignment)(g2, xss);
      alignCoordinates(xss, smallestWidth);
      return (0, exports.balance)(xss, g2.graph().align);
    };
    exports.positionX = positionX;
    var sep = function(nodeSep, edgeSep, reverseSep) {
      return function(g2, v2, w2) {
        var vLabel = g2.node(v2);
        var wLabel = g2.node(w2);
        var sum = 0;
        var delta;
        sum += vLabel.width / 2;
        if (vLabel.hasOwnProperty("labelpos")) {
          switch ((vLabel.labelpos || "").toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.width / 2;
        if (wLabel.labelpos) {
          switch ((wLabel.labelpos || "").toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
      };
    };
    exports.sep = sep;
    var width = function(g2, v2) {
      return g2.node(v2).width || 0;
    };
    exports.width = width;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/position/index.js
var require_position = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/position/index.js"(exports) {
    "use strict";
    var __spreadArray6 = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
        if (ar2 || !(i2 in from)) {
          if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
          ar2[i2] = from[i2];
        }
      }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var bk_1 = require_bk();
    var positionY = function(g2) {
      var layering = (0, util_1.buildLayerMatrix)(g2);
      var rankSep = g2.graph().ranksep;
      var prevY = 0;
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var heights = layer.map(function(v2) {
          return g2.node(v2).height;
        });
        var maxHeight = Math.max.apply(Math, __spreadArray6(__spreadArray6([], heights, false), [0], false));
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          g2.node(v2).y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + rankSep;
      });
    };
    var positionX = function(g2) {
      var layering = (0, util_1.buildLayerMatrix)(g2);
      var conflicts = Object.assign((0, bk_1.findType1Conflicts)(g2, layering), (0, bk_1.findType2Conflicts)(g2, layering));
      var xss = {};
      var adjustedLayering = [];
      ["u", "d"].forEach(function(vert) {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach(function(horiz) {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map(function(inner) {
              return Object.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
          var align = (0, bk_1.verticalAlignment)(g2, adjustedLayering, conflicts, neighborFn);
          var xs = (0, bk_1.horizontalCompaction)(g2, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            Object.keys(xs).forEach(function(xsKey) {
              return xs[xsKey] = -xs[xsKey];
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = (0, bk_1.findSmallestWidthAlignment)(g2, xss);
      smallestWidth && (0, bk_1.alignCoordinates)(xss, smallestWidth);
      return (0, bk_1.balance)(xss, g2.graph().align);
    };
    var position = function(g2) {
      var _a2;
      var ng = (0, util_1.asNonCompoundGraph)(g2);
      positionY(ng);
      var xs = positionX(ng);
      (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(key) {
        ng.node(key).x = xs[key];
      });
    };
    exports.default = position;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/init-data-order.js
var require_init_data_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/init-data-order.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var initDataOrder = function(g2, nodeOrder) {
      var simpleNodes = g2.nodes().filter(function(v2) {
        var _a2;
        return !((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length);
      });
      var ranks = simpleNodes.map(function(v2) {
        return g2.node(v2).rank;
      });
      var maxRank = Math.max.apply(Math, ranks);
      var layers = [];
      for (var i2 = 0; i2 < maxRank + 1; i2++) {
        layers[i2] = [];
      }
      nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach(function(n2) {
        var node = g2.node(n2);
        if (!node || (node === null || node === void 0 ? void 0 : node.dummy)) {
          return;
        }
        if (!isNaN(node.rank)) {
          node.fixorder = layers[node.rank].length;
          layers[node.rank].push(n2);
        }
      });
    };
    exports.default = initDataOrder;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/layout.js
var require_layout = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/layout.js"(exports) {
    "use strict";
    var __assign18 = exports && exports.__assign || function() {
      __assign18 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign18.apply(this, arguments);
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var acyclic_1 = __importDefault2(require_acyclic());
    var normalize_1 = __importDefault2(require_normalize());
    var rank_1 = __importDefault2(require_rank());
    var util_1 = require_util3();
    var parent_dummy_chains_1 = __importDefault2(require_parent_dummy_chains());
    var nesting_graph_1 = __importDefault2(require_nesting_graph());
    var add_border_segments_1 = __importDefault2(require_add_border_segments());
    var coordinate_system_1 = __importDefault2(require_coordinate_system());
    var order_1 = __importDefault2(require_order());
    var position_1 = __importDefault2(require_position());
    var init_data_order_1 = __importDefault2(require_init_data_order());
    var graph_1 = require_graph();
    var layout2 = function(g2, opts) {
      var time = opts && opts.debugTiming ? util_1.time : util_1.notime;
      time("layout", function() {
        if (opts && !opts.keepNodeOrder && opts.prevGraph) {
          time("  inheritOrder", function() {
            inheritOrder(g2, opts.prevGraph);
          });
        }
        var layoutGraph = time("  buildLayoutGraph", function() {
          return buildLayoutGraph(g2);
        });
        if (!(opts && opts.edgeLabelSpace === false)) {
          time("  makeSpaceForEdgeLabels", function() {
            makeSpaceForEdgeLabels(layoutGraph);
          });
        }
        try {
          time("  runLayout", function() {
            runLayout(layoutGraph, time, opts);
          });
        } catch (e8) {
          if (e8.message === "Not possible to find intersection inside of the rectangle") {
            console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e8);
            return;
          }
          throw e8;
        }
        time("  updateInputGraph", function() {
          updateInputGraph(g2, layoutGraph);
        });
      });
    };
    var runLayout = function(g2, time, opts) {
      time("    removeSelfEdges", function() {
        removeSelfEdges(g2);
      });
      time("    acyclic", function() {
        acyclic_1.default.run(g2);
      });
      time("    nestingGraph.run", function() {
        nesting_graph_1.default.run(g2);
      });
      time("    rank", function() {
        (0, rank_1.default)((0, util_1.asNonCompoundGraph)(g2));
      });
      time("    injectEdgeLabelProxies", function() {
        injectEdgeLabelProxies(g2);
      });
      time("    removeEmptyRanks", function() {
        (0, util_1.removeEmptyRanks)(g2);
      });
      time("    nestingGraph.cleanup", function() {
        nesting_graph_1.default.cleanup(g2);
      });
      time("    normalizeRanks", function() {
        (0, util_1.normalizeRanks)(g2);
      });
      time("    assignRankMinMax", function() {
        assignRankMinMax(g2);
      });
      time("    removeEdgeLabelProxies", function() {
        removeEdgeLabelProxies(g2);
      });
      time("    normalize.run", function() {
        normalize_1.default.run(g2);
      });
      time("    parentDummyChains", function() {
        (0, parent_dummy_chains_1.default)(g2);
      });
      time("    addBorderSegments", function() {
        (0, add_border_segments_1.default)(g2);
      });
      if (opts && opts.keepNodeOrder) {
        time("    initDataOrder", function() {
          (0, init_data_order_1.default)(g2, opts.nodeOrder);
        });
      }
      time("    order", function() {
        (0, order_1.default)(g2, opts === null || opts === void 0 ? void 0 : opts.keepNodeOrder);
      });
      time("    insertSelfEdges", function() {
        insertSelfEdges(g2);
      });
      time("    adjustCoordinateSystem", function() {
        coordinate_system_1.default.adjust(g2);
      });
      time("    position", function() {
        (0, position_1.default)(g2);
      });
      time("    positionSelfEdges", function() {
        positionSelfEdges(g2);
      });
      time("    removeBorderNodes", function() {
        removeBorderNodes(g2);
      });
      time("    normalize.undo", function() {
        normalize_1.default.undo(g2);
      });
      time("    fixupEdgeLabelCoords", function() {
        fixupEdgeLabelCoords(g2);
      });
      time("    undoCoordinateSystem", function() {
        coordinate_system_1.default.undo(g2);
      });
      time("    translateGraph", function() {
        translateGraph(g2);
      });
      time("    assignNodeIntersects", function() {
        assignNodeIntersects(g2);
      });
      time("    reversePoints", function() {
        reversePointsForReversedEdges(g2);
      });
      time("    acyclic.undo", function() {
        acyclic_1.default.undo(g2);
      });
    };
    var inheritOrder = function(currG, prevG) {
      currG.nodes().forEach(function(n2) {
        var node = currG.node(n2);
        var prevNode = prevG.node(n2);
        if (prevNode !== void 0) {
          node.fixorder = prevNode._order;
          delete prevNode._order;
        } else {
          delete node.fixorder;
        }
      });
    };
    var updateInputGraph = function(inputGraph, layoutGraph) {
      inputGraph.nodes().forEach(function(v2) {
        var _a2;
        var inputLabel = inputGraph.node(v2);
        if (inputLabel) {
          var layoutLabel = layoutGraph.node(v2);
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          inputLabel._order = layoutLabel.order;
          inputLabel._rank = layoutLabel.rank;
          if ((_a2 = layoutGraph.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      inputGraph.edges().forEach(function(e8) {
        var inputLabel = inputGraph.edge(e8);
        var layoutLabel = layoutGraph.edge(e8);
        inputLabel.points = layoutLabel ? layoutLabel.points : [];
        if (layoutLabel && layoutLabel.hasOwnProperty("x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    };
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height", "layer", "fixorder"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    var buildLayoutGraph = function(inputGraph) {
      var g2 = new graph_1.Graph({ multigraph: true, compound: true });
      var graph = canonicalize(inputGraph.graph());
      var pickedProperties = {};
      graphAttrs === null || graphAttrs === void 0 ? void 0 : graphAttrs.forEach(function(key) {
        if (graph[key] !== void 0)
          pickedProperties[key] = graph[key];
      });
      g2.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), pickedProperties));
      inputGraph.nodes().forEach(function(v2) {
        var node = canonicalize(inputGraph.node(v2));
        var defaultNode = __assign18(__assign18({}, nodeDefaults), node);
        var defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);
        g2.setNode(v2, defaultAttrs);
        g2.setParent(v2, inputGraph.parent(v2));
      });
      inputGraph.edges().forEach(function(e8) {
        var edge = canonicalize(inputGraph.edge(e8));
        var pickedProperties2 = {};
        edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach(function(key) {
          if (edge[key] !== void 0)
            pickedProperties2[key] = edge[key];
        });
        g2.setEdgeObj(e8, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties2));
      });
      return g2;
    };
    var makeSpaceForEdgeLabels = function(g2) {
      var graph = g2.graph();
      if (!graph.ranksep)
        graph.ranksep = 0;
      graph.ranksep /= 2;
      g2.nodes().forEach(function(n2) {
        var node = g2.node(n2);
        if (!isNaN(node.layer)) {
          if (!node.layer)
            node.layer = 0;
        }
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        edge.minlen *= 2;
        if (((_a2 = edge.labelpos) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    };
    var injectEdgeLabelProxies = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge.width && edge.height) {
          var v2 = g2.node(e8.v);
          var w2 = g2.node(e8.w);
          var label = {
            e: e8,
            rank: (w2.rank - v2.rank) / 2 + v2.rank
          };
          (0, util_1.addDummyNode)(g2, "edge-proxy", label, "_ep");
        }
      });
    };
    var assignRankMinMax = function(g2) {
      var maxRank = 0;
      g2.nodes().forEach(function(v2) {
        var _a2, _b;
        var node = g2.node(v2);
        if (node.borderTop) {
          node.minRank = (_a2 = g2.node(node.borderTop)) === null || _a2 === void 0 ? void 0 : _a2.rank;
          node.maxRank = (_b = g2.node(node.borderBottom)) === null || _b === void 0 ? void 0 : _b.rank;
          maxRank = Math.max(maxRank, node.maxRank || -Infinity);
        }
      });
      g2.graph().maxRank = maxRank;
    };
    var removeEdgeLabelProxies = function(g2) {
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "edge-proxy") {
          g2.edge(node.e).labelRank = node.rank;
          g2.removeNode(v2);
        }
      });
    };
    var translateGraph = function(g2) {
      var minX;
      var maxX = 0;
      var minY;
      var maxY = 0;
      var graphLabel = g2.graph();
      var marginX = graphLabel.marginx || 0;
      var marginY = graphLabel.marginy || 0;
      var getExtremes = function(attrs) {
        if (!attrs)
          return;
        var x4 = attrs.x;
        var y4 = attrs.y;
        var w2 = attrs.width;
        var h2 = attrs.height;
        if (!isNaN(x4) && !isNaN(w2)) {
          if (minX === void 0) {
            minX = x4 - w2 / 2;
          }
          minX = Math.min(minX, x4 - w2 / 2);
          maxX = Math.max(maxX, x4 + w2 / 2);
        }
        if (!isNaN(y4) && !isNaN(h2)) {
          if (minY === void 0) {
            minY = y4 - h2 / 2;
          }
          minY = Math.min(minY, y4 - h2 / 2);
          maxY = Math.max(maxY, y4 + h2 / 2);
        }
      };
      g2.nodes().forEach(function(v2) {
        getExtremes(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node) {
          node.x -= minX;
          node.y -= minY;
        }
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(p2) {
          p2.x -= minX;
          p2.y -= minY;
        });
        if (edge.hasOwnProperty("x")) {
          edge.x -= minX;
        }
        if (edge.hasOwnProperty("y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY - minY + marginY;
    };
    var assignNodeIntersects = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        var nodeV = g2.node(e8.v);
        var nodeW = g2.node(e8.w);
        var p1;
        var p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift((0, util_1.intersectRect)(nodeV, p1));
        edge.points.push((0, util_1.intersectRect)(nodeW, p2));
      });
    };
    var fixupEdgeLabelCoords = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    };
    var reversePointsForReversedEdges = function(g2) {
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        if (edge.reversed) {
          (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.reverse();
        }
      });
    };
    var removeBorderNodes = function(g2) {
      g2.nodes().forEach(function(v2) {
        var _a2, _b, _c;
        if ((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length) {
          var node = g2.node(v2);
          var t4 = g2.node(node.borderTop);
          var b10 = g2.node(node.borderBottom);
          var l2 = g2.node(node.borderLeft[((_b = node.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
          var r2 = g2.node(node.borderRight[((_c = node.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
          node.width = Math.abs((r2 === null || r2 === void 0 ? void 0 : r2.x) - (l2 === null || l2 === void 0 ? void 0 : l2.x)) || 10;
          node.height = Math.abs((b10 === null || b10 === void 0 ? void 0 : b10.y) - (t4 === null || t4 === void 0 ? void 0 : t4.y)) || 10;
          node.x = ((l2 === null || l2 === void 0 ? void 0 : l2.x) || 0) + node.width / 2;
          node.y = ((t4 === null || t4 === void 0 ? void 0 : t4.y) || 0) + node.height / 2;
        }
      });
      g2.nodes().forEach(function(v2) {
        var _a2;
        if (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) === "border") {
          g2.removeNode(v2);
        }
      });
    };
    var removeSelfEdges = function(g2) {
      g2.edges().forEach(function(e8) {
        if (e8.v === e8.w) {
          var node = g2.node(e8.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e: e8, label: g2.edge(e8) });
          g2.removeEdgeObj(e8);
        }
      });
    };
    var insertSelfEdges = function(g2) {
      var layers = (0, util_1.buildLayerMatrix)(g2);
      layers === null || layers === void 0 ? void 0 : layers.forEach(function(layer) {
        var orderShift = 0;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          var _a2;
          var node = g2.node(v2);
          node.order = i2 + orderShift;
          (_a2 = node.selfEdges) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(selfEdge) {
            (0, util_1.addDummyNode)(g2, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i2 + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    };
    var positionSelfEdges = function(g2) {
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "selfedge") {
          var selfNode = g2.node(node.e.v);
          var x4 = selfNode.x + selfNode.width / 2;
          var y4 = selfNode.y;
          var dx = node.x - x4;
          var dy = selfNode.height / 2;
          g2.setEdgeObj(node.e, node.label);
          g2.removeNode(v2);
          node.label.points = [
            { x: x4 + 2 * dx / 3, y: y4 - dy },
            { x: x4 + 5 * dx / 6, y: y4 - dy },
            { y: y4, x: x4 + dx },
            { x: x4 + 5 * dx / 6, y: y4 + dy },
            { x: x4 + 2 * dx / 3, y: y4 + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    };
    var selectNumberAttrs = function(obj, attrs) {
      var pickedProperties = {};
      attrs === null || attrs === void 0 ? void 0 : attrs.forEach(function(key) {
        if (obj[key] === void 0)
          return;
        pickedProperties[key] = +obj[key];
      });
      return pickedProperties;
    };
    var canonicalize = function(attrs) {
      if (attrs === void 0) {
        attrs = {};
      }
      var newAttrs = {};
      Object.keys(attrs).forEach(function(k2) {
        newAttrs[k2.toLowerCase()] = attrs[k2];
      });
      return newAttrs;
    };
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var layout_1 = __importDefault2(require_layout());
    var util_1 = require_util3();
    exports.default = {
      layout: layout_1.default,
      util: {
        time: util_1.time,
        notime: util_1.notime
      }
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre.js
var require_dagre2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DagreLayout = void 0;
    var index_1 = __importDefault2(require_dagre());
    var util_1 = require_util2();
    var base_1 = require_base();
    var graph_1 = require_graph();
    var DagreLayout2 = (
      /** @class */
      function(_super) {
        __extends17(DagreLayout3, _super);
        function DagreLayout3(options) {
          var _this = _super.call(this) || this;
          _this.rankdir = "TB";
          _this.nodesep = 50;
          _this.ranksep = 50;
          _this.controlPoints = false;
          _this.sortByCombo = false;
          _this.edgeLabelSpace = true;
          _this.radial = false;
          _this.nodes = [];
          _this.edges = [];
          _this.onLayoutEnd = function() {
          };
          _this.layoutNode = function(nodeId) {
            var self2 = _this;
            var nodes = self2.nodes;
            var node = nodes.find(function(node2) {
              return node2.id === nodeId;
            });
            if (node) {
              var layout2 = node.layout !== false;
              return layout2;
            }
            return true;
          };
          _this.updateCfg(options);
          return _this;
        }
        DagreLayout3.prototype.getDefaultCfg = function() {
          return {
            rankdir: "TB",
            align: void 0,
            nodeSize: void 0,
            nodesepFunc: void 0,
            ranksepFunc: void 0,
            nodesep: 50,
            ranksep: 50,
            controlPoints: false,
            radial: false,
            focusNode: null
            // radial 为 true 时生效，关注的节点
          };
        };
        DagreLayout3.prototype.execute = function() {
          var _this = this;
          var _a2, _b, _c, _d;
          var self2 = this;
          var nodes = self2.nodes, nodeSize = self2.nodeSize, rankdir = self2.rankdir, combos = self2.combos, begin = self2.begin, radial = self2.radial, _e2 = self2.comboEdges, comboEdges = _e2 === void 0 ? [] : _e2, _f = self2.vedges, vedges = _f === void 0 ? [] : _f;
          if (!nodes)
            return;
          var edges = self2.edges || [];
          var g2 = new graph_1.Graph({
            multigraph: true,
            compound: true
          });
          self2.nodeMap = {};
          var nodeComboMap = {};
          nodes.forEach(function(node) {
            self2.nodeMap[node.id] = node;
            if (!node.comboId)
              return;
            nodeComboMap[node.comboId] = nodeComboMap[node.comboId] || [];
            nodeComboMap[node.comboId].push(node.id);
          });
          var sortedNodes = [];
          var visitedMap = {};
          if ((_a2 = self2.nodeOrder) === null || _a2 === void 0 ? void 0 : _a2.length) {
            self2.nodeOrder.forEach(function(id) {
              visitedMap[id] = true;
              sortedNodes.push(self2.nodeMap[id]);
            });
            nodes.forEach(function(node) {
              if (!visitedMap[node.id])
                sortedNodes.push(node);
            });
          } else {
            sortedNodes = nodes;
          }
          var nodeSizeFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  return d2.size;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  return [d2.size.width || 40, d2.size.height || 40];
                }
                return [d2.size, d2.size];
              }
              return [40, 40];
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            nodeSizeFunc = function() {
              return nodeSize;
            };
          } else {
            nodeSizeFunc = function() {
              return [nodeSize, nodeSize];
            };
          }
          var ranksepfunc = (0, util_1.getFunc)(self2.ranksep, 50, self2.ranksepFunc);
          var nodesepfunc = (0, util_1.getFunc)(self2.nodesep, 50, self2.nodesepFunc);
          var horisep = nodesepfunc;
          var vertisep = ranksepfunc;
          if (rankdir === "LR" || rankdir === "RL") {
            horisep = ranksepfunc;
            vertisep = nodesepfunc;
          }
          g2.setDefaultEdgeLabel(function() {
            return {};
          });
          g2.setGraph(self2);
          var comboMap = {};
          if (this.sortByCombo && combos) {
            combos.forEach(function(combo) {
              comboMap[combo.id] = combo;
              if (combo.collapsed) {
                var size3 = nodeSizeFunc(combo);
                var verti = vertisep(combo);
                var hori = horisep(combo);
                var width = size3[0] + 2 * hori;
                var height = size3[1] + 2 * verti;
                g2.setNode(combo.id, { width, height });
              }
              if (!combo.parentId)
                return;
              if (!comboMap[combo.parentId]) {
                g2.setNode(combo.parentId, {});
              }
              g2.setParent(combo.id, combo.parentId);
            });
          }
          sortedNodes.filter(function(node) {
            return node.layout !== false;
          }).forEach(function(node) {
            var size3 = nodeSizeFunc(node);
            var verti = vertisep(node);
            var hori = horisep(node);
            var width = size3[0] + 2 * hori;
            var height = size3[1] + 2 * verti;
            var layer = node.layer;
            if ((0, util_1.isNumber)(layer)) {
              g2.setNode(node.id, { width, height, layer });
            } else {
              g2.setNode(node.id, { width, height });
            }
            if (_this.sortByCombo && node.comboId) {
              if (!comboMap[node.comboId]) {
                comboMap[node.comboId] = { id: node.comboId };
                g2.setNode(node.comboId, {});
              }
              g2.setParent(node.id, node.comboId);
            }
          });
          edges.forEach(function(edge) {
            var source = (0, util_1.getEdgeTerminal)(edge, "source");
            var target = (0, util_1.getEdgeTerminal)(edge, "target");
            if (_this.layoutNode(source) && _this.layoutNode(target)) {
              g2.setEdge(source, target, {
                weight: edge.weight || 1
              });
            }
          });
          (_b = comboEdges === null || comboEdges === void 0 ? void 0 : comboEdges.concat(vedges || [])) === null || _b === void 0 ? void 0 : _b.forEach(function(comboEdge) {
            var _a3, _b2;
            var source = comboEdge.source, target = comboEdge.target;
            var sources = ((_a3 = comboMap[source]) === null || _a3 === void 0 ? void 0 : _a3.collapsed) ? [source] : nodeComboMap[source] || [source];
            var targets = ((_b2 = comboMap[target]) === null || _b2 === void 0 ? void 0 : _b2.collapsed) ? [target] : nodeComboMap[target] || [target];
            sources.forEach(function(s2) {
              targets.forEach(function(t4) {
                g2.setEdge(s2, t4, {
                  weight: comboEdge.weight || 1
                });
              });
            });
          });
          var prevGraph = void 0;
          if ((_c = self2.preset) === null || _c === void 0 ? void 0 : _c.nodes) {
            prevGraph = new graph_1.Graph({
              multigraph: true,
              compound: true
            });
            self2.preset.nodes.forEach(function(node) {
              prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);
            });
          }
          index_1.default.layout(g2, {
            prevGraph,
            edgeLabelSpace: self2.edgeLabelSpace,
            keepNodeOrder: Boolean(!!self2.nodeOrder),
            nodeOrder: self2.nodeOrder
          });
          var dBegin = [0, 0];
          if (begin) {
            var minX_1 = Infinity;
            var minY_1 = Infinity;
            g2.nodes().forEach(function(node) {
              var coord = g2.node(node);
              if (minX_1 > coord.x)
                minX_1 = coord.x;
              if (minY_1 > coord.y)
                minY_1 = coord.y;
            });
            g2.edges().forEach(function(edge) {
              var _a3;
              var coord = g2.edge(edge);
              (_a3 = coord.points) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(point) {
                if (minX_1 > point.x)
                  minX_1 = point.x;
                if (minY_1 > point.y)
                  minY_1 = point.y;
              });
            });
            dBegin[0] = begin[0] - minX_1;
            dBegin[1] = begin[1] - minY_1;
          }
          var isHorizontal = rankdir === "LR" || rankdir === "RL";
          if (radial) {
            var _g = this, focusNode = _g.focusNode, ranksep = _g.ranksep, getRadialPos_1 = _g.getRadialPos;
            var focusId = (0, util_1.isString)(focusNode) ? focusNode : focusNode === null || focusNode === void 0 ? void 0 : focusNode.id;
            var focusLayer_1 = focusId ? (_d = g2.node(focusId)) === null || _d === void 0 ? void 0 : _d._rank : 0;
            var layers_1 = [];
            var dim_1 = isHorizontal ? "y" : "x";
            var sizeDim_1 = isHorizontal ? "height" : "width";
            var min_1 = Infinity;
            var max_1 = -Infinity;
            g2.nodes().forEach(function(node) {
              var coord = g2.node(node);
              if (!self2.nodeMap[node])
                return;
              var currentNodesep = nodesepfunc(self2.nodeMap[node]);
              if (focusLayer_1 === 0) {
                if (!layers_1[coord._rank]) {
                  layers_1[coord._rank] = {
                    nodes: [],
                    totalWidth: 0,
                    maxSize: -Infinity
                  };
                }
                layers_1[coord._rank].nodes.push(node);
                layers_1[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                if (layers_1[coord._rank].maxSize < Math.max(coord.width, coord.height)) {
                  layers_1[coord._rank].maxSize = Math.max(coord.width, coord.height);
                }
              } else {
                var diffLayer = coord._rank - focusLayer_1;
                if (diffLayer === 0) {
                  if (!layers_1[diffLayer]) {
                    layers_1[diffLayer] = {
                      nodes: [],
                      totalWidth: 0,
                      maxSize: -Infinity
                    };
                  }
                  layers_1[diffLayer].nodes.push(node);
                  layers_1[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                  if (layers_1[diffLayer].maxSize < Math.max(coord.width, coord.height)) {
                    layers_1[diffLayer].maxSize = Math.max(coord.width, coord.height);
                  }
                } else {
                  var diffLayerAbs = Math.abs(diffLayer);
                  if (!layers_1[diffLayerAbs]) {
                    layers_1[diffLayerAbs] = {
                      left: [],
                      right: [],
                      totalWidth: 0,
                      maxSize: -Infinity
                    };
                  }
                  layers_1[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                  if (layers_1[diffLayerAbs].maxSize < Math.max(coord.width, coord.height)) {
                    layers_1[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);
                  }
                  if (diffLayer < 0) {
                    layers_1[diffLayerAbs].left.push(node);
                  } else {
                    layers_1[diffLayerAbs].right.push(node);
                  }
                }
              }
              var leftPos = coord[dim_1] - coord[sizeDim_1] / 2 - currentNodesep;
              var rightPos = coord[dim_1] + coord[sizeDim_1] / 2 + currentNodesep;
              if (leftPos < min_1)
                min_1 = leftPos;
              if (rightPos > max_1)
                max_1 = rightPos;
            });
            var radius_1 = ranksep || 50;
            var radiusMap_1 = {};
            var rangeLength_1 = (max_1 - min_1) / 0.9;
            var range_1 = [
              (min_1 + max_1 - rangeLength_1) * 0.5,
              (min_1 + max_1 + rangeLength_1) * 0.5
            ];
            var processNodes_1 = function(layerNodes, radius, propsMaxRanksep, arcRange) {
              if (propsMaxRanksep === void 0) {
                propsMaxRanksep = -Infinity;
              }
              if (arcRange === void 0) {
                arcRange = [0, 1];
              }
              var maxRanksep = propsMaxRanksep;
              layerNodes.forEach(function(node) {
                var coord = g2.node(node);
                radiusMap_1[node] = radius;
                var _a3 = getRadialPos_1(coord[dim_1], range_1, rangeLength_1, radius, arcRange), newX = _a3.x, newY = _a3.y;
                if (!self2.nodeMap[node])
                  return;
                self2.nodeMap[node].x = newX + dBegin[0];
                self2.nodeMap[node].y = newY + dBegin[1];
                self2.nodeMap[node]._order = coord._order;
                var currentNodeRanksep = ranksepfunc(self2.nodeMap[node]);
                if (maxRanksep < currentNodeRanksep)
                  maxRanksep = currentNodeRanksep;
              });
              return maxRanksep;
            };
            var isFirstLevel_1 = true;
            var lastLayerMaxNodeSize_1 = 0;
            layers_1.forEach(function(layerNodes) {
              var _a3, _b2, _c2, _d2, _e3, _f2, _g2;
              if (!((_a3 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.nodes) === null || _a3 === void 0 ? void 0 : _a3.length) && !((_b2 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.left) === null || _b2 === void 0 ? void 0 : _b2.length) && !((_c2 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.right) === null || _c2 === void 0 ? void 0 : _c2.length)) {
                return;
              }
              if (isFirstLevel_1 && layerNodes.nodes.length === 1) {
                var nodeId = layerNodes.nodes[0];
                if (!self2.nodeMap[nodeId])
                  return;
                self2.nodeMap[nodeId].x = dBegin[0];
                self2.nodeMap[nodeId].y = dBegin[1];
                radiusMap_1[layerNodes.nodes[0]] = 0;
                radius_1 = ranksepfunc(self2.nodeMap[nodeId]);
                isFirstLevel_1 = false;
                return;
              }
              radius_1 = Math.max(radius_1, layerNodes.totalWidth / (2 * Math.PI));
              var maxRanksep = -Infinity;
              if (focusLayer_1 === 0 || ((_d2 = layerNodes.nodes) === null || _d2 === void 0 ? void 0 : _d2.length)) {
                maxRanksep = processNodes_1(layerNodes.nodes, radius_1, maxRanksep, [0, 1]);
              } else {
                var leftRatio = ((_e3 = layerNodes.left) === null || _e3 === void 0 ? void 0 : _e3.length) / (((_f2 = layerNodes.left) === null || _f2 === void 0 ? void 0 : _f2.length) + ((_g2 = layerNodes.right) === null || _g2 === void 0 ? void 0 : _g2.length));
                maxRanksep = processNodes_1(layerNodes.left, radius_1, maxRanksep, [
                  0,
                  leftRatio
                ]);
                maxRanksep = processNodes_1(layerNodes.right, radius_1, maxRanksep, [
                  leftRatio + 0.05,
                  1
                ]);
              }
              radius_1 += maxRanksep;
              isFirstLevel_1 = false;
              lastLayerMaxNodeSize_1 - layerNodes.maxSize;
            });
            g2.edges().forEach(function(edge) {
              var _a3, _b2, _c2;
              var coord = g2.edge(edge);
              var i2 = edges.findIndex(function(it2) {
                var source = (0, util_1.getEdgeTerminal)(it2, "source");
                var target = (0, util_1.getEdgeTerminal)(it2, "target");
                return source === edge.v && target === edge.w;
              });
              if (i2 <= -1)
                return;
              if (self2.edgeLabelSpace && self2.controlPoints && edges[i2].type !== "loop") {
                var otherDim_1 = dim_1 === "x" ? "y" : "x";
                var controlPoints = (_a3 = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a3 === void 0 ? void 0 : _a3.slice(1, coord.points.length - 1);
                var newControlPoints_1 = [];
                var sourceOtherDimValue_1 = (_b2 = g2.node(edge.v)) === null || _b2 === void 0 ? void 0 : _b2[otherDim_1];
                var otherDimDist_1 = sourceOtherDimValue_1 - ((_c2 = g2.node(edge.w)) === null || _c2 === void 0 ? void 0 : _c2[otherDim_1]);
                var sourceRadius_1 = radiusMap_1[edge.v];
                var radiusDist_1 = sourceRadius_1 - radiusMap_1[edge.w];
                controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.forEach(function(point) {
                  var cRadius = (point[otherDim_1] - sourceOtherDimValue_1) / otherDimDist_1 * radiusDist_1 + sourceRadius_1;
                  var newPos = getRadialPos_1(point[dim_1], range_1, rangeLength_1, cRadius);
                  newControlPoints_1.push({
                    x: newPos.x + dBegin[0],
                    y: newPos.y + dBegin[1]
                  });
                });
                edges[i2].controlPoints = newControlPoints_1;
              }
            });
          } else {
            var layerCoords_1 = /* @__PURE__ */ new Set();
            var isInvert = rankdir === "BT" || rankdir === "RL";
            var layerCoordSort = isInvert ? function(a3, b10) {
              return b10 - a3;
            } : function(a3, b10) {
              return a3 - b10;
            };
            g2.nodes().forEach(function(node) {
              var coord = g2.node(node);
              if (!coord)
                return;
              var ndata = _this.nodeMap[node];
              if (!ndata) {
                ndata = combos === null || combos === void 0 ? void 0 : combos.find(function(it2) {
                  return it2.id === node;
                });
              }
              if (!ndata)
                return;
              ndata.x = coord.x + dBegin[0];
              ndata.y = coord.y + dBegin[1];
              ndata._order = coord._order;
              layerCoords_1.add(isHorizontal ? ndata.x : ndata.y);
            });
            var layerCoordsArr_1 = Array.from(layerCoords_1).sort(layerCoordSort);
            var isDifferentLayer_1 = isHorizontal ? function(point1, point2) {
              return point1.x !== point2.x;
            } : function(point1, point2) {
              return point1.y !== point2.y;
            };
            var filterControlPointsOutOfBoundary_1 = isHorizontal ? function(ps, point1, point2) {
              var max8 = Math.max(point1.y, point2.y);
              var min6 = Math.min(point1.y, point2.y);
              return ps.filter(function(point) {
                return point.y <= max8 && point.y >= min6;
              });
            } : function(ps, point1, point2) {
              var max8 = Math.max(point1.x, point2.x);
              var min6 = Math.min(point1.x, point2.x);
              return ps.filter(function(point) {
                return point.x <= max8 && point.x >= min6;
              });
            };
            g2.edges().forEach(function(edge) {
              var _a3;
              var coord = g2.edge(edge);
              var i2 = edges.findIndex(function(it2) {
                var source = (0, util_1.getEdgeTerminal)(it2, "source");
                var target = (0, util_1.getEdgeTerminal)(it2, "target");
                return source === edge.v && target === edge.w;
              });
              if (i2 <= -1)
                return;
              if (self2.edgeLabelSpace && self2.controlPoints && edges[i2].type !== "loop") {
                (_a3 = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(point) {
                  point.x += dBegin[0];
                  point.y += dBegin[1];
                });
                var sourceNode = self2.nodeMap[edge.v];
                var targetNode = self2.nodeMap[edge.w];
                edges[i2].controlPoints = getControlPoints14(coord === null || coord === void 0 ? void 0 : coord.points, sourceNode, targetNode, layerCoordsArr_1, isHorizontal, isDifferentLayer_1, filterControlPointsOutOfBoundary_1);
              }
            });
          }
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        DagreLayout3.prototype.getRadialPos = function(dimValue, range, rangeLength, radius, arcRange) {
          if (arcRange === void 0) {
            arcRange = [0, 1];
          }
          var dimRatio = (dimValue - range[0]) / rangeLength;
          dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];
          var angle3 = dimRatio * 2 * Math.PI;
          return {
            x: Math.cos(angle3) * radius,
            y: Math.sin(angle3) * radius
          };
        };
        DagreLayout3.prototype.getType = function() {
          return "dagre";
        };
        return DagreLayout3;
      }(base_1.Base)
    );
    exports.DagreLayout = DagreLayout2;
    var getControlPoints14 = function(points, sourceNode, targetNode, layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary) {
      var controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || [];
      if (sourceNode && targetNode) {
        var sourceX = sourceNode.x, sourceY = sourceNode.y;
        var targetX = targetNode.x, targetY = targetNode.y;
        if (isHorizontal) {
          sourceX = sourceNode.y;
          sourceY = sourceNode.x;
          targetX = targetNode.y;
          targetY = targetNode.x;
        }
        if (targetY !== sourceY && sourceX !== targetX) {
          var sourceLayer = layerCoordsArr.indexOf(sourceY);
          var sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];
          if (sourceNextLayerCoord) {
            var firstControlPoint = controlPoints[0];
            var insertStartControlPoint = isHorizontal ? {
              x: (sourceY + sourceNextLayerCoord) / 2,
              y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX
            } : {
              x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,
              y: (sourceY + sourceNextLayerCoord) / 2
            };
            if (!firstControlPoint || isDifferentLayer(firstControlPoint, insertStartControlPoint)) {
              controlPoints.unshift(insertStartControlPoint);
            }
          }
          var targetLayer = layerCoordsArr.indexOf(targetY);
          var layerDiff = Math.abs(targetLayer - sourceLayer);
          if (layerDiff === 1) {
            controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode, targetNode);
            if (!controlPoints.length) {
              controlPoints.push(isHorizontal ? {
                x: (sourceY + targetY) / 2,
                y: sourceX
              } : {
                x: sourceX,
                y: (sourceY + targetY) / 2
              });
            }
          } else if (layerDiff > 1) {
            var targetLastLayerCoord = layerCoordsArr[targetLayer - 1];
            if (targetLastLayerCoord) {
              var lastControlPoints = controlPoints[controlPoints.length - 1];
              var insertEndControlPoint = isHorizontal ? {
                x: (targetY + targetLastLayerCoord) / 2,
                y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX
              } : {
                x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,
                y: (targetY + targetLastLayerCoord) / 2
              };
              if (!lastControlPoints || isDifferentLayer(lastControlPoints, insertEndControlPoint)) {
                controlPoints.push(insertEndControlPoint);
              }
            }
          }
        }
      }
      return controlPoints;
    };
  }
});

// node_modules/dagre-compound/dist/dagre-compound.es5.js
var dagre_compound_es5_exports = {};
__export(dagre_compound_es5_exports, {
  BRIDGE_GRAPH_NAME: () => o,
  GraphType: () => u,
  HierarchyNodeType: () => c2,
  InclusionType: () => a2,
  LAYOUT_CONFIG: () => e,
  NodeType: () => i,
  ROOT_NAME: () => r,
  buildGraph: () => rc,
  flatGraph: () => oc,
  getEdges: () => ic,
  mergeConfig: () => n
});
function n(n2 = {}, t4 = e) {
  var r2, o2, i2, a3;
  const u2 = JSON.parse(JSON.stringify(t4)), c3 = (null === (r2 = null == n2 ? void 0 : n2.graph) || void 0 === r2 ? void 0 : r2.meta) || {}, s2 = (null === (o2 = null == n2 ? void 0 : n2.subScene) || void 0 === o2 ? void 0 : o2.meta) || {}, d2 = (null === (i2 = null == n2 ? void 0 : n2.nodeSize) || void 0 === i2 ? void 0 : i2.meta) || {}, f2 = (null === (a3 = null == n2 ? void 0 : n2.nodeSize) || void 0 === a3 ? void 0 : a3.node) || {}, h2 = u2.nodeSize.bridge;
  return { graph: { meta: Object.assign(u2.graph.meta, c3) }, subScene: { meta: Object.assign(u2.subScene.meta, s2) }, nodeSize: { meta: Object.assign(u2.nodeSize.meta, d2), node: Object.assign(u2.nodeSize.node, f2), bridge: h2 } };
}
function t(e8) {
  return `◬${e8}◬`;
}
function d(e8, n2) {
  return e8(n2 = { exports: {} }, n2.exports), n2.exports;
}
function m2(e8) {
  var n2 = -1, t4 = null == e8 ? 0 : e8.length;
  for (this.clear(); ++n2 < t4; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function de(e8) {
  var n2 = -1, t4 = null == e8 ? 0 : e8.length;
  for (this.clear(); ++n2 < t4; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function me(e8) {
  var n2 = -1, t4 = null == e8 ? 0 : e8.length;
  for (this.clear(); ++n2 < t4; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function _e(e8) {
  var n2 = this.__data__ = new w(e8);
  this.size = n2.size;
}
function mt(e8) {
  var n2 = -1, t4 = null == e8 ? 0 : e8.length;
  for (this.__data__ = new we(); ++n2 < t4; ) this.add(e8[n2]);
}
function Vt(e8, n2) {
  if ("function" != typeof e8 || null != n2 && "function" != typeof n2) throw new TypeError("Expected a function");
  var t4 = function() {
    var r2 = arguments, o2 = n2 ? n2.apply(this, r2) : r2[0], i2 = t4.cache;
    if (i2.has(o2)) return i2.get(o2);
    var a3 = e8.apply(this, r2);
    return t4.cache = i2.set(o2, a3) || i2, a3;
  };
  return t4.cache = new (Vt.Cache || we)(), t4;
}
function vo(e8) {
  this._isDirected = !ho.has(e8, "directed") || e8.directed, this._isMultigraph = !!ho.has(e8, "multigraph") && e8.multigraph, this._isCompound = !!ho.has(e8, "compound") && e8.compound, this._label = void 0, this._defaultNodeLabelFn = ho.constant(void 0), this._defaultEdgeLabelFn = ho.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children["\0"] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
}
function po(e8, n2) {
  e8[n2] ? e8[n2]++ : e8[n2] = 1;
}
function go(e8, n2) {
  --e8[n2] || delete e8[n2];
}
function yo(e8, n2, t4, r2) {
  var o2 = "" + n2, i2 = "" + t4;
  if (!e8 && o2 > i2) {
    var a3 = o2;
    o2 = i2, i2 = a3;
  }
  return o2 + "" + i2 + "" + (ho.isUndefined(r2) ? "\0" : r2);
}
function bo(e8, n2, t4, r2) {
  var o2 = "" + n2, i2 = "" + t4;
  if (!e8 && o2 > i2) {
    var a3 = o2;
    o2 = i2, i2 = a3;
  }
  var u2 = { v: o2, w: i2 };
  return r2 && (u2.name = r2), u2;
}
function mo(e8, n2) {
  return yo(e8, n2.v, n2.w, n2.name);
}
function _o(e8) {
  return ho.map(e8.nodes(), function(n2) {
    var t4 = e8.node(n2), r2 = e8.parent(n2), o2 = { v: n2 };
    return ho.isUndefined(t4) || (o2.value = t4), ho.isUndefined(r2) || (o2.parent = r2), o2;
  });
}
function jo(e8) {
  return ho.map(e8.edges(), function(n2) {
    var t4 = e8.edge(n2), r2 = { v: n2.v, w: n2.w };
    return ho.isUndefined(n2.name) || (r2.name = n2.name), ho.isUndefined(t4) || (r2.value = t4), r2;
  });
}
function Oo() {
  this._arr = [], this._keyIndices = {};
}
function Lo(e8) {
  var n2 = {}, t4 = {}, r2 = [];
  if (ho.each(e8.sinks(), function o2(i2) {
    if (ho.has(t4, i2)) throw new Ro();
    ho.has(n2, i2) || (t4[i2] = true, n2[i2] = true, ho.each(e8.predecessors(i2), o2), delete t4[i2], r2.push(i2));
  }), ho.size(n2) !== e8.nodeCount()) throw new Ro();
  return r2;
}
function Ro() {
}
function Do(e8, n2, t4, r2, o2, i2) {
  ho.has(r2, n2) || (r2[n2] = true, t4 || i2.push(n2), ho.each(o2(n2), function(n3) {
    Do(e8, n3, t4, r2, o2, i2);
  }), t4 && i2.push(n2));
}
function qi() {
  var e8 = {};
  e8._next = e8._prev = e8, this._sentinel = e8;
}
function Yi(e8) {
  e8._prev._next = e8._next, e8._next._prev = e8._prev, delete e8._next, delete e8._prev;
}
function Ji(e8, n2) {
  if ("_next" !== e8 && "_prev" !== e8) return n2;
}
function Zi(e8, n2, t4, r2, o2) {
  var i2 = o2 ? [] : void 0;
  return Hi.forEach(e8.inEdges(r2.v), function(r3) {
    var a3 = e8.edge(r3), u2 = e8.node(r3.v);
    o2 && i2.push({ v: r3.v, w: r3.w }), u2.out -= a3, ea(n2, t4, u2);
  }), Hi.forEach(e8.outEdges(r2.v), function(r3) {
    var o3 = e8.edge(r3), i3 = r3.w, a3 = e8.node(i3);
    a3.in -= o3, ea(n2, t4, a3);
  }), e8.removeNode(r2.v), i2;
}
function ea(e8, n2, t4) {
  t4.out ? t4.in ? e8[t4.out - t4.in + n2].enqueue(t4) : e8[e8.length - 1].enqueue(t4) : e8[0].enqueue(t4);
}
function oa(e8, n2, t4, r2) {
  var o2;
  do {
    o2 = Hi.uniqueId(r2);
  } while (e8.hasNode(o2));
  return t4.dummy = n2, e8.setNode(o2, t4), o2;
}
function ia(e8) {
  return Hi.max(Hi.map(e8.nodes(), function(n2) {
    var t4 = e8.node(n2).rank;
    if (!Hi.isUndefined(t4)) return t4;
  }));
}
function ha(e8, n2) {
  return Hi.forEach(e8.nodes(), function t4(r2) {
    Hi.forEach(n2.nodeEdges(r2), function(o2) {
      var i2 = o2.v, a3 = r2 === i2 ? o2.w : i2;
      e8.hasNode(a3) || da(n2, o2) || (e8.setNode(a3, {}), e8.setEdge(r2, a3, {}), t4(a3));
    });
  }), e8.nodeCount();
}
function la(e8, n2) {
  return Hi.minBy(n2.edges(), function(t4) {
    if (e8.hasNode(t4.v) !== e8.hasNode(t4.w)) return da(n2, t4);
  });
}
function va(e8, n2, t4) {
  Hi.forEach(e8.nodes(), function(e9) {
    n2.node(e9).rank += t4;
  });
}
function Ea(e8) {
  e8 = ma(e8), ga(e8);
  var n2, t4 = fa(e8);
  for (xa(t4), _a(t4, e8); n2 = Oa(t4); ) Ia(t4, e8, n2, ka(t4, e8, n2));
}
function _a(e8, n2) {
  var t4 = ba(e8, e8.nodes());
  t4 = t4.slice(0, t4.length - 1), Hi.forEach(t4, function(t5) {
    !function(e9, n3, t6) {
      var r2 = e9.node(t6).parent;
      e9.edge(t6, r2).cutvalue = ja(e9, n3, t6);
    }(e8, n2, t5);
  });
}
function ja(e8, n2, t4) {
  var r2 = e8.node(t4).parent, o2 = true, i2 = n2.edge(t4, r2), a3 = 0;
  return i2 || (o2 = false, i2 = n2.edge(r2, t4)), a3 = i2.weight, Hi.forEach(n2.nodeEdges(t4), function(i3) {
    var u2, c3, s2 = i3.v === t4, d2 = s2 ? i3.w : i3.v;
    if (d2 !== r2) {
      var f2 = s2 === o2, h2 = n2.edge(i3).weight;
      if (a3 += f2 ? h2 : -h2, u2 = t4, c3 = d2, e8.hasEdge(u2, c3)) {
        var l2 = e8.edge(t4, d2).cutvalue;
        a3 += f2 ? -l2 : l2;
      }
    }
  }), a3;
}
function xa(e8, n2) {
  arguments.length < 2 && (n2 = e8.nodes()[0]), Na(e8, {}, 1, n2);
}
function Na(e8, n2, t4, r2, o2) {
  var i2 = t4, a3 = e8.node(r2);
  return n2[r2] = true, Hi.forEach(e8.neighbors(r2), function(o3) {
    Hi.has(n2, o3) || (t4 = Na(e8, n2, t4, o3, r2));
  }), a3.low = i2, a3.lim = t4++, o2 ? a3.parent = o2 : delete a3.parent, t4;
}
function Oa(e8) {
  return Hi.find(e8.edges(), function(n2) {
    return e8.edge(n2).cutvalue < 0;
  });
}
function ka(e8, n2, t4) {
  var r2 = t4.v, o2 = t4.w;
  n2.hasEdge(r2, o2) || (r2 = t4.w, o2 = t4.v);
  var i2 = e8.node(r2), a3 = e8.node(o2), u2 = i2, c3 = false;
  i2.lim > a3.lim && (u2 = a3, c3 = true);
  var s2 = Hi.filter(n2.edges(), function(n3) {
    return c3 === Sa(e8, e8.node(n3.v), u2) && c3 !== Sa(e8, e8.node(n3.w), u2);
  });
  return Hi.minBy(s2, function(e9) {
    return pa(n2, e9);
  });
}
function Ia(e8, n2, t4, r2) {
  var o2 = t4.v, i2 = t4.w;
  e8.removeEdge(o2, i2), e8.setEdge(r2.v, r2.w, {}), xa(e8), _a(e8, n2), function(e9, n3) {
    var t5 = Hi.find(e9.nodes(), function(e11) {
      return !n3.node(e11).parent;
    }), r3 = ya(e9, t5);
    r3 = r3.slice(1), Hi.forEach(r3, function(t6) {
      var r4 = e9.node(t6).parent, o3 = n3.edge(t6, r4), i3 = false;
      o3 || (o3 = n3.edge(r4, t6), i3 = true), n3.node(t6).rank = n3.node(r4).rank + (i3 ? o3.minlen : -o3.minlen);
    });
  }(e8, n2);
}
function Sa(e8, n2, t4) {
  return t4.low <= n2.lim && n2.lim <= t4.lim;
}
function Ba(e8) {
  wa(e8);
}
function Ra(e8, n2, t4, r2, o2, i2, a3) {
  var u2 = e8.children(a3);
  if (u2.length) {
    var c3 = ra.addBorderNode(e8, "_bt"), s2 = ra.addBorderNode(e8, "_bb"), d2 = e8.node(a3);
    e8.setParent(c3, a3), d2.borderTop = c3, e8.setParent(s2, a3), d2.borderBottom = s2, Hi.forEach(u2, function(u3) {
      Ra(e8, n2, t4, r2, o2, i2, u3);
      var d3 = e8.node(u3), f2 = d3.borderTop ? d3.borderTop : u3, h2 = d3.borderBottom ? d3.borderBottom : u3, l2 = d3.borderTop ? r2 : 2 * r2, v2 = f2 !== h2 ? 1 : o2 - i2[a3] + 1;
      e8.setEdge(c3, f2, { weight: l2, minlen: v2, nestingEdge: true }), e8.setEdge(h2, s2, { weight: l2, minlen: v2, nestingEdge: true });
    }), e8.parent(a3) || e8.setEdge(n2, c3, { weight: 0, minlen: o2 + i2[a3] });
  } else a3 !== n2 && e8.setEdge(n2, a3, { weight: 0, minlen: t4 });
}
function Da(e8, n2, t4, r2, o2, i2) {
  var a3 = { width: 0, height: 0, rank: i2, borderType: n2 }, u2 = o2[n2][i2 - 1], c3 = ra.addDummyNode(e8, "border", a3, t4);
  o2[n2][i2] = c3, e8.setParent(c3, r2), u2 && e8.setEdge(u2, c3, { weight: 1 });
}
function za(e8) {
  Hi.forEach(e8.nodes(), function(n2) {
    Fa(e8.node(n2));
  }), Hi.forEach(e8.edges(), function(n2) {
    Fa(e8.edge(n2));
  });
}
function Fa(e8) {
  var n2 = e8.width;
  e8.width = e8.height, e8.height = n2;
}
function Ua(e8) {
  e8.y = -e8.y;
}
function Va(e8) {
  var n2 = e8.x;
  e8.x = e8.y, e8.y = n2;
}
function Wa(e8, n2, t4) {
  for (var r2 = Hi.zipObject(t4, Hi.map(t4, function(e9, n3) {
    return n3;
  })), o2 = Hi.flatten(Hi.map(n2, function(n3) {
    return Hi.sortBy(Hi.map(e8.outEdges(n3), function(n4) {
      return { pos: r2[n4.w], weight: e8.edge(n4).weight };
    }), "pos");
  }), true), i2 = 1; i2 < t4.length; ) i2 <<= 1;
  var a3 = 2 * i2 - 1;
  i2 -= 1;
  var u2 = Hi.map(new Array(a3), function() {
    return 0;
  }), c3 = 0;
  return Hi.forEach(o2.forEach(function(e9) {
    var n3 = e9.pos + i2;
    u2[n3] += e9.weight;
    for (var t5 = 0; n3 > 0; ) n3 % 2 && (t5 += u2[n3 + 1]), u2[n3 = n3 - 1 >> 1] += e9.weight;
    c3 += e9.weight * t5;
  })), c3;
}
function Xa(e8, n2, t4) {
  for (var r2; n2.length && (r2 = Hi.last(n2)).i <= t4; ) n2.pop(), e8.push(r2.vs), t4++;
  return t4;
}
function ru(e8, n2, t4) {
  return Hi.map(n2, function(n3) {
    return Za(e8, n3, t4);
  });
}
function ou(e8, n2) {
  var t4 = new nu();
  Hi.forEach(e8, function(e9) {
    var r2 = e9.graph().root, o2 = Ka(e9, r2, t4, n2);
    Hi.forEach(o2.vs, function(n3, t5) {
      e9.node(n3).order = t5;
    }), eu(e9, t4, o2.vs);
  });
}
function iu(e8, n2) {
  Hi.forEach(n2, function(n3) {
    Hi.forEach(n3, function(n4, t4) {
      e8.node(n4).order = t4;
    });
  });
}
function cu(e8, n2) {
  var t4 = {};
  return Hi.reduce(n2, function(n3, r2) {
    var o2 = 0, i2 = 0, a3 = n3.length, u2 = Hi.last(r2);
    return Hi.forEach(r2, function(n4, c3) {
      var s2 = function(e9, n5) {
        if (e9.node(n5).dummy) return Hi.find(e9.predecessors(n5), function(n6) {
          return e9.node(n6).dummy;
        });
      }(e8, n4), d2 = s2 ? e8.node(s2).order : a3;
      (s2 || n4 === u2) && (Hi.forEach(r2.slice(i2, c3 + 1), function(n5) {
        Hi.forEach(e8.predecessors(n5), function(r3) {
          var i3 = e8.node(r3), a4 = i3.order;
          !(a4 < o2 || d2 < a4) || i3.dummy && e8.node(n5).dummy || du(t4, r3, n5);
        });
      }), i2 = c3 + 1, o2 = d2);
    }), r2;
  }), t4;
}
function su(e8, n2) {
  var t4 = {};
  function r2(n3, r3, o2, i2, a3) {
    var u2;
    Hi.forEach(Hi.range(r3, o2), function(r4) {
      u2 = n3[r4], e8.node(u2).dummy && Hi.forEach(e8.predecessors(u2), function(n4) {
        var r5 = e8.node(n4);
        r5.dummy && (r5.order < i2 || r5.order > a3) && du(t4, n4, u2);
      });
    });
  }
  return Hi.reduce(n2, function(n3, t5) {
    var o2, i2 = -1, a3 = 0;
    return Hi.forEach(t5, function(u2, c3) {
      if ("border" === e8.node(u2).dummy) {
        var s2 = e8.predecessors(u2);
        s2.length && (o2 = e8.node(s2[0]).order, r2(t5, a3, c3, i2, o2), a3 = c3, i2 = o2);
      }
      r2(t5, a3, t5.length, o2, n3.length);
    }), t5;
  }), t4;
}
function du(e8, n2, t4) {
  if (n2 > t4) {
    var r2 = n2;
    n2 = t4, t4 = r2;
  }
  var o2 = e8[n2];
  o2 || (e8[n2] = o2 = {}), o2[t4] = true;
}
function fu(e8, n2, t4) {
  if (n2 > t4) {
    var r2 = n2;
    n2 = t4, t4 = r2;
  }
  return Hi.has(e8[n2], t4);
}
function hu(e8, n2, t4, r2) {
  var o2 = {}, i2 = {}, a3 = {};
  return Hi.forEach(n2, function(e9) {
    Hi.forEach(e9, function(e11, n3) {
      o2[e11] = e11, i2[e11] = e11, a3[e11] = n3;
    });
  }), Hi.forEach(n2, function(e9) {
    var n3 = -1;
    Hi.forEach(e9, function(e11) {
      var u2 = r2(e11);
      if (u2.length) for (var c3 = ((u2 = Hi.sortBy(u2, function(e12) {
        return a3[e12];
      })).length - 1) / 2, s2 = Math.floor(c3), d2 = Math.ceil(c3); s2 <= d2; ++s2) {
        var f2 = u2[s2];
        i2[e11] === e11 && n3 < a3[f2] && !fu(t4, e11, f2) && (i2[f2] = e11, i2[e11] = o2[e11] = o2[f2], n3 = a3[f2]);
      }
    });
  }), { root: o2, align: i2 };
}
function lu(e8, n2, t4, r2, o2) {
  var i2 = {}, a3 = function(e9, n3, t5, r3) {
    var o3 = new au(), i3 = e9.graph(), a4 = /* @__PURE__ */ function(e11, n4, t6) {
      return function(r4, o4, i4) {
        var a5, u3 = r4.node(o4), c4 = r4.node(i4), s2 = 0;
        if (s2 += u3.width / 2, Hi.has(u3, "labelpos")) switch (u3.labelpos.toLowerCase()) {
          case "l":
            a5 = -u3.width / 2;
            break;
          case "r":
            a5 = u3.width / 2;
        }
        if (a5 && (s2 += t6 ? a5 : -a5), a5 = 0, s2 += (u3.dummy ? n4 : e11) / 2, s2 += (c4.dummy ? n4 : e11) / 2, s2 += c4.width / 2, Hi.has(c4, "labelpos")) switch (c4.labelpos.toLowerCase()) {
          case "l":
            a5 = c4.width / 2;
            break;
          case "r":
            a5 = -c4.width / 2;
        }
        return a5 && (s2 += t6 ? a5 : -a5), a5 = 0, s2;
      };
    }(i3.nodesep, i3.edgesep, r3);
    return Hi.forEach(n3, function(n4) {
      var r4;
      Hi.forEach(n4, function(n5) {
        var i4 = t5[n5];
        if (o3.setNode(i4), r4) {
          var u3 = t5[r4], c4 = o3.edge(u3, i4);
          o3.setEdge(u3, i4, Math.max(a4(e9, n5, r4), c4 || 0));
        }
        r4 = n5;
      });
    }), o3;
  }(e8, n2, t4, o2), u2 = o2 ? "borderLeft" : "borderRight";
  function c3(e9, n3) {
    for (var t5 = a3.nodes(), r3 = t5.pop(), o3 = {}; r3; ) o3[r3] ? e9(r3) : (o3[r3] = true, t5.push(r3), t5 = t5.concat(n3(r3))), r3 = t5.pop();
  }
  return c3(function(e9) {
    i2[e9] = a3.inEdges(e9).reduce(function(e11, n3) {
      return Math.max(e11, i2[n3.v] + a3.edge(n3));
    }, 0);
  }, a3.predecessors.bind(a3)), c3(function(n3) {
    var t5 = a3.outEdges(n3).reduce(function(e9, n4) {
      return Math.min(e9, i2[n4.w] - a3.edge(n4));
    }, Number.POSITIVE_INFINITY), r3 = e8.node(n3);
    t5 !== Number.POSITIVE_INFINITY && r3.borderType !== u2 && (i2[n3] = Math.max(i2[n3], t5));
  }, a3.successors.bind(a3)), Hi.forEach(r2, function(e9) {
    i2[e9] = i2[t4[e9]];
  }), i2;
}
function vu(e8, n2) {
  return Hi.minBy(Hi.values(n2), function(n3) {
    var t4 = Number.NEGATIVE_INFINITY, r2 = Number.POSITIVE_INFINITY;
    return Hi.forIn(n3, function(n4, o2) {
      var i2 = function(e9, n5) {
        return e9.node(n5).width;
      }(e8, o2) / 2;
      t4 = Math.max(n4 + i2, t4), r2 = Math.min(n4 - i2, r2);
    }), t4 - r2;
  });
}
function pu(e8, n2) {
  var t4 = Hi.values(n2), r2 = Hi.min(t4), o2 = Hi.max(t4);
  Hi.forEach(["u", "d"], function(t5) {
    Hi.forEach(["l", "r"], function(i2) {
      var a3, u2 = t5 + i2, c3 = e8[u2];
      if (c3 !== n2) {
        var s2 = Hi.values(c3);
        (a3 = "l" === i2 ? r2 - Hi.min(s2) : o2 - Hi.max(s2)) && (e8[u2] = Hi.mapValues(c3, function(e9) {
          return e9 + a3;
        }));
      }
    });
  });
}
function gu(e8, n2) {
  return Hi.mapValues(e8.ul, function(t4, r2) {
    if (n2) return e8[n2.toLowerCase()][r2];
    var o2 = Hi.sortBy(Hi.map(e8, r2));
    return (o2[1] + o2[2]) / 2;
  });
}
function Gu(e8, n2) {
  return Hi.mapValues(Hi.pick(e8, n2), Number);
}
function Bu(e8) {
  var n2 = {};
  return Hi.forEach(e8, function(e9, t4) {
    n2[t4.toLowerCase()] = e9;
  }), n2;
}
function zu(e8) {
  const n2 = new Pu();
  return e8.nodes.map((e9) => new Du(e9)).forEach((e9) => {
    n2.nodes[e9.name] = e9, e9.inputs.forEach((t4) => {
      !function(e11, n3, t5) {
        t5.name !== n3.name && e11.edges.push(Object.assign(Object.assign({}, t5.attr), { v: t5.name, w: n3.name }));
      }(n2, e9, t4);
    });
  }), n2;
}
function Vu(e8, n2 = {}) {
  return new Fu(e8, n2);
}
function $u(e8, n2) {
  return new Uu(e8, n2);
}
function Hu(e8, n2, t4) {
  const r2 = t4 || {}, o2 = new Ru.Graph(r2);
  return o2.setGraph({ name: e8, rankdir: r2.rankdir, type: n2, align: r2.align }), o2;
}
function qu(e8, n2) {
  const { rankDirection: t4, align: r2 } = n2, o2 = new Wu({ rankdir: t4, align: r2 });
  return function(e9, n3) {
    Object.keys(n3.nodes).forEach((t5) => {
      const r3 = n3.nodes[t5], o3 = r3.path;
      let i2 = e9.root;
      i2.depth = Math.max(o3.length, i2.depth);
      for (let n4 = 0; n4 < o3.length && (i2.depth = Math.max(i2.depth, o3.length - n4), i2.cardinality += r3.cardinality, n4 !== o3.length - 1); n4++) {
        const t6 = o3[n4];
        let a3 = e9.node(t6);
        a3 || (a3 = Vu(t6, e9.graphOptions), a3.path = r3.path.slice(0, n4 + 1), a3.parentNode = i2, e9.setNode(t6, a3), i2.metaGraph.setNode(t6, a3)), i2 = a3;
      }
      e9.setNode(r3.name, r3), r3.parentNode = i2, i2.metaGraph.setNode(r3.name, r3);
    });
  }(o2, e8), function(e9, n3) {
    const t5 = e9.getNodeMap();
    let r3 = [], o3 = [];
    const i2 = (e11, n4) => {
      let t6 = 0;
      for (; e11; ) n4[t6++] = e11.name, e11 = e11.parentNode;
      return t6 - 1;
    };
    n3.edges.forEach((a3) => {
      r3 = [], o3 = [];
      let u2 = i2(n3.nodes[a3.v], r3), c3 = i2(n3.nodes[a3.w], o3);
      for (; r3[u2] === o3[c3]; ) if (u2--, c3--, u2 < 0 || c3 < 0) throw Error("No difference found between ancestor paths.");
      const s2 = t5[r3[u2 + 1]], d2 = r3[u2], f2 = o3[c3];
      let h2 = s2.metaGraph.edge(d2, f2);
      h2 || (h2 = $u(d2, f2), s2.metaGraph.setEdge(d2, f2, h2)), h2.addBaseEdge(a3, e9);
    });
  }(o2, e8), o2;
}
function Yu(e8, n2, t4, r2) {
  (t4 ? e8.inEdges(n2.name) : e8.outEdges(n2.name)).forEach((n3) => {
    const t5 = e8.edge(n3);
    r2.push(t5);
  });
}
function Zu(e8, t4) {
  e8.node.isGroupNode && function(e9, t5) {
    const r2 = n(t5);
    e9.coreGraph.nodes().map((n2) => e9.coreGraph.node(n2)).forEach((e11) => {
      var n2, o2, a3, u2, c3, s2;
      const { height: d2, width: f2 } = e11;
      switch (e11.node.type) {
        case i.NODE:
          Object.assign(e11, r2.nodeSize.node), e11.height = d2 || r2.nodeSize.node.height, e11.width = f2 || r2.nodeSize.node.width;
          break;
        case i.BRIDGE:
          Object.assign(e11, r2.nodeSize.bridge);
          break;
        case i.META:
          if (e11.expanded) {
            Zu(e11, t5);
          } else Object.assign(e11, r2.nodeSize.meta), e11.height = r2.nodeSize.meta.height, e11.width = r2.nodeSize.meta.width;
          break;
        default:
          throw Error("Unrecognized node type: " + e11.node.type);
      }
      if (!e11.expanded) {
        const r3 = e11.attr;
        !function(e12, n3 = false) {
          if (e12.coreBox.width = e12.width, e12.coreBox.height = e12.height, !n3) {
            const n4 = `${e12.displayName}`.length, t6 = 3;
            e12.width = Math.max(e12.coreBox.width, n4 * t6);
          }
        }(e11, t5 && (0 === e11.node.type && !!(null === (o2 = null === (n2 = null == t5 ? void 0 : t5.nodeSize) || void 0 === n2 ? void 0 : n2.meta) || void 0 === o2 ? void 0 : o2.width) || 1 === e11.node.type && (!!(null === (u2 = null === (a3 = null == t5 ? void 0 : t5.nodeSize) || void 0 === a3 ? void 0 : a3.node) || void 0 === u2 ? void 0 : u2.width) || !!r3.width) || 2 === e11.node.type && !!(null === (s2 = null === (c3 = null == t5 ? void 0 : t5.nodeSize) || void 0 === c3 ? void 0 : c3.bridge) || void 0 === s2 ? void 0 : s2.width)));
      }
    });
  }(e8, t4), e8.node.type === i.META && function(e9, t5) {
    const r2 = n(t5), o2 = r2.subScene.meta;
    Object.assign(e9, o2);
    const { nodeSep: a3, rankSep: u2, edgeSep: c3, align: s2 } = r2.graph.meta, d2 = { nodesep: a3, ranksep: u2, edgesep: c3, align: s2 };
    Object.assign(e9.coreBox, function(e11, n2) {
      const { ranksep: t6, nodesep: r3, edgesep: o3, align: a4 } = n2;
      Object.assign(e11.graph(), { ranksep: t6, nodesep: r3, edgesep: o3, align: a4 });
      const u3 = [];
      if (e11.nodes().forEach((n3) => {
        e11.node(n3).node.type !== i.BRIDGE && u3.push(n3);
      }), !u3.length) return { width: 0, height: 0 };
      Tu(e11);
      let c4 = 1 / 0, s3 = 1 / 0, d3 = -1 / 0, f3 = -1 / 0;
      return u3.forEach((n3) => {
        const t7 = e11.node(n3), r4 = 0.5 * t7.width, o4 = t7.x - r4, i2 = t7.x + r4;
        c4 = o4 < c4 ? o4 : c4, d3 = i2 > d3 ? i2 : d3;
        const a5 = 0.5 * t7.height, u4 = t7.y - a5, h3 = t7.y + a5;
        s3 = u4 < s3 ? u4 : s3, f3 = h3 > f3 ? h3 : f3;
      }), e11.edges().forEach((n3) => {
        const t7 = e11.edge(n3), r4 = e11.node(t7.metaEdge.v), o4 = e11.node(t7.metaEdge.w);
        if (3 === t7.points.length && function(e12) {
          let n4 = ec(e12[0], e12[1]);
          for (let t8 = 1; t8 < e12.length - 1; t8++) {
            const r5 = ec(e12[t8], e12[t8 + 1]);
            if (Math.abs(r5 - n4) > 1) return false;
            n4 = r5;
          }
          return true;
        }(t7.points)) {
          if (null != r4) {
            const e12 = r4.expanded ? r4.x : nc(r4);
            t7.points[0].x = e12;
          }
          if (null != o4) {
            const e12 = o4.expanded ? o4.x : nc(o4);
            t7.points[2].x = e12;
          }
          t7.points = [t7.points[0], t7.points[1]];
        }
        const i2 = t7.points[t7.points.length - 2];
        null != o4 && (t7.points[t7.points.length - 1] = tc(i2, o4));
        const a5 = t7.points[1];
        null != r4 && (t7.points[0] = tc(a5, r4)), t7.points.forEach((e12) => {
          c4 = e12.x < c4 ? e12.x : c4, d3 = e12.x > d3 ? e12.x : d3, s3 = e12.y < s3 ? e12.y : s3, f3 = e12.y > f3 ? e12.y : f3;
        });
      }), e11.nodes().forEach((n3) => {
        const t7 = e11.node(n3);
        t7.x -= c4, t7.y -= s3;
      }), e11.edges().forEach((n3) => {
        e11.edge(n3).points.forEach((e12) => {
          e12.x -= c4, e12.y -= s3;
        });
      }), { width: d3 - c4, height: f3 - s3 };
    }(e9.coreGraph, d2));
    let f2 = 0;
    e9.coreGraph.nodeCount() > 0 && f2++;
    const h2 = f2 <= 1 ? 0 : f2;
    e9.coreBox.width += h2 + h2, e9.coreBox.height = o2.labelHeight + e9.coreBox.height, e9.width = e9.coreBox.width + o2.paddingLeft + o2.paddingRight, e9.height = e9.paddingTop + e9.coreBox.height + e9.paddingBottom;
  }(e8, t4);
}
function ec(e8, n2) {
  const t4 = n2.x - e8.x, r2 = n2.y - e8.y;
  return 180 * Math.atan(r2 / t4) / Math.PI;
}
function nc(e8) {
  if (e8.expanded) return e8.x;
  return e8.x - e8.width / 2 + 0 + e8.coreBox.width / 2;
}
function tc(e8, n2) {
  const t4 = n2.expanded ? n2.x : nc(n2), r2 = n2.y, o2 = e8.x - t4, i2 = e8.y - r2;
  let a3, u2, c3 = n2.expanded ? n2.width : n2.coreBox.width, s2 = n2.expanded ? n2.height : n2.coreBox.height;
  return Math.abs(i2) * c3 / 2 > Math.abs(o2) * s2 / 2 ? (i2 < 0 && (s2 = -s2), a3 = 0 === i2 ? 0 : s2 / 2 * o2 / i2, u2 = s2 / 2) : (o2 < 0 && (c3 = -c3), a3 = c3 / 2, u2 = 0 === o2 ? 0 : c3 / 2 * i2 / o2), { x: t4 + a3, y: r2 + u2 };
}
function rc(n2, t4, r2) {
  var o2, i2, a3, u2;
  const c3 = n2.nodes.filter((e8, n3, t5) => t5.findIndex((n4) => n4.id === e8.id) !== n3).map((e8) => e8.id);
  if (c3.length) throw new Error(`Duplicated ids found: ${c3.join(", ")}`);
  const s2 = function(e8) {
    const n3 = { nodes: [] }, t5 = e8.compound, r3 = Object.keys(t5 || {}), o3 = /* @__PURE__ */ new Map(), i3 = (e9, n4 = []) => {
      if (o3.has(e9)) return o3.get(e9);
      for (let o4 = 0; o4 < r3.length; o4++) {
        let a5 = r3[o4];
        if (t5 && -1 !== t5[a5].indexOf(e9)) return n4.unshift(a5), i3(a5, n4);
      }
      return 0 === n4.length && o3.set(e9, n4), n4;
    }, a4 = (n4) => e8.edges.filter((e9) => e9.w === n4).map((e9) => ({ name: e9.v }));
    return e8.nodes.forEach((e9) => {
      const t6 = e9.id, r4 = [...i3(t6), t6];
      let o4 = a4(t6);
      n3.nodes.push({ name: t6, path: r4, inputs: o4, width: e9.width, height: e9.height, attr: Object.assign({}, e9) });
    }), n3;
  }(n2), d2 = function(e8, n3) {
    const t5 = (e9, n4) => {
      for (let t6 of n4.values()) if (t6.includes(e9)) return true;
      return false;
    }, r3 = (e9, n4 = []) => {
      if (0 === Object.keys(e9).length) return [...new Set(n4)];
      const o3 = new Map(Object.keys(e9).map((n5) => [n5, e9[n5]])), i3 = {};
      for (let [e11, r4] of o3) t5(e11, o3) ? i3[e11] = r4 : n4 = n4.concat(e11, r4);
      return r3(i3, n4);
    };
    return r3(e8).filter((e9) => n3.includes(e9));
  }(n2.compound || {}, (null == t4 ? void 0 : t4.expanded) || []), f2 = function(e8, n3) {
    return function(e9) {
      return new Ju(e9);
    }(qu(zu(e8), n3));
  }(s2, { rankDirection: (null === (i2 = null === (o2 = null == r2 ? void 0 : r2.graph) || void 0 === o2 ? void 0 : o2.meta) || void 0 === i2 ? void 0 : i2.rankDir) || (null == t4 ? void 0 : t4.rankDirection) || e.graph.meta.rankDir, align: (null === (u2 = null === (a3 = null == r2 ? void 0 : r2.graph) || void 0 === a3 ? void 0 : a3.meta) || void 0 === u2 ? void 0 : u2.align) || e.graph.meta.align });
  return function(e8, n3) {
    n3.forEach((n4) => {
      const t5 = e8.getRenderInfoNodes().find((e9) => e9.displayName === n4);
      let r3 = t5 && t5.node && t5.node.name || "";
      const o3 = e8.getRenderNodeByName(r3);
      if (!o3) throw new Error(`No nodes found: ${r3}`);
      o3.expanded = true, e8.buildSubHierarchy(r3);
    });
  }(f2, d2), Zu(f2.root, r2), ac(f2.root);
}
function oc(e8, n2 = false) {
  const t4 = JSON.parse(JSON.stringify(e8)), o2 = { nodes: [t4], edges: [...t4.edges] };
  return t4.nodes.forEach(function e9(n3) {
    (0 === n3.type || 1 === n3.type) && o2.nodes.push(n3), 0 === n3.type && (o2.edges = o2.edges.concat(n3.edges)), Array.isArray(n3.nodes) && n3.nodes.forEach(e9);
  }), n2 && o2.nodes.forEach((e9) => {
    const n3 = o2.nodes.find((n4) => n4.id === e9.parentNodeName);
    if (n3) {
      const t5 = n3.x - n3.width / 2 + n3.paddingLeft, o3 = n3.y - n3.height / 2 + n3.labelHeight + n3.paddingTop;
      n3.id !== r && (e9.x += t5, e9.y += o3), 0 === e9.type && e9.edges.forEach((n4) => {
        n4.points.forEach((n5) => {
          n5.x += e9.x - e9.width / 2 + e9.paddingLeft, n5.y += e9.y - e9.height / 2 + e9.labelHeight + e9.paddingTop;
        });
      });
    }
  }), o2;
}
function ic(e8, n2, t4, o2) {
  var i2, a3;
  let u2 = [];
  const c3 = (null === (i2 = t4.find((n3) => n3.id === e8)) || void 0 === i2 ? void 0 : i2.path) || [], s2 = (null === (a3 = t4.find((e9) => e9.id === n2)) || void 0 === a3 ? void 0 : a3.path) || [], d2 = [r, ...c3].slice(0, c3.length).reverse(), f2 = [r, ...s2].slice(0, s2.length);
  return d2.forEach((r2) => {
    const i3 = t4.find((e9) => e9.id === r2);
    u2 = u2.concat(i3.edges.filter((t5) => t5.baseEdgeList.some((t6) => t6.v === ((null == o2 ? void 0 : o2.v) || e8) && t6.w === ((null == o2 ? void 0 : o2.w) || n2))));
  }), f2.filter((e9) => !d2.includes(e9)).forEach((r2) => {
    const i3 = t4.find((e9) => e9.id === r2);
    u2 = u2.concat(i3.edges.filter((t5) => t5.baseEdgeList.some((t6) => t6.v === ((null == o2 ? void 0 : o2.v) || e8) && t6.w === ((null == o2 ? void 0 : o2.w) || n2))));
  }), u2;
}
function ac(e8) {
  const n2 = e8.coreGraph.nodes().map((n3) => e8.coreGraph.node(n3));
  return Object.assign(Object.assign({}, uc(e8)), { expanded: e8.expanded, nodes: e8.expanded ? (t4 = n2, t4.map((e9) => e9.node.type === i.META ? ac(e9) : uc(e9))) : [], edges: e8.expanded ? cc(e8) : [] });
  var t4;
}
function uc(e8) {
  return { id: e8.node.name, name: e8.node.name, type: e8.node.type, cardinality: e8.node.cardinality, attr: e8.attr, parentNodeName: e8.node.parentNode ? e8.node.parentNode.name : null, coreBox: Object.assign({}, e8.coreBox), x: e8.x, y: e8.y, width: e8.width, height: e8.height, radius: e8.radius, labelHeight: e8.labelHeight, labelOffset: e8.labelOffset, outboxWidth: e8.outboxWidth, paddingLeft: e8.paddingLeft, paddingTop: e8.paddingTop, paddingRight: e8.paddingRight, paddingBottom: e8.paddingBottom, path: e8.node.path };
}
function cc(e8) {
  return e8.coreGraph.edges().map((n2) => ({ renderInfoEdge: e8.coreGraph.edge(n2), edge: n2 })).filter(({ renderInfoEdge: e9 }) => e9.metaEdge).map(({ edge: n2, renderInfoEdge: t4 }) => {
    const r2 = function(e9, n3) {
      const t5 = n3.points.map((e11) => Object.assign({}, e11));
      if (n3.adjoiningMetaEdge) {
        const r3 = n3.adjoiningMetaEdge.points, o2 = n3.metaEdge.inbound, i2 = o2 ? r3[r3.length - 1] : r3[0], a3 = t5[o2 ? 0 : t5.length - 1], u2 = e9.x - e9.width / 2, c3 = e9.y - e9.height / 2, s2 = i2.x - u2, d2 = i2.y - c3, f2 = -e9.paddingLeft, h2 = -(e9.paddingTop + e9.labelHeight);
        a3.x = s2 + f2, a3.y = d2 + h2;
      }
      return t5;
    }(e8, t4);
    return { adjoiningEdge: t4.adjoiningMetaEdge ? { w: t4.adjoiningMetaEdge.metaEdge.w, v: t4.adjoiningMetaEdge.metaEdge.v } : null, inbound: t4.metaEdge.inbound, w: n2.w, v: n2.v, points: r2, weight: t4.weight, baseEdgeList: t4.metaEdge.baseEdgeList, parentNodeName: e8.node.name };
  });
}
var e, r, o, i, a2, u, c2, s, f, h, l, v, p, g, y3, b, w, E2, _, j, x3, N, O, k, I, S, M, C2, G, B2, A2, L, R, T, D2, P, z, F, U, V, $, H, W, q, Y, J, X, K2, Q, Z, ee, ne, te, re, oe, ie, ae, ue, ce, se, fe, he, le, ve, pe, ge, ye, be, we, Ee, je, xe, Ne, Oe, ke, Ie, Se, Me, Ce, Ge, Be, Ae, Le, Re, Te, De, Pe, ze, Fe, Ue, Ve, $e, He, We, qe, Ye, Je, Xe, Ke, Qe, Ze, en, nn, tn, rn, on, an, un, cn, sn, dn, fn, hn, ln2, vn, pn, gn, yn, bn, mn, wn, En, _n, jn, xn, Nn, On, kn, In, Sn, Mn, Cn, Gn, Bn, An, Ln, Rn, Tn, Dn, Pn, zn, Fn, Un, Vn, $n, Hn, Wn, qn, Yn2, Jn, Xn2, Kn, Qn, Zn2, et, nt, tt, rt, ot, it, at, ut, ct, st, dt, ft, ht, lt, vt, pt, gt, yt, bt, wt, Et, _t, jt, xt, Nt, Ot, kt, It, St, Mt, Ct, Gt, Bt, At, Lt, Rt, Tt, Dt, Pt, zt, Ft, Ut, $t, Ht, Wt, qt, Yt, Jt, Xt, Kt, Qt, Zt, er, nr, tr, rr, or, ir, ar, ur, cr, sr, dr, fr, hr, lr, vr, pr, gr, yr, br, mr, wr, Er, _r, jr, xr, Nr, Or, kr, Ir, Sr, Mr, Cr, Gr, Br, Ar, Lr, Rr, Tr, Dr, Pr, zr, Fr, Ur, Vr, $r, Hr, Wr, qr, Yr, Jr, Xr, Kr, Qr, Zr, eo, no, to, ro, oo, io, ao, uo, co, so, fo, ho, lo, wo, Eo, xo, No, ko, Io, So, Mo, Co, Go, Bo, Ao, To, Po, zo, Fo, Uo, Vo, $o, Ho, Wo, qo, Yo, Jo, Xo, Ko, Qo, Zo, ei, ni, ti, ri, oi, ii, ai, ui, ci, si, di, fi, hi, li, vi, pi2, gi, yi, bi, mi, wi, Ei, _i, ji, xi, Ni, Oi, ki, Ii, Si, Mi, Ci, Gi, Bi, Ai, Li, Ri, Ti, Di, Pi, zi, Fi, Ui, Vi, $i, Hi, Wi, Xi, Ki, Qi, na, ta, ra, aa, ua, ca, sa, da, fa, pa, ga, ya, ba, ma, wa, Ma, Ca, Ga, Aa, La, Ta, Pa, $a, Ha, qa, Ya, Ja, Ka, Qa, Za, eu, nu, tu, au, uu, yu, bu, mu, wu, Eu, _u, ju, xu, Nu, Ou, ku, Iu, Su, Mu, Cu, Au, Lu, Ru, Tu, Du, Pu, Fu, Uu, Wu, Ju, Xu, Ku, Qu;
var init_dagre_compound_es5 = __esm({
  "node_modules/dagre-compound/dist/dagre-compound.es5.js"() {
    e = { graph: { meta: { rankDir: "TB", nodeSep: 50, rankSep: 50, edgeSep: 5, align: void 0 } }, subScene: { meta: { paddingTop: 20, paddingBottom: 20, paddingLeft: 20, paddingRight: 20, labelHeight: 20 } }, nodeSize: { meta: { width: 100, maxLabelWidth: 0, height: 20 }, node: { width: 80, height: 20, labelOffset: 10, maxLabelWidth: 40 }, bridge: { width: 5, height: 5, radius: 2, labelOffset: 0 } } };
    r = t("ROOT");
    o = t("BRIDGE_GRAPH");
    !function(e8) {
      e8[e8.META = 0] = "META", e8[e8.NODE = 1] = "NODE", e8[e8.BRIDGE = 2] = "BRIDGE";
    }(i || (i = {})), function(e8) {
      e8[e8.INCLUDE = 0] = "INCLUDE", e8[e8.EXCLUDE = 1] = "EXCLUDE", e8[e8.UNSPECIFIED = 2] = "UNSPECIFIED";
    }(a2 || (a2 = {})), function(e8) {
      e8[e8.META = 0] = "META", e8[e8.CORE = 1] = "CORE", e8[e8.BRIDGE = 2] = "BRIDGE";
    }(u || (u = {})), function(e8) {
      e8[e8.META = 0] = "META", e8[e8.OP = 1] = "OP", e8[e8.SERIES = 2] = "SERIES";
    }(c2 || (c2 = {}));
    s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    f = function() {
      this.__data__ = [], this.size = 0;
    };
    h = function(e8, n2) {
      return e8 === n2 || e8 != e8 && n2 != n2;
    };
    l = function(e8, n2) {
      for (var t4 = e8.length; t4--; ) if (h(e8[t4][0], n2)) return t4;
      return -1;
    };
    v = Array.prototype.splice;
    p = function(e8) {
      var n2 = this.__data__, t4 = l(n2, e8);
      return !(t4 < 0) && (t4 == n2.length - 1 ? n2.pop() : v.call(n2, t4, 1), --this.size, true);
    };
    g = function(e8) {
      var n2 = this.__data__, t4 = l(n2, e8);
      return t4 < 0 ? void 0 : n2[t4][1];
    };
    y3 = function(e8) {
      return l(this.__data__, e8) > -1;
    };
    b = function(e8, n2) {
      var t4 = this.__data__, r2 = l(t4, e8);
      return r2 < 0 ? (++this.size, t4.push([e8, n2])) : t4[r2][1] = n2, this;
    };
    m2.prototype.clear = f, m2.prototype.delete = p, m2.prototype.get = g, m2.prototype.has = y3, m2.prototype.set = b;
    w = m2;
    E2 = function() {
      this.__data__ = new w(), this.size = 0;
    };
    _ = function(e8) {
      var n2 = this.__data__, t4 = n2.delete(e8);
      return this.size = n2.size, t4;
    };
    j = function(e8) {
      return this.__data__.get(e8);
    };
    x3 = function(e8) {
      return this.__data__.has(e8);
    };
    N = "object" == typeof s && s && s.Object === Object && s;
    O = "object" == typeof self && self && self.Object === Object && self;
    k = N || O || Function("return this")();
    I = k.Symbol;
    S = Object.prototype;
    M = S.hasOwnProperty;
    C2 = S.toString;
    G = I ? I.toStringTag : void 0;
    B2 = function(e8) {
      var n2 = M.call(e8, G), t4 = e8[G];
      try {
        e8[G] = void 0;
        var r2 = true;
      } catch (e9) {
      }
      var o2 = C2.call(e8);
      return r2 && (n2 ? e8[G] = t4 : delete e8[G]), o2;
    };
    A2 = Object.prototype.toString;
    L = function(e8) {
      return A2.call(e8);
    };
    R = I ? I.toStringTag : void 0;
    T = function(e8) {
      return null == e8 ? void 0 === e8 ? "[object Undefined]" : "[object Null]" : R && R in Object(e8) ? B2(e8) : L(e8);
    };
    D2 = function(e8) {
      var n2 = typeof e8;
      return null != e8 && ("object" == n2 || "function" == n2);
    };
    z = function(e8) {
      if (!D2(e8)) return false;
      var n2 = T(e8);
      return "[object Function]" == n2 || "[object GeneratorFunction]" == n2 || "[object AsyncFunction]" == n2 || "[object Proxy]" == n2;
    };
    F = k["__core-js_shared__"];
    U = (P = /[^.]+$/.exec(F && F.keys && F.keys.IE_PROTO || "")) ? "Symbol(src)_1." + P : "";
    V = function(e8) {
      return !!U && U in e8;
    };
    $ = Function.prototype.toString;
    H = function(e8) {
      if (null != e8) {
        try {
          return $.call(e8);
        } catch (e9) {
        }
        try {
          return e8 + "";
        } catch (e9) {
        }
      }
      return "";
    };
    W = /^\[object .+?Constructor\]$/;
    q = Function.prototype;
    Y = Object.prototype;
    J = q.toString;
    X = Y.hasOwnProperty;
    K2 = RegExp("^" + J.call(X).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    Q = function(e8) {
      return !(!D2(e8) || V(e8)) && (z(e8) ? K2 : W).test(H(e8));
    };
    Z = function(e8, n2) {
      return null == e8 ? void 0 : e8[n2];
    };
    ee = function(e8, n2) {
      var t4 = Z(e8, n2);
      return Q(t4) ? t4 : void 0;
    };
    ne = ee(k, "Map");
    te = ee(Object, "create");
    re = function() {
      this.__data__ = te ? te(null) : {}, this.size = 0;
    };
    oe = function(e8) {
      var n2 = this.has(e8) && delete this.__data__[e8];
      return this.size -= n2 ? 1 : 0, n2;
    };
    ie = Object.prototype.hasOwnProperty;
    ae = function(e8) {
      var n2 = this.__data__;
      if (te) {
        var t4 = n2[e8];
        return "__lodash_hash_undefined__" === t4 ? void 0 : t4;
      }
      return ie.call(n2, e8) ? n2[e8] : void 0;
    };
    ue = Object.prototype.hasOwnProperty;
    ce = function(e8) {
      var n2 = this.__data__;
      return te ? void 0 !== n2[e8] : ue.call(n2, e8);
    };
    se = function(e8, n2) {
      var t4 = this.__data__;
      return this.size += this.has(e8) ? 0 : 1, t4[e8] = te && void 0 === n2 ? "__lodash_hash_undefined__" : n2, this;
    };
    de.prototype.clear = re, de.prototype.delete = oe, de.prototype.get = ae, de.prototype.has = ce, de.prototype.set = se;
    fe = de;
    he = function() {
      this.size = 0, this.__data__ = { hash: new fe(), map: new (ne || w)(), string: new fe() };
    };
    le = function(e8) {
      var n2 = typeof e8;
      return "string" == n2 || "number" == n2 || "symbol" == n2 || "boolean" == n2 ? "__proto__" !== e8 : null === e8;
    };
    ve = function(e8, n2) {
      var t4 = e8.__data__;
      return le(n2) ? t4["string" == typeof n2 ? "string" : "hash"] : t4.map;
    };
    pe = function(e8) {
      var n2 = ve(this, e8).delete(e8);
      return this.size -= n2 ? 1 : 0, n2;
    };
    ge = function(e8) {
      return ve(this, e8).get(e8);
    };
    ye = function(e8) {
      return ve(this, e8).has(e8);
    };
    be = function(e8, n2) {
      var t4 = ve(this, e8), r2 = t4.size;
      return t4.set(e8, n2), this.size += t4.size == r2 ? 0 : 1, this;
    };
    me.prototype.clear = he, me.prototype.delete = pe, me.prototype.get = ge, me.prototype.has = ye, me.prototype.set = be;
    we = me;
    Ee = function(e8, n2) {
      var t4 = this.__data__;
      if (t4 instanceof w) {
        var r2 = t4.__data__;
        if (!ne || r2.length < 199) return r2.push([e8, n2]), this.size = ++t4.size, this;
        t4 = this.__data__ = new we(r2);
      }
      return t4.set(e8, n2), this.size = t4.size, this;
    };
    _e.prototype.clear = E2, _e.prototype.delete = _, _e.prototype.get = j, _e.prototype.has = x3, _e.prototype.set = Ee;
    je = _e;
    xe = function(e8, n2) {
      for (var t4 = -1, r2 = null == e8 ? 0 : e8.length; ++t4 < r2 && false !== n2(e8[t4], t4, e8); ) ;
      return e8;
    };
    Ne = function() {
      try {
        var e8 = ee(Object, "defineProperty");
        return e8({}, "", {}), e8;
      } catch (e9) {
      }
    }();
    Oe = function(e8, n2, t4) {
      "__proto__" == n2 && Ne ? Ne(e8, n2, { configurable: true, enumerable: true, value: t4, writable: true }) : e8[n2] = t4;
    };
    ke = Object.prototype.hasOwnProperty;
    Ie = function(e8, n2, t4) {
      var r2 = e8[n2];
      ke.call(e8, n2) && h(r2, t4) && (void 0 !== t4 || n2 in e8) || Oe(e8, n2, t4);
    };
    Se = function(e8, n2, t4, r2) {
      var o2 = !t4;
      t4 || (t4 = {});
      for (var i2 = -1, a3 = n2.length; ++i2 < a3; ) {
        var u2 = n2[i2], c3 = r2 ? r2(t4[u2], e8[u2], u2, t4, e8) : void 0;
        void 0 === c3 && (c3 = e8[u2]), o2 ? Oe(t4, u2, c3) : Ie(t4, u2, c3);
      }
      return t4;
    };
    Me = function(e8, n2) {
      for (var t4 = -1, r2 = Array(e8); ++t4 < e8; ) r2[t4] = n2(t4);
      return r2;
    };
    Ce = function(e8) {
      return null != e8 && "object" == typeof e8;
    };
    Ge = function(e8) {
      return Ce(e8) && "[object Arguments]" == T(e8);
    };
    Be = Object.prototype;
    Ae = Be.hasOwnProperty;
    Le = Be.propertyIsEnumerable;
    Re = Ge(/* @__PURE__ */ function() {
      return arguments;
    }()) ? Ge : function(e8) {
      return Ce(e8) && Ae.call(e8, "callee") && !Le.call(e8, "callee");
    };
    Te = Array.isArray;
    De = function() {
      return false;
    };
    Pe = d(function(e8, n2) {
      var t4 = n2 && !n2.nodeType && n2, r2 = t4 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t4 ? k.Buffer : void 0, i2 = (o2 ? o2.isBuffer : void 0) || De;
      e8.exports = i2;
    });
    ze = /^(?:0|[1-9]\d*)$/;
    Fe = function(e8, n2) {
      var t4 = typeof e8;
      return !!(n2 = null == n2 ? 9007199254740991 : n2) && ("number" == t4 || "symbol" != t4 && ze.test(e8)) && e8 > -1 && e8 % 1 == 0 && e8 < n2;
    };
    Ue = function(e8) {
      return "number" == typeof e8 && e8 > -1 && e8 % 1 == 0 && e8 <= 9007199254740991;
    };
    Ve = {};
    Ve["[object Float32Array]"] = Ve["[object Float64Array]"] = Ve["[object Int8Array]"] = Ve["[object Int16Array]"] = Ve["[object Int32Array]"] = Ve["[object Uint8Array]"] = Ve["[object Uint8ClampedArray]"] = Ve["[object Uint16Array]"] = Ve["[object Uint32Array]"] = true, Ve["[object Arguments]"] = Ve["[object Array]"] = Ve["[object ArrayBuffer]"] = Ve["[object Boolean]"] = Ve["[object DataView]"] = Ve["[object Date]"] = Ve["[object Error]"] = Ve["[object Function]"] = Ve["[object Map]"] = Ve["[object Number]"] = Ve["[object Object]"] = Ve["[object RegExp]"] = Ve["[object Set]"] = Ve["[object String]"] = Ve["[object WeakMap]"] = false;
    $e = function(e8) {
      return Ce(e8) && Ue(e8.length) && !!Ve[T(e8)];
    };
    He = function(e8) {
      return function(n2) {
        return e8(n2);
      };
    };
    We = d(function(e8, n2) {
      var t4 = n2 && !n2.nodeType && n2, r2 = t4 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t4 && N.process, i2 = function() {
        try {
          var e9 = r2 && r2.require && r2.require("util").types;
          return e9 || o2 && o2.binding && o2.binding("util");
        } catch (e11) {
        }
      }();
      e8.exports = i2;
    });
    qe = We && We.isTypedArray;
    Ye = qe ? He(qe) : $e;
    Je = Object.prototype.hasOwnProperty;
    Xe = function(e8, n2) {
      var t4 = Te(e8), r2 = !t4 && Re(e8), o2 = !t4 && !r2 && Pe(e8), i2 = !t4 && !r2 && !o2 && Ye(e8), a3 = t4 || r2 || o2 || i2, u2 = a3 ? Me(e8.length, String) : [], c3 = u2.length;
      for (var s2 in e8) !n2 && !Je.call(e8, s2) || a3 && ("length" == s2 || o2 && ("offset" == s2 || "parent" == s2) || i2 && ("buffer" == s2 || "byteLength" == s2 || "byteOffset" == s2) || Fe(s2, c3)) || u2.push(s2);
      return u2;
    };
    Ke = Object.prototype;
    Qe = function(e8) {
      var n2 = e8 && e8.constructor;
      return e8 === ("function" == typeof n2 && n2.prototype || Ke);
    };
    Ze = function(e8, n2) {
      return function(t4) {
        return e8(n2(t4));
      };
    };
    en = Ze(Object.keys, Object);
    nn = Object.prototype.hasOwnProperty;
    tn = function(e8) {
      if (!Qe(e8)) return en(e8);
      var n2 = [];
      for (var t4 in Object(e8)) nn.call(e8, t4) && "constructor" != t4 && n2.push(t4);
      return n2;
    };
    rn = function(e8) {
      return null != e8 && Ue(e8.length) && !z(e8);
    };
    on = function(e8) {
      return rn(e8) ? Xe(e8) : tn(e8);
    };
    an = function(e8, n2) {
      return e8 && Se(n2, on(n2), e8);
    };
    un = function(e8) {
      var n2 = [];
      if (null != e8) for (var t4 in Object(e8)) n2.push(t4);
      return n2;
    };
    cn = Object.prototype.hasOwnProperty;
    sn = function(e8) {
      if (!D2(e8)) return un(e8);
      var n2 = Qe(e8), t4 = [];
      for (var r2 in e8) ("constructor" != r2 || !n2 && cn.call(e8, r2)) && t4.push(r2);
      return t4;
    };
    dn = function(e8) {
      return rn(e8) ? Xe(e8, true) : sn(e8);
    };
    fn = function(e8, n2) {
      return e8 && Se(n2, dn(n2), e8);
    };
    hn = d(function(e8, n2) {
      var t4 = n2 && !n2.nodeType && n2, r2 = t4 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t4 ? k.Buffer : void 0, i2 = o2 ? o2.allocUnsafe : void 0;
      e8.exports = function(e9, n3) {
        if (n3) return e9.slice();
        var t5 = e9.length, r3 = i2 ? i2(t5) : new e9.constructor(t5);
        return e9.copy(r3), r3;
      };
    });
    ln2 = function(e8, n2) {
      var t4 = -1, r2 = e8.length;
      for (n2 || (n2 = Array(r2)); ++t4 < r2; ) n2[t4] = e8[t4];
      return n2;
    };
    vn = function(e8, n2) {
      for (var t4 = -1, r2 = null == e8 ? 0 : e8.length, o2 = 0, i2 = []; ++t4 < r2; ) {
        var a3 = e8[t4];
        n2(a3, t4, e8) && (i2[o2++] = a3);
      }
      return i2;
    };
    pn = function() {
      return [];
    };
    gn = Object.prototype.propertyIsEnumerable;
    yn = Object.getOwnPropertySymbols;
    bn = yn ? function(e8) {
      return null == e8 ? [] : (e8 = Object(e8), vn(yn(e8), function(n2) {
        return gn.call(e8, n2);
      }));
    } : pn;
    mn = function(e8, n2) {
      return Se(e8, bn(e8), n2);
    };
    wn = function(e8, n2) {
      for (var t4 = -1, r2 = n2.length, o2 = e8.length; ++t4 < r2; ) e8[o2 + t4] = n2[t4];
      return e8;
    };
    En = Ze(Object.getPrototypeOf, Object);
    _n = Object.getOwnPropertySymbols ? function(e8) {
      for (var n2 = []; e8; ) wn(n2, bn(e8)), e8 = En(e8);
      return n2;
    } : pn;
    jn = function(e8, n2) {
      return Se(e8, _n(e8), n2);
    };
    xn = function(e8, n2, t4) {
      var r2 = n2(e8);
      return Te(e8) ? r2 : wn(r2, t4(e8));
    };
    Nn = function(e8) {
      return xn(e8, on, bn);
    };
    On = function(e8) {
      return xn(e8, dn, _n);
    };
    kn = ee(k, "DataView");
    In = ee(k, "Promise");
    Sn = ee(k, "Set");
    Mn = ee(k, "WeakMap");
    Cn = H(kn);
    Gn = H(ne);
    Bn = H(In);
    An = H(Sn);
    Ln = H(Mn);
    Rn = T;
    (kn && "[object DataView]" != Rn(new kn(new ArrayBuffer(1))) || ne && "[object Map]" != Rn(new ne()) || In && "[object Promise]" != Rn(In.resolve()) || Sn && "[object Set]" != Rn(new Sn()) || Mn && "[object WeakMap]" != Rn(new Mn())) && (Rn = function(e8) {
      var n2 = T(e8), t4 = "[object Object]" == n2 ? e8.constructor : void 0, r2 = t4 ? H(t4) : "";
      if (r2) switch (r2) {
        case Cn:
          return "[object DataView]";
        case Gn:
          return "[object Map]";
        case Bn:
          return "[object Promise]";
        case An:
          return "[object Set]";
        case Ln:
          return "[object WeakMap]";
      }
      return n2;
    });
    Tn = Rn;
    Dn = Object.prototype.hasOwnProperty;
    Pn = function(e8) {
      var n2 = e8.length, t4 = new e8.constructor(n2);
      return n2 && "string" == typeof e8[0] && Dn.call(e8, "index") && (t4.index = e8.index, t4.input = e8.input), t4;
    };
    zn = k.Uint8Array;
    Fn = function(e8) {
      var n2 = new e8.constructor(e8.byteLength);
      return new zn(n2).set(new zn(e8)), n2;
    };
    Un = function(e8, n2) {
      var t4 = n2 ? Fn(e8.buffer) : e8.buffer;
      return new e8.constructor(t4, e8.byteOffset, e8.byteLength);
    };
    Vn = /\w*$/;
    $n = function(e8) {
      var n2 = new e8.constructor(e8.source, Vn.exec(e8));
      return n2.lastIndex = e8.lastIndex, n2;
    };
    Hn = I ? I.prototype : void 0;
    Wn = Hn ? Hn.valueOf : void 0;
    qn = function(e8) {
      return Wn ? Object(Wn.call(e8)) : {};
    };
    Yn2 = function(e8, n2) {
      var t4 = n2 ? Fn(e8.buffer) : e8.buffer;
      return new e8.constructor(t4, e8.byteOffset, e8.length);
    };
    Jn = function(e8, n2, t4) {
      var r2 = e8.constructor;
      switch (n2) {
        case "[object ArrayBuffer]":
          return Fn(e8);
        case "[object Boolean]":
        case "[object Date]":
          return new r2(+e8);
        case "[object DataView]":
          return Un(e8, t4);
        case "[object Float32Array]":
        case "[object Float64Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object Int32Array]":
        case "[object Uint8Array]":
        case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":
        case "[object Uint32Array]":
          return Yn2(e8, t4);
        case "[object Map]":
          return new r2();
        case "[object Number]":
        case "[object String]":
          return new r2(e8);
        case "[object RegExp]":
          return $n(e8);
        case "[object Set]":
          return new r2();
        case "[object Symbol]":
          return qn(e8);
      }
    };
    Xn2 = Object.create;
    Kn = /* @__PURE__ */ function() {
      function e8() {
      }
      return function(n2) {
        if (!D2(n2)) return {};
        if (Xn2) return Xn2(n2);
        e8.prototype = n2;
        var t4 = new e8();
        return e8.prototype = void 0, t4;
      };
    }();
    Qn = function(e8) {
      return "function" != typeof e8.constructor || Qe(e8) ? {} : Kn(En(e8));
    };
    Zn2 = function(e8) {
      return Ce(e8) && "[object Map]" == Tn(e8);
    };
    et = We && We.isMap;
    nt = et ? He(et) : Zn2;
    tt = function(e8) {
      return Ce(e8) && "[object Set]" == Tn(e8);
    };
    rt = We && We.isSet;
    ot = rt ? He(rt) : tt;
    it = {};
    it["[object Arguments]"] = it["[object Array]"] = it["[object ArrayBuffer]"] = it["[object DataView]"] = it["[object Boolean]"] = it["[object Date]"] = it["[object Float32Array]"] = it["[object Float64Array]"] = it["[object Int8Array]"] = it["[object Int16Array]"] = it["[object Int32Array]"] = it["[object Map]"] = it["[object Number]"] = it["[object Object]"] = it["[object RegExp]"] = it["[object Set]"] = it["[object String]"] = it["[object Symbol]"] = it["[object Uint8Array]"] = it["[object Uint8ClampedArray]"] = it["[object Uint16Array]"] = it["[object Uint32Array]"] = true, it["[object Error]"] = it["[object Function]"] = it["[object WeakMap]"] = false;
    at = function e2(n2, t4, r2, o2, i2, a3) {
      var u2, c3 = 1 & t4, s2 = 2 & t4, d2 = 4 & t4;
      if (r2 && (u2 = i2 ? r2(n2, o2, i2, a3) : r2(n2)), void 0 !== u2) return u2;
      if (!D2(n2)) return n2;
      var f2 = Te(n2);
      if (f2) {
        if (u2 = Pn(n2), !c3) return ln2(n2, u2);
      } else {
        var h2 = Tn(n2), l2 = "[object Function]" == h2 || "[object GeneratorFunction]" == h2;
        if (Pe(n2)) return hn(n2, c3);
        if ("[object Object]" == h2 || "[object Arguments]" == h2 || l2 && !i2) {
          if (u2 = s2 || l2 ? {} : Qn(n2), !c3) return s2 ? jn(n2, fn(u2, n2)) : mn(n2, an(u2, n2));
        } else {
          if (!it[h2]) return i2 ? n2 : {};
          u2 = Jn(n2, h2, c3);
        }
      }
      a3 || (a3 = new je());
      var v2 = a3.get(n2);
      if (v2) return v2;
      a3.set(n2, u2), ot(n2) ? n2.forEach(function(o3) {
        u2.add(e2(o3, t4, r2, o3, n2, a3));
      }) : nt(n2) && n2.forEach(function(o3, i3) {
        u2.set(i3, e2(o3, t4, r2, i3, n2, a3));
      });
      var p2 = f2 ? void 0 : (d2 ? s2 ? On : Nn : s2 ? dn : on)(n2);
      return xe(p2 || n2, function(o3, i3) {
        p2 && (o3 = n2[i3 = o3]), Ie(u2, i3, e2(o3, t4, r2, i3, n2, a3));
      }), u2;
    };
    ut = function(e8) {
      return at(e8, 4);
    };
    ct = function(e8) {
      return function() {
        return e8;
      };
    };
    st = /* @__PURE__ */ function(e8) {
      return function(n2, t4, r2) {
        for (var o2 = -1, i2 = Object(n2), a3 = r2(n2), u2 = a3.length; u2--; ) {
          var c3 = a3[e8 ? u2 : ++o2];
          if (false === t4(i2[c3], c3, i2)) break;
        }
        return n2;
      };
    }();
    dt = function(e8, n2) {
      return e8 && st(e8, n2, on);
    };
    ft = /* @__PURE__ */ function(e8, n2) {
      return function(t4, r2) {
        if (null == t4) return t4;
        if (!rn(t4)) return e8(t4, r2);
        for (var o2 = t4.length, i2 = n2 ? o2 : -1, a3 = Object(t4); (n2 ? i2-- : ++i2 < o2) && false !== r2(a3[i2], i2, a3); ) ;
        return t4;
      };
    }(dt);
    ht = function(e8) {
      return e8;
    };
    lt = function(e8) {
      return "function" == typeof e8 ? e8 : ht;
    };
    vt = function(e8, n2) {
      return (Te(e8) ? xe : ft)(e8, lt(n2));
    };
    pt = vt;
    gt = function(e8, n2) {
      var t4 = [];
      return ft(e8, function(e9, r2, o2) {
        n2(e9, r2, o2) && t4.push(e9);
      }), t4;
    };
    yt = function(e8) {
      return this.__data__.set(e8, "__lodash_hash_undefined__"), this;
    };
    bt = function(e8) {
      return this.__data__.has(e8);
    };
    mt.prototype.add = mt.prototype.push = yt, mt.prototype.has = bt;
    wt = mt;
    Et = function(e8, n2) {
      for (var t4 = -1, r2 = null == e8 ? 0 : e8.length; ++t4 < r2; ) if (n2(e8[t4], t4, e8)) return true;
      return false;
    };
    _t = function(e8, n2) {
      return e8.has(n2);
    };
    jt = function(e8, n2, t4, r2, o2, i2) {
      var a3 = 1 & t4, u2 = e8.length, c3 = n2.length;
      if (u2 != c3 && !(a3 && c3 > u2)) return false;
      var s2 = i2.get(e8), d2 = i2.get(n2);
      if (s2 && d2) return s2 == n2 && d2 == e8;
      var f2 = -1, h2 = true, l2 = 2 & t4 ? new wt() : void 0;
      for (i2.set(e8, n2), i2.set(n2, e8); ++f2 < u2; ) {
        var v2 = e8[f2], p2 = n2[f2];
        if (r2) var g2 = a3 ? r2(p2, v2, f2, n2, e8, i2) : r2(v2, p2, f2, e8, n2, i2);
        if (void 0 !== g2) {
          if (g2) continue;
          h2 = false;
          break;
        }
        if (l2) {
          if (!Et(n2, function(e9, n3) {
            if (!_t(l2, n3) && (v2 === e9 || o2(v2, e9, t4, r2, i2))) return l2.push(n3);
          })) {
            h2 = false;
            break;
          }
        } else if (v2 !== p2 && !o2(v2, p2, t4, r2, i2)) {
          h2 = false;
          break;
        }
      }
      return i2.delete(e8), i2.delete(n2), h2;
    };
    xt = function(e8) {
      var n2 = -1, t4 = Array(e8.size);
      return e8.forEach(function(e9, r2) {
        t4[++n2] = [r2, e9];
      }), t4;
    };
    Nt = function(e8) {
      var n2 = -1, t4 = Array(e8.size);
      return e8.forEach(function(e9) {
        t4[++n2] = e9;
      }), t4;
    };
    Ot = I ? I.prototype : void 0;
    kt = Ot ? Ot.valueOf : void 0;
    It = function(e8, n2, t4, r2, o2, i2, a3) {
      switch (t4) {
        case "[object DataView]":
          if (e8.byteLength != n2.byteLength || e8.byteOffset != n2.byteOffset) return false;
          e8 = e8.buffer, n2 = n2.buffer;
        case "[object ArrayBuffer]":
          return !(e8.byteLength != n2.byteLength || !i2(new zn(e8), new zn(n2)));
        case "[object Boolean]":
        case "[object Date]":
        case "[object Number]":
          return h(+e8, +n2);
        case "[object Error]":
          return e8.name == n2.name && e8.message == n2.message;
        case "[object RegExp]":
        case "[object String]":
          return e8 == n2 + "";
        case "[object Map]":
          var u2 = xt;
        case "[object Set]":
          var c3 = 1 & r2;
          if (u2 || (u2 = Nt), e8.size != n2.size && !c3) return false;
          var s2 = a3.get(e8);
          if (s2) return s2 == n2;
          r2 |= 2, a3.set(e8, n2);
          var d2 = jt(u2(e8), u2(n2), r2, o2, i2, a3);
          return a3.delete(e8), d2;
        case "[object Symbol]":
          if (kt) return kt.call(e8) == kt.call(n2);
      }
      return false;
    };
    St = Object.prototype.hasOwnProperty;
    Mt = function(e8, n2, t4, r2, o2, i2) {
      var a3 = 1 & t4, u2 = Nn(e8), c3 = u2.length;
      if (c3 != Nn(n2).length && !a3) return false;
      for (var s2 = c3; s2--; ) {
        var d2 = u2[s2];
        if (!(a3 ? d2 in n2 : St.call(n2, d2))) return false;
      }
      var f2 = i2.get(e8), h2 = i2.get(n2);
      if (f2 && h2) return f2 == n2 && h2 == e8;
      var l2 = true;
      i2.set(e8, n2), i2.set(n2, e8);
      for (var v2 = a3; ++s2 < c3; ) {
        var p2 = e8[d2 = u2[s2]], g2 = n2[d2];
        if (r2) var y4 = a3 ? r2(g2, p2, d2, n2, e8, i2) : r2(p2, g2, d2, e8, n2, i2);
        if (!(void 0 === y4 ? p2 === g2 || o2(p2, g2, t4, r2, i2) : y4)) {
          l2 = false;
          break;
        }
        v2 || (v2 = "constructor" == d2);
      }
      if (l2 && !v2) {
        var b10 = e8.constructor, m3 = n2.constructor;
        b10 == m3 || !("constructor" in e8) || !("constructor" in n2) || "function" == typeof b10 && b10 instanceof b10 && "function" == typeof m3 && m3 instanceof m3 || (l2 = false);
      }
      return i2.delete(e8), i2.delete(n2), l2;
    };
    Ct = Object.prototype.hasOwnProperty;
    Gt = function(e8, n2, t4, r2, o2, i2) {
      var a3 = Te(e8), u2 = Te(n2), c3 = a3 ? "[object Array]" : Tn(e8), s2 = u2 ? "[object Array]" : Tn(n2), d2 = "[object Object]" == (c3 = "[object Arguments]" == c3 ? "[object Object]" : c3), f2 = "[object Object]" == (s2 = "[object Arguments]" == s2 ? "[object Object]" : s2), h2 = c3 == s2;
      if (h2 && Pe(e8)) {
        if (!Pe(n2)) return false;
        a3 = true, d2 = false;
      }
      if (h2 && !d2) return i2 || (i2 = new je()), a3 || Ye(e8) ? jt(e8, n2, t4, r2, o2, i2) : It(e8, n2, c3, t4, r2, o2, i2);
      if (!(1 & t4)) {
        var l2 = d2 && Ct.call(e8, "__wrapped__"), v2 = f2 && Ct.call(n2, "__wrapped__");
        if (l2 || v2) {
          var p2 = l2 ? e8.value() : e8, g2 = v2 ? n2.value() : n2;
          return i2 || (i2 = new je()), o2(p2, g2, t4, r2, i2);
        }
      }
      return !!h2 && (i2 || (i2 = new je()), Mt(e8, n2, t4, r2, o2, i2));
    };
    Bt = function e3(n2, t4, r2, o2, i2) {
      return n2 === t4 || (null == n2 || null == t4 || !Ce(n2) && !Ce(t4) ? n2 != n2 && t4 != t4 : Gt(n2, t4, r2, o2, e3, i2));
    };
    At = function(e8, n2, t4, r2) {
      var o2 = t4.length, i2 = o2, a3 = !r2;
      if (null == e8) return !i2;
      for (e8 = Object(e8); o2--; ) {
        var u2 = t4[o2];
        if (a3 && u2[2] ? u2[1] !== e8[u2[0]] : !(u2[0] in e8)) return false;
      }
      for (; ++o2 < i2; ) {
        var c3 = (u2 = t4[o2])[0], s2 = e8[c3], d2 = u2[1];
        if (a3 && u2[2]) {
          if (void 0 === s2 && !(c3 in e8)) return false;
        } else {
          var f2 = new je();
          if (r2) var h2 = r2(s2, d2, c3, e8, n2, f2);
          if (!(void 0 === h2 ? Bt(d2, s2, 3, r2, f2) : h2)) return false;
        }
      }
      return true;
    };
    Lt = function(e8) {
      return e8 == e8 && !D2(e8);
    };
    Rt = function(e8) {
      for (var n2 = on(e8), t4 = n2.length; t4--; ) {
        var r2 = n2[t4], o2 = e8[r2];
        n2[t4] = [r2, o2, Lt(o2)];
      }
      return n2;
    };
    Tt = function(e8, n2) {
      return function(t4) {
        return null != t4 && (t4[e8] === n2 && (void 0 !== n2 || e8 in Object(t4)));
      };
    };
    Dt = function(e8) {
      var n2 = Rt(e8);
      return 1 == n2.length && n2[0][2] ? Tt(n2[0][0], n2[0][1]) : function(t4) {
        return t4 === e8 || At(t4, e8, n2);
      };
    };
    Pt = function(e8) {
      return "symbol" == typeof e8 || Ce(e8) && "[object Symbol]" == T(e8);
    };
    zt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    Ft = /^\w*$/;
    Ut = function(e8, n2) {
      if (Te(e8)) return false;
      var t4 = typeof e8;
      return !("number" != t4 && "symbol" != t4 && "boolean" != t4 && null != e8 && !Pt(e8)) || (Ft.test(e8) || !zt.test(e8) || null != n2 && e8 in Object(n2));
    };
    Vt.Cache = we;
    $t = Vt;
    Ht = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    Wt = /\\(\\)?/g;
    qt = function(e8) {
      var n2 = $t(e8, function(e9) {
        return 500 === t4.size && t4.clear(), e9;
      }), t4 = n2.cache;
      return n2;
    }(function(e8) {
      var n2 = [];
      return 46 === e8.charCodeAt(0) && n2.push(""), e8.replace(Ht, function(e9, t4, r2, o2) {
        n2.push(r2 ? o2.replace(Wt, "$1") : t4 || e9);
      }), n2;
    });
    Yt = function(e8, n2) {
      for (var t4 = -1, r2 = null == e8 ? 0 : e8.length, o2 = Array(r2); ++t4 < r2; ) o2[t4] = n2(e8[t4], t4, e8);
      return o2;
    };
    Jt = I ? I.prototype : void 0;
    Xt = Jt ? Jt.toString : void 0;
    Kt = function e4(n2) {
      if ("string" == typeof n2) return n2;
      if (Te(n2)) return Yt(n2, e4) + "";
      if (Pt(n2)) return Xt ? Xt.call(n2) : "";
      var t4 = n2 + "";
      return "0" == t4 && 1 / n2 == -Infinity ? "-0" : t4;
    };
    Qt = function(e8) {
      return null == e8 ? "" : Kt(e8);
    };
    Zt = function(e8, n2) {
      return Te(e8) ? e8 : Ut(e8, n2) ? [e8] : qt(Qt(e8));
    };
    er = function(e8) {
      if ("string" == typeof e8 || Pt(e8)) return e8;
      var n2 = e8 + "";
      return "0" == n2 && 1 / e8 == -Infinity ? "-0" : n2;
    };
    nr = function(e8, n2) {
      for (var t4 = 0, r2 = (n2 = Zt(n2, e8)).length; null != e8 && t4 < r2; ) e8 = e8[er(n2[t4++])];
      return t4 && t4 == r2 ? e8 : void 0;
    };
    tr = function(e8, n2, t4) {
      var r2 = null == e8 ? void 0 : nr(e8, n2);
      return void 0 === r2 ? t4 : r2;
    };
    rr = function(e8, n2) {
      return null != e8 && n2 in Object(e8);
    };
    or = function(e8, n2, t4) {
      for (var r2 = -1, o2 = (n2 = Zt(n2, e8)).length, i2 = false; ++r2 < o2; ) {
        var a3 = er(n2[r2]);
        if (!(i2 = null != e8 && t4(e8, a3))) break;
        e8 = e8[a3];
      }
      return i2 || ++r2 != o2 ? i2 : !!(o2 = null == e8 ? 0 : e8.length) && Ue(o2) && Fe(a3, o2) && (Te(e8) || Re(e8));
    };
    ir = function(e8, n2) {
      return null != e8 && or(e8, n2, rr);
    };
    ar = function(e8, n2) {
      return Ut(e8) && Lt(n2) ? Tt(er(e8), n2) : function(t4) {
        var r2 = tr(t4, e8);
        return void 0 === r2 && r2 === n2 ? ir(t4, e8) : Bt(n2, r2, 3);
      };
    };
    ur = function(e8) {
      return function(n2) {
        return null == n2 ? void 0 : n2[e8];
      };
    };
    cr = function(e8) {
      return function(n2) {
        return nr(n2, e8);
      };
    };
    sr = function(e8) {
      return Ut(e8) ? ur(er(e8)) : cr(e8);
    };
    dr = function(e8) {
      return "function" == typeof e8 ? e8 : null == e8 ? ht : "object" == typeof e8 ? Te(e8) ? ar(e8[0], e8[1]) : Dt(e8) : sr(e8);
    };
    fr = function(e8, n2) {
      return (Te(e8) ? vn : gt)(e8, dr(n2));
    };
    hr = Object.prototype.hasOwnProperty;
    lr = function(e8, n2) {
      return null != e8 && hr.call(e8, n2);
    };
    vr = function(e8, n2) {
      return null != e8 && or(e8, n2, lr);
    };
    pr = Object.prototype.hasOwnProperty;
    gr = function(e8) {
      if (null == e8) return true;
      if (rn(e8) && (Te(e8) || "string" == typeof e8 || "function" == typeof e8.splice || Pe(e8) || Ye(e8) || Re(e8))) return !e8.length;
      var n2 = Tn(e8);
      if ("[object Map]" == n2 || "[object Set]" == n2) return !e8.size;
      if (Qe(e8)) return !tn(e8).length;
      for (var t4 in e8) if (pr.call(e8, t4)) return false;
      return true;
    };
    yr = function(e8) {
      return void 0 === e8;
    };
    br = function(e8, n2) {
      var t4 = -1, r2 = rn(e8) ? Array(e8.length) : [];
      return ft(e8, function(e9, o2, i2) {
        r2[++t4] = n2(e9, o2, i2);
      }), r2;
    };
    mr = function(e8, n2) {
      return (Te(e8) ? Yt : br)(e8, dr(n2));
    };
    wr = function(e8, n2, t4, r2) {
      var o2 = -1, i2 = null == e8 ? 0 : e8.length;
      for (r2 && i2 && (t4 = e8[++o2]); ++o2 < i2; ) t4 = n2(t4, e8[o2], o2, e8);
      return t4;
    };
    Er = function(e8, n2, t4, r2, o2) {
      return o2(e8, function(e9, o3, i2) {
        t4 = r2 ? (r2 = false, e9) : n2(t4, e9, o3, i2);
      }), t4;
    };
    _r = function(e8, n2, t4) {
      var r2 = Te(e8) ? wr : Er, o2 = arguments.length < 3;
      return r2(e8, dr(n2), t4, o2, ft);
    };
    jr = function(e8) {
      return "string" == typeof e8 || !Te(e8) && Ce(e8) && "[object String]" == T(e8);
    };
    xr = ur("length");
    Nr = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
    Or = function(e8) {
      return Nr.test(e8);
    };
    kr = "[\\ud800-\\udfff]";
    Ir = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]";
    Sr = "\\ud83c[\\udffb-\\udfff]";
    Mr = "[^\\ud800-\\udfff]";
    Cr = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    Gr = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    Br = "(?:" + Ir + "|" + Sr + ")?";
    Ar = "[\\ufe0e\\ufe0f]?" + Br + ("(?:\\u200d(?:" + [Mr, Cr, Gr].join("|") + ")[\\ufe0e\\ufe0f]?" + Br + ")*");
    Lr = "(?:" + [Mr + Ir + "?", Ir, Cr, Gr, kr].join("|") + ")";
    Rr = RegExp(Sr + "(?=" + Sr + ")|" + Lr + Ar, "g");
    Tr = function(e8) {
      for (var n2 = Rr.lastIndex = 0; Rr.test(e8); ) ++n2;
      return n2;
    };
    Dr = function(e8) {
      return Or(e8) ? Tr(e8) : xr(e8);
    };
    Pr = function(e8) {
      if (null == e8) return 0;
      if (rn(e8)) return jr(e8) ? Dr(e8) : e8.length;
      var n2 = Tn(e8);
      return "[object Map]" == n2 || "[object Set]" == n2 ? e8.size : tn(e8).length;
    };
    zr = function(e8, n2, t4) {
      var r2 = Te(e8), o2 = r2 || Pe(e8) || Ye(e8);
      if (n2 = dr(n2), null == t4) {
        var i2 = e8 && e8.constructor;
        t4 = o2 ? r2 ? new i2() : [] : D2(e8) && z(i2) ? Kn(En(e8)) : {};
      }
      return (o2 ? xe : dt)(e8, function(e9, r3, o3) {
        return n2(t4, e9, r3, o3);
      }), t4;
    };
    Fr = I ? I.isConcatSpreadable : void 0;
    Ur = function(e8) {
      return Te(e8) || Re(e8) || !!(Fr && e8 && e8[Fr]);
    };
    Vr = function e5(n2, t4, r2, o2, i2) {
      var a3 = -1, u2 = n2.length;
      for (r2 || (r2 = Ur), i2 || (i2 = []); ++a3 < u2; ) {
        var c3 = n2[a3];
        t4 > 0 && r2(c3) ? t4 > 1 ? e5(c3, t4 - 1, r2, o2, i2) : wn(i2, c3) : o2 || (i2[i2.length] = c3);
      }
      return i2;
    };
    $r = function(e8, n2, t4) {
      switch (t4.length) {
        case 0:
          return e8.call(n2);
        case 1:
          return e8.call(n2, t4[0]);
        case 2:
          return e8.call(n2, t4[0], t4[1]);
        case 3:
          return e8.call(n2, t4[0], t4[1], t4[2]);
      }
      return e8.apply(n2, t4);
    };
    Hr = Math.max;
    Wr = function(e8, n2, t4) {
      return n2 = Hr(void 0 === n2 ? e8.length - 1 : n2, 0), function() {
        for (var r2 = arguments, o2 = -1, i2 = Hr(r2.length - n2, 0), a3 = Array(i2); ++o2 < i2; ) a3[o2] = r2[n2 + o2];
        o2 = -1;
        for (var u2 = Array(n2 + 1); ++o2 < n2; ) u2[o2] = r2[o2];
        return u2[n2] = t4(a3), $r(e8, this, u2);
      };
    };
    qr = Ne ? function(e8, n2) {
      return Ne(e8, "toString", { configurable: true, enumerable: false, value: ct(n2), writable: true });
    } : ht;
    Yr = Date.now;
    Jr = /* @__PURE__ */ function(e8) {
      var n2 = 0, t4 = 0;
      return function() {
        var r2 = Yr(), o2 = 16 - (r2 - t4);
        if (t4 = r2, o2 > 0) {
          if (++n2 >= 800) return arguments[0];
        } else n2 = 0;
        return e8.apply(void 0, arguments);
      };
    }(qr);
    Xr = function(e8, n2) {
      return Jr(Wr(e8, n2, ht), e8 + "");
    };
    Kr = function(e8, n2, t4, r2) {
      for (var o2 = e8.length, i2 = t4 + (r2 ? 1 : -1); r2 ? i2-- : ++i2 < o2; ) if (n2(e8[i2], i2, e8)) return i2;
      return -1;
    };
    Qr = function(e8) {
      return e8 != e8;
    };
    Zr = function(e8, n2, t4) {
      for (var r2 = t4 - 1, o2 = e8.length; ++r2 < o2; ) if (e8[r2] === n2) return r2;
      return -1;
    };
    eo = function(e8, n2, t4) {
      return n2 == n2 ? Zr(e8, n2, t4) : Kr(e8, Qr, t4);
    };
    no = function(e8, n2) {
      return !!(null == e8 ? 0 : e8.length) && eo(e8, n2, 0) > -1;
    };
    to = function(e8, n2, t4) {
      for (var r2 = -1, o2 = null == e8 ? 0 : e8.length; ++r2 < o2; ) if (t4(n2, e8[r2])) return true;
      return false;
    };
    ro = function() {
    };
    oo = Sn && 1 / Nt(new Sn([, -0]))[1] == 1 / 0 ? function(e8) {
      return new Sn(e8);
    } : ro;
    io = function(e8, n2, t4) {
      var r2 = -1, o2 = no, i2 = e8.length, a3 = true, u2 = [], c3 = u2;
      if (t4) a3 = false, o2 = to;
      else if (i2 >= 200) {
        var s2 = n2 ? null : oo(e8);
        if (s2) return Nt(s2);
        a3 = false, o2 = _t, c3 = new wt();
      } else c3 = n2 ? [] : u2;
      e: for (; ++r2 < i2; ) {
        var d2 = e8[r2], f2 = n2 ? n2(d2) : d2;
        if (d2 = t4 || 0 !== d2 ? d2 : 0, a3 && f2 == f2) {
          for (var h2 = c3.length; h2--; ) if (c3[h2] === f2) continue e;
          n2 && c3.push(f2), u2.push(d2);
        } else o2(c3, f2, t4) || (c3 !== u2 && c3.push(f2), u2.push(d2));
      }
      return u2;
    };
    ao = function(e8) {
      return Ce(e8) && rn(e8);
    };
    uo = Xr(function(e8) {
      return io(Vr(e8, 1, ao, true));
    });
    co = function(e8, n2) {
      return Yt(n2, function(n3) {
        return e8[n3];
      });
    };
    fo = function(e8) {
      return null == e8 ? [] : co(e8, on(e8));
    };
    try {
      so = { clone: ut, constant: ct, each: pt, filter: fr, has: vr, isArray: Te, isEmpty: gr, isFunction: z, isUndefined: yr, keys: on, map: mr, reduce: _r, size: Pr, transform: zr, union: uo, values: fo };
    } catch (e8) {
    }
    so || (so = window._);
    ho = so;
    lo = vo;
    vo.prototype._nodeCount = 0, vo.prototype._edgeCount = 0, vo.prototype.isDirected = function() {
      return this._isDirected;
    }, vo.prototype.isMultigraph = function() {
      return this._isMultigraph;
    }, vo.prototype.isCompound = function() {
      return this._isCompound;
    }, vo.prototype.setGraph = function(e8) {
      return this._label = e8, this;
    }, vo.prototype.graph = function() {
      return this._label;
    }, vo.prototype.setDefaultNodeLabel = function(e8) {
      return ho.isFunction(e8) || (e8 = ho.constant(e8)), this._defaultNodeLabelFn = e8, this;
    }, vo.prototype.nodeCount = function() {
      return this._nodeCount;
    }, vo.prototype.nodes = function() {
      return ho.keys(this._nodes);
    }, vo.prototype.sources = function() {
      var e8 = this;
      return ho.filter(this.nodes(), function(n2) {
        return ho.isEmpty(e8._in[n2]);
      });
    }, vo.prototype.sinks = function() {
      var e8 = this;
      return ho.filter(this.nodes(), function(n2) {
        return ho.isEmpty(e8._out[n2]);
      });
    }, vo.prototype.setNodes = function(e8, n2) {
      var t4 = arguments, r2 = this;
      return ho.each(e8, function(e9) {
        t4.length > 1 ? r2.setNode(e9, n2) : r2.setNode(e9);
      }), this;
    }, vo.prototype.setNode = function(e8, n2) {
      return ho.has(this._nodes, e8) ? (arguments.length > 1 && (this._nodes[e8] = n2), this) : (this._nodes[e8] = arguments.length > 1 ? n2 : this._defaultNodeLabelFn(e8), this._isCompound && (this._parent[e8] = "\0", this._children[e8] = {}, this._children["\0"][e8] = true), this._in[e8] = {}, this._preds[e8] = {}, this._out[e8] = {}, this._sucs[e8] = {}, ++this._nodeCount, this);
    }, vo.prototype.node = function(e8) {
      return this._nodes[e8];
    }, vo.prototype.hasNode = function(e8) {
      return ho.has(this._nodes, e8);
    }, vo.prototype.removeNode = function(e8) {
      var n2 = this;
      if (ho.has(this._nodes, e8)) {
        var t4 = function(e9) {
          n2.removeEdge(n2._edgeObjs[e9]);
        };
        delete this._nodes[e8], this._isCompound && (this._removeFromParentsChildList(e8), delete this._parent[e8], ho.each(this.children(e8), function(e9) {
          n2.setParent(e9);
        }), delete this._children[e8]), ho.each(ho.keys(this._in[e8]), t4), delete this._in[e8], delete this._preds[e8], ho.each(ho.keys(this._out[e8]), t4), delete this._out[e8], delete this._sucs[e8], --this._nodeCount;
      }
      return this;
    }, vo.prototype.setParent = function(e8, n2) {
      if (!this._isCompound) throw new Error("Cannot set parent in a non-compound graph");
      if (ho.isUndefined(n2)) n2 = "\0";
      else {
        for (var t4 = n2 += ""; !ho.isUndefined(t4); t4 = this.parent(t4)) if (t4 === e8) throw new Error("Setting " + n2 + " as parent of " + e8 + " would create a cycle");
        this.setNode(n2);
      }
      return this.setNode(e8), this._removeFromParentsChildList(e8), this._parent[e8] = n2, this._children[n2][e8] = true, this;
    }, vo.prototype._removeFromParentsChildList = function(e8) {
      delete this._children[this._parent[e8]][e8];
    }, vo.prototype.parent = function(e8) {
      if (this._isCompound) {
        var n2 = this._parent[e8];
        if ("\0" !== n2) return n2;
      }
    }, vo.prototype.children = function(e8) {
      if (ho.isUndefined(e8) && (e8 = "\0"), this._isCompound) {
        var n2 = this._children[e8];
        if (n2) return ho.keys(n2);
      } else {
        if ("\0" === e8) return this.nodes();
        if (this.hasNode(e8)) return [];
      }
    }, vo.prototype.predecessors = function(e8) {
      var n2 = this._preds[e8];
      if (n2) return ho.keys(n2);
    }, vo.prototype.successors = function(e8) {
      var n2 = this._sucs[e8];
      if (n2) return ho.keys(n2);
    }, vo.prototype.neighbors = function(e8) {
      var n2 = this.predecessors(e8);
      if (n2) return ho.union(n2, this.successors(e8));
    }, vo.prototype.isLeaf = function(e8) {
      return 0 === (this.isDirected() ? this.successors(e8) : this.neighbors(e8)).length;
    }, vo.prototype.filterNodes = function(e8) {
      var n2 = new this.constructor({ directed: this._isDirected, multigraph: this._isMultigraph, compound: this._isCompound });
      n2.setGraph(this.graph());
      var t4 = this;
      ho.each(this._nodes, function(t5, r3) {
        e8(r3) && n2.setNode(r3, t5);
      }), ho.each(this._edgeObjs, function(e9) {
        n2.hasNode(e9.v) && n2.hasNode(e9.w) && n2.setEdge(e9, t4.edge(e9));
      });
      var r2 = {};
      function o2(e9) {
        var i2 = t4.parent(e9);
        return void 0 === i2 || n2.hasNode(i2) ? (r2[e9] = i2, i2) : i2 in r2 ? r2[i2] : o2(i2);
      }
      return this._isCompound && ho.each(n2.nodes(), function(e9) {
        n2.setParent(e9, o2(e9));
      }), n2;
    }, vo.prototype.setDefaultEdgeLabel = function(e8) {
      return ho.isFunction(e8) || (e8 = ho.constant(e8)), this._defaultEdgeLabelFn = e8, this;
    }, vo.prototype.edgeCount = function() {
      return this._edgeCount;
    }, vo.prototype.edges = function() {
      return ho.values(this._edgeObjs);
    }, vo.prototype.setPath = function(e8, n2) {
      var t4 = this, r2 = arguments;
      return ho.reduce(e8, function(e9, o2) {
        return r2.length > 1 ? t4.setEdge(e9, o2, n2) : t4.setEdge(e9, o2), o2;
      }), this;
    }, vo.prototype.setEdge = function() {
      var e8, n2, t4, r2, o2 = false, i2 = arguments[0];
      "object" == typeof i2 && null !== i2 && "v" in i2 ? (e8 = i2.v, n2 = i2.w, t4 = i2.name, 2 === arguments.length && (r2 = arguments[1], o2 = true)) : (e8 = i2, n2 = arguments[1], t4 = arguments[3], arguments.length > 2 && (r2 = arguments[2], o2 = true)), e8 = "" + e8, n2 = "" + n2, ho.isUndefined(t4) || (t4 = "" + t4);
      var a3 = yo(this._isDirected, e8, n2, t4);
      if (ho.has(this._edgeLabels, a3)) return o2 && (this._edgeLabels[a3] = r2), this;
      if (!ho.isUndefined(t4) && !this._isMultigraph) throw new Error("Cannot set a named edge when isMultigraph = false");
      this.setNode(e8), this.setNode(n2), this._edgeLabels[a3] = o2 ? r2 : this._defaultEdgeLabelFn(e8, n2, t4);
      var u2 = bo(this._isDirected, e8, n2, t4);
      return e8 = u2.v, n2 = u2.w, Object.freeze(u2), this._edgeObjs[a3] = u2, po(this._preds[n2], e8), po(this._sucs[e8], n2), this._in[n2][a3] = u2, this._out[e8][a3] = u2, this._edgeCount++, this;
    }, vo.prototype.edge = function(e8, n2, t4) {
      var r2 = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t4);
      return this._edgeLabels[r2];
    }, vo.prototype.hasEdge = function(e8, n2, t4) {
      var r2 = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t4);
      return ho.has(this._edgeLabels, r2);
    }, vo.prototype.removeEdge = function(e8, n2, t4) {
      var r2 = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t4), o2 = this._edgeObjs[r2];
      return o2 && (e8 = o2.v, n2 = o2.w, delete this._edgeLabels[r2], delete this._edgeObjs[r2], go(this._preds[n2], e8), go(this._sucs[e8], n2), delete this._in[n2][r2], delete this._out[e8][r2], this._edgeCount--), this;
    }, vo.prototype.inEdges = function(e8, n2) {
      var t4 = this._in[e8];
      if (t4) {
        var r2 = ho.values(t4);
        return n2 ? ho.filter(r2, function(e9) {
          return e9.v === n2;
        }) : r2;
      }
    }, vo.prototype.outEdges = function(e8, n2) {
      var t4 = this._out[e8];
      if (t4) {
        var r2 = ho.values(t4);
        return n2 ? ho.filter(r2, function(e9) {
          return e9.w === n2;
        }) : r2;
      }
    }, vo.prototype.nodeEdges = function(e8, n2) {
      var t4 = this.inEdges(e8, n2);
      if (t4) return t4.concat(this.outEdges(e8, n2));
    };
    wo = { Graph: lo, version: "2.1.8" };
    Eo = { write: function(e8) {
      var n2 = { options: { directed: e8.isDirected(), multigraph: e8.isMultigraph(), compound: e8.isCompound() }, nodes: _o(e8), edges: jo(e8) };
      ho.isUndefined(e8.graph()) || (n2.value = ho.clone(e8.graph()));
      return n2;
    }, read: function(e8) {
      var n2 = new lo(e8.options).setGraph(e8.value);
      return ho.each(e8.nodes, function(e9) {
        n2.setNode(e9.v, e9.value), e9.parent && n2.setParent(e9.v, e9.parent);
      }), ho.each(e8.edges, function(e9) {
        n2.setEdge({ v: e9.v, w: e9.w, name: e9.name }, e9.value);
      }), n2;
    } };
    xo = function(e8) {
      var n2, t4 = {}, r2 = [];
      function o2(r3) {
        ho.has(t4, r3) || (t4[r3] = true, n2.push(r3), ho.each(e8.successors(r3), o2), ho.each(e8.predecessors(r3), o2));
      }
      return ho.each(e8.nodes(), function(e9) {
        n2 = [], o2(e9), n2.length && r2.push(n2);
      }), r2;
    };
    No = Oo;
    Oo.prototype.size = function() {
      return this._arr.length;
    }, Oo.prototype.keys = function() {
      return this._arr.map(function(e8) {
        return e8.key;
      });
    }, Oo.prototype.has = function(e8) {
      return ho.has(this._keyIndices, e8);
    }, Oo.prototype.priority = function(e8) {
      var n2 = this._keyIndices[e8];
      if (void 0 !== n2) return this._arr[n2].priority;
    }, Oo.prototype.min = function() {
      if (0 === this.size()) throw new Error("Queue underflow");
      return this._arr[0].key;
    }, Oo.prototype.add = function(e8, n2) {
      var t4 = this._keyIndices;
      if (e8 = String(e8), !ho.has(t4, e8)) {
        var r2 = this._arr, o2 = r2.length;
        return t4[e8] = o2, r2.push({ key: e8, priority: n2 }), this._decrease(o2), true;
      }
      return false;
    }, Oo.prototype.removeMin = function() {
      this._swap(0, this._arr.length - 1);
      var e8 = this._arr.pop();
      return delete this._keyIndices[e8.key], this._heapify(0), e8.key;
    }, Oo.prototype.decrease = function(e8, n2) {
      var t4 = this._keyIndices[e8];
      if (n2 > this._arr[t4].priority) throw new Error("New priority is greater than current priority. Key: " + e8 + " Old: " + this._arr[t4].priority + " New: " + n2);
      this._arr[t4].priority = n2, this._decrease(t4);
    }, Oo.prototype._heapify = function(e8) {
      var n2 = this._arr, t4 = 2 * e8, r2 = t4 + 1, o2 = e8;
      t4 < n2.length && (o2 = n2[t4].priority < n2[o2].priority ? t4 : o2, r2 < n2.length && (o2 = n2[r2].priority < n2[o2].priority ? r2 : o2), o2 !== e8 && (this._swap(e8, o2), this._heapify(o2)));
    }, Oo.prototype._decrease = function(e8) {
      for (var n2, t4 = this._arr, r2 = t4[e8].priority; 0 !== e8 && !(t4[n2 = e8 >> 1].priority < r2); ) this._swap(e8, n2), e8 = n2;
    }, Oo.prototype._swap = function(e8, n2) {
      var t4 = this._arr, r2 = this._keyIndices, o2 = t4[e8], i2 = t4[n2];
      t4[e8] = i2, t4[n2] = o2, r2[i2.key] = e8, r2[o2.key] = n2;
    };
    ko = function(e8, n2, t4, r2) {
      return function(e9, n3, t5, r3) {
        var o2, i2, a3 = {}, u2 = new No(), c3 = function(e11) {
          var n4 = e11.v !== o2 ? e11.v : e11.w, r4 = a3[n4], c4 = t5(e11), s2 = i2.distance + c4;
          if (c4 < 0) throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e11 + " Weight: " + c4);
          s2 < r4.distance && (r4.distance = s2, r4.predecessor = o2, u2.decrease(n4, s2));
        };
        e9.nodes().forEach(function(e11) {
          var t6 = e11 === n3 ? 0 : Number.POSITIVE_INFINITY;
          a3[e11] = { distance: t6 }, u2.add(e11, t6);
        });
        for (; u2.size() > 0 && (o2 = u2.removeMin(), (i2 = a3[o2]).distance !== Number.POSITIVE_INFINITY); ) r3(o2).forEach(c3);
        return a3;
      }(e8, String(n2), t4 || Io, r2 || function(n3) {
        return e8.outEdges(n3);
      });
    };
    Io = ho.constant(1);
    So = function(e8, n2, t4) {
      return ho.transform(e8.nodes(), function(r2, o2) {
        r2[o2] = ko(e8, o2, n2, t4);
      }, {});
    };
    Mo = function(e8) {
      var n2 = 0, t4 = [], r2 = {}, o2 = [];
      function i2(a3) {
        var u2 = r2[a3] = { onStack: true, lowlink: n2, index: n2++ };
        if (t4.push(a3), e8.successors(a3).forEach(function(e9) {
          ho.has(r2, e9) ? r2[e9].onStack && (u2.lowlink = Math.min(u2.lowlink, r2[e9].index)) : (i2(e9), u2.lowlink = Math.min(u2.lowlink, r2[e9].lowlink));
        }), u2.lowlink === u2.index) {
          var c3, s2 = [];
          do {
            c3 = t4.pop(), r2[c3].onStack = false, s2.push(c3);
          } while (a3 !== c3);
          o2.push(s2);
        }
      }
      return e8.nodes().forEach(function(e9) {
        ho.has(r2, e9) || i2(e9);
      }), o2;
    };
    Co = function(e8) {
      return ho.filter(Mo(e8), function(n2) {
        return n2.length > 1 || 1 === n2.length && e8.hasEdge(n2[0], n2[0]);
      });
    };
    Go = function(e8, n2, t4) {
      return function(e9, n3, t5) {
        var r2 = {}, o2 = e9.nodes();
        return o2.forEach(function(e11) {
          r2[e11] = {}, r2[e11][e11] = { distance: 0 }, o2.forEach(function(n4) {
            e11 !== n4 && (r2[e11][n4] = { distance: Number.POSITIVE_INFINITY });
          }), t5(e11).forEach(function(t6) {
            var o3 = t6.v === e11 ? t6.w : t6.v, i2 = n3(t6);
            r2[e11][o3] = { distance: i2, predecessor: e11 };
          });
        }), o2.forEach(function(e11) {
          var n4 = r2[e11];
          o2.forEach(function(t6) {
            var i2 = r2[t6];
            o2.forEach(function(t7) {
              var r3 = i2[e11], o3 = n4[t7], a3 = i2[t7], u2 = r3.distance + o3.distance;
              u2 < a3.distance && (a3.distance = u2, a3.predecessor = o3.predecessor);
            });
          });
        }), r2;
      }(e8, n2 || Bo, t4 || function(n3) {
        return e8.outEdges(n3);
      });
    };
    Bo = ho.constant(1);
    Ao = Lo;
    Lo.CycleException = Ro, Ro.prototype = new Error();
    To = function(e8, n2, t4) {
      ho.isArray(n2) || (n2 = [n2]);
      var r2 = (e8.isDirected() ? e8.successors : e8.neighbors).bind(e8), o2 = [], i2 = {};
      return ho.each(n2, function(n3) {
        if (!e8.hasNode(n3)) throw new Error("Graph does not have node: " + n3);
        Do(e8, n3, "post" === t4, i2, r2, o2);
      }), o2;
    };
    zo = { Graph: wo.Graph, json: Eo, alg: { components: xo, dijkstra: ko, dijkstraAll: So, findCycles: Co, floydWarshall: Go, isAcyclic: function(e8) {
      try {
        Ao(e8);
      } catch (e9) {
        if (e9 instanceof Ao.CycleException) return false;
        throw e9;
      }
      return true;
    }, postorder: function(e8, n2) {
      return To(e8, n2, "post");
    }, preorder: function(e8, n2) {
      return To(e8, n2, "pre");
    }, prim: function(e8, n2) {
      var t4, r2 = new lo(), o2 = {}, i2 = new No();
      function a3(e9) {
        var r3 = e9.v === t4 ? e9.w : e9.v, a4 = i2.priority(r3);
        if (void 0 !== a4) {
          var u3 = n2(e9);
          u3 < a4 && (o2[r3] = t4, i2.decrease(r3, u3));
        }
      }
      if (0 === e8.nodeCount()) return r2;
      ho.each(e8.nodes(), function(e9) {
        i2.add(e9, Number.POSITIVE_INFINITY), r2.setNode(e9);
      }), i2.decrease(e8.nodes()[0], 0);
      var u2 = false;
      for (; i2.size() > 0; ) {
        if (t4 = i2.removeMin(), ho.has(o2, t4)) r2.setEdge(t4, o2[t4]);
        else {
          if (u2) throw new Error("Input graph is not connected: " + e8);
          u2 = true;
        }
        e8.nodeEdges(t4).forEach(a3);
      }
      return r2;
    }, tarjan: Mo, topsort: Ao }, version: wo.version };
    try {
      Po = zo;
    } catch (e8) {
    }
    Po || (Po = window.graphlib);
    Fo = Po;
    Uo = function(e8) {
      return at(e8, 5);
    };
    Vo = function(e8, n2, t4) {
      if (!D2(t4)) return false;
      var r2 = typeof n2;
      return !!("number" == r2 ? rn(t4) && Fe(n2, t4.length) : "string" == r2 && n2 in t4) && h(t4[n2], e8);
    };
    $o = Object.prototype;
    Ho = $o.hasOwnProperty;
    Wo = Xr(function(e8, n2) {
      e8 = Object(e8);
      var t4 = -1, r2 = n2.length, o2 = r2 > 2 ? n2[2] : void 0;
      for (o2 && Vo(n2[0], n2[1], o2) && (r2 = 1); ++t4 < r2; ) for (var i2 = n2[t4], a3 = dn(i2), u2 = -1, c3 = a3.length; ++u2 < c3; ) {
        var s2 = a3[u2], d2 = e8[s2];
        (void 0 === d2 || h(d2, $o[s2]) && !Ho.call(e8, s2)) && (e8[s2] = i2[s2]);
      }
      return e8;
    });
    qo = function(e8) {
      return function(n2, t4, r2) {
        var o2 = Object(n2);
        if (!rn(n2)) {
          var i2 = dr(t4);
          n2 = on(n2), t4 = function(e9) {
            return i2(o2[e9], e9, o2);
          };
        }
        var a3 = e8(n2, t4, r2);
        return a3 > -1 ? o2[i2 ? n2[a3] : a3] : void 0;
      };
    };
    Yo = /^\s+|\s+$/g;
    Jo = /^[-+]0x[0-9a-f]+$/i;
    Xo = /^0b[01]+$/i;
    Ko = /^0o[0-7]+$/i;
    Qo = parseInt;
    Zo = function(e8) {
      if ("number" == typeof e8) return e8;
      if (Pt(e8)) return NaN;
      if (D2(e8)) {
        var n2 = "function" == typeof e8.valueOf ? e8.valueOf() : e8;
        e8 = D2(n2) ? n2 + "" : n2;
      }
      if ("string" != typeof e8) return 0 === e8 ? e8 : +e8;
      e8 = e8.replace(Yo, "");
      var t4 = Xo.test(e8);
      return t4 || Ko.test(e8) ? Qo(e8.slice(2), t4 ? 2 : 8) : Jo.test(e8) ? NaN : +e8;
    };
    ei = function(e8) {
      return e8 ? Infinity === (e8 = Zo(e8)) || -Infinity === e8 ? 17976931348623157e292 * (e8 < 0 ? -1 : 1) : e8 == e8 ? e8 : 0 : 0 === e8 ? e8 : 0;
    };
    ni = function(e8) {
      var n2 = ei(e8), t4 = n2 % 1;
      return n2 == n2 ? t4 ? n2 - t4 : n2 : 0;
    };
    ti = Math.max;
    ri = qo(function(e8, n2, t4) {
      var r2 = null == e8 ? 0 : e8.length;
      if (!r2) return -1;
      var o2 = null == t4 ? 0 : ni(t4);
      return o2 < 0 && (o2 = ti(r2 + o2, 0)), Kr(e8, dr(n2), o2);
    });
    oi = function(e8) {
      return (null == e8 ? 0 : e8.length) ? Vr(e8, 1) : [];
    };
    ii = function(e8, n2) {
      return null == e8 ? e8 : st(e8, lt(n2), dn);
    };
    ai = function(e8) {
      var n2 = null == e8 ? 0 : e8.length;
      return n2 ? e8[n2 - 1] : void 0;
    };
    ui = function(e8, n2) {
      var t4 = {};
      return n2 = dr(n2), dt(e8, function(e9, r2, o2) {
        Oe(t4, r2, n2(e9, r2, o2));
      }), t4;
    };
    ci = function(e8, n2, t4) {
      for (var r2 = -1, o2 = e8.length; ++r2 < o2; ) {
        var i2 = e8[r2], a3 = n2(i2);
        if (null != a3 && (void 0 === u2 ? a3 == a3 && !Pt(a3) : t4(a3, u2))) var u2 = a3, c3 = i2;
      }
      return c3;
    };
    si = function(e8, n2) {
      return e8 > n2;
    };
    di = function(e8) {
      return e8 && e8.length ? ci(e8, ht, si) : void 0;
    };
    fi = function(e8, n2, t4) {
      (void 0 !== t4 && !h(e8[n2], t4) || void 0 === t4 && !(n2 in e8)) && Oe(e8, n2, t4);
    };
    hi = Function.prototype;
    li = Object.prototype;
    vi = hi.toString;
    pi2 = li.hasOwnProperty;
    gi = vi.call(Object);
    yi = function(e8) {
      if (!Ce(e8) || "[object Object]" != T(e8)) return false;
      var n2 = En(e8);
      if (null === n2) return true;
      var t4 = pi2.call(n2, "constructor") && n2.constructor;
      return "function" == typeof t4 && t4 instanceof t4 && vi.call(t4) == gi;
    };
    bi = function(e8, n2) {
      if (("constructor" !== n2 || "function" != typeof e8[n2]) && "__proto__" != n2) return e8[n2];
    };
    mi = function(e8) {
      return Se(e8, dn(e8));
    };
    wi = function(e8, n2, t4, r2, o2, i2, a3) {
      var u2 = bi(e8, t4), c3 = bi(n2, t4), s2 = a3.get(c3);
      if (s2) fi(e8, t4, s2);
      else {
        var d2 = i2 ? i2(u2, c3, t4 + "", e8, n2, a3) : void 0, f2 = void 0 === d2;
        if (f2) {
          var h2 = Te(c3), l2 = !h2 && Pe(c3), v2 = !h2 && !l2 && Ye(c3);
          d2 = c3, h2 || l2 || v2 ? Te(u2) ? d2 = u2 : ao(u2) ? d2 = ln2(u2) : l2 ? (f2 = false, d2 = hn(c3, true)) : v2 ? (f2 = false, d2 = Yn2(c3, true)) : d2 = [] : yi(c3) || Re(c3) ? (d2 = u2, Re(u2) ? d2 = mi(u2) : D2(u2) && !z(u2) || (d2 = Qn(c3))) : f2 = false;
        }
        f2 && (a3.set(c3, d2), o2(d2, c3, r2, i2, a3), a3.delete(c3)), fi(e8, t4, d2);
      }
    };
    Ei = function e6(n2, t4, r2, o2, i2) {
      n2 !== t4 && st(t4, function(a3, u2) {
        if (i2 || (i2 = new je()), D2(a3)) wi(n2, t4, u2, r2, e6, o2, i2);
        else {
          var c3 = o2 ? o2(bi(n2, u2), a3, u2 + "", n2, t4, i2) : void 0;
          void 0 === c3 && (c3 = a3), fi(n2, u2, c3);
        }
      }, dn);
    };
    _i = function(e8) {
      return Xr(function(n2, t4) {
        var r2 = -1, o2 = t4.length, i2 = o2 > 1 ? t4[o2 - 1] : void 0, a3 = o2 > 2 ? t4[2] : void 0;
        for (i2 = e8.length > 3 && "function" == typeof i2 ? (o2--, i2) : void 0, a3 && Vo(t4[0], t4[1], a3) && (i2 = o2 < 3 ? void 0 : i2, o2 = 1), n2 = Object(n2); ++r2 < o2; ) {
          var u2 = t4[r2];
          u2 && e8(n2, u2, r2, i2);
        }
        return n2;
      });
    }(function(e8, n2, t4) {
      Ei(e8, n2, t4);
    });
    ji = function(e8, n2) {
      return e8 < n2;
    };
    xi = function(e8) {
      return e8 && e8.length ? ci(e8, ht, ji) : void 0;
    };
    Ni = function(e8, n2) {
      return e8 && e8.length ? ci(e8, dr(n2), ji) : void 0;
    };
    Oi = function() {
      return k.Date.now();
    };
    ki = function(e8, n2, t4, r2) {
      if (!D2(e8)) return e8;
      for (var o2 = -1, i2 = (n2 = Zt(n2, e8)).length, a3 = i2 - 1, u2 = e8; null != u2 && ++o2 < i2; ) {
        var c3 = er(n2[o2]), s2 = t4;
        if ("__proto__" === c3 || "constructor" === c3 || "prototype" === c3) return e8;
        if (o2 != a3) {
          var d2 = u2[c3];
          void 0 === (s2 = r2 ? r2(d2, c3, u2) : void 0) && (s2 = D2(d2) ? d2 : Fe(n2[o2 + 1]) ? [] : {});
        }
        Ie(u2, c3, s2), u2 = u2[c3];
      }
      return e8;
    };
    Ii = function(e8, n2, t4) {
      for (var r2 = -1, o2 = n2.length, i2 = {}; ++r2 < o2; ) {
        var a3 = n2[r2], u2 = nr(e8, a3);
        t4(u2, a3) && ki(i2, Zt(a3, e8), u2);
      }
      return i2;
    };
    Si = function(e8, n2) {
      return Ii(e8, n2, function(n3, t4) {
        return ir(e8, t4);
      });
    };
    Mi = function(e8) {
      return Jr(Wr(e8, void 0, oi), e8 + "");
    }(function(e8, n2) {
      return null == e8 ? {} : Si(e8, n2);
    });
    Ci = Math.ceil;
    Gi = Math.max;
    Bi = function(e8, n2, t4, r2) {
      for (var o2 = -1, i2 = Gi(Ci((n2 - e8) / (t4 || 1)), 0), a3 = Array(i2); i2--; ) a3[r2 ? i2 : ++o2] = e8, e8 += t4;
      return a3;
    };
    Ai = /* @__PURE__ */ function(e8) {
      return function(n2, t4, r2) {
        return r2 && "number" != typeof r2 && Vo(n2, t4, r2) && (t4 = r2 = void 0), n2 = ei(n2), void 0 === t4 ? (t4 = n2, n2 = 0) : t4 = ei(t4), r2 = void 0 === r2 ? n2 < t4 ? 1 : -1 : ei(r2), Bi(n2, t4, r2, e8);
      };
    }();
    Li = function(e8, n2) {
      var t4 = e8.length;
      for (e8.sort(n2); t4--; ) e8[t4] = e8[t4].value;
      return e8;
    };
    Ri = function(e8, n2) {
      if (e8 !== n2) {
        var t4 = void 0 !== e8, r2 = null === e8, o2 = e8 == e8, i2 = Pt(e8), a3 = void 0 !== n2, u2 = null === n2, c3 = n2 == n2, s2 = Pt(n2);
        if (!u2 && !s2 && !i2 && e8 > n2 || i2 && a3 && c3 && !u2 && !s2 || r2 && a3 && c3 || !t4 && c3 || !o2) return 1;
        if (!r2 && !i2 && !s2 && e8 < n2 || s2 && t4 && o2 && !r2 && !i2 || u2 && t4 && o2 || !a3 && o2 || !c3) return -1;
      }
      return 0;
    };
    Ti = function(e8, n2, t4) {
      for (var r2 = -1, o2 = e8.criteria, i2 = n2.criteria, a3 = o2.length, u2 = t4.length; ++r2 < a3; ) {
        var c3 = Ri(o2[r2], i2[r2]);
        if (c3) return r2 >= u2 ? c3 : c3 * ("desc" == t4[r2] ? -1 : 1);
      }
      return e8.index - n2.index;
    };
    Di = function(e8, n2, t4) {
      n2 = n2.length ? Yt(n2, function(e9) {
        return Te(e9) ? function(n3) {
          return nr(n3, 1 === e9.length ? e9[0] : e9);
        } : e9;
      }) : [ht];
      var r2 = -1;
      n2 = Yt(n2, He(dr));
      var o2 = br(e8, function(e9, t5, o3) {
        return { criteria: Yt(n2, function(n3) {
          return n3(e9);
        }), index: ++r2, value: e9 };
      });
      return Li(o2, function(e9, n3) {
        return Ti(e9, n3, t4);
      });
    };
    Pi = Xr(function(e8, n2) {
      if (null == e8) return [];
      var t4 = n2.length;
      return t4 > 1 && Vo(e8, n2[0], n2[1]) ? n2 = [] : t4 > 2 && Vo(n2[0], n2[1], n2[2]) && (n2 = [n2[0]]), Di(e8, Vr(n2, 1), []);
    });
    zi = 0;
    Fi = function(e8) {
      var n2 = ++zi;
      return Qt(e8) + n2;
    };
    Ui = function(e8, n2, t4) {
      for (var r2 = -1, o2 = e8.length, i2 = n2.length, a3 = {}; ++r2 < o2; ) {
        var u2 = r2 < i2 ? n2[r2] : void 0;
        t4(a3, e8[r2], u2);
      }
      return a3;
    };
    $i = function(e8, n2) {
      return Ui(e8 || [], n2 || [], Ie);
    };
    try {
      Vi = { cloneDeep: Uo, constant: ct, defaults: Wo, each: pt, filter: fr, find: ri, flatten: oi, forEach: vt, forIn: ii, has: vr, isUndefined: yr, last: ai, map: mr, mapValues: ui, max: di, merge: _i, min: xi, minBy: Ni, now: Oi, pick: Mi, range: Ai, reduce: _r, sortBy: Pi, uniqueId: Fi, values: fo, zipObject: $i };
    } catch (e8) {
    }
    Vi || (Vi = window._);
    Hi = Vi;
    Wi = qi;
    qi.prototype.dequeue = function() {
      var e8 = this._sentinel, n2 = e8._prev;
      if (n2 !== e8) return Yi(n2), n2;
    }, qi.prototype.enqueue = function(e8) {
      var n2 = this._sentinel;
      e8._prev && e8._next && Yi(e8), e8._next = n2._next, n2._next._prev = e8, n2._next = e8, e8._prev = n2;
    }, qi.prototype.toString = function() {
      for (var e8 = [], n2 = this._sentinel, t4 = n2._prev; t4 !== n2; ) e8.push(JSON.stringify(t4, Ji)), t4 = t4._prev;
      return "[" + e8.join(", ") + "]";
    };
    Xi = Fo.Graph;
    Ki = function(e8, n2) {
      if (e8.nodeCount() <= 1) return [];
      var t4 = function(e9, n3) {
        var t5 = new Xi(), r3 = 0, o2 = 0;
        Hi.forEach(e9.nodes(), function(e11) {
          t5.setNode(e11, { v: e11, in: 0, out: 0 });
        }), Hi.forEach(e9.edges(), function(e11) {
          var i3 = t5.edge(e11.v, e11.w) || 0, a4 = n3(e11), u2 = i3 + a4;
          t5.setEdge(e11.v, e11.w, u2), o2 = Math.max(o2, t5.node(e11.v).out += a4), r3 = Math.max(r3, t5.node(e11.w).in += a4);
        });
        var i2 = Hi.range(o2 + r3 + 3).map(function() {
          return new Wi();
        }), a3 = r3 + 1;
        return Hi.forEach(t5.nodes(), function(e11) {
          ea(i2, a3, t5.node(e11));
        }), { graph: t5, buckets: i2, zeroIdx: a3 };
      }(e8, n2 || Qi), r2 = function(e9, n3, t5) {
        var r3, o2 = [], i2 = n3[n3.length - 1], a3 = n3[0];
        for (; e9.nodeCount(); ) {
          for (; r3 = a3.dequeue(); ) Zi(e9, n3, t5, r3);
          for (; r3 = i2.dequeue(); ) Zi(e9, n3, t5, r3);
          if (e9.nodeCount()) {
            for (var u2 = n3.length - 2; u2 > 0; --u2) if (r3 = n3[u2].dequeue()) {
              o2 = o2.concat(Zi(e9, n3, t5, r3, true));
              break;
            }
          }
        }
        return o2;
      }(t4.graph, t4.buckets, t4.zeroIdx);
      return Hi.flatten(Hi.map(r2, function(n3) {
        return e8.outEdges(n3.v, n3.w);
      }), true);
    };
    Qi = Hi.constant(1);
    na = { run: function(e8) {
      var n2 = "greedy" === e8.graph().acyclicer ? Ki(e8, /* @__PURE__ */ function(e9) {
        return function(n3) {
          return e9.edge(n3).weight;
        };
      }(e8)) : function(e9) {
        var n3 = [], t4 = {}, r2 = {};
        function o2(i2) {
          Hi.has(r2, i2) || (r2[i2] = true, t4[i2] = true, Hi.forEach(e9.outEdges(i2), function(e11) {
            Hi.has(t4, e11.w) ? n3.push(e11) : o2(e11.w);
          }), delete t4[i2]);
        }
        return Hi.forEach(e9.nodes(), o2), n3;
      }(e8);
      Hi.forEach(n2, function(n3) {
        var t4 = e8.edge(n3);
        e8.removeEdge(n3), t4.forwardName = n3.name, t4.reversed = true, e8.setEdge(n3.w, n3.v, t4, Hi.uniqueId("rev"));
      });
    }, undo: function(e8) {
      Hi.forEach(e8.edges(), function(n2) {
        var t4 = e8.edge(n2);
        if (t4.reversed) {
          e8.removeEdge(n2);
          var r2 = t4.forwardName;
          delete t4.reversed, delete t4.forwardName, e8.setEdge(n2.w, n2.v, t4, r2);
        }
      });
    } };
    ta = Fo.Graph;
    ra = { addDummyNode: oa, simplify: function(e8) {
      var n2 = new ta().setGraph(e8.graph());
      return Hi.forEach(e8.nodes(), function(t4) {
        n2.setNode(t4, e8.node(t4));
      }), Hi.forEach(e8.edges(), function(t4) {
        var r2 = n2.edge(t4.v, t4.w) || { weight: 0, minlen: 1 }, o2 = e8.edge(t4);
        n2.setEdge(t4.v, t4.w, { weight: r2.weight + o2.weight, minlen: Math.max(r2.minlen, o2.minlen) });
      }), n2;
    }, asNonCompoundGraph: function(e8) {
      var n2 = new ta({ multigraph: e8.isMultigraph() }).setGraph(e8.graph());
      return Hi.forEach(e8.nodes(), function(t4) {
        e8.children(t4).length || n2.setNode(t4, e8.node(t4));
      }), Hi.forEach(e8.edges(), function(t4) {
        n2.setEdge(t4, e8.edge(t4));
      }), n2;
    }, successorWeights: function(e8) {
      var n2 = Hi.map(e8.nodes(), function(n3) {
        var t4 = {};
        return Hi.forEach(e8.outEdges(n3), function(n4) {
          t4[n4.w] = (t4[n4.w] || 0) + e8.edge(n4).weight;
        }), t4;
      });
      return Hi.zipObject(e8.nodes(), n2);
    }, predecessorWeights: function(e8) {
      var n2 = Hi.map(e8.nodes(), function(n3) {
        var t4 = {};
        return Hi.forEach(e8.inEdges(n3), function(n4) {
          t4[n4.v] = (t4[n4.v] || 0) + e8.edge(n4).weight;
        }), t4;
      });
      return Hi.zipObject(e8.nodes(), n2);
    }, intersectRect: function(e8, n2) {
      var t4, r2, o2 = e8.x, i2 = e8.y, a3 = n2.x - o2, u2 = n2.y - i2, c3 = e8.width / 2, s2 = e8.height / 2;
      if (!a3 && !u2) throw new Error("Not possible to find intersection inside of the rectangle");
      Math.abs(u2) * c3 > Math.abs(a3) * s2 ? (u2 < 0 && (s2 = -s2), t4 = s2 * a3 / u2, r2 = s2) : (a3 < 0 && (c3 = -c3), t4 = c3, r2 = c3 * u2 / a3);
      return { x: o2 + t4, y: i2 + r2 };
    }, buildLayerMatrix: function(e8) {
      var n2 = Hi.map(Hi.range(ia(e8) + 1), function() {
        return [];
      });
      return Hi.forEach(e8.nodes(), function(t4) {
        var r2 = e8.node(t4), o2 = r2.rank;
        Hi.isUndefined(o2) || (n2[o2][r2.order] = t4);
      }), n2;
    }, normalizeRanks: function(e8) {
      var n2 = Hi.min(Hi.map(e8.nodes(), function(n3) {
        return e8.node(n3).rank;
      }));
      Hi.forEach(e8.nodes(), function(t4) {
        var r2 = e8.node(t4);
        Hi.has(r2, "rank") && (r2.rank -= n2);
      });
    }, removeEmptyRanks: function(e8) {
      var n2 = Hi.min(Hi.map(e8.nodes(), function(n3) {
        return e8.node(n3).rank;
      })), t4 = [];
      Hi.forEach(e8.nodes(), function(r3) {
        var o3 = e8.node(r3).rank - n2;
        t4[o3] || (t4[o3] = []), t4[o3].push(r3);
      });
      var r2 = 0, o2 = e8.graph().nodeRankFactor;
      Hi.forEach(t4, function(n3, t5) {
        Hi.isUndefined(n3) && t5 % o2 != 0 ? --r2 : r2 && Hi.forEach(n3, function(n4) {
          e8.node(n4).rank += r2;
        });
      });
    }, addBorderNode: function(e8, n2, t4, r2) {
      var o2 = { width: 0, height: 0 };
      arguments.length >= 4 && (o2.rank = t4, o2.order = r2);
      return oa(e8, "border", o2, n2);
    }, maxRank: ia, partition: function(e8, n2) {
      var t4 = { lhs: [], rhs: [] };
      return Hi.forEach(e8, function(e9) {
        n2(e9) ? t4.lhs.push(e9) : t4.rhs.push(e9);
      }), t4;
    }, time: function(e8, n2) {
      var t4 = Hi.now();
      try {
        return n2();
      } finally {
        console.log(e8 + " time: " + (Hi.now() - t4) + "ms");
      }
    }, notime: function(e8, n2) {
      return n2();
    } };
    aa = { run: function(e8) {
      e8.graph().dummyChains = [], Hi.forEach(e8.edges(), function(n2) {
        !function(e9, n3) {
          var t4, r2, o2, i2 = n3.v, a3 = e9.node(i2).rank, u2 = n3.w, c3 = e9.node(u2).rank, s2 = n3.name, d2 = e9.edge(n3), f2 = d2.labelRank;
          if (c3 === a3 + 1) return;
          for (e9.removeEdge(n3), o2 = 0, ++a3; a3 < c3; ++o2, ++a3) d2.points = [], r2 = { width: 0, height: 0, edgeLabel: d2, edgeObj: n3, rank: a3 }, t4 = ra.addDummyNode(e9, "edge", r2, "_d"), a3 === f2 && (r2.width = d2.width, r2.height = d2.height, r2.dummy = "edge-label", r2.labelpos = d2.labelpos), e9.setEdge(i2, t4, { weight: d2.weight }, s2), 0 === o2 && e9.graph().dummyChains.push(t4), i2 = t4;
          e9.setEdge(i2, u2, { weight: d2.weight }, s2);
        }(e8, n2);
      });
    }, undo: function(e8) {
      Hi.forEach(e8.graph().dummyChains, function(n2) {
        var t4, r2 = e8.node(n2), o2 = r2.edgeLabel;
        for (e8.setEdge(r2.edgeObj, o2); r2.dummy; ) t4 = e8.successors(n2)[0], e8.removeNode(n2), o2.points.push({ x: r2.x, y: r2.y }), "edge-label" === r2.dummy && (o2.x = r2.x, o2.y = r2.y, o2.width = r2.width, o2.height = r2.height), n2 = t4, r2 = e8.node(n2);
      });
    } };
    ua = function(e8) {
      var n2 = {};
      Hi.forEach(e8.sources(), function t4(r2) {
        var o2 = e8.node(r2);
        if (Hi.has(n2, r2)) return o2.rank;
        n2[r2] = true;
        var i2 = Hi.min(Hi.map(e8.outEdges(r2), function(n3) {
          return t4(n3.w) - e8.edge(n3).minlen;
        }));
        return i2 !== Number.POSITIVE_INFINITY && null != i2 || (i2 = 0), o2.rank = i2;
      });
    };
    ca = function(e8, n2) {
      return e8.node(n2.w).rank - e8.node(n2.v).rank - e8.edge(n2).minlen;
    };
    sa = Fo.Graph;
    da = ca;
    fa = function(e8) {
      var n2, t4, r2 = new sa({ directed: false }), o2 = e8.nodes()[0], i2 = e8.nodeCount();
      r2.setNode(o2, {});
      for (; ha(r2, e8) < i2; ) n2 = la(r2, e8), t4 = r2.hasNode(n2.v) ? da(e8, n2) : -da(e8, n2), va(r2, e8, t4);
      return r2;
    };
    pa = ca;
    ga = ua;
    ya = Fo.alg.preorder;
    ba = Fo.alg.postorder;
    ma = ra.simplify;
    wa = Ea;
    Ea.initLowLimValues = xa, Ea.initCutValues = _a, Ea.calcCutValue = ja, Ea.leaveEdge = Oa, Ea.enterEdge = ka, Ea.exchangeEdges = Ia;
    Ma = ua;
    Ca = function(e8) {
      switch (e8.graph().ranker) {
        case "network-simplex":
          Ba(e8);
          break;
        case "tight-tree":
          !function(e9) {
            Ma(e9), fa(e9);
          }(e8);
          break;
        case "longest-path":
          Ga(e8);
          break;
        default:
          Ba(e8);
      }
    };
    Ga = Ma;
    Aa = function(e8) {
      var n2 = function(e9) {
        var n3 = {}, t4 = 0;
        function r2(o2) {
          var i2 = t4;
          Hi.forEach(e9.children(o2), r2), n3[o2] = { low: i2, lim: t4++ };
        }
        return Hi.forEach(e9.children(), r2), n3;
      }(e8);
      Hi.forEach(e8.graph().dummyChains, function(t4) {
        for (var r2 = e8.node(t4), o2 = r2.edgeObj, i2 = function(e9, n3, t5, r3) {
          var o3, i3, a4 = [], u3 = [], c4 = Math.min(n3[t5].low, n3[r3].low), s3 = Math.max(n3[t5].lim, n3[r3].lim);
          o3 = t5;
          do {
            o3 = e9.parent(o3), a4.push(o3);
          } while (o3 && (n3[o3].low > c4 || s3 > n3[o3].lim));
          i3 = o3, o3 = r3;
          for (; (o3 = e9.parent(o3)) !== i3; ) u3.push(o3);
          return { path: a4.concat(u3.reverse()), lca: i3 };
        }(e8, n2, o2.v, o2.w), a3 = i2.path, u2 = i2.lca, c3 = 0, s2 = a3[c3], d2 = true; t4 !== o2.w; ) {
          if (r2 = e8.node(t4), d2) {
            for (; (s2 = a3[c3]) !== u2 && e8.node(s2).maxRank < r2.rank; ) c3++;
            s2 === u2 && (d2 = false);
          }
          if (!d2) {
            for (; c3 < a3.length - 1 && e8.node(s2 = a3[c3 + 1]).minRank <= r2.rank; ) c3++;
            s2 = a3[c3];
          }
          e8.setParent(t4, s2), t4 = e8.successors(t4)[0];
        }
      });
    };
    La = { run: function(e8) {
      var n2 = ra.addDummyNode(e8, "root", {}, "_root"), t4 = function(e9) {
        var n3 = {};
        function t5(r3, o3) {
          var i3 = e9.children(r3);
          i3 && i3.length && Hi.forEach(i3, function(e11) {
            t5(e11, o3 + 1);
          }), n3[r3] = o3;
        }
        return Hi.forEach(e9.children(), function(e11) {
          t5(e11, 1);
        }), n3;
      }(e8), r2 = Hi.max(Hi.values(t4)) - 1, o2 = 2 * r2 + 1;
      e8.graph().nestingRoot = n2, Hi.forEach(e8.edges(), function(n3) {
        e8.edge(n3).minlen *= o2;
      });
      var i2 = function(e9) {
        return Hi.reduce(e9.edges(), function(n3, t5) {
          return n3 + e9.edge(t5).weight;
        }, 0);
      }(e8) + 1;
      Hi.forEach(e8.children(), function(a3) {
        Ra(e8, n2, o2, i2, r2, t4, a3);
      }), e8.graph().nodeRankFactor = o2;
    }, cleanup: function(e8) {
      var n2 = e8.graph();
      e8.removeNode(n2.nestingRoot), delete n2.nestingRoot, Hi.forEach(e8.edges(), function(n3) {
        e8.edge(n3).nestingEdge && e8.removeEdge(n3);
      });
    } };
    Ta = function(e8) {
      Hi.forEach(e8.children(), function n2(t4) {
        var r2 = e8.children(t4), o2 = e8.node(t4);
        if (r2.length && Hi.forEach(r2, n2), Hi.has(o2, "minRank")) {
          o2.borderLeft = [], o2.borderRight = [];
          for (var i2 = o2.minRank, a3 = o2.maxRank + 1; i2 < a3; ++i2) Da(e8, "borderLeft", "_bl", t4, o2, i2), Da(e8, "borderRight", "_br", t4, o2, i2);
        }
      });
    };
    Pa = { adjust: function(e8) {
      var n2 = e8.graph().rankdir.toLowerCase();
      "lr" !== n2 && "rl" !== n2 || za(e8);
    }, undo: function(e8) {
      var n2 = e8.graph().rankdir.toLowerCase();
      "bt" !== n2 && "rl" !== n2 || function(e9) {
        Hi.forEach(e9.nodes(), function(n3) {
          Ua(e9.node(n3));
        }), Hi.forEach(e9.edges(), function(n3) {
          var t4 = e9.edge(n3);
          Hi.forEach(t4.points, Ua), Hi.has(t4, "y") && Ua(t4);
        });
      }(e8);
      "lr" !== n2 && "rl" !== n2 || (!function(e9) {
        Hi.forEach(e9.nodes(), function(n3) {
          Va(e9.node(n3));
        }), Hi.forEach(e9.edges(), function(n3) {
          var t4 = e9.edge(n3);
          Hi.forEach(t4.points, Va), Hi.has(t4, "x") && Va(t4);
        });
      }(e8), za(e8));
    } };
    $a = function(e8) {
      var n2 = {}, t4 = Hi.filter(e8.nodes(), function(n3) {
        return !e8.children(n3).length;
      }), r2 = Hi.max(Hi.map(t4, function(n3) {
        return e8.node(n3).rank;
      })), o2 = Hi.map(Hi.range(r2 + 1), function() {
        return [];
      });
      function i2(t5) {
        if (!Hi.has(n2, t5)) {
          n2[t5] = true;
          var r3 = e8.node(t5);
          o2[r3.rank].push(t5), Hi.forEach(e8.successors(t5), i2);
        }
      }
      var a3 = Hi.sortBy(t4, function(n3) {
        return e8.node(n3).rank;
      });
      return Hi.forEach(a3, i2), o2;
    };
    Ha = function(e8, n2) {
      for (var t4 = 0, r2 = 1; r2 < n2.length; ++r2) t4 += Wa(e8, n2[r2 - 1], n2[r2]);
      return t4;
    };
    qa = function(e8, n2) {
      return Hi.map(n2, function(n3) {
        var t4 = e8.inEdges(n3);
        if (t4.length) {
          var r2 = Hi.reduce(t4, function(n4, t5) {
            var r3 = e8.edge(t5), o2 = e8.node(t5.v);
            return { sum: n4.sum + r3.weight * o2.order, weight: n4.weight + r3.weight };
          }, { sum: 0, weight: 0 });
          return { v: n3, barycenter: r2.sum / r2.weight, weight: r2.weight };
        }
        return { v: n3 };
      });
    };
    Ya = function(e8, n2) {
      var t4 = {};
      return Hi.forEach(e8, function(e9, n3) {
        var r2 = t4[e9.v] = { indegree: 0, in: [], out: [], vs: [e9.v], i: n3 };
        Hi.isUndefined(e9.barycenter) || (r2.barycenter = e9.barycenter, r2.weight = e9.weight);
      }), Hi.forEach(n2.edges(), function(e9) {
        var n3 = t4[e9.v], r2 = t4[e9.w];
        Hi.isUndefined(n3) || Hi.isUndefined(r2) || (r2.indegree++, n3.out.push(t4[e9.w]));
      }), function(e9) {
        var n3 = [];
        function t5(e11) {
          return function(n4) {
            n4.merged || (Hi.isUndefined(n4.barycenter) || Hi.isUndefined(e11.barycenter) || n4.barycenter >= e11.barycenter) && function(e12, n5) {
              var t6 = 0, r3 = 0;
              e12.weight && (t6 += e12.barycenter * e12.weight, r3 += e12.weight);
              n5.weight && (t6 += n5.barycenter * n5.weight, r3 += n5.weight);
              e12.vs = n5.vs.concat(e12.vs), e12.barycenter = t6 / r3, e12.weight = r3, e12.i = Math.min(n5.i, e12.i), n5.merged = true;
            }(e11, n4);
          };
        }
        function r2(n4) {
          return function(t6) {
            t6.in.push(n4), 0 == --t6.indegree && e9.push(t6);
          };
        }
        for (; e9.length; ) {
          var o2 = e9.pop();
          n3.push(o2), Hi.forEach(o2.in.reverse(), t5(o2)), Hi.forEach(o2.out, r2(o2));
        }
        return Hi.map(Hi.filter(n3, function(e11) {
          return !e11.merged;
        }), function(e11) {
          return Hi.pick(e11, ["vs", "i", "barycenter", "weight"]);
        });
      }(Hi.filter(t4, function(e9) {
        return !e9.indegree;
      }));
    };
    Ja = function(e8, n2) {
      var t4 = ra.partition(e8, function(e9) {
        return Hi.has(e9, "barycenter");
      }), r2 = t4.lhs, o2 = Hi.sortBy(t4.rhs, function(e9) {
        return -e9.i;
      }), i2 = [], a3 = 0, u2 = 0, c3 = 0;
      r2.sort((s2 = !!n2, function(e9, n3) {
        return e9.barycenter < n3.barycenter ? -1 : e9.barycenter > n3.barycenter ? 1 : s2 ? n3.i - e9.i : e9.i - n3.i;
      })), c3 = Xa(i2, o2, c3), Hi.forEach(r2, function(e9) {
        c3 += e9.vs.length, i2.push(e9.vs), a3 += e9.barycenter * e9.weight, u2 += e9.weight, c3 = Xa(i2, o2, c3);
      });
      var s2;
      var d2 = { vs: Hi.flatten(i2, true) };
      u2 && (d2.barycenter = a3 / u2, d2.weight = u2);
      return d2;
    };
    Ka = function e7(n2, t4, r2, o2) {
      var i2 = n2.children(t4), a3 = n2.node(t4), u2 = a3 ? a3.borderLeft : void 0, c3 = a3 ? a3.borderRight : void 0, s2 = {};
      u2 && (i2 = Hi.filter(i2, function(e8) {
        return e8 !== u2 && e8 !== c3;
      }));
      var d2 = qa(n2, i2);
      Hi.forEach(d2, function(t5) {
        if (n2.children(t5.v).length) {
          var i3 = e7(n2, t5.v, r2, o2);
          s2[t5.v] = i3, Hi.has(i3, "barycenter") && (a4 = t5, u3 = i3, Hi.isUndefined(a4.barycenter) ? (a4.barycenter = u3.barycenter, a4.weight = u3.weight) : (a4.barycenter = (a4.barycenter * a4.weight + u3.barycenter * u3.weight) / (a4.weight + u3.weight), a4.weight += u3.weight));
        }
        var a4, u3;
      });
      var f2 = Ya(d2, r2);
      !function(e8, n3) {
        Hi.forEach(e8, function(e9) {
          e9.vs = Hi.flatten(e9.vs.map(function(e11) {
            return n3[e11] ? n3[e11].vs : e11;
          }), true);
        });
      }(f2, s2);
      var h2 = Ja(f2, o2);
      if (u2 && (h2.vs = Hi.flatten([u2, h2.vs, c3], true), n2.predecessors(u2).length)) {
        var l2 = n2.node(n2.predecessors(u2)[0]), v2 = n2.node(n2.predecessors(c3)[0]);
        Hi.has(h2, "barycenter") || (h2.barycenter = 0, h2.weight = 0), h2.barycenter = (h2.barycenter * h2.weight + l2.order + v2.order) / (h2.weight + 2), h2.weight += 2;
      }
      return h2;
    };
    Qa = Fo.Graph;
    Za = function(e8, n2, t4) {
      var r2 = function(e9) {
        var n3;
        for (; e9.hasNode(n3 = Hi.uniqueId("_root")); ) ;
        return n3;
      }(e8), o2 = new Qa({ compound: true }).setGraph({ root: r2 }).setDefaultNodeLabel(function(n3) {
        return e8.node(n3);
      });
      return Hi.forEach(e8.nodes(), function(i2) {
        var a3 = e8.node(i2), u2 = e8.parent(i2);
        (a3.rank === n2 || a3.minRank <= n2 && n2 <= a3.maxRank) && (o2.setNode(i2), o2.setParent(i2, u2 || r2), Hi.forEach(e8[t4](i2), function(n3) {
          var t5 = n3.v === i2 ? n3.w : n3.v, r3 = o2.edge(t5, i2), a4 = Hi.isUndefined(r3) ? 0 : r3.weight;
          o2.setEdge(t5, i2, { weight: e8.edge(n3).weight + a4 });
        }), Hi.has(a3, "minRank") && o2.setNode(i2, { borderLeft: a3.borderLeft[n2], borderRight: a3.borderRight[n2] }));
      }), o2;
    };
    eu = function(e8, n2, t4) {
      var r2, o2 = {};
      Hi.forEach(t4, function(t5) {
        for (var i2, a3, u2 = e8.parent(t5); u2; ) {
          if ((i2 = e8.parent(u2)) ? (a3 = o2[i2], o2[i2] = u2) : (a3 = r2, r2 = u2), a3 && a3 !== u2) return void n2.setEdge(a3, u2);
          u2 = i2;
        }
      });
    };
    nu = Fo.Graph;
    tu = function(e8) {
      var n2 = ra.maxRank(e8), t4 = ru(e8, Hi.range(1, n2 + 1), "inEdges"), r2 = ru(e8, Hi.range(n2 - 1, -1, -1), "outEdges"), o2 = $a(e8);
      iu(e8, o2);
      for (var i2, a3 = Number.POSITIVE_INFINITY, u2 = 0, c3 = 0; c3 < 4; ++u2, ++c3) {
        ou(u2 % 2 ? t4 : r2, u2 % 4 >= 2), o2 = ra.buildLayerMatrix(e8);
        var s2 = Ha(e8, o2);
        s2 < a3 && (c3 = 0, i2 = Hi.cloneDeep(o2), a3 = s2);
      }
      iu(e8, i2);
    };
    au = Fo.Graph;
    uu = function(e8) {
      var n2, t4 = ra.buildLayerMatrix(e8), r2 = Hi.merge(cu(e8, t4), su(e8, t4)), o2 = {};
      Hi.forEach(["u", "d"], function(i3) {
        n2 = "u" === i3 ? t4 : Hi.values(t4).reverse(), Hi.forEach(["l", "r"], function(t5) {
          "r" === t5 && (n2 = Hi.map(n2, function(e9) {
            return Hi.values(e9).reverse();
          }));
          var a3 = ("u" === i3 ? e8.predecessors : e8.successors).bind(e8), u2 = hu(e8, n2, r2, a3), c3 = lu(e8, n2, u2.root, u2.align, "r" === t5);
          "r" === t5 && (c3 = Hi.mapValues(c3, function(e9) {
            return -e9;
          })), o2[i3 + t5] = c3;
        });
      });
      var i2 = vu(e8, o2);
      return pu(o2, i2), gu(o2, e8.graph().align);
    };
    yu = uu;
    bu = function(e8) {
      (function(e9) {
        var n2 = ra.buildLayerMatrix(e9), t4 = e9.graph().ranksep, r2 = 0;
        Hi.forEach(n2, function(n3) {
          var o2 = Hi.max(Hi.map(n3, function(n4) {
            return e9.node(n4).height;
          }));
          Hi.forEach(n3, function(n4) {
            e9.node(n4).y = r2 + o2 / 2;
          }), r2 += o2 + t4;
        });
      })(e8 = ra.asNonCompoundGraph(e8)), Hi.forEach(yu(e8), function(n2, t4) {
        e8.node(t4).x = n2;
      });
    };
    mu = ra.normalizeRanks;
    wu = ra.removeEmptyRanks;
    Eu = ra;
    _u = Fo.Graph;
    ju = function(e8, n2) {
      var t4 = n2 && n2.debugTiming ? Eu.time : Eu.notime;
      t4("layout", function() {
        var n3 = t4("  buildLayoutGraph", function() {
          return function(e9) {
            var n4 = new _u({ multigraph: true, compound: true }), t5 = Bu(e9.graph());
            return n4.setGraph(Hi.merge({}, Nu, Gu(t5, xu), Hi.pick(t5, Ou))), Hi.forEach(e9.nodes(), function(t6) {
              var r2 = Bu(e9.node(t6));
              n4.setNode(t6, Hi.defaults(Gu(r2, ku), Iu)), n4.setParent(t6, e9.parent(t6));
            }), Hi.forEach(e9.edges(), function(t6) {
              var r2 = Bu(e9.edge(t6));
              n4.setEdge(t6, Hi.merge({}, Mu, Gu(r2, Su), Hi.pick(r2, Cu)));
            }), n4;
          }(e8);
        });
        t4("  runLayout", function() {
          !function(e9, n4) {
            n4("    makeSpaceForEdgeLabels", function() {
              !function(e11) {
                var n5 = e11.graph();
                n5.ranksep /= 2, Hi.forEach(e11.edges(), function(t5) {
                  var r2 = e11.edge(t5);
                  r2.minlen *= 2, "c" !== r2.labelpos.toLowerCase() && ("TB" === n5.rankdir || "BT" === n5.rankdir ? r2.width += r2.labeloffset : r2.height += r2.labeloffset);
                });
              }(e9);
            }), n4("    removeSelfEdges", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  if (n5.v === n5.w) {
                    var t5 = e11.node(n5.v);
                    t5.selfEdges || (t5.selfEdges = []), t5.selfEdges.push({ e: n5, label: e11.edge(n5) }), e11.removeEdge(n5);
                  }
                });
              }(e9);
            }), n4("    acyclic", function() {
              na.run(e9);
            }), n4("    nestingGraph.run", function() {
              La.run(e9);
            }), n4("    rank", function() {
              Ca(Eu.asNonCompoundGraph(e9));
            }), n4("    injectEdgeLabelProxies", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5 = e11.edge(n5);
                  if (t5.width && t5.height) {
                    var r2 = e11.node(n5.v), o2 = { rank: (e11.node(n5.w).rank - r2.rank) / 2 + r2.rank, e: n5 };
                    Eu.addDummyNode(e11, "edge-proxy", o2, "_ep");
                  }
                });
              }(e9);
            }), n4("    removeEmptyRanks", function() {
              wu(e9);
            }), n4("    nestingGraph.cleanup", function() {
              La.cleanup(e9);
            }), n4("    normalizeRanks", function() {
              mu(e9);
            }), n4("    assignRankMinMax", function() {
              !function(e11) {
                var n5 = 0;
                Hi.forEach(e11.nodes(), function(t5) {
                  var r2 = e11.node(t5);
                  r2.borderTop && (r2.minRank = e11.node(r2.borderTop).rank, r2.maxRank = e11.node(r2.borderBottom).rank, n5 = Hi.max(n5, r2.maxRank));
                }), e11.graph().maxRank = n5;
              }(e9);
            }), n4("    removeEdgeLabelProxies", function() {
              !function(e11) {
                Hi.forEach(e11.nodes(), function(n5) {
                  var t5 = e11.node(n5);
                  "edge-proxy" === t5.dummy && (e11.edge(t5.e).labelRank = t5.rank, e11.removeNode(n5));
                });
              }(e9);
            }), n4("    normalize.run", function() {
              aa.run(e9);
            }), n4("    parentDummyChains", function() {
              Aa(e9);
            }), n4("    addBorderSegments", function() {
              Ta(e9);
            }), n4("    order", function() {
              tu(e9);
            }), n4("    insertSelfEdges", function() {
              !function(e11) {
                var n5 = Eu.buildLayerMatrix(e11);
                Hi.forEach(n5, function(n6) {
                  var t5 = 0;
                  Hi.forEach(n6, function(n7, r2) {
                    var o2 = e11.node(n7);
                    o2.order = r2 + t5, Hi.forEach(o2.selfEdges, function(n8) {
                      Eu.addDummyNode(e11, "selfedge", { width: n8.label.width, height: n8.label.height, rank: o2.rank, order: r2 + ++t5, e: n8.e, label: n8.label }, "_se");
                    }), delete o2.selfEdges;
                  });
                });
              }(e9);
            }), n4("    adjustCoordinateSystem", function() {
              Pa.adjust(e9);
            }), n4("    position", function() {
              bu(e9);
            }), n4("    positionSelfEdges", function() {
              !function(e11) {
                Hi.forEach(e11.nodes(), function(n5) {
                  var t5 = e11.node(n5);
                  if ("selfedge" === t5.dummy) {
                    var r2 = e11.node(t5.e.v), o2 = r2.x + r2.width / 2, i2 = r2.y, a3 = t5.x - o2, u2 = r2.height / 2;
                    e11.setEdge(t5.e, t5.label), e11.removeNode(n5), t5.label.points = [{ x: o2 + 2 * a3 / 3, y: i2 - u2 }, { x: o2 + 5 * a3 / 6, y: i2 - u2 }, { x: o2 + a3, y: i2 }, { x: o2 + 5 * a3 / 6, y: i2 + u2 }, { x: o2 + 2 * a3 / 3, y: i2 + u2 }], t5.label.x = t5.x, t5.label.y = t5.y;
                  }
                });
              }(e9);
            }), n4("    removeBorderNodes", function() {
              !function(e11) {
                Hi.forEach(e11.nodes(), function(n5) {
                  if (e11.children(n5).length) {
                    var t5 = e11.node(n5), r2 = e11.node(t5.borderTop), o2 = e11.node(t5.borderBottom), i2 = e11.node(Hi.last(t5.borderLeft)), a3 = e11.node(Hi.last(t5.borderRight));
                    t5.width = Math.abs(a3.x - i2.x), t5.height = Math.abs(o2.y - r2.y), t5.x = i2.x + t5.width / 2, t5.y = r2.y + t5.height / 2;
                  }
                }), Hi.forEach(e11.nodes(), function(n5) {
                  "border" === e11.node(n5).dummy && e11.removeNode(n5);
                });
              }(e9);
            }), n4("    normalize.undo", function() {
              aa.undo(e9);
            }), n4("    fixupEdgeLabelCoords", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5 = e11.edge(n5);
                  if (Hi.has(t5, "x")) switch ("l" !== t5.labelpos && "r" !== t5.labelpos || (t5.width -= t5.labeloffset), t5.labelpos) {
                    case "l":
                      t5.x -= t5.width / 2 + t5.labeloffset;
                      break;
                    case "r":
                      t5.x += t5.width / 2 + t5.labeloffset;
                  }
                });
              }(e9);
            }), n4("    undoCoordinateSystem", function() {
              Pa.undo(e9);
            }), n4("    translateGraph", function() {
              !function(e11) {
                var n5 = Number.POSITIVE_INFINITY, t5 = 0, r2 = Number.POSITIVE_INFINITY, o2 = 0, i2 = e11.graph(), a3 = i2.marginx || 0, u2 = i2.marginy || 0;
                function c3(e12) {
                  var i3 = e12.x, a4 = e12.y, u3 = e12.width, c4 = e12.height;
                  n5 = Math.min(n5, i3 - u3 / 2), t5 = Math.max(t5, i3 + u3 / 2), r2 = Math.min(r2, a4 - c4 / 2), o2 = Math.max(o2, a4 + c4 / 2);
                }
                Hi.forEach(e11.nodes(), function(n6) {
                  c3(e11.node(n6));
                }), Hi.forEach(e11.edges(), function(n6) {
                  var t6 = e11.edge(n6);
                  Hi.has(t6, "x") && c3(t6);
                }), n5 -= a3, r2 -= u2, Hi.forEach(e11.nodes(), function(t6) {
                  var o3 = e11.node(t6);
                  o3.x -= n5, o3.y -= r2;
                }), Hi.forEach(e11.edges(), function(t6) {
                  var o3 = e11.edge(t6);
                  Hi.forEach(o3.points, function(e12) {
                    e12.x -= n5, e12.y -= r2;
                  }), Hi.has(o3, "x") && (o3.x -= n5), Hi.has(o3, "y") && (o3.y -= r2);
                }), i2.width = t5 - n5 + a3, i2.height = o2 - r2 + u2;
              }(e9);
            }), n4("    assignNodeIntersects", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5, r2, o2 = e11.edge(n5), i2 = e11.node(n5.v), a3 = e11.node(n5.w);
                  o2.points ? (t5 = o2.points[0], r2 = o2.points[o2.points.length - 1]) : (o2.points = [], t5 = a3, r2 = i2), o2.points.unshift(Eu.intersectRect(i2, t5)), o2.points.push(Eu.intersectRect(a3, r2));
                });
              }(e9);
            }), n4("    reversePoints", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5 = e11.edge(n5);
                  t5.reversed && t5.points.reverse();
                });
              }(e9);
            }), n4("    acyclic.undo", function() {
              na.undo(e9);
            });
          }(n3, t4);
        }), t4("  updateInputGraph", function() {
          !function(e9, n4) {
            Hi.forEach(e9.nodes(), function(t5) {
              var r2 = e9.node(t5), o2 = n4.node(t5);
              r2 && (r2.x = o2.x, r2.y = o2.y, n4.children(t5).length && (r2.width = o2.width, r2.height = o2.height));
            }), Hi.forEach(e9.edges(), function(t5) {
              var r2 = e9.edge(t5), o2 = n4.edge(t5);
              r2.points = o2.points, Hi.has(o2, "x") && (r2.x = o2.x, r2.y = o2.y);
            }), e9.graph().width = n4.graph().width, e9.graph().height = n4.graph().height;
          }(e8, n3);
        });
      });
    };
    xu = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    Nu = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    Ou = ["acyclicer", "ranker", "rankdir", "align"];
    ku = ["width", "height"];
    Iu = { width: 0, height: 0 };
    Su = ["minlen", "weight", "width", "height", "labeloffset"];
    Mu = { minlen: 1, weight: 1, width: 0, height: 0, labeloffset: 10, labelpos: "r" };
    Cu = ["labelpos"];
    Au = Fo.Graph;
    Lu = { graphlib: Fo, layout: ju, debug: { debugOrdering: function(e8) {
      var n2 = ra.buildLayerMatrix(e8), t4 = new Au({ compound: true, multigraph: true }).setGraph({});
      return Hi.forEach(e8.nodes(), function(n3) {
        t4.setNode(n3, { label: n3 }), t4.setParent(n3, "layer" + e8.node(n3).rank);
      }), Hi.forEach(e8.edges(), function(e9) {
        t4.setEdge(e9.v, e9.w, {}, e9.name);
      }), Hi.forEach(n2, function(e9, n3) {
        var r2 = "layer" + n3;
        t4.setNode(r2, { rank: "same" }), Hi.reduce(e9, function(e11, n4) {
          return t4.setEdge(e11, n4, { style: "invis" }), n4;
        });
      }), t4;
    } }, util: { time: ra.time, notime: ra.notime }, version: "0.8.5" };
    Ru = Lu.graphlib;
    Tu = Lu.layout;
    Du = class {
      constructor(e8) {
        this.cardinality = 1, this.include = a2.UNSPECIFIED, this.isGroupNode = false, this.parentNode = null, this.type = i.NODE, this.name = e8.name, this.attr = e8.attr || {}, this.inputs = e8.inputs, this.path = e8.path || [], this.width = e8.width, this.height = e8.height;
      }
    };
    Pu = class {
      constructor() {
        this.nodes = {}, this.edges = [], this.nodes = {}, this.edges = [];
      }
    };
    Fu = class {
      constructor(e8, n2 = {}) {
        this.attr = null, this.bridgeGraph = null, this.cardinality = 0, this.depth = 1, this.include = a2.UNSPECIFIED, this.isGroupNode = true, this.parentNode = null, this.type = i.META, this.path = [], this.name = e8, this.metaGraph = Hu(e8, u.META, n2);
      }
      getFirstChild() {
        return this.metaGraph.node(this.metaGraph.nodes()[0]);
      }
      getChildren() {
        return this.metaGraph.nodes().map((e8) => this.metaGraph.node(e8));
      }
      leaves() {
        let e8, n2 = [], t4 = [this];
        for (; t4.length; ) {
          let r2 = t4.shift();
          r2.isGroupNode ? (e8 = r2.metaGraph, e8.nodes().forEach((n3) => t4.push(e8.node(n3)))) : n2.push(r2.name);
        }
        return n2;
      }
    };
    Uu = class {
      constructor(e8, n2) {
        this.v = e8, this.w = n2, this.baseEdgeList = [], this.inbound = null, this.name = null;
      }
      addBaseEdge(e8, n2) {
        this.baseEdgeList.push(e8);
      }
    };
    Wu = class {
      constructor(e8 = {}) {
        this.graphOptions = e8, this.index = {}, this.graphOptions.compound = true, this.root = Vu(r, this.graphOptions), this.index[r] = this.root;
      }
      getNodeMap() {
        return this.index;
      }
      node(e8) {
        return this.index[e8];
      }
      setNode(e8, n2) {
        this.index[e8] = n2;
      }
      getBridgeGraph(e8) {
        const n2 = this.index[e8];
        if (!n2) throw Error("Could not find node in hierarchy: " + e8);
        if (!("metaGraph" in n2)) return null;
        const t4 = n2;
        if (t4.bridgeGraph) return t4.bridgeGraph;
        const r2 = Hu(o, u.BRIDGE, this.graphOptions);
        if (t4.bridgeGraph = r2, !n2.parentNode || !("metaGraph" in n2.parentNode)) return r2;
        const i2 = n2.parentNode;
        return [i2.metaGraph, this.getBridgeGraph(i2.name)].forEach((n3) => {
          n3.edges().filter((n4) => n4.v === e8 || n4.w === e8).forEach((t5) => {
            const o2 = t5.w === e8;
            n3.edge(t5).baseEdgeList.forEach((n4) => {
              const [i3, a3] = o2 ? [n4.w, t5.v] : [n4.v, t5.w], u2 = this.getChildName(e8, i3), c3 = { v: o2 ? a3 : u2, w: o2 ? u2 : a3 };
              let s2 = r2.edge(c3);
              s2 || (s2 = $u(c3.v, c3.w), s2.inbound = o2, r2.setEdge(c3.v, c3.w, s2)), s2.addBaseEdge(n4, this);
            });
          });
        }), r2;
      }
      getChildName(e8, n2) {
        let t4 = this.index[n2];
        for (; t4; ) {
          if (t4.parentNode && t4.parentNode.name === e8) return t4.name;
          t4 = t4.parentNode;
        }
        throw Error("Could not find immediate child for descendant: " + n2);
      }
      getPredecessors(e8) {
        const n2 = this.index[e8];
        if (!n2) throw Error("Could not find node with name: " + e8);
        return this.getOneWayEdges(n2, true);
      }
      getSuccessors(e8) {
        const n2 = this.index[e8];
        if (!n2) throw Error("Could not find node with name: " + e8);
        return this.getOneWayEdges(n2, false);
      }
      getOneWayEdges(e8, n2) {
        const t4 = [];
        if (!e8.parentNode || !e8.parentNode.isGroupNode) return t4;
        const r2 = e8.parentNode, o2 = r2.metaGraph, i2 = this.getBridgeGraph(r2.name);
        return Yu(o2, e8, n2, t4), Yu(i2, e8, n2, t4), t4;
      }
    };
    Ju = class {
      constructor(e8) {
        this.hierarchy = e8, this.index = {}, this.hasSubHierarchy = {}, this.root = new Qu(this.hierarchy.root, this.hierarchy.graphOptions), this.index[e8.root.name] = this.root, this.buildSubHierarchy(e8.root.name), this.root.expanded = true;
      }
      getRenderInfoNodes() {
        return Object.values(this.index);
      }
      getSubHierarchy() {
        return this.hasSubHierarchy;
      }
      buildSubHierarchy(e8) {
        if (e8 in this.hasSubHierarchy) return;
        this.hasSubHierarchy[e8] = true;
        const n2 = this.index[e8];
        if (n2.node.type !== i.META) return;
        const t4 = n2, r2 = t4.node.metaGraph, o2 = t4.coreGraph;
        r2.nodes().forEach((e9) => {
          const n3 = this.getOrCreateRenderNodeByName(e9);
          o2.setNode(e9, n3);
        }), r2.edges().forEach((e9) => {
          const n3 = r2.edge(e9), t5 = new Ku(n3);
          o2.setEdge(e9.v, e9.w, t5);
        });
        const u2 = t4.node.parentNode;
        if (!u2) return;
        const c3 = this.getRenderNodeByName(u2.name), s2 = (e9, ...n3) => n3.concat([e9 ? "IN" : "OUT"]).join("~~"), d2 = this.hierarchy.getBridgeGraph(e8);
        d2.edges().forEach((n3) => {
          const t5 = d2.edge(n3), f2 = !!r2.node(n3.w), [h2, l2] = f2 ? [n3.w, n3.v] : [n3.v, n3.w], v2 = (n4) => {
            const t6 = f2 ? { v: n4, w: e8 } : { v: e8, w: n4 };
            return c3.coreGraph.edge(t6);
          };
          let p2 = v2(l2);
          p2 || (p2 = v2(s2(f2, l2, u2.name)));
          const g2 = s2(f2, e8), y4 = s2(f2, l2, e8);
          let b10 = o2.node(y4);
          if (!b10) {
            let e9 = o2.node(g2);
            if (!e9) {
              const n5 = { name: g2, type: i.BRIDGE, isGroupNode: false, cardinality: 0, parentNode: null, include: a2.UNSPECIFIED, inbound: f2, attr: {} };
              e9 = new Xu(n5), this.index[g2] = e9, o2.setNode(g2, e9);
            }
            const n4 = { name: y4, type: i.BRIDGE, isGroupNode: false, cardinality: 1, parentNode: null, include: a2.UNSPECIFIED, inbound: f2, attr: {} };
            b10 = new Xu(n4), this.index[y4] = b10, o2.setNode(y4, b10), o2.setParent(y4, g2), e9.node.cardinality++;
          }
          const m3 = new Ku(t5);
          m3.adjoiningMetaEdge = p2, f2 ? o2.setEdge(y4, h2, m3) : o2.setEdge(h2, y4, m3);
        });
      }
      getOrCreateRenderNodeByName(e8) {
        if (!e8) return null;
        if (e8 in this.index) return this.index[e8];
        const n2 = this.getNodeByName(e8);
        return n2 ? (this.index[e8] = n2.isGroupNode ? new Qu(n2, this.hierarchy.graphOptions) : new Xu(n2), this.index[e8]) : null;
      }
      getRenderNodeByName(e8) {
        return this.index[e8];
      }
      getNodeByName(e8) {
        return this.hierarchy.node(e8);
      }
    };
    Xu = class {
      constructor(e8) {
        this.node = e8, this.expanded = false, this.x = 0, this.y = 0, this.coreBox = { width: 0, height: 0 }, this.outboxWidth = 0, this.labelOffset = 0, this.radius = 0, this.labelHeight = 0, this.paddingTop = 0, this.paddingLeft = 0, this.paddingRight = 0, this.paddingBottom = 0, this.width = e8.width || 0, this.height = e8.height || 0, this.displayName = e8.name, this.attr = e8.attr;
      }
    };
    Ku = class {
      constructor(e8) {
        this.metaEdge = e8, this.adjoiningMetaEdge = null, this.weight = 1, this.points = [];
      }
    };
    Qu = class extends Xu {
      constructor(e8, n2) {
        super(e8);
        const t4 = e8.metaGraph.graph();
        n2.compound = true, this.coreGraph = Hu(t4.name, u.CORE, n2);
      }
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagreCompound.js
var require_dagreCompound = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagreCompound.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __assign18 = exports && exports.__assign || function() {
      __assign18 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign18.apply(this, arguments);
    };
    var __spreadArray6 = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
        if (ar2 || !(i2 in from)) {
          if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
          ar2[i2] = from[i2];
        }
      }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DagreCompoundLayout = void 0;
    var base_1 = require_base();
    var dagre_compound_1 = (init_dagre_compound_es5(), __toCommonJS(dagre_compound_es5_exports));
    var util_1 = require_util2();
    var DagreCompoundLayout2 = (
      /** @class */
      function(_super) {
        __extends17(DagreCompoundLayout3, _super);
        function DagreCompoundLayout3(options) {
          var _this = _super.call(this) || this;
          _this.rankdir = "TB";
          _this.nodesep = 50;
          _this.edgesep = 5;
          _this.ranksep = 50;
          _this.controlPoints = true;
          _this.anchorPoint = true;
          _this.nodes = [];
          _this.edges = [];
          _this.combos = [];
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        DagreCompoundLayout3.prototype.getDefaultCfg = function() {
          return {
            rankdir: "TB",
            align: void 0,
            begin: void 0,
            nodeSize: void 0,
            nodesep: 50,
            ranksep: 50,
            controlPoints: true,
            anchorPoint: true
            // 是否使用布局计算的锚点
          };
        };
        DagreCompoundLayout3.prototype.init = function(data) {
          var hiddenNodes = data.hiddenNodes || [];
          var hiddenEdges = data.hiddenEdges || [];
          var hiddenCombos = data.hiddenCombos || [];
          this.nodes = this.getDataByOrder((data.nodes || []).concat(hiddenNodes));
          this.edges = this.getDataByOrder((data.edges || []).concat(hiddenEdges));
          this.combos = (data.combos || []).concat(hiddenCombos.map(function(hc) {
            return __assign18(__assign18({}, hc), { collapsed: true });
          }));
        };
        DagreCompoundLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges;
          if (!nodes)
            return;
          var _a2 = self2.getLayoutConfig(), graphDef = _a2.graphDef, graphOption = _a2.graphOption, graphSettings = _a2.graphSettings;
          var renderInfo = (0, dagre_compound_1.buildGraph)(graphDef, graphOption, graphSettings);
          var flattenedRenderInfo = (0, dagre_compound_1.flatGraph)(renderInfo, true);
          this.updatePosition(flattenedRenderInfo);
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        DagreCompoundLayout3.prototype.getNodePath = function(nodeId) {
          var self2 = this;
          var nodes = self2.nodes, combos = self2.combos;
          var targetNode = nodes.find(function(n2) {
            return n2.id === nodeId;
          });
          var findPath = function(comboId, fullPath) {
            if (fullPath === void 0) {
              fullPath = [];
            }
            var combo = combos.find(function(c3) {
              return c3.id === comboId;
            });
            if (combo) {
              fullPath.unshift(comboId);
              if (combo.parentId) {
                return findPath(combo.parentId, fullPath);
              }
              return fullPath;
            }
            return fullPath;
          };
          if (targetNode && targetNode.comboId) {
            return findPath(targetNode.comboId, [nodeId]);
          }
          return [nodeId];
        };
        DagreCompoundLayout3.prototype.getLayoutConfig = function() {
          var _a2, _b, _c;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, combos = self2.combos, nodeSize = self2.nodeSize, rankdir = self2.rankdir, align = self2.align, edgesep = self2.edgesep, nodesep = self2.nodesep, ranksep = self2.ranksep, settings = self2.settings;
          var compound = (combos || []).reduce(function(pre, cur) {
            var matchedNodes = nodes.filter(function(n2) {
              return n2.comboId === cur.id;
            }).map(function(n2) {
              return n2.id;
            });
            var matchedCombos = (combos || []).filter(function(n2) {
              return n2.parentId === cur.id;
            }).map(function(n2) {
              return n2.id;
            });
            if (matchedNodes.length || matchedCombos.length) {
              pre[cur.id] = __spreadArray6(__spreadArray6([], matchedNodes, true), matchedCombos, true);
            }
            return pre;
          }, {});
          var nodeSizeFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2 && d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  return d2.size;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  return [d2.size.width || 40, d2.size.height || 40];
                }
                return [d2.size, d2.size];
              }
              return [40, 40];
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            nodeSizeFunc = function() {
              return nodeSize;
            };
          } else {
            nodeSizeFunc = function() {
              return [nodeSize, nodeSize];
            };
          }
          var comboSizeFunc = function(d2) {
            if (d2 && d2.size) {
              if ((0, util_1.isArray)(d2.size)) {
                return d2.size;
              }
              return [d2.size, d2.size];
            }
            return [80, 40];
          };
          var _d = comboSizeFunc(combos === null || combos === void 0 ? void 0 : combos[0]), metaWidth = _d[0], metaHeight = _d[1];
          var subSceneMeta = (_b = (_a2 = self2.graphSettings) === null || _a2 === void 0 ? void 0 : _a2.subScene) === null || _b === void 0 ? void 0 : _b.meta;
          var _e2 = ((_c = combos.find(function(c3) {
            return !c3.collapsed;
          })) === null || _c === void 0 ? void 0 : _c.padding) || [20, 20, 20, 20], paddingTop = _e2[0], paddingRight = _e2[1], paddingBottom = _e2[2], paddingLeft = _e2[3];
          var graphDef = {
            compound,
            nodes: __spreadArray6([], (nodes || []).map(function(n2) {
              var size3 = nodeSizeFunc(n2);
              var width = size3[0];
              var height = size3[1];
              return __assign18(__assign18({}, n2), { width, height });
            }), true),
            edges: __spreadArray6([], (edges || []).map(function(e8) {
              return __assign18(__assign18({}, e8), { v: e8.source, w: e8.target });
            }), true)
          };
          var graphOption = {
            expanded: (combos || []).filter(function(c3) {
              return !c3.collapsed;
            }).map(function(c3) {
              return c3.id;
            })
          };
          var graphMetaConfig = {
            graph: {
              meta: {
                align,
                rankDir: rankdir,
                nodeSep: nodesep,
                edgeSep: edgesep,
                rankSep: ranksep
              }
            },
            subScene: {
              meta: {
                paddingTop: paddingTop || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop) || 20,
                paddingRight: paddingRight || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight) || 20,
                paddingBottom: paddingBottom || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom) || 20,
                paddingLeft: paddingLeft || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft) || 20,
                labelHeight: 0
              }
            },
            nodeSize: {
              meta: {
                width: metaWidth,
                height: metaHeight
              }
            }
          };
          var graphSettings = (0, dagre_compound_1.mergeConfig)(settings, __assign18({}, (0, dagre_compound_1.mergeConfig)(graphMetaConfig, dagre_compound_1.LAYOUT_CONFIG)));
          self2.graphSettings = graphSettings;
          return {
            graphDef,
            graphOption,
            graphSettings
          };
        };
        DagreCompoundLayout3.prototype.updatePosition = function(flattenedGraph) {
          var nodes = flattenedGraph.nodes, edges = flattenedGraph.edges;
          this.updateNodePosition(nodes, edges);
          this.updateEdgePosition(nodes, edges);
        };
        DagreCompoundLayout3.prototype.getBegin = function(flattenedNodes, flattenedEdges) {
          var self2 = this;
          var begin = self2.begin;
          var dBegin = [0, 0];
          if (begin) {
            var minX_1 = Infinity;
            var minY_1 = Infinity;
            flattenedNodes.forEach(function(node) {
              if (minX_1 > node.x)
                minX_1 = node.x;
              if (minY_1 > node.y)
                minY_1 = node.y;
            });
            flattenedEdges.forEach(function(edge) {
              edge.points.forEach(function(point) {
                if (minX_1 > point.x)
                  minX_1 = point.x;
                if (minY_1 > point.y)
                  minY_1 = point.y;
              });
            });
            dBegin[0] = begin[0] - minX_1;
            dBegin[1] = begin[1] - minY_1;
          }
          return dBegin;
        };
        DagreCompoundLayout3.prototype.updateNodePosition = function(flattenedNodes, flattenedEdges) {
          var self2 = this;
          var combos = self2.combos, nodes = self2.nodes, edges = self2.edges, anchorPoint = self2.anchorPoint, graphSettings = self2.graphSettings;
          var dBegin = this.getBegin(flattenedNodes, flattenedEdges);
          flattenedNodes.forEach(function(node) {
            var _a2;
            var x4 = node.x, y4 = node.y, id = node.id, type = node.type, coreBox = node.coreBox;
            if (type === dagre_compound_1.HierarchyNodeType.META && id !== dagre_compound_1.ROOT_NAME) {
              var i2 = combos.findIndex(function(item) {
                return item.id === id;
              });
              var subSceneMeta = (_a2 = graphSettings === null || graphSettings === void 0 ? void 0 : graphSettings.subScene) === null || _a2 === void 0 ? void 0 : _a2.meta;
              combos[i2].offsetX = x4 + dBegin[0];
              combos[i2].offsetY = y4 + dBegin[1];
              combos[i2].fixSize = [coreBox.width, coreBox.height];
              combos[i2].fixCollapseSize = [coreBox.width, coreBox.height];
              if (!node.expanded) {
                combos[i2].padding = [0, 0, 0, 0];
              } else {
                combos[i2].padding = [
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop,
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight,
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom,
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft
                ];
              }
            } else if (type === dagre_compound_1.HierarchyNodeType.OP) {
              var i2 = nodes.findIndex(function(item) {
                return item.id === id;
              });
              nodes[i2].x = x4 + dBegin[0];
              nodes[i2].y = y4 + dBegin[1];
              if (anchorPoint) {
                var anchorPoints_1 = [];
                var outEdges = flattenedEdges.filter(function(e8) {
                  return e8.v === id;
                });
                var inEdges = flattenedEdges.filter(function(e8) {
                  return e8.w === id;
                });
                if (outEdges.length > 0) {
                  outEdges.forEach(function(outEdge) {
                    var firstPoint = outEdge.points[0];
                    var anchorPointX = (firstPoint.x - x4) / node.width + 0.5;
                    var anchorPointY = (firstPoint.y - y4) / node.height + 0.5;
                    anchorPoints_1.push([anchorPointX, anchorPointY]);
                    outEdge.baseEdgeList.forEach(function(baseEdge) {
                      var edge = edges.find(function(e8) {
                        return e8.source === baseEdge.v && e8.target === baseEdge.w;
                      });
                      if (edge) {
                        edge.sourceAnchor = anchorPoints_1.length - 1;
                      }
                    });
                  });
                }
                if (inEdges.length > 0) {
                  inEdges.forEach(function(inEdge) {
                    var lastPoint = inEdge.points[inEdge.points.length - 1];
                    var anchorPointX = (lastPoint.x - x4) / node.width + 0.5;
                    var anchorPointY = (lastPoint.y - y4) / node.height + 0.5;
                    anchorPoints_1.push([anchorPointX, anchorPointY]);
                    inEdge.baseEdgeList.forEach(function(baseEdge) {
                      var edge = edges.find(function(e8) {
                        return e8.source === baseEdge.v && e8.target === baseEdge.w;
                      });
                      if (edge) {
                        edge.targetAnchor = anchorPoints_1.length - 1;
                      }
                    });
                  });
                }
                nodes[i2].anchorPoints = anchorPoints_1.length > 0 ? anchorPoints_1 : nodes[i2].anchorPoints || [];
              }
            }
          });
        };
        DagreCompoundLayout3.prototype.updateEdgePosition = function(flattenedNodes, flattenedEdges) {
          var self2 = this;
          var combos = self2.combos, edges = self2.edges, controlPoints = self2.controlPoints;
          var dBegin = this.getBegin(flattenedNodes, flattenedEdges);
          if (controlPoints) {
            combos.forEach(function(combo) {
              combo.inEdges = [];
              combo.outEdges = [];
            });
            edges.forEach(function(sourceEdge) {
              var _a2, _b, _c, _d;
              var sourceNode = flattenedNodes.find(function(v2) {
                return v2.id === sourceEdge.source;
              });
              var targetNode = flattenedNodes.find(function(v2) {
                return v2.id === sourceEdge.target;
              });
              var points = [];
              var sortedEdges = [];
              if (sourceNode && targetNode) {
                sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes);
              } else if (!sourceNode || !targetNode) {
                var sourceNodePath = self2.getNodePath(sourceEdge.source);
                var targetNodePath = self2.getNodePath(sourceEdge.target);
                var lastExistingSource_1 = sourceNodePath.reverse().slice(!sourceNode ? 1 : 0).find(function(parentId) {
                  return flattenedNodes.find(function(fNode) {
                    return fNode.id === parentId;
                  });
                });
                var lastExistingTarget_1 = targetNodePath.reverse().slice(!targetNode ? 1 : 0).find(function(parentId) {
                  return flattenedNodes.find(function(fNode) {
                    return fNode.id === parentId;
                  });
                });
                sourceNode = flattenedNodes.find(function(v2) {
                  return v2.id === lastExistingSource_1;
                });
                targetNode = flattenedNodes.find(function(v2) {
                  return v2.id === lastExistingTarget_1;
                });
                sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes, { v: sourceEdge.source, w: sourceEdge.target });
              }
              points = sortedEdges.reduce(function(pre, cur) {
                return __spreadArray6(__spreadArray6([], pre, true), cur.points.map(function(p2) {
                  return __assign18(__assign18({}, p2), { x: p2.x + dBegin[0], y: p2.y + dBegin[1] });
                }), true);
              }, []);
              points = points.slice(1, -1);
              sourceEdge.controlPoints = points;
              if ((targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === dagre_compound_1.NodeType.META) {
                var i2 = combos.findIndex(function(item) {
                  return item.id === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.id);
                });
                if (!combos[i2] || ((_a2 = combos[i2].inEdges) === null || _a2 === void 0 ? void 0 : _a2.some(function(inEdge) {
                  return inEdge.source === sourceNode.id && inEdge.target === targetNode.id;
                }))) {
                  return;
                }
                (_b = combos[i2].inEdges) === null || _b === void 0 ? void 0 : _b.push({
                  source: sourceNode.id,
                  target: targetNode.id,
                  controlPoints: points
                });
              }
              if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === dagre_compound_1.NodeType.META) {
                var i2 = combos.findIndex(function(item) {
                  return item.id === (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id);
                });
                if (!combos[i2] || ((_c = combos[i2].outEdges) === null || _c === void 0 ? void 0 : _c.some(function(oedge) {
                  return oedge.source === sourceNode.id && oedge.target === targetNode.id;
                }))) {
                  return;
                }
                (_d = combos[i2].outEdges) === null || _d === void 0 ? void 0 : _d.push({
                  source: sourceNode.id,
                  target: targetNode.id,
                  controlPoints: points
                });
              }
            });
          }
        };
        DagreCompoundLayout3.prototype.getType = function() {
          return "dagreCompound";
        };
        DagreCompoundLayout3.prototype.getDataByOrder = function(list) {
          if (list.every(function(n2) {
            return n2.layoutOrder !== void 0;
          })) {
          } else {
            list.forEach(function(n2, i2) {
              n2.layoutOrder = i2;
            });
          }
          return list.sort(function(pre, cur) {
            return pre.layoutOrder - cur.layoutOrder;
          });
        };
        return DagreCompoundLayout3;
      }(base_1.Base)
    );
    exports.DagreCompoundLayout = DagreCompoundLayout2;
  }
});

// node_modules/is-any-array/lib-esm/index.js
function isAnyArray(value) {
  const tag = toString6.call(value);
  return tag.endsWith("Array]") && !tag.includes("Big");
}
var toString6;
var init_lib_esm = __esm({
  "node_modules/is-any-array/lib-esm/index.js"() {
    toString6 = Object.prototype.toString;
  }
});

// node_modules/ml-array-max/lib-es6/index.js
function max5(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var maxValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] > maxValue) maxValue = input[i2];
  }
  return maxValue;
}
var init_lib_es6 = __esm({
  "node_modules/ml-array-max/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-min/lib-es6/index.js
function min4(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var minValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] < minValue) minValue = input[i2];
  }
  return minValue;
}
var init_lib_es62 = __esm({
  "node_modules/ml-array-min/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-rescale/lib-es6/index.js
function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  } else if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var output;
  if (options.output !== void 0) {
    if (!isAnyArray(options.output)) {
      throw new TypeError("output option must be an array if specified");
    }
    output = options.output;
  } else {
    output = new Array(input.length);
  }
  var currentMin = min4(input);
  var currentMax = max5(input);
  if (currentMin === currentMax) {
    throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
  }
  var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
  if (minValue >= maxValue) {
    throw new RangeError("min option must be smaller than max option");
  }
  var factor = (maxValue - minValue) / (currentMax - currentMin);
  for (var i2 = 0; i2 < input.length; i2++) {
    output[i2] = (input[i2] - currentMin) * factor + minValue;
  }
  return output;
}
var init_lib_es63 = __esm({
  "node_modules/ml-array-rescale/lib-es6/index.js"() {
    init_lib_esm();
    init_lib_es6();
    init_lib_es62();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/inspect.js
function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}
function inspectMatrixWithOptions(matrix, options = {}) {
  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;
  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
}
function inspectData(matrix, maxRows, maxColumns, maxNumSize) {
  const { rows, columns } = matrix;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];
  for (let i2 = 0; i2 < maxI; i2++) {
    let line = [];
    for (let j2 = 0; j2 < maxJ; j2++) {
      line.push(formatNumber(matrix.get(i2, j2), maxNumSize));
    }
    result.push(`${line.join(" ")}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`
${indentData}`);
}
function formatNumber(num, maxNumSize) {
  const numStr = String(num);
  if (numStr.length <= maxNumSize) {
    return numStr.padEnd(maxNumSize, " ");
  }
  const precise = num.toPrecision(maxNumSize - 2);
  if (precise.length <= maxNumSize) {
    return precise;
  }
  const exponential2 = num.toExponential(maxNumSize - 2);
  const eIndex = exponential2.indexOf("e");
  const e8 = exponential2.slice(eIndex);
  return exponential2.slice(0, maxNumSize - e8.length) + e8;
}
var indent, indentData;
var init_inspect = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/inspect.js"() {
    indent = " ".repeat(2);
    indentData = " ".repeat(4);
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/mathOperations.js
function installMathOperations(AbstractMatrix2, Matrix2) {
  AbstractMatrix2.prototype.add = function add11(value) {
    if (typeof value === "number") return this.addS(value);
    return this.addM(value);
  };
  AbstractMatrix2.prototype.addS = function addS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) + value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.addM = function addM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) + matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.add = function add11(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.add(value);
  };
  AbstractMatrix2.prototype.sub = function sub8(value) {
    if (typeof value === "number") return this.subS(value);
    return this.subM(value);
  };
  AbstractMatrix2.prototype.subS = function subS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) - value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.subM = function subM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) - matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.sub = function sub8(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sub(value);
  };
  AbstractMatrix2.prototype.subtract = AbstractMatrix2.prototype.sub;
  AbstractMatrix2.prototype.subtractS = AbstractMatrix2.prototype.subS;
  AbstractMatrix2.prototype.subtractM = AbstractMatrix2.prototype.subM;
  AbstractMatrix2.subtract = AbstractMatrix2.sub;
  AbstractMatrix2.prototype.mul = function mul10(value) {
    if (typeof value === "number") return this.mulS(value);
    return this.mulM(value);
  };
  AbstractMatrix2.prototype.mulS = function mulS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) * value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.mulM = function mulM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) * matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.mul = function mul10(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.mul(value);
  };
  AbstractMatrix2.prototype.multiply = AbstractMatrix2.prototype.mul;
  AbstractMatrix2.prototype.multiplyS = AbstractMatrix2.prototype.mulS;
  AbstractMatrix2.prototype.multiplyM = AbstractMatrix2.prototype.mulM;
  AbstractMatrix2.multiply = AbstractMatrix2.mul;
  AbstractMatrix2.prototype.div = function div4(value) {
    if (typeof value === "number") return this.divS(value);
    return this.divM(value);
  };
  AbstractMatrix2.prototype.divS = function divS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) / value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.divM = function divM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) / matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.div = function div4(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.div(value);
  };
  AbstractMatrix2.prototype.divide = AbstractMatrix2.prototype.div;
  AbstractMatrix2.prototype.divideS = AbstractMatrix2.prototype.divS;
  AbstractMatrix2.prototype.divideM = AbstractMatrix2.prototype.divM;
  AbstractMatrix2.divide = AbstractMatrix2.div;
  AbstractMatrix2.prototype.mod = function mod4(value) {
    if (typeof value === "number") return this.modS(value);
    return this.modM(value);
  };
  AbstractMatrix2.prototype.modS = function modS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) % value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.modM = function modM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) % matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.mod = function mod4(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.mod(value);
  };
  AbstractMatrix2.prototype.modulus = AbstractMatrix2.prototype.mod;
  AbstractMatrix2.prototype.modulusS = AbstractMatrix2.prototype.modS;
  AbstractMatrix2.prototype.modulusM = AbstractMatrix2.prototype.modM;
  AbstractMatrix2.modulus = AbstractMatrix2.mod;
  AbstractMatrix2.prototype.and = function and(value) {
    if (typeof value === "number") return this.andS(value);
    return this.andM(value);
  };
  AbstractMatrix2.prototype.andS = function andS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) & value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.andM = function andM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) & matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.and = function and(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.and(value);
  };
  AbstractMatrix2.prototype.or = function or2(value) {
    if (typeof value === "number") return this.orS(value);
    return this.orM(value);
  };
  AbstractMatrix2.prototype.orS = function orS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) | value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.orM = function orM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) | matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.or = function or2(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.or(value);
  };
  AbstractMatrix2.prototype.xor = function xor(value) {
    if (typeof value === "number") return this.xorS(value);
    return this.xorM(value);
  };
  AbstractMatrix2.prototype.xorS = function xorS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) ^ value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.xorM = function xorM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) ^ matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.xor = function xor(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.xor(value);
  };
  AbstractMatrix2.prototype.leftShift = function leftShift(value) {
    if (typeof value === "number") return this.leftShiftS(value);
    return this.leftShiftM(value);
  };
  AbstractMatrix2.prototype.leftShiftS = function leftShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) << value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.leftShiftM = function leftShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) << matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.leftShift = function leftShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.leftShift(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === "number") return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >> matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.signPropagatingRightShift(value);
  };
  AbstractMatrix2.prototype.rightShift = function rightShift(value) {
    if (typeof value === "number") return this.rightShiftS(value);
    return this.rightShiftM(value);
  };
  AbstractMatrix2.prototype.rightShiftS = function rightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >>> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.rightShiftM = function rightShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >>> matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.rightShift = function rightShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix2.prototype.zeroFillRightShift = AbstractMatrix2.prototype.rightShift;
  AbstractMatrix2.prototype.zeroFillRightShiftS = AbstractMatrix2.prototype.rightShiftS;
  AbstractMatrix2.prototype.zeroFillRightShiftM = AbstractMatrix2.prototype.rightShiftM;
  AbstractMatrix2.zeroFillRightShift = AbstractMatrix2.rightShift;
  AbstractMatrix2.prototype.not = function not() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, ~this.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.not = function not(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.not();
  };
  AbstractMatrix2.prototype.abs = function abs3() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.abs(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.abs = function abs3(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.abs();
  };
  AbstractMatrix2.prototype.acos = function acos() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.acos(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.acos = function acos(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.acos();
  };
  AbstractMatrix2.prototype.acosh = function acosh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.acosh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.acosh = function acosh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.acosh();
  };
  AbstractMatrix2.prototype.asin = function asin() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.asin(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.asin = function asin(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.asin();
  };
  AbstractMatrix2.prototype.asinh = function asinh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.asinh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.asinh = function asinh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.asinh();
  };
  AbstractMatrix2.prototype.atan = function atan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.atan(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.atan = function atan(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.atan();
  };
  AbstractMatrix2.prototype.atanh = function atanh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.atanh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.atanh = function atanh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.atanh();
  };
  AbstractMatrix2.prototype.cbrt = function cbrt() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cbrt(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cbrt = function cbrt(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cbrt();
  };
  AbstractMatrix2.prototype.ceil = function ceil4() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.ceil(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.ceil = function ceil4(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.ceil();
  };
  AbstractMatrix2.prototype.clz32 = function clz32() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.clz32(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.clz32 = function clz32(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.clz32();
  };
  AbstractMatrix2.prototype.cos = function cos3() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cos(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cos = function cos3(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cos();
  };
  AbstractMatrix2.prototype.cosh = function cosh2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cosh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cosh = function cosh2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cosh();
  };
  AbstractMatrix2.prototype.exp = function exp2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.exp(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.exp = function exp2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.exp();
  };
  AbstractMatrix2.prototype.expm1 = function expm1() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.expm1(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.expm1 = function expm1(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.expm1();
  };
  AbstractMatrix2.prototype.floor = function floor4() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.floor(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.floor = function floor4(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.floor();
  };
  AbstractMatrix2.prototype.fround = function fround() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.fround(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.fround = function fround(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.fround();
  };
  AbstractMatrix2.prototype.log = function log2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log = function log2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log();
  };
  AbstractMatrix2.prototype.log1p = function log1p() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log1p(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log1p = function log1p(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log1p();
  };
  AbstractMatrix2.prototype.log10 = function log10() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log10(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log10 = function log10(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log10();
  };
  AbstractMatrix2.prototype.log2 = function log2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log2(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log2 = function log2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log2();
  };
  AbstractMatrix2.prototype.round = function round6() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.round(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.round = function round6(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.round();
  };
  AbstractMatrix2.prototype.sign = function sign() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sign(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sign = function sign(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sign();
  };
  AbstractMatrix2.prototype.sin = function sin3() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sin(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sin = function sin3(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sin();
  };
  AbstractMatrix2.prototype.sinh = function sinh2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sinh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sinh = function sinh2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sinh();
  };
  AbstractMatrix2.prototype.sqrt = function sqrt() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sqrt(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sqrt = function sqrt(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sqrt();
  };
  AbstractMatrix2.prototype.tan = function tan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.tan(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.tan = function tan(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.tan();
  };
  AbstractMatrix2.prototype.tanh = function tanh2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.tanh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.tanh = function tanh2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.tanh();
  };
  AbstractMatrix2.prototype.trunc = function trunc() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.trunc(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.trunc = function trunc(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.trunc();
  };
  AbstractMatrix2.pow = function pow2(matrix, arg0) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.pow(arg0);
  };
  AbstractMatrix2.prototype.pow = function pow2(value) {
    if (typeof value === "number") return this.powS(value);
    return this.powM(value);
  };
  AbstractMatrix2.prototype.powS = function powS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.pow(this.get(i2, j2), value));
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.powM = function powM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.pow(this.get(i2, j2), matrix.get(i2, j2)));
      }
    }
    return this;
  };
}
var init_mathOperations = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/mathOperations.js"() {
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/util.js
function checkRowIndex(matrix, index2, outer) {
  let max8 = outer ? matrix.rows : matrix.rows - 1;
  if (index2 < 0 || index2 > max8) {
    throw new RangeError("Row index out of range");
  }
}
function checkColumnIndex(matrix, index2, outer) {
  let max8 = outer ? matrix.columns : matrix.columns - 1;
  if (index2 < 0 || index2 > max8) {
    throw new RangeError("Column index out of range");
  }
}
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      "vector size must be the same as the number of columns"
    );
  }
  return vector;
}
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError("vector size must be the same as the number of rows");
  }
  return vector;
}
function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices)
  };
}
function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== "object") {
    throw new TypeError("unexpected type for row indices");
  }
  let rowOut = rowIndices.some((r2) => {
    return r2 < 0 || r2 >= matrix.rows;
  });
  if (rowOut) {
    throw new RangeError("row indices are out of range");
  }
  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);
  return rowIndices;
}
function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== "object") {
    throw new TypeError("unexpected type for column indices");
  }
  let columnOut = columnIndices.some((c3) => {
    return c3 < 0 || c3 >= matrix.columns;
  });
  if (columnOut) {
    throw new RangeError("column indices are out of range");
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);
  return columnIndices;
}
function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError("expected 4 arguments");
  }
  checkNumber("startRow", startRow);
  checkNumber("endRow", endRow);
  checkNumber("startColumn", startColumn);
  checkNumber("endColumn", endColumn);
  if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {
    throw new RangeError("Submatrix indices are out of range");
  }
}
function newArray(length6, value = 0) {
  let array = [];
  for (let i2 = 0; i2 < length6; i2++) {
    array.push(value);
  }
  return array;
}
function checkNumber(name, value) {
  if (typeof value !== "number") {
    throw new TypeError(`${name} must be a number`);
  }
}
var init_util2 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/util.js"() {
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/stat.js
function sumByRow(matrix) {
  let sum = newArray(matrix.rows);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[i2] += matrix.get(i2, j2);
    }
  }
  return sum;
}
function sumByColumn(matrix) {
  let sum = newArray(matrix.columns);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[j2] += matrix.get(i2, j2);
    }
  }
  return sum;
}
function sumAll(matrix) {
  let v2 = 0;
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      v2 += matrix.get(i2, j2);
    }
  }
  return v2;
}
function productByRow(matrix) {
  let sum = newArray(matrix.rows, 1);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[i2] *= matrix.get(i2, j2);
    }
  }
  return sum;
}
function productByColumn(matrix) {
  let sum = newArray(matrix.columns, 1);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[j2] *= matrix.get(i2, j2);
    }
  }
  return sum;
}
function productAll(matrix) {
  let v2 = 1;
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      v2 *= matrix.get(i2, j2);
    }
  }
  return v2;
}
function varianceByRow(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];
  for (let i2 = 0; i2 < rows; i2++) {
    let sum1 = 0;
    let sum2 = 0;
    let x4 = 0;
    for (let j2 = 0; j2 < cols; j2++) {
      x4 = matrix.get(i2, j2) - mean[i2];
      sum1 += x4;
      sum2 += x4 * x4;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / cols) / cols);
    }
  }
  return variance;
}
function varianceByColumn(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];
  for (let j2 = 0; j2 < cols; j2++) {
    let sum1 = 0;
    let sum2 = 0;
    let x4 = 0;
    for (let i2 = 0; i2 < rows; i2++) {
      x4 = matrix.get(i2, j2) - mean[j2];
      sum1 += x4;
      sum2 += x4 * x4;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / rows) / rows);
    }
  }
  return variance;
}
function varianceAll(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const size3 = rows * cols;
  let sum1 = 0;
  let sum2 = 0;
  let x4 = 0;
  for (let i2 = 0; i2 < rows; i2++) {
    for (let j2 = 0; j2 < cols; j2++) {
      x4 = matrix.get(i2, j2) - mean;
      sum1 += x4;
      sum2 += x4 * x4;
    }
  }
  if (unbiased) {
    return (sum2 - sum1 * sum1 / size3) / (size3 - 1);
  } else {
    return (sum2 - sum1 * sum1 / size3) / size3;
  }
}
function centerByRow(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean[i2]);
    }
  }
}
function centerByColumn(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean[j2]);
    }
  }
}
function centerAll(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean);
    }
  }
}
function getScaleByRow(matrix) {
  const scale12 = [];
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    let sum = 0;
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / (matrix.columns - 1);
    }
    scale12.push(Math.sqrt(sum));
  }
  return scale12;
}
function scaleByRow(matrix, scale12) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale12[i2]);
    }
  }
}
function getScaleByColumn(matrix) {
  const scale12 = [];
  for (let j2 = 0; j2 < matrix.columns; j2++) {
    let sum = 0;
    for (let i2 = 0; i2 < matrix.rows; i2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / (matrix.rows - 1);
    }
    scale12.push(Math.sqrt(sum));
  }
  return scale12;
}
function scaleByColumn(matrix, scale12) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale12[j2]);
    }
  }
}
function getScaleAll(matrix) {
  const divider = matrix.size - 1;
  let sum = 0;
  for (let j2 = 0; j2 < matrix.columns; j2++) {
    for (let i2 = 0; i2 < matrix.rows; i2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / divider;
    }
  }
  return Math.sqrt(sum);
}
function scaleAll(matrix, scale12) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale12);
    }
  }
}
var init_stat = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/stat.js"() {
    init_util2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/matrix.js
function compareNumbers(a3, b10) {
  return a3 - b10;
}
var AbstractMatrix, Matrix;
var init_matrix2 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/matrix.js"() {
    init_lib_es63();
    init_inspect();
    init_mathOperations();
    init_stat();
    init_util2();
    AbstractMatrix = class _AbstractMatrix {
      static from1DArray(newRows, newColumns, newData) {
        let length6 = newRows * newColumns;
        if (length6 !== newData.length) {
          throw new RangeError("data length does not match given dimensions");
        }
        let newMatrix = new Matrix(newRows, newColumns);
        for (let row = 0; row < newRows; row++) {
          for (let column = 0; column < newColumns; column++) {
            newMatrix.set(row, column, newData[row * newColumns + column]);
          }
        }
        return newMatrix;
      }
      static rowVector(newData) {
        let vector = new Matrix(1, newData.length);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(0, i2, newData[i2]);
        }
        return vector;
      }
      static columnVector(newData) {
        let vector = new Matrix(newData.length, 1);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(i2, 0, newData[i2]);
        }
        return vector;
      }
      static zeros(rows, columns) {
        return new Matrix(rows, columns);
      }
      static ones(rows, columns) {
        return new Matrix(rows, columns).fill(1);
      }
      static rand(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { random: random5 = Math.random } = options;
        let matrix = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix.set(i2, j2, random5());
          }
        }
        return matrix;
      }
      static randInt(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min6 = 0, max: max8 = 1e3, random: random5 = Math.random } = options;
        if (!Number.isInteger(min6)) throw new TypeError("min must be an integer");
        if (!Number.isInteger(max8)) throw new TypeError("max must be an integer");
        if (min6 >= max8) throw new RangeError("min must be smaller than max");
        let interval2 = max8 - min6;
        let matrix = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            let value = min6 + Math.round(random5() * interval2);
            matrix.set(i2, j2, value);
          }
        }
        return matrix;
      }
      static eye(rows, columns, value) {
        if (columns === void 0) columns = rows;
        if (value === void 0) value = 1;
        let min6 = Math.min(rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min6; i2++) {
          matrix.set(i2, i2, value);
        }
        return matrix;
      }
      static diag(data, rows, columns) {
        let l2 = data.length;
        if (rows === void 0) rows = l2;
        if (columns === void 0) columns = rows;
        let min6 = Math.min(l2, rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min6; i2++) {
          matrix.set(i2, i2, data[i2]);
        }
        return matrix;
      }
      static min(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.min(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static max(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new this(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.max(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static checkMatrix(value) {
        return _AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
      }
      static isMatrix(value) {
        return value != null && value.klass === "Matrix";
      }
      get size() {
        return this.rows * this.columns;
      }
      apply(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            callback.call(this, i2, j2);
          }
        }
        return this;
      }
      to1DArray() {
        let array = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            array.push(this.get(i2, j2));
          }
        }
        return array;
      }
      to2DArray() {
        let copy10 = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          copy10.push([]);
          for (let j2 = 0; j2 < this.columns; j2++) {
            copy10[i2].push(this.get(i2, j2));
          }
        }
        return copy10;
      }
      toJSON() {
        return this.to2DArray();
      }
      isRowVector() {
        return this.rows === 1;
      }
      isColumnVector() {
        return this.columns === 1;
      }
      isVector() {
        return this.rows === 1 || this.columns === 1;
      }
      isSquare() {
        return this.rows === this.columns;
      }
      isSymmetric() {
        if (this.isSquare()) {
          for (let i2 = 0; i2 < this.rows; i2++) {
            for (let j2 = 0; j2 <= i2; j2++) {
              if (this.get(i2, j2) !== this.get(j2, i2)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      isEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isEchelonForm = false;
              checked = true;
            }
          }
          i2++;
        }
        return isEchelonForm;
      }
      isReducedEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isReducedEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isReducedEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isReducedEchelonForm = false;
              checked = true;
            }
          }
          for (let k2 = j2 + 1; k2 < this.rows; k2++) {
            if (this.get(i2, k2) !== 0) {
              isReducedEchelonForm = false;
            }
          }
          i2++;
        }
        return isReducedEchelonForm;
      }
      echelonForm() {
        let result = this.clone();
        let h2 = 0;
        let k2 = 0;
        while (h2 < result.rows && k2 < result.columns) {
          let iMax = h2;
          for (let i2 = h2; i2 < result.rows; i2++) {
            if (result.get(i2, k2) > result.get(iMax, k2)) {
              iMax = i2;
            }
          }
          if (result.get(iMax, k2) === 0) {
            k2++;
          } else {
            result.swapRows(h2, iMax);
            let tmp = result.get(h2, k2);
            for (let j2 = k2; j2 < result.columns; j2++) {
              result.set(h2, j2, result.get(h2, j2) / tmp);
            }
            for (let i2 = h2 + 1; i2 < result.rows; i2++) {
              let factor = result.get(i2, k2) / result.get(h2, k2);
              result.set(i2, k2, 0);
              for (let j2 = k2 + 1; j2 < result.columns; j2++) {
                result.set(i2, j2, result.get(i2, j2) - result.get(h2, j2) * factor);
              }
            }
            h2++;
            k2++;
          }
        }
        return result;
      }
      reducedEchelonForm() {
        let result = this.echelonForm();
        let m3 = result.columns;
        let n2 = result.rows;
        let h2 = n2 - 1;
        while (h2 >= 0) {
          if (result.maxRow(h2) === 0) {
            h2--;
          } else {
            let p2 = 0;
            let pivot = false;
            while (p2 < n2 && pivot === false) {
              if (result.get(h2, p2) === 1) {
                pivot = true;
              } else {
                p2++;
              }
            }
            for (let i2 = 0; i2 < h2; i2++) {
              let factor = result.get(i2, p2);
              for (let j2 = p2; j2 < m3; j2++) {
                let tmp = result.get(i2, j2) - factor * result.get(h2, j2);
                result.set(i2, j2, tmp);
              }
            }
            h2--;
          }
        }
        return result;
      }
      set() {
        throw new Error("set method is unimplemented");
      }
      get() {
        throw new Error("get method is unimplemented");
      }
      repeat(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { rows = 1, columns = 1 } = options;
        if (!Number.isInteger(rows) || rows <= 0) {
          throw new TypeError("rows must be a positive integer");
        }
        if (!Number.isInteger(columns) || columns <= 0) {
          throw new TypeError("columns must be a positive integer");
        }
        let matrix = new Matrix(this.rows * rows, this.columns * columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix.setSubMatrix(this, this.rows * i2, this.columns * j2);
          }
        }
        return matrix;
      }
      fill(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, value);
          }
        }
        return this;
      }
      neg() {
        return this.mulS(-1);
      }
      getRow(index2) {
        checkRowIndex(this, index2);
        let row = [];
        for (let i2 = 0; i2 < this.columns; i2++) {
          row.push(this.get(index2, i2));
        }
        return row;
      }
      getRowVector(index2) {
        return Matrix.rowVector(this.getRow(index2));
      }
      setRow(index2, array) {
        checkRowIndex(this, index2);
        array = checkRowVector(this, array);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index2, i2, array[i2]);
        }
        return this;
      }
      swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        for (let i2 = 0; i2 < this.columns; i2++) {
          let temp = this.get(row1, i2);
          this.set(row1, i2, this.get(row2, i2));
          this.set(row2, i2, temp);
        }
        return this;
      }
      getColumn(index2) {
        checkColumnIndex(this, index2);
        let column = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          column.push(this.get(i2, index2));
        }
        return column;
      }
      getColumnVector(index2) {
        return Matrix.columnVector(this.getColumn(index2));
      }
      setColumn(index2, array) {
        checkColumnIndex(this, index2);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index2, array[i2]);
        }
        return this;
      }
      swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          let temp = this.get(i2, column1);
          this.set(i2, column1, this.get(i2, column2));
          this.set(i2, column2, temp);
        }
        return this;
      }
      addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[j2]);
          }
        }
        return this;
      }
      subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[j2]);
          }
        }
        return this;
      }
      mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[j2]);
          }
        }
        return this;
      }
      divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[j2]);
          }
        }
        return this;
      }
      addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[i2]);
          }
        }
        return this;
      }
      subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[i2]);
          }
        }
        return this;
      }
      mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[i2]);
          }
        }
        return this;
      }
      divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[i2]);
          }
        }
        return this;
      }
      mulRow(index2, value) {
        checkRowIndex(this, index2);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index2, i2, this.get(index2, i2) * value);
        }
        return this;
      }
      mulColumn(index2, value) {
        checkColumnIndex(this, index2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index2, this.get(i2, index2) * value);
        }
        return this;
      }
      max() {
        let v2 = this.get(0, 0);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) > v2) {
              v2 = this.get(i2, j2);
            }
          }
        }
        return v2;
      }
      maxIndex() {
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) > v2) {
              v2 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      min() {
        let v2 = this.get(0, 0);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) < v2) {
              v2 = this.get(i2, j2);
            }
          }
        }
        return v2;
      }
      minIndex() {
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) < v2) {
              v2 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      maxRow(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v2) {
            v2 = this.get(row, i2);
          }
        }
        return v2;
      }
      maxRowIndex(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v2) {
            v2 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      minRow(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v2) {
            v2 = this.get(row, i2);
          }
        }
        return v2;
      }
      minRowIndex(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v2) {
            v2 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      maxColumn(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v2) {
            v2 = this.get(i2, column);
          }
        }
        return v2;
      }
      maxColumnIndex(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v2) {
            v2 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      minColumn(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v2) {
            v2 = this.get(i2, column);
          }
        }
        return v2;
      }
      minColumnIndex(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v2) {
            v2 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      diag() {
        let min6 = Math.min(this.rows, this.columns);
        let diag = [];
        for (let i2 = 0; i2 < min6; i2++) {
          diag.push(this.get(i2, i2));
        }
        return diag;
      }
      norm(type = "frobenius") {
        let result = 0;
        if (type === "max") {
          return this.max();
        } else if (type === "frobenius") {
          for (let i2 = 0; i2 < this.rows; i2++) {
            for (let j2 = 0; j2 < this.columns; j2++) {
              result = result + this.get(i2, j2) * this.get(i2, j2);
            }
          }
          return Math.sqrt(result);
        } else {
          throw new RangeError(`unknown norm type: ${type}`);
        }
      }
      cumulativeSum() {
        let sum = 0;
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            sum += this.get(i2, j2);
            this.set(i2, j2, sum);
          }
        }
        return this;
      }
      dot(vector2) {
        if (_AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
        let vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
          throw new RangeError("vectors do not have the same size");
        }
        let dot6 = 0;
        for (let i2 = 0; i2 < vector1.length; i2++) {
          dot6 += vector1[i2] * vector2[i2];
        }
        return dot6;
      }
      mmul(other) {
        other = Matrix.checkMatrix(other);
        let m3 = this.rows;
        let n2 = this.columns;
        let p2 = other.columns;
        let result = new Matrix(m3, p2);
        let Bcolj = new Float64Array(n2);
        for (let j2 = 0; j2 < p2; j2++) {
          for (let k2 = 0; k2 < n2; k2++) {
            Bcolj[k2] = other.get(k2, j2);
          }
          for (let i2 = 0; i2 < m3; i2++) {
            let s2 = 0;
            for (let k2 = 0; k2 < n2; k2++) {
              s2 += this.get(i2, k2) * Bcolj[k2];
            }
            result.set(i2, j2, s2);
          }
        }
        return result;
      }
      strassen2x2(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(2, 2);
        const a11 = this.get(0, 0);
        const b11 = other.get(0, 0);
        const a12 = this.get(0, 1);
        const b12 = other.get(0, 1);
        const a21 = this.get(1, 0);
        const b21 = other.get(1, 0);
        const a22 = this.get(1, 1);
        const b22 = other.get(1, 1);
        const m1 = (a11 + a22) * (b11 + b22);
        const m22 = (a21 + a22) * b11;
        const m3 = a11 * (b12 - b22);
        const m4 = a22 * (b21 - b11);
        const m5 = (a11 + a12) * b22;
        const m6 = (a21 - a11) * (b11 + b12);
        const m7 = (a12 - a22) * (b21 + b22);
        const c00 = m1 + m4 - m5 + m7;
        const c01 = m3 + m5;
        const c10 = m22 + m4;
        const c11 = m1 - m22 + m3 + m6;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        return result;
      }
      strassen3x3(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(3, 3);
        const a00 = this.get(0, 0);
        const a01 = this.get(0, 1);
        const a02 = this.get(0, 2);
        const a10 = this.get(1, 0);
        const a11 = this.get(1, 1);
        const a12 = this.get(1, 2);
        const a20 = this.get(2, 0);
        const a21 = this.get(2, 1);
        const a22 = this.get(2, 2);
        const b00 = other.get(0, 0);
        const b01 = other.get(0, 1);
        const b02 = other.get(0, 2);
        const b10 = other.get(1, 0);
        const b11 = other.get(1, 1);
        const b12 = other.get(1, 2);
        const b20 = other.get(2, 0);
        const b21 = other.get(2, 1);
        const b22 = other.get(2, 2);
        const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
        const m22 = (a00 - a10) * (-b01 + b11);
        const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
        const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
        const m5 = (a10 + a11) * (-b00 + b01);
        const m6 = a00 * b00;
        const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
        const m8 = (-a00 + a20) * (b02 - b12);
        const m9 = (a20 + a21) * (-b00 + b02);
        const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
        const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
        const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
        const m13 = (a02 - a22) * (b11 - b21);
        const m14 = a02 * b20;
        const m15 = (a21 + a22) * (-b20 + b21);
        const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
        const m17 = (a02 - a12) * (b12 - b22);
        const m18 = (a11 + a12) * (-b20 + b22);
        const m19 = a01 * b10;
        const m20 = a12 * b21;
        const m21 = a10 * b02;
        const m222 = a20 * b01;
        const m23 = a22 * b22;
        const c00 = m6 + m14 + m19;
        const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
        const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
        const c10 = m22 + m3 + m4 + m6 + m14 + m16 + m17;
        const c11 = m22 + m4 + m5 + m6 + m20;
        const c12 = m14 + m16 + m17 + m18 + m21;
        const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
        const c21 = m12 + m13 + m14 + m15 + m222;
        const c22 = m6 + m7 + m8 + m9 + m23;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(0, 2, c02);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        result.set(1, 2, c12);
        result.set(2, 0, c20);
        result.set(2, 1, c21);
        result.set(2, 2, c22);
        return result;
      }
      mmulStrassen(y4) {
        y4 = Matrix.checkMatrix(y4);
        let x4 = this.clone();
        let r1 = x4.rows;
        let c1 = x4.columns;
        let r2 = y4.rows;
        let c22 = y4.columns;
        if (c1 !== r2) {
          console.warn(
            `Multiplying ${r1} x ${c1} and ${r2} x ${c22} matrix: dimensions do not match.`
          );
        }
        function embed(mat, rows, cols) {
          let r4 = mat.rows;
          let c4 = mat.columns;
          if (r4 === rows && c4 === cols) {
            return mat;
          } else {
            let resultat = _AbstractMatrix.zeros(rows, cols);
            resultat = resultat.setSubMatrix(mat, 0, 0);
            return resultat;
          }
        }
        let r3 = Math.max(r1, r2);
        let c3 = Math.max(c1, c22);
        x4 = embed(x4, r3, c3);
        y4 = embed(y4, r3, c3);
        function blockMult(a3, b10, rows, cols) {
          if (rows <= 512 || cols <= 512) {
            return a3.mmul(b10);
          }
          if (rows % 2 === 1 && cols % 2 === 1) {
            a3 = embed(a3, rows + 1, cols + 1);
            b10 = embed(b10, rows + 1, cols + 1);
          } else if (rows % 2 === 1) {
            a3 = embed(a3, rows + 1, cols);
            b10 = embed(b10, rows + 1, cols);
          } else if (cols % 2 === 1) {
            a3 = embed(a3, rows, cols + 1);
            b10 = embed(b10, rows, cols + 1);
          }
          let halfRows = parseInt(a3.rows / 2, 10);
          let halfCols = parseInt(a3.columns / 2, 10);
          let a11 = a3.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let b11 = b10.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let a12 = a3.subMatrix(0, halfRows - 1, halfCols, a3.columns - 1);
          let b12 = b10.subMatrix(0, halfRows - 1, halfCols, b10.columns - 1);
          let a21 = a3.subMatrix(halfRows, a3.rows - 1, 0, halfCols - 1);
          let b21 = b10.subMatrix(halfRows, b10.rows - 1, 0, halfCols - 1);
          let a22 = a3.subMatrix(halfRows, a3.rows - 1, halfCols, a3.columns - 1);
          let b22 = b10.subMatrix(halfRows, b10.rows - 1, halfCols, b10.columns - 1);
          let m1 = blockMult(
            _AbstractMatrix.add(a11, a22),
            _AbstractMatrix.add(b11, b22),
            halfRows,
            halfCols
          );
          let m22 = blockMult(_AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
          let m3 = blockMult(a11, _AbstractMatrix.sub(b12, b22), halfRows, halfCols);
          let m4 = blockMult(a22, _AbstractMatrix.sub(b21, b11), halfRows, halfCols);
          let m5 = blockMult(_AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
          let m6 = blockMult(
            _AbstractMatrix.sub(a21, a11),
            _AbstractMatrix.add(b11, b12),
            halfRows,
            halfCols
          );
          let m7 = blockMult(
            _AbstractMatrix.sub(a12, a22),
            _AbstractMatrix.add(b21, b22),
            halfRows,
            halfCols
          );
          let c11 = _AbstractMatrix.add(m1, m4);
          c11.sub(m5);
          c11.add(m7);
          let c12 = _AbstractMatrix.add(m3, m5);
          let c21 = _AbstractMatrix.add(m22, m4);
          let c222 = _AbstractMatrix.sub(m1, m22);
          c222.add(m3);
          c222.add(m6);
          let resultat = _AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
          resultat = resultat.setSubMatrix(c11, 0, 0);
          resultat = resultat.setSubMatrix(c12, c11.rows, 0);
          resultat = resultat.setSubMatrix(c21, 0, c11.columns);
          resultat = resultat.setSubMatrix(c222, c11.rows, c11.columns);
          return resultat.subMatrix(0, rows - 1, 0, cols - 1);
        }
        return blockMult(x4, y4, r3, c3);
      }
      scaleRows(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min6 = 0, max: max8 = 1 } = options;
        if (!Number.isFinite(min6)) throw new TypeError("min must be a number");
        if (!Number.isFinite(max8)) throw new TypeError("max must be a number");
        if (min6 >= max8) throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const row = this.getRow(i2);
          rescale(row, { min: min6, max: max8, output: row });
          newMatrix.setRow(i2, row);
        }
        return newMatrix;
      }
      scaleColumns(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min6 = 0, max: max8 = 1 } = options;
        if (!Number.isFinite(min6)) throw new TypeError("min must be a number");
        if (!Number.isFinite(max8)) throw new TypeError("max must be a number");
        if (min6 >= max8) throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i2 = 0; i2 < this.columns; i2++) {
          const column = this.getColumn(i2);
          rescale(column, {
            min: min6,
            max: max8,
            output: column
          });
          newMatrix.setColumn(i2, column);
        }
        return newMatrix;
      }
      flipRows() {
        const middle = Math.ceil(this.columns / 2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < middle; j2++) {
            let first = this.get(i2, j2);
            let last3 = this.get(i2, this.columns - 1 - j2);
            this.set(i2, j2, last3);
            this.set(i2, this.columns - 1 - j2, first);
          }
        }
        return this;
      }
      flipColumns() {
        const middle = Math.ceil(this.rows / 2);
        for (let j2 = 0; j2 < this.columns; j2++) {
          for (let i2 = 0; i2 < middle; i2++) {
            let first = this.get(i2, j2);
            let last3 = this.get(this.rows - 1 - i2, j2);
            this.set(i2, j2, last3);
            this.set(this.rows - 1 - i2, j2, first);
          }
        }
        return this;
      }
      kroneckerProduct(other) {
        other = Matrix.checkMatrix(other);
        let m3 = this.rows;
        let n2 = this.columns;
        let p2 = other.rows;
        let q2 = other.columns;
        let result = new Matrix(m3 * p2, n2 * q2);
        for (let i2 = 0; i2 < m3; i2++) {
          for (let j2 = 0; j2 < n2; j2++) {
            for (let k2 = 0; k2 < p2; k2++) {
              for (let l2 = 0; l2 < q2; l2++) {
                result.set(p2 * i2 + k2, q2 * j2 + l2, this.get(i2, j2) * other.get(k2, l2));
              }
            }
          }
        }
        return result;
      }
      transpose() {
        let result = new Matrix(this.columns, this.rows);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            result.set(j2, i2, this.get(i2, j2));
          }
        }
        return result;
      }
      sortRows(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.setRow(i2, this.getRow(i2).sort(compareFunction));
        }
        return this;
      }
      sortColumns(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.setColumn(i2, this.getColumn(i2).sort(compareFunction));
        }
        return this;
      }
      subMatrix(startRow, endRow, startColumn, endColumn) {
        checkRange(this, startRow, endRow, startColumn, endColumn);
        let newMatrix = new Matrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1
        );
        for (let i2 = startRow; i2 <= endRow; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            newMatrix.set(i2 - startRow, j2 - startColumn, this.get(i2, j2));
          }
        }
        return newMatrix;
      }
      subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === void 0) startColumn = 0;
        if (endColumn === void 0) endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.rows) {
              throw new RangeError(`Row index out of range: ${indices[i2]}`);
            }
            newMatrix.set(i2, j2 - startColumn, this.get(indices[i2], j2));
          }
        }
        return newMatrix;
      }
      subMatrixColumn(indices, startRow, endRow) {
        if (startRow === void 0) startRow = 0;
        if (endRow === void 0) endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startRow; j2 <= endRow; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.columns) {
              throw new RangeError(`Column index out of range: ${indices[i2]}`);
            }
            newMatrix.set(j2 - startRow, i2, this.get(j2, indices[i2]));
          }
        }
        return newMatrix;
      }
      setSubMatrix(matrix, startRow, startColumn) {
        matrix = Matrix.checkMatrix(matrix);
        let endRow = startRow + matrix.rows - 1;
        let endColumn = startColumn + matrix.columns - 1;
        checkRange(this, startRow, endRow, startColumn, endColumn);
        for (let i2 = 0; i2 < matrix.rows; i2++) {
          for (let j2 = 0; j2 < matrix.columns; j2++) {
            this.set(startRow + i2, startColumn + j2, matrix.get(i2, j2));
          }
        }
        return this;
      }
      selection(rowIndices, columnIndices) {
        let indices = checkIndices(this, rowIndices, columnIndices);
        let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
        for (let i2 = 0; i2 < indices.row.length; i2++) {
          let rowIndex = indices.row[i2];
          for (let j2 = 0; j2 < indices.column.length; j2++) {
            let columnIndex = indices.column[j2];
            newMatrix.set(i2, j2, this.get(rowIndex, columnIndex));
          }
        }
        return newMatrix;
      }
      trace() {
        let min6 = Math.min(this.rows, this.columns);
        let trace = 0;
        for (let i2 = 0; i2 < min6; i2++) {
          trace += this.get(i2, i2);
        }
        return trace;
      }
      clone() {
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            newMatrix.set(row, column, this.get(row, column));
          }
        }
        return newMatrix;
      }
      sum(by) {
        switch (by) {
          case "row":
            return sumByRow(this);
          case "column":
            return sumByColumn(this);
          case void 0:
            return sumAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      product(by) {
        switch (by) {
          case "row":
            return productByRow(this);
          case "column":
            return productByColumn(this);
          case void 0:
            return productAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      mean(by) {
        const sum = this.sum(by);
        switch (by) {
          case "row": {
            for (let i2 = 0; i2 < this.rows; i2++) {
              sum[i2] /= this.columns;
            }
            return sum;
          }
          case "column": {
            for (let i2 = 0; i2 < this.columns; i2++) {
              sum[i2] /= this.rows;
            }
            return sum;
          }
          case void 0:
            return sum / this.size;
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      variance(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { unbiased = true, mean = this.mean(by) } = options;
        if (typeof unbiased !== "boolean") {
          throw new TypeError("unbiased must be a boolean");
        }
        switch (by) {
          case "row": {
            if (!Array.isArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByRow(this, unbiased, mean);
          }
          case "column": {
            if (!Array.isArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByColumn(this, unbiased, mean);
          }
          case void 0: {
            if (typeof mean !== "number") {
              throw new TypeError("mean must be a number");
            }
            return varianceAll(this, unbiased, mean);
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      standardDeviation(by, options) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        const variance = this.variance(by, options);
        if (by === void 0) {
          return Math.sqrt(variance);
        } else {
          for (let i2 = 0; i2 < variance.length; i2++) {
            variance[i2] = Math.sqrt(variance[i2]);
          }
          return variance;
        }
      }
      center(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { center = this.mean(by) } = options;
        switch (by) {
          case "row": {
            if (!Array.isArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByRow(this, center);
            return this;
          }
          case "column": {
            if (!Array.isArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByColumn(this, center);
            return this;
          }
          case void 0: {
            if (typeof center !== "number") {
              throw new TypeError("center must be a number");
            }
            centerAll(this, center);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      scale(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        let scale12 = options.scale;
        switch (by) {
          case "row": {
            if (scale12 === void 0) {
              scale12 = getScaleByRow(this);
            } else if (!Array.isArray(scale12)) {
              throw new TypeError("scale must be an array");
            }
            scaleByRow(this, scale12);
            return this;
          }
          case "column": {
            if (scale12 === void 0) {
              scale12 = getScaleByColumn(this);
            } else if (!Array.isArray(scale12)) {
              throw new TypeError("scale must be an array");
            }
            scaleByColumn(this, scale12);
            return this;
          }
          case void 0: {
            if (scale12 === void 0) {
              scale12 = getScaleAll(this);
            } else if (typeof scale12 !== "number") {
              throw new TypeError("scale must be a number");
            }
            scaleAll(this, scale12);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      toString(options) {
        return inspectMatrixWithOptions(this, options);
      }
    };
    AbstractMatrix.prototype.klass = "Matrix";
    if (typeof Symbol !== "undefined") {
      AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
    }
    AbstractMatrix.random = AbstractMatrix.rand;
    AbstractMatrix.randomInt = AbstractMatrix.randInt;
    AbstractMatrix.diagonal = AbstractMatrix.diag;
    AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
    AbstractMatrix.identity = AbstractMatrix.eye;
    AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
    AbstractMatrix.prototype.tensorProduct = AbstractMatrix.prototype.kroneckerProduct;
    Matrix = class _Matrix extends AbstractMatrix {
      constructor(nRows, nColumns) {
        super();
        if (_Matrix.isMatrix(nRows)) {
          return nRows.clone();
        } else if (Number.isInteger(nRows) && nRows > 0) {
          this.data = [];
          if (Number.isInteger(nColumns) && nColumns > 0) {
            for (let i2 = 0; i2 < nRows; i2++) {
              this.data.push(new Float64Array(nColumns));
            }
          } else {
            throw new TypeError("nColumns must be a positive integer");
          }
        } else if (Array.isArray(nRows)) {
          const arrayData = nRows;
          nRows = arrayData.length;
          nColumns = arrayData[0].length;
          if (typeof nColumns !== "number" || nColumns === 0) {
            throw new TypeError(
              "Data must be a 2D array with at least one element"
            );
          }
          this.data = [];
          for (let i2 = 0; i2 < nRows; i2++) {
            if (arrayData[i2].length !== nColumns) {
              throw new RangeError("Inconsistent array dimensions");
            }
            this.data.push(Float64Array.from(arrayData[i2]));
          }
        } else {
          throw new TypeError(
            "First argument must be a positive number or an array"
          );
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
      removeRow(index2) {
        checkRowIndex(this, index2);
        if (this.rows === 1) {
          throw new RangeError("A matrix cannot have less than one row");
        }
        this.data.splice(index2, 1);
        this.rows -= 1;
        return this;
      }
      addRow(index2, array) {
        if (array === void 0) {
          array = index2;
          index2 = this.rows;
        }
        checkRowIndex(this, index2, true);
        array = Float64Array.from(checkRowVector(this, array, true));
        this.data.splice(index2, 0, array);
        this.rows += 1;
        return this;
      }
      removeColumn(index2) {
        checkColumnIndex(this, index2);
        if (this.columns === 1) {
          throw new RangeError("A matrix cannot have less than one column");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns - 1);
          for (let j2 = 0; j2 < index2; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          for (let j2 = index2 + 1; j2 < this.columns; j2++) {
            newRow[j2 - 1] = this.data[i2][j2];
          }
          this.data[i2] = newRow;
        }
        this.columns -= 1;
        return this;
      }
      addColumn(index2, array) {
        if (typeof array === "undefined") {
          array = index2;
          index2 = this.columns;
        }
        checkColumnIndex(this, index2, true);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns + 1);
          let j2 = 0;
          for (; j2 < index2; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          newRow[j2++] = array[i2];
          for (; j2 < this.columns + 1; j2++) {
            newRow[j2] = this.data[i2][j2 - 1];
          }
          this.data[i2] = newRow;
        }
        this.columns += 1;
        return this;
      }
    };
    installMathOperations(AbstractMatrix, Matrix);
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/base.js
var BaseView;
var init_base = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/base.js"() {
    init_matrix2();
    BaseView = class extends AbstractMatrix {
      constructor(matrix, rows, columns) {
        super();
        this.matrix = matrix;
        this.rows = rows;
        this.columns = columns;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/column.js
var MatrixColumnView;
var init_column = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/column.js"() {
    init_util2();
    init_base();
    MatrixColumnView = class extends BaseView {
      constructor(matrix, column) {
        checkColumnIndex(matrix, column);
        super(matrix, matrix.rows, 1);
        this.column = column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }
      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/columnSelection.js
var MatrixColumnSelectionView;
var init_columnSelection = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/columnSelection.js"() {
    init_util2();
    init_base();
    MatrixColumnSelectionView = class extends BaseView {
      constructor(matrix, columnIndices) {
        columnIndices = checkColumnIndices(matrix, columnIndices);
        super(matrix, matrix.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipColumn.js
var MatrixFlipColumnView;
var init_flipColumn = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipColumn.js"() {
    init_base();
    MatrixFlipColumnView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipRow.js
var MatrixFlipRowView;
var init_flipRow = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipRow.js"() {
    init_base();
    MatrixFlipRowView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/row.js
var MatrixRowView;
var init_row = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/row.js"() {
    init_util2();
    init_base();
    MatrixRowView = class extends BaseView {
      constructor(matrix, row) {
        checkRowIndex(matrix, row);
        super(matrix, 1, matrix.columns);
        this.row = row;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/rowSelection.js
var MatrixRowSelectionView;
var init_rowSelection = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/rowSelection.js"() {
    init_util2();
    init_base();
    MatrixRowSelectionView = class extends BaseView {
      constructor(matrix, rowIndices) {
        rowIndices = checkRowIndices(matrix, rowIndices);
        super(matrix, rowIndices.length, matrix.columns);
        this.rowIndices = rowIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/selection.js
var MatrixSelectionView;
var init_selection = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/selection.js"() {
    init_util2();
    init_base();
    MatrixSelectionView = class extends BaseView {
      constructor(matrix, rowIndices, columnIndices) {
        let indices = checkIndices(matrix, rowIndices, columnIndices);
        super(matrix, indices.row.length, indices.column.length);
        this.rowIndices = indices.row;
        this.columnIndices = indices.column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/sub.js
var MatrixSubView;
var init_sub = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/sub.js"() {
    init_util2();
    init_base();
    MatrixSubView = class extends BaseView {
      constructor(matrix, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix, startRow, endRow, startColumn, endColumn);
        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/transpose.js
var MatrixTransposeView;
var init_transpose = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/transpose.js"() {
    init_base();
    MatrixTransposeView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.columns, matrix.rows);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/index.js
var init_views = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/index.js"() {
    init_column();
    init_columnSelection();
    init_flipColumn();
    init_flipRow();
    init_row();
    init_rowSelection();
    init_selection();
    init_sub();
    init_transpose();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js
var WrapperMatrix1D;
var init_WrapperMatrix1D = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js"() {
    init_matrix2();
    WrapperMatrix1D = class extends AbstractMatrix {
      constructor(data, options = {}) {
        const { rows = 1 } = options;
        if (data.length % rows !== 0) {
          throw new Error("the data length is not divisible by the number of rows");
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }
      set(rowIndex, columnIndex, value) {
        let index2 = this._calculateIndex(rowIndex, columnIndex);
        this.data[index2] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        let index2 = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index2];
      }
      _calculateIndex(row, column) {
        return row * this.columns + column;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js
var WrapperMatrix2D;
var init_WrapperMatrix2D = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js"() {
    init_matrix2();
    WrapperMatrix2D = class extends AbstractMatrix {
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/wrap.js
function wrap(array, options) {
  if (Array.isArray(array)) {
    if (array[0] && Array.isArray(array[0])) {
      return new WrapperMatrix2D(array);
    } else {
      return new WrapperMatrix1D(array, options);
    }
  } else {
    throw new Error("the argument is not an array");
  }
}
var init_wrap = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/wrap.js"() {
    init_WrapperMatrix1D();
    init_WrapperMatrix2D();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/lu.js
var LuDecomposition;
var init_lu = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/lu.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    LuDecomposition = class {
      constructor(matrix) {
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        let lu2 = matrix.clone();
        let rows = lu2.rows;
        let columns = lu2.columns;
        let pivotVector = new Float64Array(rows);
        let pivotSign = 1;
        let i2, j2, k2, p2, s2, t4, v2;
        let LUcolj, kmax;
        for (i2 = 0; i2 < rows; i2++) {
          pivotVector[i2] = i2;
        }
        LUcolj = new Float64Array(rows);
        for (j2 = 0; j2 < columns; j2++) {
          for (i2 = 0; i2 < rows; i2++) {
            LUcolj[i2] = lu2.get(i2, j2);
          }
          for (i2 = 0; i2 < rows; i2++) {
            kmax = Math.min(i2, j2);
            s2 = 0;
            for (k2 = 0; k2 < kmax; k2++) {
              s2 += lu2.get(i2, k2) * LUcolj[k2];
            }
            LUcolj[i2] -= s2;
            lu2.set(i2, j2, LUcolj[i2]);
          }
          p2 = j2;
          for (i2 = j2 + 1; i2 < rows; i2++) {
            if (Math.abs(LUcolj[i2]) > Math.abs(LUcolj[p2])) {
              p2 = i2;
            }
          }
          if (p2 !== j2) {
            for (k2 = 0; k2 < columns; k2++) {
              t4 = lu2.get(p2, k2);
              lu2.set(p2, k2, lu2.get(j2, k2));
              lu2.set(j2, k2, t4);
            }
            v2 = pivotVector[p2];
            pivotVector[p2] = pivotVector[j2];
            pivotVector[j2] = v2;
            pivotSign = -pivotSign;
          }
          if (j2 < rows && lu2.get(j2, j2) !== 0) {
            for (i2 = j2 + 1; i2 < rows; i2++) {
              lu2.set(i2, j2, lu2.get(i2, j2) / lu2.get(j2, j2));
            }
          }
        }
        this.LU = lu2;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }
      isSingular() {
        let data = this.LU;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          if (data.get(j2, j2) === 0) {
            return true;
          }
        }
        return false;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let lu2 = this.LU;
        let rows = lu2.rows;
        if (rows !== value.rows) {
          throw new Error("Invalid matrix dimensions");
        }
        if (this.isSingular()) {
          throw new Error("LU matrix is singular");
        }
        let count = value.columns;
        let X2 = value.subMatrixRow(this.pivotVector, 0, count - 1);
        let columns = lu2.columns;
        let i2, j2, k2;
        for (k2 = 0; k2 < columns; k2++) {
          for (i2 = k2 + 1; i2 < columns; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu2.get(i2, k2));
            }
          }
        }
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / lu2.get(k2, k2));
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu2.get(i2, k2));
            }
          }
        }
        return X2;
      }
      get determinant() {
        let data = this.LU;
        if (!data.isSquare()) {
          throw new Error("Matrix must be square");
        }
        let determinant6 = this.pivotSign;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          determinant6 *= data.get(j2, j2);
        }
        return determinant6;
      }
      get lowerTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 > j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, 1);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get upperTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 <= j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get pivotPermutationVector() {
        return Array.from(this.pivotVector);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/util.js
function hypotenuse(a3, b10) {
  let r2 = 0;
  if (Math.abs(a3) > Math.abs(b10)) {
    r2 = b10 / a3;
    return Math.abs(a3) * Math.sqrt(1 + r2 * r2);
  }
  if (b10 !== 0) {
    r2 = a3 / b10;
    return Math.abs(b10) * Math.sqrt(1 + r2 * r2);
  }
  return 0;
}
var init_util3 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/util.js"() {
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/qr.js
var QrDecomposition;
var init_qr = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/qr.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    init_util3();
    QrDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let qr2 = value.clone();
        let m3 = value.rows;
        let n2 = value.columns;
        let rdiag = new Float64Array(n2);
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          let nrm = 0;
          for (i2 = k2; i2 < m3; i2++) {
            nrm = hypotenuse(nrm, qr2.get(i2, k2));
          }
          if (nrm !== 0) {
            if (qr2.get(k2, k2) < 0) {
              nrm = -nrm;
            }
            for (i2 = k2; i2 < m3; i2++) {
              qr2.set(i2, k2, qr2.get(i2, k2) / nrm);
            }
            qr2.set(k2, k2, qr2.get(k2, k2) + 1);
            for (j2 = k2 + 1; j2 < n2; j2++) {
              s2 = 0;
              for (i2 = k2; i2 < m3; i2++) {
                s2 += qr2.get(i2, k2) * qr2.get(i2, j2);
              }
              s2 = -s2 / qr2.get(k2, k2);
              for (i2 = k2; i2 < m3; i2++) {
                qr2.set(i2, j2, qr2.get(i2, j2) + s2 * qr2.get(i2, k2));
              }
            }
          }
          rdiag[k2] = -nrm;
        }
        this.QR = qr2;
        this.Rdiag = rdiag;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let qr2 = this.QR;
        let m3 = qr2.rows;
        if (value.rows !== m3) {
          throw new Error("Matrix row dimensions must agree");
        }
        if (!this.isFullRank()) {
          throw new Error("Matrix is rank deficient");
        }
        let count = value.columns;
        let X2 = value.clone();
        let n2 = qr2.columns;
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            s2 = 0;
            for (i2 = k2; i2 < m3; i2++) {
              s2 += qr2.get(i2, k2) * X2.get(i2, j2);
            }
            s2 = -s2 / qr2.get(k2, k2);
            for (i2 = k2; i2 < m3; i2++) {
              X2.set(i2, j2, X2.get(i2, j2) + s2 * qr2.get(i2, k2));
            }
          }
        }
        for (k2 = n2 - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / this.Rdiag[k2]);
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * qr2.get(i2, k2));
            }
          }
        }
        return X2.subMatrix(0, n2 - 1, 0, count - 1);
      }
      isFullRank() {
        let columns = this.QR.columns;
        for (let i2 = 0; i2 < columns; i2++) {
          if (this.Rdiag[i2] === 0) {
            return false;
          }
        }
        return true;
      }
      get upperTriangularMatrix() {
        let qr2 = this.QR;
        let n2 = qr2.columns;
        let X2 = new Matrix(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            if (i2 < j2) {
              X2.set(i2, j2, qr2.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, this.Rdiag[i2]);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get orthogonalMatrix() {
        let qr2 = this.QR;
        let rows = qr2.rows;
        let columns = qr2.columns;
        let X2 = new Matrix(rows, columns);
        let i2, j2, k2, s2;
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (i2 = 0; i2 < rows; i2++) {
            X2.set(i2, k2, 0);
          }
          X2.set(k2, k2, 1);
          for (j2 = k2; j2 < columns; j2++) {
            if (qr2.get(k2, k2) !== 0) {
              s2 = 0;
              for (i2 = k2; i2 < rows; i2++) {
                s2 += qr2.get(i2, k2) * X2.get(i2, j2);
              }
              s2 = -s2 / qr2.get(k2, k2);
              for (i2 = k2; i2 < rows; i2++) {
                X2.set(i2, j2, X2.get(i2, j2) + s2 * qr2.get(i2, k2));
              }
            }
          }
        }
        return X2;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/svd.js
var SingularValueDecomposition;
var init_svd = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/svd.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    init_util3();
    SingularValueDecomposition = class {
      constructor(value, options = {}) {
        value = WrapperMatrix2D.checkMatrix(value);
        let m3 = value.rows;
        let n2 = value.columns;
        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;
        let wantu = Boolean(computeLeftSingularVectors);
        let wantv = Boolean(computeRightSingularVectors);
        let swapped = false;
        let a3;
        if (m3 < n2) {
          if (!autoTranspose) {
            a3 = value.clone();
            console.warn(
              "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
            );
          } else {
            a3 = value.transpose();
            m3 = a3.rows;
            n2 = a3.columns;
            swapped = true;
            let aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a3 = value.clone();
        }
        let nu2 = Math.min(m3, n2);
        let ni2 = Math.min(m3 + 1, n2);
        let s2 = new Float64Array(ni2);
        let U2 = new Matrix(m3, nu2);
        let V2 = new Matrix(n2, n2);
        let e8 = new Float64Array(n2);
        let work = new Float64Array(m3);
        let si2 = new Float64Array(ni2);
        for (let i2 = 0; i2 < ni2; i2++) si2[i2] = i2;
        let nct = Math.min(m3 - 1, n2);
        let nrt = Math.max(0, Math.min(n2 - 2, m3));
        let mrc = Math.max(nct, nrt);
        for (let k2 = 0; k2 < mrc; k2++) {
          if (k2 < nct) {
            s2[k2] = 0;
            for (let i2 = k2; i2 < m3; i2++) {
              s2[k2] = hypotenuse(s2[k2], a3.get(i2, k2));
            }
            if (s2[k2] !== 0) {
              if (a3.get(k2, k2) < 0) {
                s2[k2] = -s2[k2];
              }
              for (let i2 = k2; i2 < m3; i2++) {
                a3.set(i2, k2, a3.get(i2, k2) / s2[k2]);
              }
              a3.set(k2, k2, a3.get(k2, k2) + 1);
            }
            s2[k2] = -s2[k2];
          }
          for (let j2 = k2 + 1; j2 < n2; j2++) {
            if (k2 < nct && s2[k2] !== 0) {
              let t4 = 0;
              for (let i2 = k2; i2 < m3; i2++) {
                t4 += a3.get(i2, k2) * a3.get(i2, j2);
              }
              t4 = -t4 / a3.get(k2, k2);
              for (let i2 = k2; i2 < m3; i2++) {
                a3.set(i2, j2, a3.get(i2, j2) + t4 * a3.get(i2, k2));
              }
            }
            e8[j2] = a3.get(k2, j2);
          }
          if (wantu && k2 < nct) {
            for (let i2 = k2; i2 < m3; i2++) {
              U2.set(i2, k2, a3.get(i2, k2));
            }
          }
          if (k2 < nrt) {
            e8[k2] = 0;
            for (let i2 = k2 + 1; i2 < n2; i2++) {
              e8[k2] = hypotenuse(e8[k2], e8[i2]);
            }
            if (e8[k2] !== 0) {
              if (e8[k2 + 1] < 0) {
                e8[k2] = 0 - e8[k2];
              }
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                e8[i2] /= e8[k2];
              }
              e8[k2 + 1] += 1;
            }
            e8[k2] = -e8[k2];
            if (k2 + 1 < m3 && e8[k2] !== 0) {
              for (let i2 = k2 + 1; i2 < m3; i2++) {
                work[i2] = 0;
              }
              for (let i2 = k2 + 1; i2 < m3; i2++) {
                for (let j2 = k2 + 1; j2 < n2; j2++) {
                  work[i2] += e8[j2] * a3.get(i2, j2);
                }
              }
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t4 = -e8[j2] / e8[k2 + 1];
                for (let i2 = k2 + 1; i2 < m3; i2++) {
                  a3.set(i2, j2, a3.get(i2, j2) + t4 * work[i2]);
                }
              }
            }
            if (wantv) {
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                V2.set(i2, k2, e8[i2]);
              }
            }
          }
        }
        let p2 = Math.min(n2, m3 + 1);
        if (nct < n2) {
          s2[nct] = a3.get(nct, nct);
        }
        if (m3 < p2) {
          s2[p2 - 1] = 0;
        }
        if (nrt + 1 < p2) {
          e8[nrt] = a3.get(nrt, p2 - 1);
        }
        e8[p2 - 1] = 0;
        if (wantu) {
          for (let j2 = nct; j2 < nu2; j2++) {
            for (let i2 = 0; i2 < m3; i2++) {
              U2.set(i2, j2, 0);
            }
            U2.set(j2, j2, 1);
          }
          for (let k2 = nct - 1; k2 >= 0; k2--) {
            if (s2[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < nu2; j2++) {
                let t4 = 0;
                for (let i2 = k2; i2 < m3; i2++) {
                  t4 += U2.get(i2, k2) * U2.get(i2, j2);
                }
                t4 = -t4 / U2.get(k2, k2);
                for (let i2 = k2; i2 < m3; i2++) {
                  U2.set(i2, j2, U2.get(i2, j2) + t4 * U2.get(i2, k2));
                }
              }
              for (let i2 = k2; i2 < m3; i2++) {
                U2.set(i2, k2, -U2.get(i2, k2));
              }
              U2.set(k2, k2, 1 + U2.get(k2, k2));
              for (let i2 = 0; i2 < k2 - 1; i2++) {
                U2.set(i2, k2, 0);
              }
            } else {
              for (let i2 = 0; i2 < m3; i2++) {
                U2.set(i2, k2, 0);
              }
              U2.set(k2, k2, 1);
            }
          }
        }
        if (wantv) {
          for (let k2 = n2 - 1; k2 >= 0; k2--) {
            if (k2 < nrt && e8[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t4 = 0;
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  t4 += V2.get(i2, k2) * V2.get(i2, j2);
                }
                t4 = -t4 / V2.get(k2 + 1, k2);
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  V2.set(i2, j2, V2.get(i2, j2) + t4 * V2.get(i2, k2));
                }
              }
            }
            for (let i2 = 0; i2 < n2; i2++) {
              V2.set(i2, k2, 0);
            }
            V2.set(k2, k2, 1);
          }
        }
        let pp = p2 - 1;
        let iter = 0;
        let eps2 = Number.EPSILON;
        while (p2 > 0) {
          let k2, kase;
          for (k2 = p2 - 2; k2 >= -1; k2--) {
            if (k2 === -1) {
              break;
            }
            const alpha = Number.MIN_VALUE + eps2 * Math.abs(s2[k2] + Math.abs(s2[k2 + 1]));
            if (Math.abs(e8[k2]) <= alpha || Number.isNaN(e8[k2])) {
              e8[k2] = 0;
              break;
            }
          }
          if (k2 === p2 - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p2 - 1; ks >= k2; ks--) {
              if (ks === k2) {
                break;
              }
              let t4 = (ks !== p2 ? Math.abs(e8[ks]) : 0) + (ks !== k2 + 1 ? Math.abs(e8[ks - 1]) : 0);
              if (Math.abs(s2[ks]) <= eps2 * t4) {
                s2[ks] = 0;
                break;
              }
            }
            if (ks === k2) {
              kase = 3;
            } else if (ks === p2 - 1) {
              kase = 1;
            } else {
              kase = 2;
              k2 = ks;
            }
          }
          k2++;
          switch (kase) {
            case 1: {
              let f2 = e8[p2 - 2];
              e8[p2 - 2] = 0;
              for (let j2 = p2 - 2; j2 >= k2; j2--) {
                let t4 = hypotenuse(s2[j2], f2);
                let cs = s2[j2] / t4;
                let sn2 = f2 / t4;
                s2[j2] = t4;
                if (j2 !== k2) {
                  f2 = -sn2 * e8[j2 - 1];
                  e8[j2 - 1] = cs * e8[j2 - 1];
                }
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t4 = cs * V2.get(i2, j2) + sn2 * V2.get(i2, p2 - 1);
                    V2.set(i2, p2 - 1, -sn2 * V2.get(i2, j2) + cs * V2.get(i2, p2 - 1));
                    V2.set(i2, j2, t4);
                  }
                }
              }
              break;
            }
            case 2: {
              let f2 = e8[k2 - 1];
              e8[k2 - 1] = 0;
              for (let j2 = k2; j2 < p2; j2++) {
                let t4 = hypotenuse(s2[j2], f2);
                let cs = s2[j2] / t4;
                let sn2 = f2 / t4;
                s2[j2] = t4;
                f2 = -sn2 * e8[j2];
                e8[j2] = cs * e8[j2];
                if (wantu) {
                  for (let i2 = 0; i2 < m3; i2++) {
                    t4 = cs * U2.get(i2, j2) + sn2 * U2.get(i2, k2 - 1);
                    U2.set(i2, k2 - 1, -sn2 * U2.get(i2, j2) + cs * U2.get(i2, k2 - 1));
                    U2.set(i2, j2, t4);
                  }
                }
              }
              break;
            }
            case 3: {
              const scale12 = Math.max(
                Math.abs(s2[p2 - 1]),
                Math.abs(s2[p2 - 2]),
                Math.abs(e8[p2 - 2]),
                Math.abs(s2[k2]),
                Math.abs(e8[k2])
              );
              const sp = s2[p2 - 1] / scale12;
              const spm1 = s2[p2 - 2] / scale12;
              const epm1 = e8[p2 - 2] / scale12;
              const sk = s2[k2] / scale12;
              const ek = e8[k2] / scale12;
              const b10 = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c3 = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b10 !== 0 || c3 !== 0) {
                if (b10 < 0) {
                  shift = 0 - Math.sqrt(b10 * b10 + c3);
                } else {
                  shift = Math.sqrt(b10 * b10 + c3);
                }
                shift = c3 / (b10 + shift);
              }
              let f2 = (sk + sp) * (sk - sp) + shift;
              let g2 = sk * ek;
              for (let j2 = k2; j2 < p2 - 1; j2++) {
                let t4 = hypotenuse(f2, g2);
                if (t4 === 0) t4 = Number.MIN_VALUE;
                let cs = f2 / t4;
                let sn2 = g2 / t4;
                if (j2 !== k2) {
                  e8[j2 - 1] = t4;
                }
                f2 = cs * s2[j2] + sn2 * e8[j2];
                e8[j2] = cs * e8[j2] - sn2 * s2[j2];
                g2 = sn2 * s2[j2 + 1];
                s2[j2 + 1] = cs * s2[j2 + 1];
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t4 = cs * V2.get(i2, j2) + sn2 * V2.get(i2, j2 + 1);
                    V2.set(i2, j2 + 1, -sn2 * V2.get(i2, j2) + cs * V2.get(i2, j2 + 1));
                    V2.set(i2, j2, t4);
                  }
                }
                t4 = hypotenuse(f2, g2);
                if (t4 === 0) t4 = Number.MIN_VALUE;
                cs = f2 / t4;
                sn2 = g2 / t4;
                s2[j2] = t4;
                f2 = cs * e8[j2] + sn2 * s2[j2 + 1];
                s2[j2 + 1] = -sn2 * e8[j2] + cs * s2[j2 + 1];
                g2 = sn2 * e8[j2 + 1];
                e8[j2 + 1] = cs * e8[j2 + 1];
                if (wantu && j2 < m3 - 1) {
                  for (let i2 = 0; i2 < m3; i2++) {
                    t4 = cs * U2.get(i2, j2) + sn2 * U2.get(i2, j2 + 1);
                    U2.set(i2, j2 + 1, -sn2 * U2.get(i2, j2) + cs * U2.get(i2, j2 + 1));
                    U2.set(i2, j2, t4);
                  }
                }
              }
              e8[p2 - 2] = f2;
              iter = iter + 1;
              break;
            }
            case 4: {
              if (s2[k2] <= 0) {
                s2[k2] = s2[k2] < 0 ? -s2[k2] : 0;
                if (wantv) {
                  for (let i2 = 0; i2 <= pp; i2++) {
                    V2.set(i2, k2, -V2.get(i2, k2));
                  }
                }
              }
              while (k2 < pp) {
                if (s2[k2] >= s2[k2 + 1]) {
                  break;
                }
                let t4 = s2[k2];
                s2[k2] = s2[k2 + 1];
                s2[k2 + 1] = t4;
                if (wantv && k2 < n2 - 1) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t4 = V2.get(i2, k2 + 1);
                    V2.set(i2, k2 + 1, V2.get(i2, k2));
                    V2.set(i2, k2, t4);
                  }
                }
                if (wantu && k2 < m3 - 1) {
                  for (let i2 = 0; i2 < m3; i2++) {
                    t4 = U2.get(i2, k2 + 1);
                    U2.set(i2, k2 + 1, U2.get(i2, k2));
                    U2.set(i2, k2, t4);
                  }
                }
                k2++;
              }
              iter = 0;
              p2--;
              break;
            }
          }
        }
        if (swapped) {
          let tmp = V2;
          V2 = U2;
          U2 = tmp;
        }
        this.m = m3;
        this.n = n2;
        this.s = s2;
        this.U = U2;
        this.V = V2;
      }
      solve(value) {
        let Y2 = value;
        let e8 = this.threshold;
        let scols = this.s.length;
        let Ls = Matrix.zeros(scols, scols);
        for (let i2 = 0; i2 < scols; i2++) {
          if (Math.abs(this.s[i2]) <= e8) {
            Ls.set(i2, i2, 0);
          } else {
            Ls.set(i2, i2, 1 / this.s[i2]);
          }
        }
        let U2 = this.U;
        let V2 = this.rightSingularVectors;
        let VL = V2.mmul(Ls);
        let vrows = V2.rows;
        let urows = U2.rows;
        let VLU = Matrix.zeros(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < scols; k2++) {
              sum += VL.get(i2, k2) * U2.get(j2, k2);
            }
            VLU.set(i2, j2, sum);
          }
        }
        return VLU.mmul(Y2);
      }
      solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
      }
      inverse() {
        let V2 = this.V;
        let e8 = this.threshold;
        let vrows = V2.rows;
        let vcols = V2.columns;
        let X2 = new Matrix(vrows, this.s.length);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < vcols; j2++) {
            if (Math.abs(this.s[j2]) > e8) {
              X2.set(i2, j2, V2.get(i2, j2) / this.s[j2]);
            }
          }
        }
        let U2 = this.U;
        let urows = U2.rows;
        let ucols = U2.columns;
        let Y2 = new Matrix(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < ucols; k2++) {
              sum += X2.get(i2, k2) * U2.get(j2, k2);
            }
            Y2.set(i2, j2, sum);
          }
        }
        return Y2;
      }
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }
      get norm2() {
        return this.s[0];
      }
      get rank() {
        let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        let r2 = 0;
        let s2 = this.s;
        for (let i2 = 0, ii2 = s2.length; i2 < ii2; i2++) {
          if (s2[i2] > tol) {
            r2++;
          }
        }
        return r2;
      }
      get diagonal() {
        return Array.from(this.s);
      }
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }
      get leftSingularVectors() {
        return this.U;
      }
      get rightSingularVectors() {
        return this.V;
      }
      get diagonalMatrix() {
        return Matrix.diag(this.s);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/decompositions.js
function inverse4(matrix, useSVD = false) {
  matrix = WrapperMatrix2D.checkMatrix(matrix);
  if (useSVD) {
    return new SingularValueDecomposition(matrix).inverse();
  } else {
    return solve(matrix, Matrix.eye(matrix.rows));
  }
}
function solve(leftHandSide, rightHandSide, useSVD = false) {
  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
  if (useSVD) {
    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
  } else {
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);
  }
}
var init_decompositions = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/decompositions.js"() {
    init_lu();
    init_qr();
    init_svd();
    init_matrix2();
    init_WrapperMatrix2D();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/determinant.js
function determinant5(matrix) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isSquare()) {
    let a3, b10, c3, d2;
    if (matrix.columns === 2) {
      a3 = matrix.get(0, 0);
      b10 = matrix.get(0, 1);
      c3 = matrix.get(1, 0);
      d2 = matrix.get(1, 1);
      return a3 * d2 - b10 * c3;
    } else if (matrix.columns === 3) {
      let subMatrix0, subMatrix1, subMatrix2;
      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);
      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);
      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);
      a3 = matrix.get(0, 0);
      b10 = matrix.get(0, 1);
      c3 = matrix.get(0, 2);
      return a3 * determinant5(subMatrix0) - b10 * determinant5(subMatrix1) + c3 * determinant5(subMatrix2);
    } else {
      return new LuDecomposition(matrix).determinant;
    }
  } else {
    throw Error("determinant can only be calculated for a square matrix");
  }
}
var init_determinant = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/determinant.js"() {
    init_lu();
    init_matrix2();
    init_selection();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/linearDependencies.js
function xrange(n2, exception) {
  let range = [];
  for (let i2 = 0; i2 < n2; i2++) {
    if (i2 !== exception) {
      range.push(i2);
    }
  }
  return range;
}
function dependenciesOneRow(error, matrix, index2, thresholdValue = 1e-9, thresholdError = 1e-9) {
  if (error > thresholdError) {
    return new Array(matrix.rows + 1).fill(0);
  } else {
    let returnArray = matrix.addRow(index2, [0]);
    for (let i2 = 0; i2 < returnArray.rows; i2++) {
      if (Math.abs(returnArray.get(i2, 0)) < thresholdValue) {
        returnArray.set(i2, 0, 0);
      }
    }
    return returnArray.to1DArray();
  }
}
function linearDependencies(matrix, options = {}) {
  const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
  matrix = Matrix.checkMatrix(matrix);
  let n2 = matrix.rows;
  let results = new Matrix(n2, n2);
  for (let i2 = 0; i2 < n2; i2++) {
    let b10 = Matrix.columnVector(matrix.getRow(i2));
    let Abis = matrix.subMatrixRow(xrange(n2, i2)).transpose();
    let svd = new SingularValueDecomposition(Abis);
    let x4 = svd.solve(b10);
    let error = Matrix.sub(b10, Abis.mmul(x4)).abs().max();
    results.setRow(
      i2,
      dependenciesOneRow(error, x4, i2, thresholdValue, thresholdError)
    );
  }
  return results;
}
var init_linearDependencies = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/linearDependencies.js"() {
    init_svd();
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/pseudoInverse.js
function pseudoInverse(matrix, threshold = Number.EPSILON) {
  matrix = Matrix.checkMatrix(matrix);
  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });
  let U2 = svdSolution.leftSingularVectors;
  let V2 = svdSolution.rightSingularVectors;
  let s2 = svdSolution.diagonal;
  for (let i2 = 0; i2 < s2.length; i2++) {
    if (Math.abs(s2[i2]) > threshold) {
      s2[i2] = 1 / s2[i2];
    } else {
      s2[i2] = 0;
    }
  }
  return V2.mmul(Matrix.diag(s2).mmul(U2.transpose()));
}
var init_pseudoInverse = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/pseudoInverse.js"() {
    init_svd();
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/covariance.js
function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !Array.isArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true } = options;
  if (center) {
    xMatrix = xMatrix.center("column");
    if (!yIsSame) {
      yMatrix = yMatrix.center("column");
    }
  }
  const cov = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < cov.rows; i2++) {
    for (let j2 = 0; j2 < cov.columns; j2++) {
      cov.set(i2, j2, cov.get(i2, j2) * (1 / (xMatrix.rows - 1)));
    }
  }
  return cov;
}
var init_covariance = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/covariance.js"() {
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/correlation.js
function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !Array.isArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true, scale: scale12 = true } = options;
  if (center) {
    xMatrix.center("column");
    if (!yIsSame) {
      yMatrix.center("column");
    }
  }
  if (scale12) {
    xMatrix.scale("column");
    if (!yIsSame) {
      yMatrix.scale("column");
    }
  }
  const sdx = xMatrix.standardDeviation("column", { unbiased: true });
  const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
  const corr = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < corr.rows; i2++) {
    for (let j2 = 0; j2 < corr.columns; j2++) {
      corr.set(
        i2,
        j2,
        corr.get(i2, j2) * (1 / (sdx[i2] * sdy[j2])) * (1 / (xMatrix.rows - 1))
      );
    }
  }
  return corr;
}
var init_correlation = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/correlation.js"() {
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/evd.js
function tred2(n2, e8, d2, V2) {
  let f2, g2, h2, i2, j2, k2, hh, scale12;
  for (j2 = 0; j2 < n2; j2++) {
    d2[j2] = V2.get(n2 - 1, j2);
  }
  for (i2 = n2 - 1; i2 > 0; i2--) {
    scale12 = 0;
    h2 = 0;
    for (k2 = 0; k2 < i2; k2++) {
      scale12 = scale12 + Math.abs(d2[k2]);
    }
    if (scale12 === 0) {
      e8[i2] = d2[i2 - 1];
      for (j2 = 0; j2 < i2; j2++) {
        d2[j2] = V2.get(i2 - 1, j2);
        V2.set(i2, j2, 0);
        V2.set(j2, i2, 0);
      }
    } else {
      for (k2 = 0; k2 < i2; k2++) {
        d2[k2] /= scale12;
        h2 += d2[k2] * d2[k2];
      }
      f2 = d2[i2 - 1];
      g2 = Math.sqrt(h2);
      if (f2 > 0) {
        g2 = -g2;
      }
      e8[i2] = scale12 * g2;
      h2 = h2 - f2 * g2;
      d2[i2 - 1] = f2 - g2;
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] = 0;
      }
      for (j2 = 0; j2 < i2; j2++) {
        f2 = d2[j2];
        V2.set(j2, i2, f2);
        g2 = e8[j2] + V2.get(j2, j2) * f2;
        for (k2 = j2 + 1; k2 <= i2 - 1; k2++) {
          g2 += V2.get(k2, j2) * d2[k2];
          e8[k2] += V2.get(k2, j2) * f2;
        }
        e8[j2] = g2;
      }
      f2 = 0;
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] /= h2;
        f2 += e8[j2] * d2[j2];
      }
      hh = f2 / (h2 + h2);
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] -= hh * d2[j2];
      }
      for (j2 = 0; j2 < i2; j2++) {
        f2 = d2[j2];
        g2 = e8[j2];
        for (k2 = j2; k2 <= i2 - 1; k2++) {
          V2.set(k2, j2, V2.get(k2, j2) - (f2 * e8[k2] + g2 * d2[k2]));
        }
        d2[j2] = V2.get(i2 - 1, j2);
        V2.set(i2, j2, 0);
      }
    }
    d2[i2] = h2;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    V2.set(n2 - 1, i2, V2.get(i2, i2));
    V2.set(i2, i2, 1);
    h2 = d2[i2 + 1];
    if (h2 !== 0) {
      for (k2 = 0; k2 <= i2; k2++) {
        d2[k2] = V2.get(k2, i2 + 1) / h2;
      }
      for (j2 = 0; j2 <= i2; j2++) {
        g2 = 0;
        for (k2 = 0; k2 <= i2; k2++) {
          g2 += V2.get(k2, i2 + 1) * V2.get(k2, j2);
        }
        for (k2 = 0; k2 <= i2; k2++) {
          V2.set(k2, j2, V2.get(k2, j2) - g2 * d2[k2]);
        }
      }
    }
    for (k2 = 0; k2 <= i2; k2++) {
      V2.set(k2, i2 + 1, 0);
    }
  }
  for (j2 = 0; j2 < n2; j2++) {
    d2[j2] = V2.get(n2 - 1, j2);
    V2.set(n2 - 1, j2, 0);
  }
  V2.set(n2 - 1, n2 - 1, 1);
  e8[0] = 0;
}
function tql2(n2, e8, d2, V2) {
  let g2, h2, i2, j2, k2, l2, m3, p2, r2, dl1, c3, c22, c32, el1, s2, s22, iter;
  for (i2 = 1; i2 < n2; i2++) {
    e8[i2 - 1] = e8[i2];
  }
  e8[n2 - 1] = 0;
  let f2 = 0;
  let tst1 = 0;
  let eps2 = Number.EPSILON;
  for (l2 = 0; l2 < n2; l2++) {
    tst1 = Math.max(tst1, Math.abs(d2[l2]) + Math.abs(e8[l2]));
    m3 = l2;
    while (m3 < n2) {
      if (Math.abs(e8[m3]) <= eps2 * tst1) {
        break;
      }
      m3++;
    }
    if (m3 > l2) {
      iter = 0;
      do {
        iter = iter + 1;
        g2 = d2[l2];
        p2 = (d2[l2 + 1] - g2) / (2 * e8[l2]);
        r2 = hypotenuse(p2, 1);
        if (p2 < 0) {
          r2 = -r2;
        }
        d2[l2] = e8[l2] / (p2 + r2);
        d2[l2 + 1] = e8[l2] * (p2 + r2);
        dl1 = d2[l2 + 1];
        h2 = g2 - d2[l2];
        for (i2 = l2 + 2; i2 < n2; i2++) {
          d2[i2] -= h2;
        }
        f2 = f2 + h2;
        p2 = d2[m3];
        c3 = 1;
        c22 = c3;
        c32 = c3;
        el1 = e8[l2 + 1];
        s2 = 0;
        s22 = 0;
        for (i2 = m3 - 1; i2 >= l2; i2--) {
          c32 = c22;
          c22 = c3;
          s22 = s2;
          g2 = c3 * e8[i2];
          h2 = c3 * p2;
          r2 = hypotenuse(p2, e8[i2]);
          e8[i2 + 1] = s2 * r2;
          s2 = e8[i2] / r2;
          c3 = p2 / r2;
          p2 = c3 * d2[i2] - s2 * g2;
          d2[i2 + 1] = h2 + s2 * (c3 * g2 + s2 * d2[i2]);
          for (k2 = 0; k2 < n2; k2++) {
            h2 = V2.get(k2, i2 + 1);
            V2.set(k2, i2 + 1, s2 * V2.get(k2, i2) + c3 * h2);
            V2.set(k2, i2, c3 * V2.get(k2, i2) - s2 * h2);
          }
        }
        p2 = -s2 * s22 * c32 * el1 * e8[l2] / dl1;
        e8[l2] = s2 * p2;
        d2[l2] = c3 * p2;
      } while (Math.abs(e8[l2]) > eps2 * tst1);
    }
    d2[l2] = d2[l2] + f2;
    e8[l2] = 0;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    k2 = i2;
    p2 = d2[i2];
    for (j2 = i2 + 1; j2 < n2; j2++) {
      if (d2[j2] < p2) {
        k2 = j2;
        p2 = d2[j2];
      }
    }
    if (k2 !== i2) {
      d2[k2] = d2[i2];
      d2[i2] = p2;
      for (j2 = 0; j2 < n2; j2++) {
        p2 = V2.get(j2, i2);
        V2.set(j2, i2, V2.get(j2, k2));
        V2.set(j2, k2, p2);
      }
    }
  }
}
function orthes(n2, H2, ort, V2) {
  let low = 0;
  let high = n2 - 1;
  let f2, g2, h2, i2, j2, m3;
  let scale12;
  for (m3 = low + 1; m3 <= high - 1; m3++) {
    scale12 = 0;
    for (i2 = m3; i2 <= high; i2++) {
      scale12 = scale12 + Math.abs(H2.get(i2, m3 - 1));
    }
    if (scale12 !== 0) {
      h2 = 0;
      for (i2 = high; i2 >= m3; i2--) {
        ort[i2] = H2.get(i2, m3 - 1) / scale12;
        h2 += ort[i2] * ort[i2];
      }
      g2 = Math.sqrt(h2);
      if (ort[m3] > 0) {
        g2 = -g2;
      }
      h2 = h2 - ort[m3] * g2;
      ort[m3] = ort[m3] - g2;
      for (j2 = m3; j2 < n2; j2++) {
        f2 = 0;
        for (i2 = high; i2 >= m3; i2--) {
          f2 += ort[i2] * H2.get(i2, j2);
        }
        f2 = f2 / h2;
        for (i2 = m3; i2 <= high; i2++) {
          H2.set(i2, j2, H2.get(i2, j2) - f2 * ort[i2]);
        }
      }
      for (i2 = 0; i2 <= high; i2++) {
        f2 = 0;
        for (j2 = high; j2 >= m3; j2--) {
          f2 += ort[j2] * H2.get(i2, j2);
        }
        f2 = f2 / h2;
        for (j2 = m3; j2 <= high; j2++) {
          H2.set(i2, j2, H2.get(i2, j2) - f2 * ort[j2]);
        }
      }
      ort[m3] = scale12 * ort[m3];
      H2.set(m3, m3 - 1, scale12 * g2);
    }
  }
  for (i2 = 0; i2 < n2; i2++) {
    for (j2 = 0; j2 < n2; j2++) {
      V2.set(i2, j2, i2 === j2 ? 1 : 0);
    }
  }
  for (m3 = high - 1; m3 >= low + 1; m3--) {
    if (H2.get(m3, m3 - 1) !== 0) {
      for (i2 = m3 + 1; i2 <= high; i2++) {
        ort[i2] = H2.get(i2, m3 - 1);
      }
      for (j2 = m3; j2 <= high; j2++) {
        g2 = 0;
        for (i2 = m3; i2 <= high; i2++) {
          g2 += ort[i2] * V2.get(i2, j2);
        }
        g2 = g2 / ort[m3] / H2.get(m3, m3 - 1);
        for (i2 = m3; i2 <= high; i2++) {
          V2.set(i2, j2, V2.get(i2, j2) + g2 * ort[i2]);
        }
      }
    }
  }
}
function hqr2(nn2, e8, d2, V2, H2) {
  let n2 = nn2 - 1;
  let low = 0;
  let high = nn2 - 1;
  let eps2 = Number.EPSILON;
  let exshift = 0;
  let norm = 0;
  let p2 = 0;
  let q2 = 0;
  let r2 = 0;
  let s2 = 0;
  let z2 = 0;
  let iter = 0;
  let i2, j2, k2, l2, m3, t4, w2, x4, y4;
  let ra2, sa2, vr2, vi2;
  let notlast, cdivres;
  for (i2 = 0; i2 < nn2; i2++) {
    if (i2 < low || i2 > high) {
      d2[i2] = H2.get(i2, i2);
      e8[i2] = 0;
    }
    for (j2 = Math.max(i2 - 1, 0); j2 < nn2; j2++) {
      norm = norm + Math.abs(H2.get(i2, j2));
    }
  }
  while (n2 >= low) {
    l2 = n2;
    while (l2 > low) {
      s2 = Math.abs(H2.get(l2 - 1, l2 - 1)) + Math.abs(H2.get(l2, l2));
      if (s2 === 0) {
        s2 = norm;
      }
      if (Math.abs(H2.get(l2, l2 - 1)) < eps2 * s2) {
        break;
      }
      l2--;
    }
    if (l2 === n2) {
      H2.set(n2, n2, H2.get(n2, n2) + exshift);
      d2[n2] = H2.get(n2, n2);
      e8[n2] = 0;
      n2--;
      iter = 0;
    } else if (l2 === n2 - 1) {
      w2 = H2.get(n2, n2 - 1) * H2.get(n2 - 1, n2);
      p2 = (H2.get(n2 - 1, n2 - 1) - H2.get(n2, n2)) / 2;
      q2 = p2 * p2 + w2;
      z2 = Math.sqrt(Math.abs(q2));
      H2.set(n2, n2, H2.get(n2, n2) + exshift);
      H2.set(n2 - 1, n2 - 1, H2.get(n2 - 1, n2 - 1) + exshift);
      x4 = H2.get(n2, n2);
      if (q2 >= 0) {
        z2 = p2 >= 0 ? p2 + z2 : p2 - z2;
        d2[n2 - 1] = x4 + z2;
        d2[n2] = d2[n2 - 1];
        if (z2 !== 0) {
          d2[n2] = x4 - w2 / z2;
        }
        e8[n2 - 1] = 0;
        e8[n2] = 0;
        x4 = H2.get(n2, n2 - 1);
        s2 = Math.abs(x4) + Math.abs(z2);
        p2 = x4 / s2;
        q2 = z2 / s2;
        r2 = Math.sqrt(p2 * p2 + q2 * q2);
        p2 = p2 / r2;
        q2 = q2 / r2;
        for (j2 = n2 - 1; j2 < nn2; j2++) {
          z2 = H2.get(n2 - 1, j2);
          H2.set(n2 - 1, j2, q2 * z2 + p2 * H2.get(n2, j2));
          H2.set(n2, j2, q2 * H2.get(n2, j2) - p2 * z2);
        }
        for (i2 = 0; i2 <= n2; i2++) {
          z2 = H2.get(i2, n2 - 1);
          H2.set(i2, n2 - 1, q2 * z2 + p2 * H2.get(i2, n2));
          H2.set(i2, n2, q2 * H2.get(i2, n2) - p2 * z2);
        }
        for (i2 = low; i2 <= high; i2++) {
          z2 = V2.get(i2, n2 - 1);
          V2.set(i2, n2 - 1, q2 * z2 + p2 * V2.get(i2, n2));
          V2.set(i2, n2, q2 * V2.get(i2, n2) - p2 * z2);
        }
      } else {
        d2[n2 - 1] = x4 + p2;
        d2[n2] = x4 + p2;
        e8[n2 - 1] = z2;
        e8[n2] = -z2;
      }
      n2 = n2 - 2;
      iter = 0;
    } else {
      x4 = H2.get(n2, n2);
      y4 = 0;
      w2 = 0;
      if (l2 < n2) {
        y4 = H2.get(n2 - 1, n2 - 1);
        w2 = H2.get(n2, n2 - 1) * H2.get(n2 - 1, n2);
      }
      if (iter === 10) {
        exshift += x4;
        for (i2 = low; i2 <= n2; i2++) {
          H2.set(i2, i2, H2.get(i2, i2) - x4);
        }
        s2 = Math.abs(H2.get(n2, n2 - 1)) + Math.abs(H2.get(n2 - 1, n2 - 2));
        x4 = y4 = 0.75 * s2;
        w2 = -0.4375 * s2 * s2;
      }
      if (iter === 30) {
        s2 = (y4 - x4) / 2;
        s2 = s2 * s2 + w2;
        if (s2 > 0) {
          s2 = Math.sqrt(s2);
          if (y4 < x4) {
            s2 = -s2;
          }
          s2 = x4 - w2 / ((y4 - x4) / 2 + s2);
          for (i2 = low; i2 <= n2; i2++) {
            H2.set(i2, i2, H2.get(i2, i2) - s2);
          }
          exshift += s2;
          x4 = y4 = w2 = 0.964;
        }
      }
      iter = iter + 1;
      m3 = n2 - 2;
      while (m3 >= l2) {
        z2 = H2.get(m3, m3);
        r2 = x4 - z2;
        s2 = y4 - z2;
        p2 = (r2 * s2 - w2) / H2.get(m3 + 1, m3) + H2.get(m3, m3 + 1);
        q2 = H2.get(m3 + 1, m3 + 1) - z2 - r2 - s2;
        r2 = H2.get(m3 + 2, m3 + 1);
        s2 = Math.abs(p2) + Math.abs(q2) + Math.abs(r2);
        p2 = p2 / s2;
        q2 = q2 / s2;
        r2 = r2 / s2;
        if (m3 === l2) {
          break;
        }
        if (Math.abs(H2.get(m3, m3 - 1)) * (Math.abs(q2) + Math.abs(r2)) < eps2 * (Math.abs(p2) * (Math.abs(H2.get(m3 - 1, m3 - 1)) + Math.abs(z2) + Math.abs(H2.get(m3 + 1, m3 + 1))))) {
          break;
        }
        m3--;
      }
      for (i2 = m3 + 2; i2 <= n2; i2++) {
        H2.set(i2, i2 - 2, 0);
        if (i2 > m3 + 2) {
          H2.set(i2, i2 - 3, 0);
        }
      }
      for (k2 = m3; k2 <= n2 - 1; k2++) {
        notlast = k2 !== n2 - 1;
        if (k2 !== m3) {
          p2 = H2.get(k2, k2 - 1);
          q2 = H2.get(k2 + 1, k2 - 1);
          r2 = notlast ? H2.get(k2 + 2, k2 - 1) : 0;
          x4 = Math.abs(p2) + Math.abs(q2) + Math.abs(r2);
          if (x4 !== 0) {
            p2 = p2 / x4;
            q2 = q2 / x4;
            r2 = r2 / x4;
          }
        }
        if (x4 === 0) {
          break;
        }
        s2 = Math.sqrt(p2 * p2 + q2 * q2 + r2 * r2);
        if (p2 < 0) {
          s2 = -s2;
        }
        if (s2 !== 0) {
          if (k2 !== m3) {
            H2.set(k2, k2 - 1, -s2 * x4);
          } else if (l2 !== m3) {
            H2.set(k2, k2 - 1, -H2.get(k2, k2 - 1));
          }
          p2 = p2 + s2;
          x4 = p2 / s2;
          y4 = q2 / s2;
          z2 = r2 / s2;
          q2 = q2 / p2;
          r2 = r2 / p2;
          for (j2 = k2; j2 < nn2; j2++) {
            p2 = H2.get(k2, j2) + q2 * H2.get(k2 + 1, j2);
            if (notlast) {
              p2 = p2 + r2 * H2.get(k2 + 2, j2);
              H2.set(k2 + 2, j2, H2.get(k2 + 2, j2) - p2 * z2);
            }
            H2.set(k2, j2, H2.get(k2, j2) - p2 * x4);
            H2.set(k2 + 1, j2, H2.get(k2 + 1, j2) - p2 * y4);
          }
          for (i2 = 0; i2 <= Math.min(n2, k2 + 3); i2++) {
            p2 = x4 * H2.get(i2, k2) + y4 * H2.get(i2, k2 + 1);
            if (notlast) {
              p2 = p2 + z2 * H2.get(i2, k2 + 2);
              H2.set(i2, k2 + 2, H2.get(i2, k2 + 2) - p2 * r2);
            }
            H2.set(i2, k2, H2.get(i2, k2) - p2);
            H2.set(i2, k2 + 1, H2.get(i2, k2 + 1) - p2 * q2);
          }
          for (i2 = low; i2 <= high; i2++) {
            p2 = x4 * V2.get(i2, k2) + y4 * V2.get(i2, k2 + 1);
            if (notlast) {
              p2 = p2 + z2 * V2.get(i2, k2 + 2);
              V2.set(i2, k2 + 2, V2.get(i2, k2 + 2) - p2 * r2);
            }
            V2.set(i2, k2, V2.get(i2, k2) - p2);
            V2.set(i2, k2 + 1, V2.get(i2, k2 + 1) - p2 * q2);
          }
        }
      }
    }
  }
  if (norm === 0) {
    return;
  }
  for (n2 = nn2 - 1; n2 >= 0; n2--) {
    p2 = d2[n2];
    q2 = e8[n2];
    if (q2 === 0) {
      l2 = n2;
      H2.set(n2, n2, 1);
      for (i2 = n2 - 1; i2 >= 0; i2--) {
        w2 = H2.get(i2, i2) - p2;
        r2 = 0;
        for (j2 = l2; j2 <= n2; j2++) {
          r2 = r2 + H2.get(i2, j2) * H2.get(j2, n2);
        }
        if (e8[i2] < 0) {
          z2 = w2;
          s2 = r2;
        } else {
          l2 = i2;
          if (e8[i2] === 0) {
            H2.set(i2, n2, w2 !== 0 ? -r2 / w2 : -r2 / (eps2 * norm));
          } else {
            x4 = H2.get(i2, i2 + 1);
            y4 = H2.get(i2 + 1, i2);
            q2 = (d2[i2] - p2) * (d2[i2] - p2) + e8[i2] * e8[i2];
            t4 = (x4 * s2 - z2 * r2) / q2;
            H2.set(i2, n2, t4);
            H2.set(
              i2 + 1,
              n2,
              Math.abs(x4) > Math.abs(z2) ? (-r2 - w2 * t4) / x4 : (-s2 - y4 * t4) / z2
            );
          }
          t4 = Math.abs(H2.get(i2, n2));
          if (eps2 * t4 * t4 > 1) {
            for (j2 = i2; j2 <= n2; j2++) {
              H2.set(j2, n2, H2.get(j2, n2) / t4);
            }
          }
        }
      }
    } else if (q2 < 0) {
      l2 = n2 - 1;
      if (Math.abs(H2.get(n2, n2 - 1)) > Math.abs(H2.get(n2 - 1, n2))) {
        H2.set(n2 - 1, n2 - 1, q2 / H2.get(n2, n2 - 1));
        H2.set(n2 - 1, n2, -(H2.get(n2, n2) - p2) / H2.get(n2, n2 - 1));
      } else {
        cdivres = cdiv(0, -H2.get(n2 - 1, n2), H2.get(n2 - 1, n2 - 1) - p2, q2);
        H2.set(n2 - 1, n2 - 1, cdivres[0]);
        H2.set(n2 - 1, n2, cdivres[1]);
      }
      H2.set(n2, n2 - 1, 0);
      H2.set(n2, n2, 1);
      for (i2 = n2 - 2; i2 >= 0; i2--) {
        ra2 = 0;
        sa2 = 0;
        for (j2 = l2; j2 <= n2; j2++) {
          ra2 = ra2 + H2.get(i2, j2) * H2.get(j2, n2 - 1);
          sa2 = sa2 + H2.get(i2, j2) * H2.get(j2, n2);
        }
        w2 = H2.get(i2, i2) - p2;
        if (e8[i2] < 0) {
          z2 = w2;
          r2 = ra2;
          s2 = sa2;
        } else {
          l2 = i2;
          if (e8[i2] === 0) {
            cdivres = cdiv(-ra2, -sa2, w2, q2);
            H2.set(i2, n2 - 1, cdivres[0]);
            H2.set(i2, n2, cdivres[1]);
          } else {
            x4 = H2.get(i2, i2 + 1);
            y4 = H2.get(i2 + 1, i2);
            vr2 = (d2[i2] - p2) * (d2[i2] - p2) + e8[i2] * e8[i2] - q2 * q2;
            vi2 = (d2[i2] - p2) * 2 * q2;
            if (vr2 === 0 && vi2 === 0) {
              vr2 = eps2 * norm * (Math.abs(w2) + Math.abs(q2) + Math.abs(x4) + Math.abs(y4) + Math.abs(z2));
            }
            cdivres = cdiv(
              x4 * r2 - z2 * ra2 + q2 * sa2,
              x4 * s2 - z2 * sa2 - q2 * ra2,
              vr2,
              vi2
            );
            H2.set(i2, n2 - 1, cdivres[0]);
            H2.set(i2, n2, cdivres[1]);
            if (Math.abs(x4) > Math.abs(z2) + Math.abs(q2)) {
              H2.set(
                i2 + 1,
                n2 - 1,
                (-ra2 - w2 * H2.get(i2, n2 - 1) + q2 * H2.get(i2, n2)) / x4
              );
              H2.set(
                i2 + 1,
                n2,
                (-sa2 - w2 * H2.get(i2, n2) - q2 * H2.get(i2, n2 - 1)) / x4
              );
            } else {
              cdivres = cdiv(
                -r2 - y4 * H2.get(i2, n2 - 1),
                -s2 - y4 * H2.get(i2, n2),
                z2,
                q2
              );
              H2.set(i2 + 1, n2 - 1, cdivres[0]);
              H2.set(i2 + 1, n2, cdivres[1]);
            }
          }
          t4 = Math.max(Math.abs(H2.get(i2, n2 - 1)), Math.abs(H2.get(i2, n2)));
          if (eps2 * t4 * t4 > 1) {
            for (j2 = i2; j2 <= n2; j2++) {
              H2.set(j2, n2 - 1, H2.get(j2, n2 - 1) / t4);
              H2.set(j2, n2, H2.get(j2, n2) / t4);
            }
          }
        }
      }
    }
  }
  for (i2 = 0; i2 < nn2; i2++) {
    if (i2 < low || i2 > high) {
      for (j2 = i2; j2 < nn2; j2++) {
        V2.set(i2, j2, H2.get(i2, j2));
      }
    }
  }
  for (j2 = nn2 - 1; j2 >= low; j2--) {
    for (i2 = low; i2 <= high; i2++) {
      z2 = 0;
      for (k2 = low; k2 <= Math.min(j2, high); k2++) {
        z2 = z2 + V2.get(i2, k2) * H2.get(k2, j2);
      }
      V2.set(i2, j2, z2);
    }
  }
}
function cdiv(xr2, xi2, yr2, yi2) {
  let r2, d2;
  if (Math.abs(yr2) > Math.abs(yi2)) {
    r2 = yi2 / yr2;
    d2 = yr2 + r2 * yi2;
    return [(xr2 + r2 * xi2) / d2, (xi2 - r2 * xr2) / d2];
  } else {
    r2 = yr2 / yi2;
    d2 = yi2 + r2 * yr2;
    return [(r2 * xr2 + xi2) / d2, (r2 * xi2 - xr2) / d2];
  }
}
var EigenvalueDecomposition;
var init_evd = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/evd.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    init_util3();
    EigenvalueDecomposition = class {
      constructor(matrix, options = {}) {
        const { assumeSymmetric = false } = options;
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        if (!matrix.isSquare()) {
          throw new Error("Matrix is not a square matrix");
        }
        let n2 = matrix.columns;
        let V2 = new Matrix(n2, n2);
        let d2 = new Float64Array(n2);
        let e8 = new Float64Array(n2);
        let value = matrix;
        let i2, j2;
        let isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix.isSymmetric();
        }
        if (isSymmetric) {
          for (i2 = 0; i2 < n2; i2++) {
            for (j2 = 0; j2 < n2; j2++) {
              V2.set(i2, j2, value.get(i2, j2));
            }
          }
          tred2(n2, e8, d2, V2);
          tql2(n2, e8, d2, V2);
        } else {
          let H2 = new Matrix(n2, n2);
          let ort = new Float64Array(n2);
          for (j2 = 0; j2 < n2; j2++) {
            for (i2 = 0; i2 < n2; i2++) {
              H2.set(i2, j2, value.get(i2, j2));
            }
          }
          orthes(n2, H2, ort, V2);
          hqr2(n2, e8, d2, V2, H2);
        }
        this.n = n2;
        this.e = e8;
        this.d = d2;
        this.V = V2;
      }
      get realEigenvalues() {
        return Array.from(this.d);
      }
      get imaginaryEigenvalues() {
        return Array.from(this.e);
      }
      get eigenvectorMatrix() {
        return this.V;
      }
      get diagonalMatrix() {
        let n2 = this.n;
        let e8 = this.e;
        let d2 = this.d;
        let X2 = new Matrix(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            X2.set(i2, j2, 0);
          }
          X2.set(i2, i2, d2[i2]);
          if (e8[i2] > 0) {
            X2.set(i2, i2 + 1, e8[i2]);
          } else if (e8[i2] < 0) {
            X2.set(i2, i2 - 1, e8[i2]);
          }
        }
        return X2;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/cholesky.js
var CholeskyDecomposition;
var init_cholesky = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/cholesky.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    CholeskyDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error("Matrix is not symmetric");
        }
        let a3 = value;
        let dimension = a3.rows;
        let l2 = new Matrix(dimension, dimension);
        let positiveDefinite = true;
        let i2, j2, k2;
        for (j2 = 0; j2 < dimension; j2++) {
          let d2 = 0;
          for (k2 = 0; k2 < j2; k2++) {
            let s2 = 0;
            for (i2 = 0; i2 < k2; i2++) {
              s2 += l2.get(k2, i2) * l2.get(j2, i2);
            }
            s2 = (a3.get(j2, k2) - s2) / l2.get(k2, k2);
            l2.set(j2, k2, s2);
            d2 = d2 + s2 * s2;
          }
          d2 = a3.get(j2, j2) - d2;
          positiveDefinite &= d2 > 0;
          l2.set(j2, j2, Math.sqrt(Math.max(d2, 0)));
          for (k2 = j2 + 1; k2 < dimension; k2++) {
            l2.set(j2, k2, 0);
          }
        }
        this.L = l2;
        this.positiveDefinite = Boolean(positiveDefinite);
      }
      isPositiveDefinite() {
        return this.positiveDefinite;
      }
      solve(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let l2 = this.L;
        let dimension = l2.rows;
        if (value.rows !== dimension) {
          throw new Error("Matrix dimensions do not match");
        }
        if (this.isPositiveDefinite() === false) {
          throw new Error("Matrix is not positive definite");
        }
        let count = value.columns;
        let B3 = value.clone();
        let i2, j2, k2;
        for (k2 = 0; k2 < dimension; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = 0; i2 < k2; i2++) {
              B3.set(k2, j2, B3.get(k2, j2) - B3.get(i2, j2) * l2.get(k2, i2));
            }
            B3.set(k2, j2, B3.get(k2, j2) / l2.get(k2, k2));
          }
        }
        for (k2 = dimension - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = k2 + 1; i2 < dimension; i2++) {
              B3.set(k2, j2, B3.get(k2, j2) - B3.get(i2, j2) * l2.get(i2, k2));
            }
            B3.set(k2, j2, B3.get(k2, j2) / l2.get(k2, k2));
          }
        }
        return B3;
      }
      get lowerTriangularMatrix() {
        return this.L;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/nipals.js
var nipals;
var init_nipals = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/nipals.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    nipals = class {
      constructor(X2, options = {}) {
        X2 = WrapperMatrix2D.checkMatrix(X2);
        let { Y: Y2 } = options;
        const {
          scaleScores = false,
          maxIterations = 1e3,
          terminationCriteria = 1e-10
        } = options;
        let u2;
        if (Y2) {
          if (Array.isArray(Y2) && typeof Y2[0] === "number") {
            Y2 = Matrix.columnVector(Y2);
          } else {
            Y2 = WrapperMatrix2D.checkMatrix(Y2);
          }
          if (!Y2.isColumnVector() || Y2.rows !== X2.rows) {
            throw new Error("Y must be a column vector of length X.rows");
          }
          u2 = Y2;
        } else {
          u2 = X2.getColumnVector(0);
        }
        let diff = 1;
        let t4, q2, w2, tOld;
        for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
          w2 = X2.transpose().mmul(u2).div(u2.transpose().mmul(u2).get(0, 0));
          w2 = w2.div(w2.norm());
          t4 = X2.mmul(w2).div(w2.transpose().mmul(w2).get(0, 0));
          if (counter > 0) {
            diff = t4.clone().sub(tOld).pow(2).sum();
          }
          tOld = t4.clone();
          if (Y2) {
            q2 = Y2.transpose().mmul(t4).div(t4.transpose().mmul(t4).get(0, 0));
            q2 = q2.div(q2.norm());
            u2 = Y2.mmul(q2).div(q2.transpose().mmul(q2).get(0, 0));
          } else {
            u2 = t4;
          }
        }
        if (Y2) {
          let p2 = X2.transpose().mmul(t4).div(t4.transpose().mmul(t4).get(0, 0));
          p2 = p2.div(p2.norm());
          let xResidual = X2.clone().sub(t4.clone().mmul(p2.transpose()));
          let residual = u2.transpose().mmul(t4).div(t4.transpose().mmul(t4).get(0, 0));
          let yResidual = Y2.clone().sub(
            t4.clone().mulS(residual.get(0, 0)).mmul(q2.transpose())
          );
          this.t = t4;
          this.p = p2.transpose();
          this.w = w2.transpose();
          this.q = q2;
          this.u = u2;
          this.s = t4.transpose().mmul(t4);
          this.xResidual = xResidual;
          this.yResidual = yResidual;
          this.betas = residual;
        } else {
          this.w = w2.transpose();
          this.s = t4.transpose().mmul(t4).sqrt();
          if (scaleScores) {
            this.t = t4.clone().div(this.s.get(0, 0));
          } else {
            this.t = t4;
          }
          this.xResidual = X2.sub(t4.mmul(w2.transpose()));
        }
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/index.js
var src_exports5 = {};
__export(src_exports5, {
  AbstractMatrix: () => AbstractMatrix,
  CHO: () => CholeskyDecomposition,
  CholeskyDecomposition: () => CholeskyDecomposition,
  EVD: () => EigenvalueDecomposition,
  EigenvalueDecomposition: () => EigenvalueDecomposition,
  LU: () => LuDecomposition,
  LuDecomposition: () => LuDecomposition,
  Matrix: () => Matrix,
  MatrixColumnSelectionView: () => MatrixColumnSelectionView,
  MatrixColumnView: () => MatrixColumnView,
  MatrixFlipColumnView: () => MatrixFlipColumnView,
  MatrixFlipRowView: () => MatrixFlipRowView,
  MatrixRowSelectionView: () => MatrixRowSelectionView,
  MatrixRowView: () => MatrixRowView,
  MatrixSelectionView: () => MatrixSelectionView,
  MatrixSubView: () => MatrixSubView,
  MatrixTransposeView: () => MatrixTransposeView,
  NIPALS: () => nipals,
  Nipals: () => nipals,
  QR: () => QrDecomposition,
  QrDecomposition: () => QrDecomposition,
  SVD: () => SingularValueDecomposition,
  SingularValueDecomposition: () => SingularValueDecomposition,
  WrapperMatrix1D: () => WrapperMatrix1D,
  WrapperMatrix2D: () => WrapperMatrix2D,
  correlation: () => correlation,
  covariance: () => covariance,
  default: () => Matrix,
  determinant: () => determinant5,
  inverse: () => inverse4,
  linearDependencies: () => linearDependencies,
  pseudoInverse: () => pseudoInverse,
  solve: () => solve,
  wrap: () => wrap
});
var init_src5 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/index.js"() {
    init_matrix2();
    init_views();
    init_wrap();
    init_WrapperMatrix1D();
    init_WrapperMatrix2D();
    init_decompositions();
    init_determinant();
    init_linearDependencies();
    init_pseudoInverse();
    init_covariance();
    init_correlation();
    init_svd();
    init_evd();
    init_cholesky();
    init_lu();
    init_qr();
    init_nipals();
  }
});

// node_modules/@antv/layout/lib/layout/radial/mds.js
var require_mds = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/mds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ml_matrix_1 = (init_src5(), __toCommonJS(src_exports5));
    var MDS = (
      /** @class */
      function() {
        function MDS2(params) {
          this.distances = params.distances;
          this.dimension = params.dimension || 2;
          this.linkDistance = params.linkDistance;
        }
        MDS2.prototype.layout = function() {
          var self2 = this;
          var dimension = self2.dimension, distances = self2.distances, linkDistance = self2.linkDistance;
          try {
            var M2 = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);
            var rowMeans = M2.mean("row");
            var colMeans = M2.mean("column");
            var totalMean = M2.mean();
            M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
            var ret = new ml_matrix_1.SingularValueDecomposition(M2);
            var eigenValues_1 = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();
            return ret.leftSingularVectors.toJSON().map(function(row) {
              return ml_matrix_1.Matrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);
            });
          } catch (_a2) {
            var res = [];
            for (var i2 = 0; i2 < distances.length; i2++) {
              var x4 = Math.random() * linkDistance;
              var y4 = Math.random() * linkDistance;
              res.push([x4, y4]);
            }
            return res;
          }
        };
        return MDS2;
      }()
    );
    exports.default = MDS;
  }
});

// node_modules/@antv/layout/lib/layout/radial/radialNonoverlapForce.js
var require_radialNonoverlapForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/radialNonoverlapForce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SPEED_DIVISOR = 800;
    var RadialNonoverlapForce = (
      /** @class */
      function() {
        function RadialNonoverlapForce2(params) {
          this.disp = [];
          this.positions = params.positions;
          this.adjMatrix = params.adjMatrix;
          this.focusID = params.focusID;
          this.radii = params.radii;
          this.iterations = params.iterations || 10;
          this.height = params.height || 10;
          this.width = params.width || 10;
          this.speed = params.speed || 100;
          this.gravity = params.gravity || 10;
          this.nodeSizeFunc = params.nodeSizeFunc;
          this.k = params.k || 5;
          this.strictRadial = params.strictRadial;
          this.nodes = params.nodes;
        }
        RadialNonoverlapForce2.prototype.layout = function() {
          var self2 = this;
          var positions = self2.positions;
          var disp = [];
          var iterations = self2.iterations;
          var maxDisplace = self2.width / 10;
          self2.maxDisplace = maxDisplace;
          self2.disp = disp;
          for (var i2 = 0; i2 < iterations; i2++) {
            positions.forEach(function(_2, k2) {
              disp[k2] = { x: 0, y: 0 };
            });
            self2.getRepulsion();
            self2.updatePositions();
          }
          return positions;
        };
        RadialNonoverlapForce2.prototype.getRepulsion = function() {
          var self2 = this;
          var positions = self2.positions;
          var nodes = self2.nodes;
          var disp = self2.disp;
          var k2 = self2.k;
          var radii = self2.radii || [];
          positions.forEach(function(v2, i2) {
            disp[i2] = { x: 0, y: 0 };
            positions.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              if (radii[i2] !== radii[j2]) {
                return;
              }
              var vecx = v2[0] - u2[0];
              var vecy = v2[1] - u2[1];
              var vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
              if (vecLength === 0) {
                vecLength = 1;
                var sign = i2 > j2 ? 1 : -1;
                vecx = 0.01 * sign;
                vecy = 0.01 * sign;
              }
              if (vecLength < self2.nodeSizeFunc(nodes[i2]) / 2 + self2.nodeSizeFunc(nodes[j2]) / 2) {
                var common = k2 * k2 / vecLength;
                disp[i2].x += vecx / vecLength * common;
                disp[i2].y += vecy / vecLength * common;
              }
            });
          });
        };
        RadialNonoverlapForce2.prototype.updatePositions = function() {
          var self2 = this;
          var positions = self2.positions;
          var disp = self2.disp;
          var speed = self2.speed;
          var strictRadial = self2.strictRadial;
          var f2 = self2.focusID;
          var maxDisplace = self2.maxDisplace || self2.width / 10;
          if (strictRadial) {
            disp.forEach(function(di2, i2) {
              var vx = positions[i2][0] - positions[f2][0];
              var vy = positions[i2][1] - positions[f2][1];
              var vLength = Math.sqrt(vx * vx + vy * vy);
              var vpx = vy / vLength;
              var vpy = -vx / vLength;
              var diLength = Math.sqrt(di2.x * di2.x + di2.y * di2.y);
              var alpha = Math.acos((vpx * di2.x + vpy * di2.y) / diLength);
              if (alpha > Math.PI / 2) {
                alpha -= Math.PI / 2;
                vpx *= -1;
                vpy *= -1;
              }
              var tdispLength = Math.cos(alpha) * diLength;
              di2.x = vpx * tdispLength;
              di2.y = vpy * tdispLength;
            });
          }
          var radii = self2.radii;
          positions.forEach(function(n2, i2) {
            if (i2 === f2) {
              return;
            }
            var distLength = Math.sqrt(disp[i2].x * disp[i2].x + disp[i2].y * disp[i2].y);
            if (distLength > 0 && i2 !== f2) {
              var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
              n2[0] += disp[i2].x / distLength * limitedDist;
              n2[1] += disp[i2].y / distLength * limitedDist;
              if (strictRadial) {
                var vx = n2[0] - positions[f2][0];
                var vy = n2[1] - positions[f2][1];
                var nfDis = Math.sqrt(vx * vx + vy * vy);
                vx = vx / nfDis * radii[i2];
                vy = vy / nfDis * radii[i2];
                n2[0] = positions[f2][0] + vx;
                n2[1] = positions[f2][1] + vy;
              }
            }
          });
        };
        return RadialNonoverlapForce2;
      }()
    );
    exports.default = RadialNonoverlapForce;
  }
});

// node_modules/@antv/layout/lib/layout/radial/radial.js
var require_radial = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/radial.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RadialLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var mds_1 = __importDefault2(require_mds());
    var radialNonoverlapForce_1 = __importDefault2(require_radialNonoverlapForce());
    function getWeightMatrix(M2) {
      var rows = M2.length;
      var cols = M2[0].length;
      var result = [];
      for (var i2 = 0; i2 < rows; i2++) {
        var row = [];
        for (var j2 = 0; j2 < cols; j2++) {
          if (M2[i2][j2] !== 0) {
            row.push(1 / (M2[i2][j2] * M2[i2][j2]));
          } else {
            row.push(0);
          }
        }
        result.push(row);
      }
      return result;
    }
    function getIndexById(array, id) {
      var index2 = -1;
      array.forEach(function(a3, i2) {
        if (a3.id === id) {
          index2 = i2;
        }
      });
      return index2;
    }
    function getEDistance(p1, p2) {
      return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));
    }
    var RadialLayout2 = (
      /** @class */
      function(_super) {
        __extends17(RadialLayout3, _super);
        function RadialLayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.focusNode = null;
          _this.unitRadius = null;
          _this.linkDistance = 50;
          _this.preventOverlap = false;
          _this.strictRadial = true;
          _this.maxPreventOverlapIteration = 200;
          _this.sortStrength = 10;
          _this.nodes = [];
          _this.edges = [];
          _this.updateCfg(options);
          return _this;
        }
        RadialLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 1e3,
            focusNode: null,
            unitRadius: null,
            linkDistance: 50,
            preventOverlap: false,
            nodeSize: void 0,
            nodeSpacing: void 0,
            strictRadial: true,
            maxPreventOverlapIteration: 200,
            sortBy: void 0,
            sortStrength: 10
          };
        };
        RadialLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges || [];
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          var linkDistance = self2.linkDistance;
          var focusNode = null;
          if ((0, util_1.isString)(self2.focusNode)) {
            var found = false;
            for (var i2 = 0; i2 < nodes.length; i2++) {
              if (nodes[i2].id === self2.focusNode) {
                focusNode = nodes[i2];
                self2.focusNode = focusNode;
                found = true;
                i2 = nodes.length;
              }
            }
            if (!found) {
              focusNode = null;
            }
          } else {
            focusNode = self2.focusNode;
          }
          if (!focusNode) {
            focusNode = nodes[0];
            self2.focusNode = focusNode;
          }
          var focusIndex = getIndexById(nodes, focusNode.id);
          if (focusIndex < 0)
            focusIndex = 0;
          self2.focusIndex = focusIndex;
          var adjMatrix3 = (0, util_1.getAdjMatrix)({ nodes, edges }, false);
          var D3 = (0, util_1.floydWarshall)(adjMatrix3);
          var maxDistance = self2.maxToFocus(D3, focusIndex);
          self2.handleInfinity(D3, focusIndex, maxDistance + 1);
          self2.distances = D3;
          var focusNodeD = D3[focusIndex];
          var width = self2.width || 500;
          var height = self2.height || 500;
          var semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];
          var semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
          if (semiWidth === 0) {
            semiWidth = width / 2;
          }
          if (semiHeight === 0) {
            semiHeight = height / 2;
          }
          var maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;
          var maxD = Math.max.apply(Math, focusNodeD);
          var radii = [];
          focusNodeD.forEach(function(value, i3) {
            if (!self2.unitRadius) {
              self2.unitRadius = maxRadius / maxD;
            }
            radii[i3] = value * self2.unitRadius;
          });
          self2.radii = radii;
          var eIdealD = self2.eIdealDisMatrix();
          self2.eIdealDistances = eIdealD;
          var W2 = getWeightMatrix(eIdealD);
          self2.weights = W2;
          var mds = new mds_1.default({ linkDistance, distances: eIdealD });
          var positions = mds.layout();
          positions.forEach(function(p2) {
            if ((0, util_1.isNaN)(p2[0])) {
              p2[0] = Math.random() * linkDistance;
            }
            if ((0, util_1.isNaN)(p2[1])) {
              p2[1] = Math.random() * linkDistance;
            }
          });
          self2.positions = positions;
          positions.forEach(function(p2, i3) {
            nodes[i3].x = p2[0] + center[0];
            nodes[i3].y = p2[1] + center[1];
          });
          positions.forEach(function(p2) {
            p2[0] -= positions[focusIndex][0];
            p2[1] -= positions[focusIndex][1];
          });
          self2.run();
          var preventOverlap = self2.preventOverlap;
          var nodeSize = self2.nodeSize;
          var nodeSizeFunc;
          var strictRadial = self2.strictRadial;
          if (preventOverlap) {
            var nodeSpacing_1 = self2.nodeSpacing;
            var nodeSpacingFunc_1;
            if ((0, util_1.isNumber)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = function() {
                return nodeSpacing_1;
              };
            } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = nodeSpacing_1;
            } else {
              nodeSpacingFunc_1 = function() {
                return 0;
              };
            }
            if (!nodeSize) {
              nodeSizeFunc = function(d2) {
                if (d2.size) {
                  if ((0, util_1.isArray)(d2.size)) {
                    var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                    return res + nodeSpacingFunc_1(d2);
                  }
                  if ((0, util_1.isObject)(d2.size)) {
                    var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                    return res + nodeSpacingFunc_1(d2);
                  }
                  return d2.size + nodeSpacingFunc_1(d2);
                }
                return 10 + nodeSpacingFunc_1(d2);
              };
            } else if ((0, util_1.isArray)(nodeSize)) {
              nodeSizeFunc = function(d2) {
                var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
                return res + nodeSpacingFunc_1(d2);
              };
            } else {
              nodeSizeFunc = function(d2) {
                return nodeSize + nodeSpacingFunc_1(d2);
              };
            }
            var nonoverlapForceParams = {
              nodes,
              nodeSizeFunc,
              adjMatrix: adjMatrix3,
              positions,
              radii,
              height,
              width,
              strictRadial,
              focusID: focusIndex,
              iterations: self2.maxPreventOverlapIteration || 200,
              k: positions.length / 4.5
            };
            var nonoverlapForce = new radialNonoverlapForce_1.default(nonoverlapForceParams);
            positions = nonoverlapForce.layout();
          }
          positions.forEach(function(p2, i3) {
            nodes[i3].x = p2[0] + center[0];
            nodes[i3].y = p2[1] + center[1];
          });
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        RadialLayout3.prototype.run = function() {
          var self2 = this;
          var maxIteration = self2.maxIteration;
          var positions = self2.positions || [];
          var W2 = self2.weights || [];
          var eIdealDis = self2.eIdealDistances || [];
          var radii = self2.radii || [];
          for (var i2 = 0; i2 <= maxIteration; i2++) {
            var param = i2 / maxIteration;
            self2.oneIteration(param, positions, radii, eIdealDis, W2);
          }
        };
        RadialLayout3.prototype.oneIteration = function(param, positions, radii, D3, W2) {
          var self2 = this;
          var vparam = 1 - param;
          var focusIndex = self2.focusIndex;
          positions.forEach(function(v2, i2) {
            var originDis = getEDistance(v2, [0, 0]);
            var reciODis = originDis === 0 ? 0 : 1 / originDis;
            if (i2 === focusIndex) {
              return;
            }
            var xMolecule = 0;
            var yMolecule = 0;
            var denominator = 0;
            positions.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              var edis = getEDistance(v2, u2);
              var reciEdis = edis === 0 ? 0 : 1 / edis;
              var idealDis = D3[j2][i2];
              denominator += W2[i2][j2];
              xMolecule += W2[i2][j2] * (u2[0] + idealDis * (v2[0] - u2[0]) * reciEdis);
              yMolecule += W2[i2][j2] * (u2[1] + idealDis * (v2[1] - u2[1]) * reciEdis);
            });
            var reciR = radii[i2] === 0 ? 0 : 1 / radii[i2];
            denominator *= vparam;
            denominator += param * reciR * reciR;
            xMolecule *= vparam;
            xMolecule += param * reciR * v2[0] * reciODis;
            v2[0] = xMolecule / denominator;
            yMolecule *= vparam;
            yMolecule += param * reciR * v2[1] * reciODis;
            v2[1] = yMolecule / denominator;
          });
        };
        RadialLayout3.prototype.eIdealDisMatrix = function() {
          var self2 = this;
          var nodes = self2.nodes;
          if (!nodes)
            return [];
          var D3 = self2.distances;
          var linkDis = self2.linkDistance;
          var radii = self2.radii || [];
          var unitRadius = self2.unitRadius || 50;
          var result = [];
          if (D3) {
            D3.forEach(function(row, i2) {
              var newRow = [];
              row.forEach(function(v2, j2) {
                if (i2 === j2) {
                  newRow.push(0);
                } else if (radii[i2] === radii[j2]) {
                  if (self2.sortBy === "data") {
                    newRow.push(v2 * (Math.abs(i2 - j2) * self2.sortStrength) / (radii[i2] / unitRadius));
                  } else if (self2.sortBy) {
                    var iValue = nodes[i2][self2.sortBy] || 0;
                    var jValue = nodes[j2][self2.sortBy] || 0;
                    if ((0, util_1.isString)(iValue)) {
                      iValue = iValue.charCodeAt(0);
                    }
                    if ((0, util_1.isString)(jValue)) {
                      jValue = jValue.charCodeAt(0);
                    }
                    newRow.push(v2 * (Math.abs(iValue - jValue) * self2.sortStrength) / (radii[i2] / unitRadius));
                  } else {
                    newRow.push(v2 * linkDis / (radii[i2] / unitRadius));
                  }
                } else {
                  var link = (linkDis + unitRadius) / 2;
                  newRow.push(v2 * link);
                }
              });
              result.push(newRow);
            });
          }
          return result;
        };
        RadialLayout3.prototype.handleInfinity = function(matrix, focusIndex, step) {
          var length6 = matrix.length;
          for (var i2 = 0; i2 < length6; i2++) {
            if (matrix[focusIndex][i2] === Infinity) {
              matrix[focusIndex][i2] = step;
              matrix[i2][focusIndex] = step;
              for (var j2 = 0; j2 < length6; j2++) {
                if (matrix[i2][j2] !== Infinity && matrix[focusIndex][j2] === Infinity) {
                  matrix[focusIndex][j2] = step + matrix[i2][j2];
                  matrix[j2][focusIndex] = step + matrix[i2][j2];
                }
              }
            }
          }
          for (var i2 = 0; i2 < length6; i2++) {
            if (i2 === focusIndex) {
              continue;
            }
            for (var j2 = 0; j2 < length6; j2++) {
              if (matrix[i2][j2] === Infinity) {
                var minus = Math.abs(matrix[focusIndex][i2] - matrix[focusIndex][j2]);
                minus = minus === 0 ? 1 : minus;
                matrix[i2][j2] = minus;
              }
            }
          }
        };
        RadialLayout3.prototype.maxToFocus = function(matrix, focusIndex) {
          var max8 = 0;
          for (var i2 = 0; i2 < matrix[focusIndex].length; i2++) {
            if (matrix[focusIndex][i2] === Infinity) {
              continue;
            }
            max8 = matrix[focusIndex][i2] > max8 ? matrix[focusIndex][i2] : max8;
          }
          return max8;
        };
        RadialLayout3.prototype.getType = function() {
          return "radial";
        };
        return RadialLayout3;
      }(base_1.Base)
    );
    exports.RadialLayout = RadialLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/radial/index.js
var require_radial2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding2(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_radial(), exports);
  }
});

// node_modules/@antv/layout/lib/layout/concentric.js
var require_concentric = __commonJS({
  "node_modules/@antv/layout/lib/layout/concentric.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConcentricLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var ConcentricLayout2 = (
      /** @class */
      function(_super) {
        __extends17(ConcentricLayout3, _super);
        function ConcentricLayout3(options) {
          var _this = _super.call(this) || this;
          _this.nodeSize = 30;
          _this.minNodeSpacing = 10;
          _this.nodeSpacing = 10;
          _this.preventOverlap = false;
          _this.equidistant = false;
          _this.startAngle = 3 / 2 * Math.PI;
          _this.clockwise = true;
          _this.sortBy = "degree";
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        ConcentricLayout3.prototype.getDefaultCfg = function() {
          return {
            nodeSize: 30,
            minNodeSpacing: 10,
            nodeSpacing: 10,
            preventOverlap: false,
            sweep: void 0,
            equidistant: false,
            startAngle: 3 / 2 * Math.PI,
            clockwise: true,
            maxLevelDiff: void 0,
            sortBy: "degree"
          };
        };
        ConcentricLayout3.prototype.execute = function() {
          var _a2, _b;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges;
          var n2 = nodes.length;
          if (n2 === 0) {
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (n2 === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
            return;
          }
          var nodeSize = self2.nodeSize, nodeSpacing = self2.nodeSpacing;
          var layoutNodes = [];
          var maxNodeSize;
          var maxNodeSpacing = 0;
          if ((0, util_1.isArray)(nodeSize)) {
            maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
          } else {
            maxNodeSize = nodeSize;
          }
          if ((0, util_1.isArray)(nodeSpacing)) {
            maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
          } else if ((0, util_1.isNumber)(nodeSpacing)) {
            maxNodeSpacing = nodeSpacing;
          }
          nodes.forEach(function(node) {
            layoutNodes.push(node);
            var nodeSize2 = maxNodeSize;
            if ((0, util_1.isArray)(node.size)) {
              nodeSize2 = Math.max(node.size[0], node.size[1]);
            } else if ((0, util_1.isNumber)(node.size)) {
              nodeSize2 = node.size;
            } else if ((0, util_1.isObject)(node.size)) {
              nodeSize2 = Math.max(node.size.width, node.size.height);
            }
            maxNodeSize = Math.max(maxNodeSize, nodeSize2);
            if ((0, util_1.isFunction)(nodeSpacing)) {
              maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
            }
          });
          self2.clockwise = self2.counterclockwise !== void 0 ? !self2.counterclockwise : self2.clockwise;
          var nodeMap = {};
          var indexMap = {};
          layoutNodes.forEach(function(node, i3) {
            nodeMap[node.id] = node;
            indexMap[node.id] = i3;
          });
          if (self2.sortBy === "degree" || !(0, util_1.isString)(self2.sortBy) || layoutNodes[0][self2.sortBy] === void 0) {
            self2.sortBy = "degree";
            if (!(0, util_1.isNumber)(nodes[0].degree)) {
              var values_1 = (0, util_1.getDegree)(nodes.length, indexMap, edges);
              layoutNodes.forEach(function(node, i3) {
                node.degree = values_1[i3].all;
              });
            }
          }
          layoutNodes.sort(function(n1, n22) {
            return n22[self2.sortBy] - n1[self2.sortBy];
          });
          self2.maxValueNode = layoutNodes[0];
          self2.maxLevelDiff = self2.maxLevelDiff || self2.maxValueNode[self2.sortBy] / 4;
          var levels = [[]];
          var currentLevel = levels[0];
          layoutNodes.forEach(function(node) {
            if (currentLevel.length > 0) {
              var diff = Math.abs(currentLevel[0][self2.sortBy] - node[self2.sortBy]);
              if (self2.maxLevelDiff && diff >= self2.maxLevelDiff) {
                currentLevel = [];
                levels.push(currentLevel);
              }
            }
            currentLevel.push(node);
          });
          var minDist = maxNodeSize + (maxNodeSpacing || self2.minNodeSpacing);
          if (!self2.preventOverlap) {
            var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
            var maxR = Math.min(self2.width, self2.height) / 2 - minDist;
            var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
            minDist = Math.min(minDist, rStep);
          }
          var r2 = 0;
          levels.forEach(function(level2) {
            var sweep = self2.sweep;
            if (sweep === void 0) {
              sweep = 2 * Math.PI - 2 * Math.PI / level2.length;
            }
            var dTheta = level2.dTheta = sweep / Math.max(1, level2.length - 1);
            if (level2.length > 1 && self2.preventOverlap) {
              var dcos = Math.cos(dTheta) - Math.cos(0);
              var dsin = Math.sin(dTheta) - Math.sin(0);
              var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin));
              r2 = Math.max(rMin, r2);
            }
            level2.r = r2;
            r2 += minDist;
          });
          if (self2.equidistant) {
            var rDeltaMax_1 = 0;
            var rr_1 = 0;
            for (var i2 = 0; i2 < levels.length; i2++) {
              var level = levels[i2];
              var rDelta = level.r - rr_1;
              rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);
            }
            rr_1 = 0;
            levels.forEach(function(level2, i3) {
              if (i3 === 0) {
                rr_1 = level2.r;
              }
              level2.r = rr_1;
              rr_1 += rDeltaMax_1;
            });
          }
          levels.forEach(function(level2) {
            var dTheta = level2.dTheta;
            var rr2 = level2.r;
            level2.forEach(function(node, j2) {
              var theta = self2.startAngle + (self2.clockwise ? 1 : -1) * dTheta * j2;
              node.x = center[0] + rr2 * Math.cos(theta);
              node.y = center[1] + rr2 * Math.sin(theta);
            });
          });
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        ConcentricLayout3.prototype.getType = function() {
          return "concentric";
        };
        return ConcentricLayout3;
      }(base_1.Base)
    );
    exports.ConcentricLayout = ConcentricLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/mds.js
var require_mds2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/mds.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MDSLayout = void 0;
    var ml_matrix_1 = (init_src5(), __toCommonJS(src_exports5));
    var util_1 = require_util2();
    var base_1 = require_base();
    var MDSLayout2 = (
      /** @class */
      function(_super) {
        __extends17(MDSLayout3, _super);
        function MDSLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.linkDistance = 50;
          _this.nodes = [];
          _this.edges = [];
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        MDSLayout3.prototype.getDefaultCfg = function() {
          return {
            center: [0, 0],
            linkDistance: 50
          };
        };
        MDSLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, _a2 = self2.edges, edges = _a2 === void 0 ? [] : _a2;
          var center = self2.center;
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          var linkDistance = self2.linkDistance;
          var adjMatrix3 = (0, util_1.getAdjMatrix)({ nodes, edges }, false);
          var distances = (0, util_1.floydWarshall)(adjMatrix3);
          self2.handleInfinity(distances);
          var scaledD = (0, util_1.scaleMatrix)(distances, linkDistance);
          self2.scaledDistances = scaledD;
          var positions = self2.runMDS();
          self2.positions = positions;
          positions.forEach(function(p2, i2) {
            nodes[i2].x = p2[0] + center[0];
            nodes[i2].y = p2[1] + center[1];
          });
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        MDSLayout3.prototype.runMDS = function() {
          var self2 = this;
          var dimension = 2;
          var distances = self2.scaledDistances;
          var M2 = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);
          var rowMeans = M2.mean("row");
          var colMeans = M2.mean("column");
          var totalMean = M2.mean();
          M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
          var ret = new ml_matrix_1.SingularValueDecomposition(M2);
          var eigenValues = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();
          return ret.leftSingularVectors.toJSON().map(function(row) {
            return ml_matrix_1.Matrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);
          });
        };
        MDSLayout3.prototype.handleInfinity = function(distances) {
          var maxDistance = -999999;
          distances.forEach(function(row) {
            row.forEach(function(value) {
              if (value === Infinity) {
                return;
              }
              if (maxDistance < value) {
                maxDistance = value;
              }
            });
          });
          distances.forEach(function(row, i2) {
            row.forEach(function(value, j2) {
              if (value === Infinity) {
                distances[i2][j2] = maxDistance;
              }
            });
          });
        };
        MDSLayout3.prototype.getType = function() {
          return "mds";
        };
        return MDSLayout3;
      }(base_1.Base)
    );
    exports.MDSLayout = MDSLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/fruchterman.js
var require_fruchterman = __commonJS({
  "node_modules/@antv/layout/lib/layout/fruchterman.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FruchtermanLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var SPEED_DIVISOR = 800;
    var FruchtermanLayout2 = (
      /** @class */
      function(_super) {
        __extends17(FruchtermanLayout3, _super);
        function FruchtermanLayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.workerEnabled = false;
          _this.gravity = 10;
          _this.speed = 5;
          _this.clustering = false;
          _this.clusterGravity = 10;
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.onLayoutEnd = function() {
          };
          _this.tick = function() {
          };
          _this.animate = true;
          _this.updateCfg(options);
          return _this;
        }
        FruchtermanLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 1e3,
            gravity: 10,
            speed: 1,
            clustering: false,
            clusterGravity: 10,
            animate: true
          };
        };
        FruchtermanLayout3.prototype.execute = function() {
          var _this = this;
          var _a2, _b;
          var self2 = this;
          var nodes = self2.nodes;
          if (self2.timeInterval !== void 0 && typeof window !== "undefined") {
            window.clearInterval(self2.timeInterval);
          }
          if (!nodes || nodes.length === 0) {
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
            return;
          }
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * _this.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * _this.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          return self2.run();
        };
        FruchtermanLayout3.prototype.run = function() {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes;
          if (!nodes)
            return;
          var edges = self2.edges, maxIteration = self2.maxIteration, workerEnabled = self2.workerEnabled, clustering = self2.clustering, animate = self2.animate;
          var clusterMap = {};
          if (clustering) {
            nodes.forEach(function(n2) {
              if (clusterMap[n2.cluster] === void 0) {
                clusterMap[n2.cluster] = {
                  name: n2.cluster,
                  cx: 0,
                  cy: 0,
                  count: 0
                };
              }
            });
          }
          if (workerEnabled || !animate) {
            for (var i2 = 0; i2 < maxIteration; i2++) {
              self2.runOneStep(clusterMap);
            }
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          } else {
            if (typeof window === "undefined")
              return;
            var iter_1 = 0;
            this.timeInterval = window.setInterval(function() {
              var _a3;
              self2.runOneStep(clusterMap);
              iter_1++;
              if (iter_1 >= maxIteration) {
                (_a3 = self2.onLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(self2);
                window.clearInterval(self2.timeInterval);
              }
            }, 0);
          }
          return {
            nodes,
            edges
          };
        };
        FruchtermanLayout3.prototype.runOneStep = function(clusterMap) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes;
          if (!nodes)
            return;
          var edges = self2.edges, center = self2.center, gravity = self2.gravity, speed = self2.speed, clustering = self2.clustering;
          var area = self2.height * self2.width;
          var maxDisplace = Math.sqrt(area) / 10;
          var k2 = area / (nodes.length + 1);
          var k3 = Math.sqrt(k2);
          var displacements = [];
          nodes.forEach(function(_2, j2) {
            displacements[j2] = { x: 0, y: 0 };
          });
          self2.applyCalculate(nodes, edges, displacements, k3, k2);
          if (clustering) {
            for (var key in clusterMap) {
              clusterMap[key].cx = 0;
              clusterMap[key].cy = 0;
              clusterMap[key].count = 0;
            }
            nodes.forEach(function(n2) {
              var c3 = clusterMap[n2.cluster];
              if ((0, util_1.isNumber)(n2.x)) {
                c3.cx += n2.x;
              }
              if ((0, util_1.isNumber)(n2.y)) {
                c3.cy += n2.y;
              }
              c3.count++;
            });
            for (var key in clusterMap) {
              clusterMap[key].cx /= clusterMap[key].count;
              clusterMap[key].cy /= clusterMap[key].count;
            }
            var clusterGravity_1 = self2.clusterGravity || gravity;
            nodes.forEach(function(n2, j2) {
              if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
                return;
              var c3 = clusterMap[n2.cluster];
              var distLength = Math.sqrt((n2.x - c3.cx) * (n2.x - c3.cx) + (n2.y - c3.cy) * (n2.y - c3.cy));
              var gravityForce = k3 * clusterGravity_1;
              displacements[j2].x -= gravityForce * (n2.x - c3.cx) / distLength;
              displacements[j2].y -= gravityForce * (n2.y - c3.cy) / distLength;
            });
          }
          nodes.forEach(function(n2, j2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            var gravityForce = 0.01 * k3 * gravity;
            displacements[j2].x -= gravityForce * (n2.x - center[0]);
            displacements[j2].y -= gravityForce * (n2.y - center[1]);
          });
          nodes.forEach(function(n2, j2) {
            if ((0, util_1.isNumber)(n2.fx) && (0, util_1.isNumber)(n2.fy)) {
              n2.x = n2.fx;
              n2.y = n2.fy;
              return;
            }
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            var distLength = Math.sqrt(displacements[j2].x * displacements[j2].x + displacements[j2].y * displacements[j2].y);
            if (distLength > 0) {
              var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
              n2.x += displacements[j2].x / distLength * limitedDist;
              n2.y += displacements[j2].y / distLength * limitedDist;
            }
          });
          (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
        };
        FruchtermanLayout3.prototype.applyCalculate = function(nodes, edges, displacements, k2, k22) {
          var self2 = this;
          self2.calRepulsive(nodes, displacements, k22);
          if (edges)
            self2.calAttractive(edges, displacements, k2);
        };
        FruchtermanLayout3.prototype.calRepulsive = function(nodes, displacements, k2) {
          nodes.forEach(function(v2, i2) {
            displacements[i2] = { x: 0, y: 0 };
            nodes.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
                return;
              }
              var vecX = v2.x - u2.x;
              var vecY = v2.y - u2.y;
              var vecLengthSqr = vecX * vecX + vecY * vecY;
              if (vecLengthSqr === 0) {
                vecLengthSqr = 1;
                var sign = i2 > j2 ? 1 : -1;
                vecX = 0.01 * sign;
                vecY = 0.01 * sign;
              }
              var common = k2 / vecLengthSqr;
              displacements[i2].x += vecX * common;
              displacements[i2].y += vecY * common;
            });
          });
        };
        FruchtermanLayout3.prototype.calAttractive = function(edges, displacements, k2) {
          var _this = this;
          edges.forEach(function(e8) {
            var source = (0, util_1.getEdgeTerminal)(e8, "source");
            var target = (0, util_1.getEdgeTerminal)(e8, "target");
            if (!source || !target)
              return;
            var uIndex = _this.nodeIdxMap[source];
            var vIndex = _this.nodeIdxMap[target];
            if (uIndex === vIndex) {
              return;
            }
            var u2 = _this.nodeMap[source];
            var v2 = _this.nodeMap[target];
            if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
              return;
            }
            var vecX = v2.x - u2.x;
            var vecY = v2.y - u2.y;
            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            var common = vecLength * vecLength / k2;
            displacements[vIndex].x -= vecX / vecLength * common;
            displacements[vIndex].y -= vecY / vecLength * common;
            displacements[uIndex].x += vecX / vecLength * common;
            displacements[uIndex].y += vecY / vecLength * common;
          });
        };
        FruchtermanLayout3.prototype.stop = function() {
          if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
          }
        };
        FruchtermanLayout3.prototype.destroy = function() {
          var self2 = this;
          self2.stop();
          self2.tick = null;
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        FruchtermanLayout3.prototype.getType = function() {
          return "fruchterman";
        };
        return FruchtermanLayout3;
      }(base_1.Base)
    );
    exports.FruchtermanLayout = FruchtermanLayout2;
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n2, t4, e8, r2, o2, a3, c3) {
  try {
    var i2 = n2[a3](c3), u2 = i2.value;
  } catch (n3) {
    return void e8(n3);
  }
  i2.done ? t4(u2) : Promise.resolve(u2).then(r2, o2);
}
function _asyncToGenerator(n2) {
  return function() {
    var t4 = this, e8 = arguments;
    return new Promise(function(r2, o2) {
      var a3 = n2.apply(t4, e8);
      function _next(n3) {
        asyncGeneratorStep(a3, r2, o2, _next, _throw, "next", n3);
      }
      function _throw(n3) {
        asyncGeneratorStep(a3, r2, o2, _next, _throw, "throw", n3);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof6(o2) {
  "@babel/helpers - typeof";
  return _typeof6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof6(o2);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t4, r2) {
  if ("object" != _typeof6(t4) || !t4) return t4;
  var e8 = t4[Symbol.toPrimitive];
  if (void 0 !== e8) {
    var i2 = e8.call(t4, r2 || "default");
    if ("object" != _typeof6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t4);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t4) {
  var i2 = toPrimitive(t4, "string");
  return "symbol" == _typeof6(i2) ? i2 : i2 + "";
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty2(e8, r2, t4) {
  return (r2 = toPropertyKey(r2)) in e8 ? Object.defineProperty(e8, r2, {
    value: t4,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e8[r2] = t4, e8;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck5(a3, n2) {
  if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties5(e8, r2) {
  for (var t4 = 0; t4 < r2.length; t4++) {
    var o2 = r2[t4];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e8, toPropertyKey(o2.key), o2);
  }
}
function _createClass5(e8, r2, t4) {
  return r2 && _defineProperties5(e8.prototype, r2), t4 && _defineProperties5(e8, t4), Object.defineProperty(e8, "prototype", {
    writable: false
  }), e8;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto3 = Object.prototype;
    var hasOwnProperty7 = objectProto3.hasOwnProperty;
    var nativeObjectToString = objectProto3.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty7.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e8) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto3 = Object.prototype;
    var nativeObjectToString = objectProto3.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike3(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike3;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike3 = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike3(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e8) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike3 = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber3(value) {
      return typeof value == "number" || isObjectLike3(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber3;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray2 = Array.isArray;
    module.exports = isArray2;
  }
});

// node_modules/@babel/runtime/helpers/OverloadYield.js
var require_OverloadYield = __commonJS({
  "node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module) {
    function _OverloadYield(e8, d2) {
      this.v = e8, this.k = d2;
    }
    module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorDefine.js
var require_regeneratorDefine = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module) {
    function _regeneratorDefine(e8, r2, n2, t4) {
      var i2 = Object.defineProperty;
      try {
        i2({}, "", {});
      } catch (e9) {
        i2 = 0;
      }
      module.exports = _regeneratorDefine = function regeneratorDefine(e9, r3, n3, t5) {
        function o2(r4, n4) {
          _regeneratorDefine(e9, r4, function(e11) {
            return this._invoke(r4, n4, e11);
          });
        }
        r3 ? i2 ? i2(e9, r3, {
          value: n3,
          enumerable: !t5,
          configurable: !t5,
          writable: !t5
        }) : e9[r3] = n3 : (o2("next", 0), o2("throw", 1), o2("return", 2));
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e8, r2, n2, t4);
    }
    module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regenerator.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/regenerator.js"(exports, module) {
    var regeneratorDefine = require_regeneratorDefine();
    function _regenerator() {
      var e8, t4, r2 = "function" == typeof Symbol ? Symbol : {}, n2 = r2.iterator || "@@iterator", o2 = r2.toStringTag || "@@toStringTag";
      function i2(r3, n3, o3, i3) {
        var c4 = n3 && n3.prototype instanceof Generator ? n3 : Generator, u3 = Object.create(c4.prototype);
        return regeneratorDefine(u3, "_invoke", function(r4, n4, o4) {
          var i4, c5, u4, f3 = 0, p2 = o4 || [], y4 = false, G2 = {
            p: 0,
            n: 0,
            v: e8,
            a: d2,
            f: d2.bind(e8, 4),
            d: function d3(t5, r5) {
              return i4 = t5, c5 = 0, u4 = e8, G2.n = r5, a3;
            }
          };
          function d2(r5, n5) {
            for (c5 = r5, u4 = n5, t4 = 0; !y4 && f3 && !o5 && t4 < p2.length; t4++) {
              var o5, i5 = p2[t4], d3 = G2.p, l2 = i5[2];
              r5 > 3 ? (o5 = l2 === n5) && (u4 = i5[(c5 = i5[4]) ? 5 : (c5 = 3, 3)], i5[4] = i5[5] = e8) : i5[0] <= d3 && ((o5 = r5 < 2 && d3 < i5[1]) ? (c5 = 0, G2.v = n5, G2.n = i5[1]) : d3 < l2 && (o5 = r5 < 3 || i5[0] > n5 || n5 > l2) && (i5[4] = r5, i5[5] = n5, G2.n = l2, c5 = 0));
            }
            if (o5 || r5 > 1) return a3;
            throw y4 = true, n5;
          }
          return function(o5, p3, l2) {
            if (f3 > 1) throw TypeError("Generator is already running");
            for (y4 && 1 === p3 && d2(p3, l2), c5 = p3, u4 = l2; (t4 = c5 < 2 ? e8 : u4) || !y4; ) {
              i4 || (c5 ? c5 < 3 ? (c5 > 1 && (G2.n = -1), d2(c5, u4)) : G2.n = u4 : G2.v = u4);
              try {
                if (f3 = 2, i4) {
                  if (c5 || (o5 = "next"), t4 = i4[o5]) {
                    if (!(t4 = t4.call(i4, u4))) throw TypeError("iterator result is not an object");
                    if (!t4.done) return t4;
                    u4 = t4.value, c5 < 2 && (c5 = 0);
                  } else 1 === c5 && (t4 = i4["return"]) && t4.call(i4), c5 < 2 && (u4 = TypeError("The iterator does not provide a '" + o5 + "' method"), c5 = 1);
                  i4 = e8;
                } else if ((t4 = (y4 = G2.n < 0) ? u4 : r4.call(n4, G2)) !== a3) break;
              } catch (t5) {
                i4 = e8, c5 = 1, u4 = t5;
              } finally {
                f3 = 1;
              }
            }
            return {
              value: t4,
              done: y4
            };
          };
        }(r3, o3, i3), true), u3;
      }
      var a3 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t4 = Object.getPrototypeOf;
      var c3 = [][n2] ? t4(t4([][n2]())) : (regeneratorDefine(t4 = {}, n2, function() {
        return this;
      }), t4), u2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c3);
      function f2(e9) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e9, GeneratorFunctionPrototype) : (e9.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e9, o2, "GeneratorFunction")), e9.prototype = Object.create(u2), e9;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u2, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o2, "GeneratorFunction"), regeneratorDefine(u2), regeneratorDefine(u2, o2, "Generator"), regeneratorDefine(u2, n2, function() {
        return this;
      }), regeneratorDefine(u2, "toString", function() {
        return "[object Generator]";
      }), (module.exports = _regenerator = function _regenerator2() {
        return {
          w: i2,
          m: f2
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
var require_regeneratorAsyncIterator = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regeneratorDefine = require_regeneratorDefine();
    function AsyncIterator2(t4, e8) {
      function n2(r3, o2, i2, f2) {
        try {
          var c3 = t4[r3](o2), u2 = c3.value;
          return u2 instanceof OverloadYield ? e8.resolve(u2.v).then(function(t5) {
            n2("next", t5, i2, f2);
          }, function(t5) {
            n2("throw", t5, i2, f2);
          }) : e8.resolve(u2).then(function(t5) {
            c3.value = t5, i2(c3);
          }, function(t5) {
            return n2("throw", t5, i2, f2);
          });
        } catch (t5) {
          f2(t5);
        }
      }
      var r2;
      this.next || (regeneratorDefine(AsyncIterator2.prototype), regeneratorDefine(AsyncIterator2.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
        return this;
      })), regeneratorDefine(this, "_invoke", function(t5, o2, i2) {
        function f2() {
          return new e8(function(e9, r3) {
            n2(t5, i2, e9, r3);
          });
        }
        return r2 = r2 ? r2.then(f2, f2) : f2();
      }, true);
    }
    module.exports = AsyncIterator2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
var require_regeneratorAsyncGen = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module) {
    var regenerator = require_regenerator();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    function _regeneratorAsyncGen(r2, e8, t4, o2, n2) {
      return new regeneratorAsyncIterator(regenerator().w(r2, e8, t4, o2), n2 || Promise);
    }
    module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsync.js
var require_regeneratorAsync = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module) {
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    function _regeneratorAsync(n2, e8, r2, t4, o2) {
      var a3 = regeneratorAsyncGen(n2, e8, r2, t4, o2);
      return a3.next().then(function(n3) {
        return n3.done ? n3.value : a3.next();
      });
    }
    module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorKeys.js
var require_regeneratorKeys = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module) {
    function _regeneratorKeys(e8) {
      var n2 = Object(e8), r2 = [];
      for (var t4 in n2) r2.unshift(t4);
      return function e9() {
        for (; r2.length; ) if ((t4 = r2.pop()) in n2) return e9.value = t4, e9.done = false, e9;
        return e9.done = true, e9;
      };
    }
    module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof9(o2) {
      "@babel/helpers - typeof";
      return module.exports = _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof9(o2);
    }
    module.exports = _typeof9, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorValues.js
var require_regeneratorValues = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module) {
    var _typeof9 = require_typeof()["default"];
    function _regeneratorValues(e8) {
      if (null != e8) {
        var t4 = e8["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r2 = 0;
        if (t4) return t4.call(e8);
        if ("function" == typeof e8.next) return e8;
        if (!isNaN(e8.length)) return {
          next: function next() {
            return e8 && r2 >= e8.length && (e8 = void 0), {
              value: e8 && e8[r2++],
              done: !e8
            };
          }
        };
      }
      throw new TypeError(_typeof9(e8) + " is not iterable");
    }
    module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regenerator = require_regenerator();
    var regeneratorAsync = require_regeneratorAsync();
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    var regeneratorKeys = require_regeneratorKeys();
    var regeneratorValues = require_regeneratorValues();
    function _regeneratorRuntime5() {
      "use strict";
      var r2 = regenerator(), e8 = r2.m(_regeneratorRuntime5), t4 = (Object.getPrototypeOf ? Object.getPrototypeOf(e8) : e8.__proto__).constructor;
      function n2(r3) {
        var e9 = "function" == typeof r3 && r3.constructor;
        return !!e9 && (e9 === t4 || "GeneratorFunction" === (e9.displayName || e9.name));
      }
      var o2 = {
        "throw": 1,
        "return": 2,
        "break": 3,
        "continue": 3
      };
      function a3(r3) {
        var e9, t5;
        return function(n3) {
          e9 || (e9 = {
            stop: function stop() {
              return t5(n3.a, 2);
            },
            "catch": function _catch() {
              return n3.v;
            },
            abrupt: function abrupt(r4, e11) {
              return t5(n3.a, o2[r4], e11);
            },
            delegateYield: function delegateYield(r4, o3, a4) {
              return e9.resultName = o3, t5(n3.d, regeneratorValues(r4), a4);
            },
            finish: function finish(r4) {
              return t5(n3.f, r4);
            }
          }, t5 = function t6(r4, _t2, o3) {
            n3.p = e9.prev, n3.n = e9.next;
            try {
              return r4(_t2, o3);
            } finally {
              e9.next = n3.n;
            }
          }), e9.resultName && (e9[e9.resultName] = n3.v, e9.resultName = void 0), e9.sent = n3.v, e9.next = n3.n;
          try {
            return r3.call(this, e9);
          } finally {
            n3.p = e9.prev, n3.n = e9.next;
          }
        };
      }
      return (module.exports = _regeneratorRuntime5 = function _regeneratorRuntime6() {
        return {
          wrap: function wrap2(e9, t5, n3, o3) {
            return r2.w(a3(e9), t5, n3, o3 && o3.reverse());
          },
          isGeneratorFunction: n2,
          mark: r2.m,
          awrap: function awrap(r3, e9) {
            return new OverloadYield(r3, e9);
          },
          AsyncIterator: regeneratorAsyncIterator,
          async: function async(r3, e9, t5, o3, u2) {
            return (n2(e9) ? regeneratorAsyncGen : regeneratorAsync)(a3(r3), e9, t5, o3, u2);
          },
          keys: regeneratorKeys,
          values: regeneratorValues
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regeneratorRuntime5, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator2 = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@antv/g-webgpu-core/es/Entity.js
function createEntity() {
  return entitySequence++;
}
var EMPTY, entitySequence;
var init_Entity = __esm({
  "node_modules/@antv/g-webgpu-core/es/Entity.js"() {
    EMPTY = -1;
    entitySequence = 1;
  }
});

// node_modules/@antv/g-webgpu-core/es/ComponentManager.js
var import_regenerator, Component, ComponentManager;
var init_ComponentManager = __esm({
  "node_modules/@antv/g-webgpu-core/es/ComponentManager.js"() {
    init_asyncToGenerator();
    init_createClass();
    init_classCallCheck();
    import_regenerator = __toESM(require_regenerator2());
    init_Entity();
    Component = _createClass5(
      function Component2(data) {
        _classCallCheck5(this, Component2);
      }
      //
    );
    ComponentManager = function() {
      function ComponentManager2(clazz) {
        _classCallCheck5(this, ComponentManager2);
        this.clazz = void 0;
        this.components = [];
        this.entities = [];
        this.lookup = {};
        this.clazz = clazz;
      }
      _createClass5(ComponentManager2, [{
        key: "clear",
        value: function clear() {
          this.components = [];
          this.entities = [];
          this.lookup = {};
        }
      }, {
        key: "contains",
        value: function contains3(entity) {
          return this.lookup[entity] > -1;
        }
      }, {
        key: "create",
        value: function create10(entity, data) {
          this.lookup[entity] = this.components.length;
          var component = new this.clazz(data || {});
          this.components.push(component);
          this.entities.push(entity);
          return component;
        }
      }, {
        key: "remove",
        value: function remove3(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            if (componentIndex < this.components.length - 1) {
              this.components[componentIndex] = this.components[this.components.length - 1];
              this.entities[componentIndex] = this.entities[this.entities.length - 1];
              this.lookup[this.entities[componentIndex]] = componentIndex;
            }
          }
          this.components.pop();
          this.entities.pop();
          delete this.lookup[entity];
        }
      }, {
        key: "removeKeepSorted",
        value: function removeKeepSorted(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            var entity2 = this.entities[componentIndex];
            if (componentIndex < this.components.length - 1) {
              for (var _i2 = componentIndex + 1; _i2 < this.components.length; ++_i2) {
                this.components[_i2 - 1] = this.components[_i2];
              }
              for (var _i22 = componentIndex + 1; _i22 < this.entities.length; ++_i22) {
                this.entities[_i22 - 1] = this.entities[_i22];
                this.lookup[this.entities[_i22 - 1]] = _i22 - 1;
              }
            }
            this.components.pop();
            this.entities.pop();
            delete this.lookup[entity2];
          }
        }
      }, {
        key: "moveItem",
        value: function moveItem(srcIndex, destIndex) {
          if (srcIndex === destIndex) {
            return;
          }
          var srcComponent = this.components[srcIndex];
          var srcEntity = this.entities[srcIndex];
          var direction3 = srcIndex < destIndex ? 1 : -1;
          for (var _i3 = srcIndex; _i3 !== destIndex; _i3 += direction3) {
            var next = _i3 + direction3;
            this.components[_i3] = this.components[next];
            this.entities[_i3] = this.entities[next];
            this.lookup[this.entities[_i3]] = _i3;
          }
          this.components[destIndex] = srcComponent;
          this.entities[destIndex] = srcEntity;
          this.lookup[srcEntity] = destIndex;
        }
      }, {
        key: "getEntity",
        value: function getEntity(index2) {
          return this.entities[index2];
        }
        /**
         * 由于缺少类似 C++ 的重载操作符，没法通过 [下标] 直接访问。因此只能增加该方法用于遍历。
         */
      }, {
        key: "getComponent",
        value: function getComponent(index2) {
          return this.components[index2];
        }
      }, {
        key: "getComponentByEntity",
        value: function getComponentByEntity(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            return this.components[componentIndex];
          }
          return null;
        }
      }, {
        key: "getCount",
        value: function getCount() {
          return this.components.length;
        }
      }, {
        key: "getEntityByComponentIndex",
        value: function getEntityByComponentIndex(componentIdx) {
          for (var _i4 = 0, _Object$keys = Object.keys(this.lookup); _i4 < _Object$keys.length; _i4++) {
            var _entity = _Object$keys[_i4];
            var entityInNum = Number(_entity);
            if (this.lookup[entityInNum] === componentIdx) {
              return entityInNum;
            }
          }
          return EMPTY;
        }
      }, {
        key: "find",
        value: function find4(callback) {
          for (var _i5 = 0; _i5 < this.getCount(); _i5++) {
            var _component = this.getComponent(_i5);
            if (callback(_component, _i5)) {
              return _component;
            }
          }
          return null;
        }
      }, {
        key: "findIndex",
        value: function findIndex3(callback) {
          for (var _i6 = 0; _i6 < this.getCount(); _i6++) {
            var _component2 = this.getComponent(_i6);
            if (callback(_component2, _i6)) {
              return _i6;
            }
          }
          return -1;
        }
      }, {
        key: "forEach",
        value: function forEach4(callback) {
          for (var _i7 = 0, _Object$keys2 = Object.keys(this.lookup); _i7 < _Object$keys2.length; _i7++) {
            var _entity2 = _Object$keys2[_i7];
            var entityInNum = Number(_entity2);
            var componentIndex = this.lookup[entityInNum];
            callback(entityInNum, this.getComponent(componentIndex));
          }
        }
      }, {
        key: "forEachAsync",
        value: function() {
          var _forEachAsync = _asyncToGenerator(import_regenerator.default.mark(function _callee(callback) {
            var _i8, _Object$keys3, _entity3, entityInNum, componentIndex;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _i8 = 0, _Object$keys3 = Object.keys(this.lookup);
                  case 1:
                    if (!(_i8 < _Object$keys3.length)) {
                      _context.next = 10;
                      break;
                    }
                    _entity3 = _Object$keys3[_i8];
                    entityInNum = Number(_entity3);
                    componentIndex = this.lookup[entityInNum];
                    _context.next = 7;
                    return callback(entityInNum, this.getComponent(componentIndex));
                  case 7:
                    _i8++;
                    _context.next = 1;
                    break;
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function forEachAsync(_x) {
            return _forEachAsync.apply(this, arguments);
          }
          return forEachAsync;
        }()
      }, {
        key: "map",
        value: function map6(callback) {
          var result = [];
          for (var _i9 = 0, _Object$keys4 = Object.keys(this.lookup); _i9 < _Object$keys4.length; _i9++) {
            var _entity4 = _Object$keys4[_i9];
            var entityInNum = Number(_entity4);
            var componentIndex = this.lookup[entityInNum];
            result.push(callback(entityInNum, this.getComponent(componentIndex)));
          }
          return result;
        }
      }]);
      return ComponentManager2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js
var gl;
var init_gl = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js"() {
    (function(gl2) {
      gl2[gl2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
      gl2[gl2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
      gl2[gl2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
      gl2[gl2["POINTS"] = 0] = "POINTS";
      gl2[gl2["LINES"] = 1] = "LINES";
      gl2[gl2["LINE_LOOP"] = 2] = "LINE_LOOP";
      gl2[gl2["LINE_STRIP"] = 3] = "LINE_STRIP";
      gl2[gl2["TRIANGLES"] = 4] = "TRIANGLES";
      gl2[gl2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      gl2[gl2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
      gl2[gl2["ZERO"] = 0] = "ZERO";
      gl2[gl2["ONE"] = 1] = "ONE";
      gl2[gl2["SRC_COLOR"] = 768] = "SRC_COLOR";
      gl2[gl2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
      gl2[gl2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
      gl2[gl2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
      gl2[gl2["DST_ALPHA"] = 772] = "DST_ALPHA";
      gl2[gl2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
      gl2[gl2["DST_COLOR"] = 774] = "DST_COLOR";
      gl2[gl2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
      gl2[gl2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
      gl2[gl2["FUNC_ADD"] = 32774] = "FUNC_ADD";
      gl2[gl2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
      gl2[gl2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
      gl2[gl2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
      gl2[gl2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
      gl2[gl2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
      gl2[gl2["MAX_EXT"] = 32776] = "MAX_EXT";
      gl2[gl2["MIN_EXT"] = 32775] = "MIN_EXT";
      gl2[gl2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
      gl2[gl2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
      gl2[gl2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
      gl2[gl2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
      gl2[gl2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
      gl2[gl2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
      gl2[gl2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
      gl2[gl2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
      gl2[gl2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
      gl2[gl2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      gl2[gl2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      gl2[gl2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
      gl2[gl2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
      gl2[gl2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
      gl2[gl2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
      gl2[gl2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
      gl2[gl2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
      gl2[gl2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
      gl2[gl2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
      gl2[gl2["FRONT"] = 1028] = "FRONT";
      gl2[gl2["BACK"] = 1029] = "BACK";
      gl2[gl2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
      gl2[gl2["CULL_FACE"] = 2884] = "CULL_FACE";
      gl2[gl2["BLEND"] = 3042] = "BLEND";
      gl2[gl2["DITHER"] = 3024] = "DITHER";
      gl2[gl2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
      gl2[gl2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
      gl2[gl2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
      gl2[gl2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
      gl2[gl2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
      gl2[gl2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
      gl2[gl2["NO_ERROR"] = 0] = "NO_ERROR";
      gl2[gl2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
      gl2[gl2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
      gl2[gl2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
      gl2[gl2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
      gl2[gl2["CW"] = 2304] = "CW";
      gl2[gl2["CCW"] = 2305] = "CCW";
      gl2[gl2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
      gl2[gl2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
      gl2[gl2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
      gl2[gl2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
      gl2[gl2["FRONT_FACE"] = 2886] = "FRONT_FACE";
      gl2[gl2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
      gl2[gl2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
      gl2[gl2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
      gl2[gl2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
      gl2[gl2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
      gl2[gl2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
      gl2[gl2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
      gl2[gl2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
      gl2[gl2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
      gl2[gl2["STENCIL_REF"] = 2967] = "STENCIL_REF";
      gl2[gl2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
      gl2[gl2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
      gl2[gl2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
      gl2[gl2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
      gl2[gl2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
      gl2[gl2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
      gl2[gl2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
      gl2[gl2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
      gl2[gl2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
      gl2[gl2["VIEWPORT"] = 2978] = "VIEWPORT";
      gl2[gl2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
      gl2[gl2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
      gl2[gl2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
      gl2[gl2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
      gl2[gl2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
      gl2[gl2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
      gl2[gl2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
      gl2[gl2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
      gl2[gl2["RED_BITS"] = 3410] = "RED_BITS";
      gl2[gl2["GREEN_BITS"] = 3411] = "GREEN_BITS";
      gl2[gl2["BLUE_BITS"] = 3412] = "BLUE_BITS";
      gl2[gl2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
      gl2[gl2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
      gl2[gl2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
      gl2[gl2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
      gl2[gl2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
      gl2[gl2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
      gl2[gl2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
      gl2[gl2["SAMPLES"] = 32937] = "SAMPLES";
      gl2[gl2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
      gl2[gl2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
      gl2[gl2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
      gl2[gl2["DONT_CARE"] = 4352] = "DONT_CARE";
      gl2[gl2["FASTEST"] = 4353] = "FASTEST";
      gl2[gl2["NICEST"] = 4354] = "NICEST";
      gl2[gl2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
      gl2[gl2["BYTE"] = 5120] = "BYTE";
      gl2[gl2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      gl2[gl2["SHORT"] = 5122] = "SHORT";
      gl2[gl2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      gl2[gl2["INT"] = 5124] = "INT";
      gl2[gl2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      gl2[gl2["FLOAT"] = 5126] = "FLOAT";
      gl2[gl2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      gl2[gl2["ALPHA"] = 6406] = "ALPHA";
      gl2[gl2["RGB"] = 6407] = "RGB";
      gl2[gl2["RGBA"] = 6408] = "RGBA";
      gl2[gl2["LUMINANCE"] = 6409] = "LUMINANCE";
      gl2[gl2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      gl2[gl2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      gl2[gl2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      gl2[gl2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      gl2[gl2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
      gl2[gl2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
      gl2[gl2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
      gl2[gl2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
      gl2[gl2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
      gl2[gl2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
      gl2[gl2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
      gl2[gl2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
      gl2[gl2["LINK_STATUS"] = 35714] = "LINK_STATUS";
      gl2[gl2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
      gl2[gl2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
      gl2[gl2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
      gl2[gl2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
      gl2[gl2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
      gl2[gl2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
      gl2[gl2["NEVER"] = 512] = "NEVER";
      gl2[gl2["LESS"] = 513] = "LESS";
      gl2[gl2["EQUAL"] = 514] = "EQUAL";
      gl2[gl2["LEQUAL"] = 515] = "LEQUAL";
      gl2[gl2["GREATER"] = 516] = "GREATER";
      gl2[gl2["NOTEQUAL"] = 517] = "NOTEQUAL";
      gl2[gl2["GEQUAL"] = 518] = "GEQUAL";
      gl2[gl2["ALWAYS"] = 519] = "ALWAYS";
      gl2[gl2["KEEP"] = 7680] = "KEEP";
      gl2[gl2["REPLACE"] = 7681] = "REPLACE";
      gl2[gl2["INCR"] = 7682] = "INCR";
      gl2[gl2["DECR"] = 7683] = "DECR";
      gl2[gl2["INVERT"] = 5386] = "INVERT";
      gl2[gl2["INCR_WRAP"] = 34055] = "INCR_WRAP";
      gl2[gl2["DECR_WRAP"] = 34056] = "DECR_WRAP";
      gl2[gl2["VENDOR"] = 7936] = "VENDOR";
      gl2[gl2["RENDERER"] = 7937] = "RENDERER";
      gl2[gl2["VERSION"] = 7938] = "VERSION";
      gl2[gl2["NEAREST"] = 9728] = "NEAREST";
      gl2[gl2["LINEAR"] = 9729] = "LINEAR";
      gl2[gl2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
      gl2[gl2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
      gl2[gl2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
      gl2[gl2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
      gl2[gl2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
      gl2[gl2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
      gl2[gl2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
      gl2[gl2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
      gl2[gl2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      gl2[gl2["TEXTURE"] = 5890] = "TEXTURE";
      gl2[gl2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      gl2[gl2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      gl2[gl2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
      gl2[gl2["TEXTURE0"] = 33984] = "TEXTURE0";
      gl2[gl2["TEXTURE1"] = 33985] = "TEXTURE1";
      gl2[gl2["TEXTURE2"] = 33986] = "TEXTURE2";
      gl2[gl2["TEXTURE3"] = 33987] = "TEXTURE3";
      gl2[gl2["TEXTURE4"] = 33988] = "TEXTURE4";
      gl2[gl2["TEXTURE5"] = 33989] = "TEXTURE5";
      gl2[gl2["TEXTURE6"] = 33990] = "TEXTURE6";
      gl2[gl2["TEXTURE7"] = 33991] = "TEXTURE7";
      gl2[gl2["TEXTURE8"] = 33992] = "TEXTURE8";
      gl2[gl2["TEXTURE9"] = 33993] = "TEXTURE9";
      gl2[gl2["TEXTURE10"] = 33994] = "TEXTURE10";
      gl2[gl2["TEXTURE11"] = 33995] = "TEXTURE11";
      gl2[gl2["TEXTURE12"] = 33996] = "TEXTURE12";
      gl2[gl2["TEXTURE13"] = 33997] = "TEXTURE13";
      gl2[gl2["TEXTURE14"] = 33998] = "TEXTURE14";
      gl2[gl2["TEXTURE15"] = 33999] = "TEXTURE15";
      gl2[gl2["TEXTURE16"] = 34e3] = "TEXTURE16";
      gl2[gl2["TEXTURE17"] = 34001] = "TEXTURE17";
      gl2[gl2["TEXTURE18"] = 34002] = "TEXTURE18";
      gl2[gl2["TEXTURE19"] = 34003] = "TEXTURE19";
      gl2[gl2["TEXTURE20"] = 34004] = "TEXTURE20";
      gl2[gl2["TEXTURE21"] = 34005] = "TEXTURE21";
      gl2[gl2["TEXTURE22"] = 34006] = "TEXTURE22";
      gl2[gl2["TEXTURE23"] = 34007] = "TEXTURE23";
      gl2[gl2["TEXTURE24"] = 34008] = "TEXTURE24";
      gl2[gl2["TEXTURE25"] = 34009] = "TEXTURE25";
      gl2[gl2["TEXTURE26"] = 34010] = "TEXTURE26";
      gl2[gl2["TEXTURE27"] = 34011] = "TEXTURE27";
      gl2[gl2["TEXTURE28"] = 34012] = "TEXTURE28";
      gl2[gl2["TEXTURE29"] = 34013] = "TEXTURE29";
      gl2[gl2["TEXTURE30"] = 34014] = "TEXTURE30";
      gl2[gl2["TEXTURE31"] = 34015] = "TEXTURE31";
      gl2[gl2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
      gl2[gl2["REPEAT"] = 10497] = "REPEAT";
      gl2[gl2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
      gl2[gl2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
      gl2[gl2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
      gl2[gl2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
      gl2[gl2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
      gl2[gl2["INT_VEC2"] = 35667] = "INT_VEC2";
      gl2[gl2["INT_VEC3"] = 35668] = "INT_VEC3";
      gl2[gl2["INT_VEC4"] = 35669] = "INT_VEC4";
      gl2[gl2["BOOL"] = 35670] = "BOOL";
      gl2[gl2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
      gl2[gl2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
      gl2[gl2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
      gl2[gl2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
      gl2[gl2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
      gl2[gl2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
      gl2[gl2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
      gl2[gl2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
      gl2[gl2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
      gl2[gl2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
      gl2[gl2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
      gl2[gl2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
      gl2[gl2["LOW_INT"] = 36339] = "LOW_INT";
      gl2[gl2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
      gl2[gl2["HIGH_INT"] = 36341] = "HIGH_INT";
      gl2[gl2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
      gl2[gl2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
      gl2[gl2["RGBA4"] = 32854] = "RGBA4";
      gl2[gl2["RGB5_A1"] = 32855] = "RGB5_A1";
      gl2[gl2["RGB565"] = 36194] = "RGB565";
      gl2[gl2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
      gl2[gl2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
      gl2[gl2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
      gl2[gl2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      gl2[gl2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
      gl2[gl2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
      gl2[gl2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
      gl2[gl2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
      gl2[gl2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
      gl2[gl2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
      gl2[gl2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
      gl2[gl2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
      gl2[gl2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
      gl2[gl2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
      gl2[gl2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
      gl2[gl2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
      gl2[gl2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
      gl2[gl2["NONE"] = 0] = "NONE";
      gl2[gl2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      gl2[gl2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
      gl2[gl2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
      gl2[gl2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
      gl2[gl2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
      gl2[gl2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
      gl2[gl2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
      gl2[gl2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
      gl2[gl2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
      gl2[gl2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
      gl2[gl2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
      gl2[gl2["COPY_SRC"] = 1] = "COPY_SRC";
      gl2[gl2["COPY_DST"] = 2] = "COPY_DST";
      gl2[gl2["SAMPLED"] = 4] = "SAMPLED";
      gl2[gl2["STORAGE"] = 8] = "STORAGE";
      gl2[gl2["RENDER_ATTACHMENT"] = 16] = "RENDER_ATTACHMENT";
    })(gl || (gl = {}));
  }
});

// node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js
var ConfigService;
var init_ConfigService = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js"() {
    init_classCallCheck();
    init_createClass();
    ConfigService = function() {
      function ConfigService2() {
        _classCallCheck5(this, ConfigService2);
        this.config = void 0;
      }
      _createClass5(ConfigService2, [{
        key: "get",
        value: function get3() {
          return this.config;
        }
      }, {
        key: "set",
        value: function set12(config) {
          this.config = config;
        }
      }]);
      return ConfigService2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/isSafari.js
var isSafari;
var init_isSafari = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/isSafari.js"() {
    isSafari = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
  }
});

// node_modules/@antv/g-webgpu-core/es/index.js
var AST_TOKEN_TYPES, AST_NODE_TYPES, STORAGE_CLASS, Target, DefineValuePlaceholder;
var init_es2 = __esm({
  "node_modules/@antv/g-webgpu-core/es/index.js"() {
    init_ComponentManager();
    init_gl();
    init_Entity();
    init_ConfigService();
    init_isSafari();
    (function(AST_TOKEN_TYPES2) {
      AST_TOKEN_TYPES2["Void"] = "Void";
      AST_TOKEN_TYPES2["Boolean"] = "Boolean";
      AST_TOKEN_TYPES2["Float"] = "Float";
      AST_TOKEN_TYPES2["Uint32"] = "Uint32";
      AST_TOKEN_TYPES2["Int32"] = "Int32";
      AST_TOKEN_TYPES2["Vector"] = "Vector";
      AST_TOKEN_TYPES2["Vector2Float"] = "vec2<f32>";
      AST_TOKEN_TYPES2["Vector3Float"] = "vec3<f32>";
      AST_TOKEN_TYPES2["Vector4Float"] = "vec4<f32>";
      AST_TOKEN_TYPES2["Vector2Boolean"] = "vec2<bool>";
      AST_TOKEN_TYPES2["Vector3Boolean"] = "vec3<bool>";
      AST_TOKEN_TYPES2["Vector4Boolean"] = "vec4<bool>";
      AST_TOKEN_TYPES2["Vector2Uint"] = "vec2<u32>";
      AST_TOKEN_TYPES2["Vector3Uint"] = "vec3<u32>";
      AST_TOKEN_TYPES2["Vector4Uint"] = "vec4<u32>";
      AST_TOKEN_TYPES2["Vector2Int"] = "vec2<i32>";
      AST_TOKEN_TYPES2["Vector3Int"] = "vec3<i32>";
      AST_TOKEN_TYPES2["Vector4Int"] = "vec4<i32>";
      AST_TOKEN_TYPES2["Matrix"] = "Matrix";
      AST_TOKEN_TYPES2["Matrix3x3Float"] = "mat3x3<f32>";
      AST_TOKEN_TYPES2["Matrix4x4Float"] = "mat4x4<i32>";
      AST_TOKEN_TYPES2["Struct"] = "Struct";
      AST_TOKEN_TYPES2["FloatArray"] = "Float[]";
      AST_TOKEN_TYPES2["Vector4FloatArray"] = "vec4<f32>[]";
    })(AST_TOKEN_TYPES || (AST_TOKEN_TYPES = {}));
    (function(AST_NODE_TYPES2) {
      AST_NODE_TYPES2["Program"] = "Program";
      AST_NODE_TYPES2["Identifier"] = "Identifier";
      AST_NODE_TYPES2["VariableDeclaration"] = "VariableDeclaration";
      AST_NODE_TYPES2["BlockStatement"] = "BlockStatement";
      AST_NODE_TYPES2["ReturnStatement"] = "ReturnStatement";
      AST_NODE_TYPES2["FunctionDeclaration"] = "FunctionDeclaration";
      AST_NODE_TYPES2["VariableDeclarator"] = "VariableDeclarator";
      AST_NODE_TYPES2["AssignmentExpression"] = "AssignmentExpression";
      AST_NODE_TYPES2["LogicalExpression"] = "LogicalExpression";
      AST_NODE_TYPES2["BinaryExpression"] = "BinaryExpression";
      AST_NODE_TYPES2["ArrayExpression"] = "ArrayExpression";
      AST_NODE_TYPES2["UnaryExpression"] = "UnaryExpression";
      AST_NODE_TYPES2["UpdateExpression"] = "UpdateExpression";
      AST_NODE_TYPES2["FunctionExpression"] = "FunctionExpression";
      AST_NODE_TYPES2["MemberExpression"] = "MemberExpression";
      AST_NODE_TYPES2["ConditionalExpression"] = "ConditionalExpression";
      AST_NODE_TYPES2["ExpressionStatement"] = "ExpressionStatement";
      AST_NODE_TYPES2["CallExpression"] = "CallExpression";
      AST_NODE_TYPES2["NumThreadStatement"] = "NumThreadStatement";
      AST_NODE_TYPES2["StorageStatement"] = "StorageStatement";
      AST_NODE_TYPES2["DoWhileStatement"] = "DoWhileStatement";
      AST_NODE_TYPES2["WhileStatement"] = "WhileStatement";
      AST_NODE_TYPES2["ForStatement"] = "ForStatement";
      AST_NODE_TYPES2["BreakStatement"] = "BreakStatement";
      AST_NODE_TYPES2["ContinueStatement"] = "ContinueStatement";
      AST_NODE_TYPES2["IfStatement"] = "IfStatement";
      AST_NODE_TYPES2["ImportedFunctionStatement"] = "ImportedFunctionStatement";
    })(AST_NODE_TYPES || (AST_NODE_TYPES = {}));
    (function(STORAGE_CLASS2) {
      STORAGE_CLASS2["Input"] = "Input";
      STORAGE_CLASS2["Output"] = "Output";
      STORAGE_CLASS2["Uniform"] = "Uniform";
      STORAGE_CLASS2["Workgroup"] = "Workgroup";
      STORAGE_CLASS2["UniformConstant"] = "UniformConstant";
      STORAGE_CLASS2["Image"] = "Image";
      STORAGE_CLASS2["StorageBuffer"] = "StorageBuffer";
      STORAGE_CLASS2["Private"] = "Private";
      STORAGE_CLASS2["Function"] = "Function";
    })(STORAGE_CLASS || (STORAGE_CLASS = {}));
    (function(Target2) {
      Target2["GLSL100"] = "GLSL100";
      Target2["GLSL450"] = "GLSL450";
      Target2["WGSL"] = "WGSL";
    })(Target || (Target = {}));
    DefineValuePlaceholder = "__DefineValuePlaceholder__";
  }
});

// node_modules/@antv/g-webgpu/es/utils/canvas.js
function createCanvas() {
  if (typeof document !== "undefined") {
    return document.createElement("canvas");
  } else {
    throw new Error("Cannot create a canvas in this context");
  }
}
var init_canvas = __esm({
  "node_modules/@antv/g-webgpu/es/utils/canvas.js"() {
  }
});

// node_modules/@antv/g-webgpu/es/Kernel.js
function ownKeys2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_isTypedArray, import_isNumber, import_isArray, import_regenerator2, Kernel;
var init_Kernel = __esm({
  "node_modules/@antv/g-webgpu/es/Kernel.js"() {
    init_asyncToGenerator();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    import_isTypedArray = __toESM(require_isTypedArray());
    import_isNumber = __toESM(require_isNumber());
    import_isArray = __toESM(require_isArray());
    import_regenerator2 = __toESM(require_regenerator2());
    init_es2();
    init_canvas();
    Kernel = function() {
      function Kernel2(engine, configService) {
        _classCallCheck5(this, Kernel2);
        this.engine = engine;
        this.configService = configService;
        this.model = void 0;
        this.dirty = true;
        this.compiledBundle = void 0;
        this.initPromise = void 0;
      }
      _createClass5(Kernel2, [{
        key: "init",
        value: function init() {
          var _this$configService$g = this.configService.get(), canvas = _this$configService$g.canvas, engineOptions = _this$configService$g.engineOptions;
          this.initPromise = this.engine.init(_objectSpread2({
            canvas: canvas || createCanvas(),
            // swapChainFormat: WebGPUConstants.TextureFormat.BGRA8Unorm,
            antialiasing: false
          }, engineOptions));
        }
      }, {
        key: "setBundle",
        value: function setBundle(bundle) {
          this.compiledBundle = JSON.parse(JSON.stringify(bundle));
        }
      }, {
        key: "setDispatch",
        value: function setDispatch(dispatch2) {
          if (this.compiledBundle.context) {
            this.compiledBundle.context.dispatch = dispatch2;
          }
          return this;
        }
      }, {
        key: "setMaxIteration",
        value: function setMaxIteration(maxIteration) {
          if (this.compiledBundle.context) {
            this.compiledBundle.context.maxIteration = maxIteration;
          }
          return this;
        }
      }, {
        key: "setBinding",
        value: function setBinding(name, data) {
          var _this = this;
          if (typeof name === "string") {
            var isNumberLikeData = (0, import_isNumber.default)(data) || (0, import_isTypedArray.default)(data) || (0, import_isArray.default)(data);
            if (this.compiledBundle && this.compiledBundle.context) {
              var existedDefine = this.compiledBundle.context.defines.find(function(b10) {
                return b10.name === name;
              });
              if (existedDefine) {
                existedDefine.value = data;
                return this;
              }
              var existedBinding = this.compiledBundle.context.uniforms.find(function(b10) {
                return b10.name === name;
              });
              if (existedBinding) {
                if (isNumberLikeData) {
                  existedBinding.data = data;
                  existedBinding.isReferer = false;
                  if (existedBinding.storageClass === STORAGE_CLASS.Uniform) {
                    if (this.model) {
                      this.model.updateUniform(name, data);
                    }
                  } else {
                    if (this.model) {
                      this.model.updateBuffer(name, data);
                    }
                  }
                } else {
                  existedBinding.isReferer = true;
                  existedBinding.data = data;
                }
              }
            }
          } else {
            Object.keys(name).forEach(function(key) {
              _this.setBinding(key, name[key]);
            });
          }
          return this;
        }
      }, {
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
            var _this2 = this;
            var iteration, i2, _args = arguments;
            return import_regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    iteration = _args.length > 0 && _args[0] !== void 0 ? _args[0] : 1;
                    if (!this.dirty) {
                      _context.next = 6;
                      break;
                    }
                    if (this.compiledBundle.context) {
                      if (iteration > 1) {
                        this.compiledBundle.context.maxIteration = iteration;
                      } else {
                        this.compiledBundle.context.maxIteration++;
                      }
                    }
                    _context.next = 5;
                    return this.compile();
                  case 5:
                    this.dirty = false;
                  case 6:
                    this.engine.beginFrame();
                    this.engine.clear({});
                    if (this.compiledBundle.context) {
                      this.compiledBundle.context.uniforms.filter(function(_ref) {
                        var isReferer = _ref.isReferer;
                        return isReferer;
                      }).forEach(function(_ref2) {
                        var data = _ref2.data, name = _ref2.name;
                        _this2.model.confirmInput(data.model, name);
                      });
                    }
                    for (i2 = 0; i2 < iteration; i2++) {
                      this.model.run();
                    }
                    this.engine.endFrame();
                    return _context.abrupt("return", this);
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute() {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
        /**
         * read output from GPUBuffer
         */
      }, {
        key: "getOutput",
        value: function() {
          var _getOutput = _asyncToGenerator(import_regenerator2.default.mark(function _callee2() {
            return import_regenerator2.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.model.readData());
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getOutput() {
            return _getOutput.apply(this, arguments);
          }
          return getOutput;
        }()
      }, {
        key: "compile",
        value: function() {
          var _compile = _asyncToGenerator(import_regenerator2.default.mark(function _callee3() {
            var context, target, shader;
            return import_regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.initPromise;
                  case 2:
                    context = _objectSpread2({}, this.compiledBundle.context);
                    target = this.engine.supportWebGPU ? this.engine.useWGSL ? Target.WGSL : Target.GLSL450 : Target.GLSL100;
                    shader = this.compiledBundle.shaders[target];
                    context.defines.filter(function(define2) {
                      return define2.runtime;
                    }).forEach(function(define2) {
                      var valuePlaceHolder = "".concat(DefineValuePlaceholder).concat(define2.name);
                      shader = shader.replace(valuePlaceHolder, "".concat(define2.value));
                    });
                    context.shader = shader;
                    context.uniforms.forEach(function(uniform) {
                      if (!uniform.data) {
                        if (uniform.storageClass === STORAGE_CLASS.StorageBuffer) {
                          var sizePerElement = 1;
                          if (uniform.type === AST_TOKEN_TYPES.FloatArray) {
                            sizePerElement = 1;
                          } else if (uniform.type === AST_TOKEN_TYPES.Vector4FloatArray) {
                            sizePerElement = 4;
                          }
                          uniform.data = new Float32Array(context.output.length * sizePerElement).fill(0);
                        }
                      }
                    });
                    this.compiledBundle.context = context;
                    _context3.next = 11;
                    return this.engine.createComputeModel(this.compiledBundle.context);
                  case 11:
                    this.model = _context3.sent;
                  case 12:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function compile() {
            return _compile.apply(this, arguments);
          }
          return compile;
        }()
      }]);
      return Kernel2;
    }();
  }
});

// node_modules/regl/dist/regl.js
var require_regl = __commonJS({
  "node_modules/regl/dist/regl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.createREGL = factory();
    })(exports, function() {
      "use strict";
      var isTypedArray = function(x4) {
        return x4 instanceof Uint8Array || x4 instanceof Uint16Array || x4 instanceof Uint32Array || x4 instanceof Int8Array || x4 instanceof Int16Array || x4 instanceof Int32Array || x4 instanceof Float32Array || x4 instanceof Float64Array || x4 instanceof Uint8ClampedArray;
      };
      var extend4 = function(base, opts) {
        var keys3 = Object.keys(opts);
        for (var i2 = 0; i2 < keys3.length; ++i2) {
          base[keys3[i2]] = opts[keys3[i2]];
        }
        return base;
      };
      var endl = "\n";
      function decodeB64(str10) {
        if (typeof atob !== "undefined") {
          return atob(str10);
        }
        return "base64:" + str10;
      }
      function raise(message) {
        var error = new Error("(regl) " + message);
        console.error(error);
        throw error;
      }
      function check(pred, message) {
        if (!pred) {
          raise(message);
        }
      }
      function encolon(message) {
        if (message) {
          return ": " + message;
        }
        return "";
      }
      function checkParameter(param, possibilities, message) {
        if (!(param in possibilities)) {
          raise("unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join());
        }
      }
      function checkIsTypedArray(data, message) {
        if (!isTypedArray(data)) {
          raise(
            "invalid parameter type" + encolon(message) + ". must be a typed array"
          );
        }
      }
      function standardTypeEh(value, type) {
        switch (type) {
          case "number":
            return typeof value === "number";
          case "object":
            return typeof value === "object";
          case "string":
            return typeof value === "string";
          case "boolean":
            return typeof value === "boolean";
          case "function":
            return typeof value === "function";
          case "undefined":
            return typeof value === "undefined";
          case "symbol":
            return typeof value === "symbol";
        }
      }
      function checkTypeOf(value, type, message) {
        if (!standardTypeEh(value, type)) {
          raise(
            "invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value
          );
        }
      }
      function checkNonNegativeInt(value, message) {
        if (!(value >= 0 && (value | 0) === value)) {
          raise("invalid parameter type, (" + value + ")" + encolon(message) + ". must be a nonnegative integer");
        }
      }
      function checkOneOf(value, list, message) {
        if (list.indexOf(value) < 0) {
          raise("invalid value" + encolon(message) + ". must be one of: " + list);
        }
      }
      var constructorKeys = [
        "gl",
        "canvas",
        "container",
        "attributes",
        "pixelRatio",
        "extensions",
        "optionalExtensions",
        "profile",
        "onDone"
      ];
      function checkConstructor(obj) {
        Object.keys(obj).forEach(function(key) {
          if (constructorKeys.indexOf(key) < 0) {
            raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
          }
        });
      }
      function leftPad(str10, n2) {
        str10 = str10 + "";
        while (str10.length < n2) {
          str10 = " " + str10;
        }
        return str10;
      }
      function ShaderFile() {
        this.name = "unknown";
        this.lines = [];
        this.index = {};
        this.hasErrors = false;
      }
      function ShaderLine(number, line2) {
        this.number = number;
        this.line = line2;
        this.errors = [];
      }
      function ShaderError(fileNumber, lineNumber, message) {
        this.file = fileNumber;
        this.line = lineNumber;
        this.message = message;
      }
      function guessCommand() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function guessCallSite() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function parseSource(source, command) {
        var lines2 = source.split("\n");
        var lineNumber = 1;
        var fileNumber = 0;
        var files = {
          unknown: new ShaderFile(),
          0: new ShaderFile()
        };
        files.unknown.name = files[0].name = command || guessCommand();
        files.unknown.lines.push(new ShaderLine(0, ""));
        for (var i2 = 0; i2 < lines2.length; ++i2) {
          var line2 = lines2[i2];
          var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line2);
          if (parts) {
            switch (parts[1]) {
              case "line":
                var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
                if (lineNumberInfo) {
                  lineNumber = lineNumberInfo[1] | 0;
                  if (lineNumberInfo[2]) {
                    fileNumber = lineNumberInfo[2] | 0;
                    if (!(fileNumber in files)) {
                      files[fileNumber] = new ShaderFile();
                    }
                  }
                }
                break;
              case "define":
                var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
                if (nameInfo) {
                  files[fileNumber].name = nameInfo[1] ? decodeB64(nameInfo[2]) : nameInfo[2];
                }
                break;
            }
          }
          files[fileNumber].lines.push(new ShaderLine(lineNumber++, line2));
        }
        Object.keys(files).forEach(function(fileNumber2) {
          var file = files[fileNumber2];
          file.lines.forEach(function(line3) {
            file.index[line3.number] = line3;
          });
        });
        return files;
      }
      function parseErrorLog(errLog) {
        var result = [];
        errLog.split("\n").forEach(function(errMsg) {
          if (errMsg.length < 5) {
            return;
          }
          var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg);
          if (parts) {
            result.push(new ShaderError(
              parts[1] | 0,
              parts[2] | 0,
              parts[3].trim()
            ));
          } else if (errMsg.length > 0) {
            result.push(new ShaderError("unknown", 0, errMsg));
          }
        });
        return result;
      }
      function annotateFiles(files, errors) {
        errors.forEach(function(error) {
          var file = files[error.file];
          if (file) {
            var line2 = file.index[error.line];
            if (line2) {
              line2.errors.push(error);
              file.hasErrors = true;
              return;
            }
          }
          files.unknown.hasErrors = true;
          files.unknown.lines[0].errors.push(error);
        });
      }
      function checkShaderError(gl2, shader, source, type, command) {
        if (!gl2.getShaderParameter(shader, gl2.COMPILE_STATUS)) {
          var errLog = gl2.getShaderInfoLog(shader);
          var typeName = type === gl2.FRAGMENT_SHADER ? "fragment" : "vertex";
          checkCommandType(source, "string", typeName + " shader source must be a string", command);
          var files = parseSource(source, command);
          var errors = parseErrorLog(errLog);
          annotateFiles(files, errors);
          Object.keys(files).forEach(function(fileNumber) {
            var file = files[fileNumber];
            if (!file.hasErrors) {
              return;
            }
            var strings = [""];
            var styles = [""];
            function push(str10, style) {
              strings.push(str10);
              styles.push(style || "");
            }
            push("file number " + fileNumber + ": " + file.name + "\n", "color:red;text-decoration:underline;font-weight:bold");
            file.lines.forEach(function(line2) {
              if (line2.errors.length > 0) {
                push(leftPad(line2.number, 4) + "|  ", "background-color:yellow; font-weight:bold");
                push(line2.line + endl, "color:red; background-color:yellow; font-weight:bold");
                var offset = 0;
                line2.errors.forEach(function(error) {
                  var message = error.message;
                  var token2 = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message);
                  if (token2) {
                    var tokenPat = token2[1];
                    message = token2[2];
                    switch (tokenPat) {
                      case "assign":
                        tokenPat = "=";
                        break;
                    }
                    offset = Math.max(line2.line.indexOf(tokenPat, offset), 0);
                  } else {
                    offset = 0;
                  }
                  push(leftPad("| ", 6));
                  push(leftPad("^^^", offset + 3) + endl, "font-weight:bold");
                  push(leftPad("| ", 6));
                  push(message + endl, "font-weight:bold");
                });
                push(leftPad("| ", 6) + endl);
              } else {
                push(leftPad(line2.number, 4) + "|  ");
                push(line2.line + endl, "color:red");
              }
            });
            if (typeof document !== "undefined" && !window.chrome) {
              styles[0] = strings.join("%c");
              console.log.apply(console, styles);
            } else {
              console.log(strings.join(""));
            }
          });
          check.raise("Error compiling " + typeName + " shader, " + files[0].name);
        }
      }
      function checkLinkError(gl2, program, fragShader, vertShader, command) {
        if (!gl2.getProgramParameter(program, gl2.LINK_STATUS)) {
          var errLog = gl2.getProgramInfoLog(program);
          var fragParse = parseSource(fragShader, command);
          var vertParse = parseSource(vertShader, command);
          var header = 'Error linking program with vertex shader, "' + vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';
          if (typeof document !== "undefined") {
            console.log(
              "%c" + header + endl + "%c" + errLog,
              "color:red;text-decoration:underline;font-weight:bold",
              "color:red"
            );
          } else {
            console.log(header + endl + errLog);
          }
          check.raise(header);
        }
      }
      function saveCommandRef(object) {
        object._commandRef = guessCommand();
      }
      function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
        saveCommandRef(opts);
        function id(str10) {
          if (str10) {
            return stringStore.id(str10);
          }
          return 0;
        }
        opts._fragId = id(opts.static.frag);
        opts._vertId = id(opts.static.vert);
        function addProps(dict, set12) {
          Object.keys(set12).forEach(function(u2) {
            dict[stringStore.id(u2)] = true;
          });
        }
        var uniformSet = opts._uniformSet = {};
        addProps(uniformSet, uniforms.static);
        addProps(uniformSet, uniforms.dynamic);
        var attributeSet = opts._attributeSet = {};
        addProps(attributeSet, attributes.static);
        addProps(attributeSet, attributes.dynamic);
        opts._hasCount = "count" in opts.static || "count" in opts.dynamic || "elements" in opts.static || "elements" in opts.dynamic;
      }
      function commandRaise(message, command) {
        var callSite = guessCallSite();
        raise(message + " in command " + (command || guessCommand()) + (callSite === "unknown" ? "" : " called from " + callSite));
      }
      function checkCommand(pred, message, command) {
        if (!pred) {
          commandRaise(message, command || guessCommand());
        }
      }
      function checkParameterCommand(param, possibilities, message, command) {
        if (!(param in possibilities)) {
          commandRaise(
            "unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join(),
            command || guessCommand()
          );
        }
      }
      function checkCommandType(value, type, message, command) {
        if (!standardTypeEh(value, type)) {
          commandRaise(
            "invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value,
            command || guessCommand()
          );
        }
      }
      function checkOptional(block) {
        block();
      }
      function checkFramebufferFormat(attachment, texFormats, rbFormats) {
        if (attachment.texture) {
          checkOneOf(
            attachment.texture._texture.internalformat,
            texFormats,
            "unsupported texture format for attachment"
          );
        } else {
          checkOneOf(
            attachment.renderbuffer._renderbuffer.format,
            rbFormats,
            "unsupported renderbuffer format for attachment"
          );
        }
      }
      var GL_CLAMP_TO_EDGE = 33071;
      var GL_NEAREST = 9728;
      var GL_NEAREST_MIPMAP_NEAREST = 9984;
      var GL_LINEAR_MIPMAP_NEAREST = 9985;
      var GL_NEAREST_MIPMAP_LINEAR = 9986;
      var GL_LINEAR_MIPMAP_LINEAR = 9987;
      var GL_BYTE = 5120;
      var GL_UNSIGNED_BYTE = 5121;
      var GL_SHORT = 5122;
      var GL_UNSIGNED_SHORT = 5123;
      var GL_INT = 5124;
      var GL_UNSIGNED_INT = 5125;
      var GL_FLOAT = 5126;
      var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL = 34042;
      var GL_HALF_FLOAT_OES = 36193;
      var TYPE_SIZE = {};
      TYPE_SIZE[GL_BYTE] = TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;
      TYPE_SIZE[GL_SHORT] = TYPE_SIZE[GL_UNSIGNED_SHORT] = TYPE_SIZE[GL_HALF_FLOAT_OES] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] = TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;
      TYPE_SIZE[GL_INT] = TYPE_SIZE[GL_UNSIGNED_INT] = TYPE_SIZE[GL_FLOAT] = TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;
      function pixelSize(type, channels) {
        if (type === GL_UNSIGNED_SHORT_5_5_5_1 || type === GL_UNSIGNED_SHORT_4_4_4_4 || type === GL_UNSIGNED_SHORT_5_6_5) {
          return 2;
        } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
          return 4;
        } else {
          return TYPE_SIZE[type] * channels;
        }
      }
      function isPow2(v2) {
        return !(v2 & v2 - 1) && !!v2;
      }
      function checkTexture2D(info, mipData, limits) {
        var i2;
        var w2 = mipData.width;
        var h2 = mipData.height;
        var c3 = mipData.channels;
        check(
          w2 > 0 && w2 <= limits.maxTextureSize && h2 > 0 && h2 <= limits.maxTextureSize,
          "invalid texture shape"
        );
        if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
          check(
            isPow2(w2) && isPow2(h2),
            "incompatible wrap mode for texture, both width and height must be power of 2"
          );
        }
        if (mipData.mipmask === 1) {
          if (w2 !== 1 && h2 !== 1) {
            check(
              info.minFilter !== GL_NEAREST_MIPMAP_NEAREST && info.minFilter !== GL_NEAREST_MIPMAP_LINEAR && info.minFilter !== GL_LINEAR_MIPMAP_NEAREST && info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
              "min filter requires mipmap"
            );
          }
        } else {
          check(
            isPow2(w2) && isPow2(h2),
            "texture must be a square power of 2 to support mipmapping"
          );
          check(
            mipData.mipmask === (w2 << 1) - 1,
            "missing or incomplete mipmap data"
          );
        }
        if (mipData.type === GL_FLOAT) {
          if (limits.extensions.indexOf("oes_texture_float_linear") < 0) {
            check(
              info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
              "filter not supported, must enable oes_texture_float_linear"
            );
          }
          check(
            !info.genMipmaps,
            "mipmap generation not supported with float textures"
          );
        }
        var mipimages = mipData.images;
        for (i2 = 0; i2 < 16; ++i2) {
          if (mipimages[i2]) {
            var mw = w2 >> i2;
            var mh = h2 >> i2;
            check(mipData.mipmask & 1 << i2, "missing mipmap data");
            var img = mipimages[i2];
            check(
              img.width === mw && img.height === mh,
              "invalid shape for mip images"
            );
            check(
              img.format === mipData.format && img.internalformat === mipData.internalformat && img.type === mipData.type,
              "incompatible type for mip image"
            );
            if (img.compressed) {
            } else if (img.data) {
              var rowSize = Math.ceil(pixelSize(img.type, c3) * mw / img.unpackAlignment) * img.unpackAlignment;
              check(
                img.data.byteLength === rowSize * mh,
                "invalid data for image, buffer size is inconsistent with image format"
              );
            } else if (img.element) {
            } else if (img.copy) {
            }
          } else if (!info.genMipmaps) {
            check((mipData.mipmask & 1 << i2) === 0, "extra mipmap data");
          }
        }
        if (mipData.compressed) {
          check(
            !info.genMipmaps,
            "mipmap generation for compressed images not supported"
          );
        }
      }
      function checkTextureCube(texture, info, faces, limits) {
        var w2 = texture.width;
        var h2 = texture.height;
        var c3 = texture.channels;
        check(
          w2 > 0 && w2 <= limits.maxTextureSize && h2 > 0 && h2 <= limits.maxTextureSize,
          "invalid texture shape"
        );
        check(
          w2 === h2,
          "cube map must be square"
        );
        check(
          info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
          "wrap mode not supported by cube map"
        );
        for (var i2 = 0; i2 < faces.length; ++i2) {
          var face = faces[i2];
          check(
            face.width === w2 && face.height === h2,
            "inconsistent cube map face shape"
          );
          if (info.genMipmaps) {
            check(
              !face.compressed,
              "can not generate mipmap for compressed textures"
            );
            check(
              face.mipmask === 1,
              "can not specify mipmaps and generate mipmaps"
            );
          } else {
          }
          var mipmaps = face.images;
          for (var j2 = 0; j2 < 16; ++j2) {
            var img = mipmaps[j2];
            if (img) {
              var mw = w2 >> j2;
              var mh = h2 >> j2;
              check(face.mipmask & 1 << j2, "missing mipmap data");
              check(
                img.width === mw && img.height === mh,
                "invalid shape for mip images"
              );
              check(
                img.format === texture.format && img.internalformat === texture.internalformat && img.type === texture.type,
                "incompatible type for mip image"
              );
              if (img.compressed) {
              } else if (img.data) {
                check(
                  img.data.byteLength === mw * mh * Math.max(pixelSize(img.type, c3), img.unpackAlignment),
                  "invalid data for image, buffer size is inconsistent with image format"
                );
              } else if (img.element) {
              } else if (img.copy) {
              }
            }
          }
        }
      }
      var check$1 = extend4(check, {
        optional: checkOptional,
        raise,
        commandRaise,
        command: checkCommand,
        parameter: checkParameter,
        commandParameter: checkParameterCommand,
        constructor: checkConstructor,
        type: checkTypeOf,
        commandType: checkCommandType,
        isTypedArray: checkIsTypedArray,
        nni: checkNonNegativeInt,
        oneOf: checkOneOf,
        shaderError: checkShaderError,
        linkError: checkLinkError,
        callSite: guessCallSite,
        saveCommandRef,
        saveDrawInfo: saveDrawCommandInfo,
        framebufferFormat: checkFramebufferFormat,
        guessCommand,
        texture2D: checkTexture2D,
        textureCube: checkTextureCube
      });
      var VARIABLE_COUNTER = 0;
      var DYN_FUNC = 0;
      var DYN_CONSTANT = 5;
      var DYN_ARRAY = 6;
      function DynamicVariable(type, data) {
        this.id = VARIABLE_COUNTER++;
        this.type = type;
        this.data = data;
      }
      function escapeStr(str10) {
        return str10.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      }
      function splitParts(str10) {
        if (str10.length === 0) {
          return [];
        }
        var firstChar = str10.charAt(0);
        var lastChar = str10.charAt(str10.length - 1);
        if (str10.length > 1 && firstChar === lastChar && (firstChar === '"' || firstChar === "'")) {
          return ['"' + escapeStr(str10.substr(1, str10.length - 2)) + '"'];
        }
        var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str10);
        if (parts) {
          return splitParts(str10.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str10.substr(parts.index + parts[0].length)));
        }
        var subparts = str10.split(".");
        if (subparts.length === 1) {
          return ['"' + escapeStr(str10) + '"'];
        }
        var result = [];
        for (var i2 = 0; i2 < subparts.length; ++i2) {
          result = result.concat(splitParts(subparts[i2]));
        }
        return result;
      }
      function toAccessorString(str10) {
        return "[" + splitParts(str10).join("][") + "]";
      }
      function defineDynamic(type, data) {
        return new DynamicVariable(type, toAccessorString(data + ""));
      }
      function isDynamic(x4) {
        return typeof x4 === "function" && !x4._reglType || x4 instanceof DynamicVariable;
      }
      function unbox(x4, path) {
        if (typeof x4 === "function") {
          return new DynamicVariable(DYN_FUNC, x4);
        } else if (typeof x4 === "number" || typeof x4 === "boolean") {
          return new DynamicVariable(DYN_CONSTANT, x4);
        } else if (Array.isArray(x4)) {
          return new DynamicVariable(DYN_ARRAY, x4.map((y4, i2) => unbox(y4, path + "[" + i2 + "]")));
        } else if (x4 instanceof DynamicVariable) {
          return x4;
        }
        check$1(false, "invalid option type in uniform " + path);
      }
      var dynamic = {
        DynamicVariable,
        define: defineDynamic,
        isDynamic,
        unbox,
        accessor: toAccessorString
      };
      var raf = {
        next: typeof requestAnimationFrame === "function" ? function(cb) {
          return requestAnimationFrame(cb);
        } : function(cb) {
          return setTimeout(cb, 16);
        },
        cancel: typeof cancelAnimationFrame === "function" ? function(raf2) {
          return cancelAnimationFrame(raf2);
        } : clearTimeout
      };
      var clock2 = typeof performance !== "undefined" && performance.now ? function() {
        return performance.now();
      } : function() {
        return +/* @__PURE__ */ new Date();
      };
      function createStringStore() {
        var stringIds = { "": 0 };
        var stringValues = [""];
        return {
          id: function(str10) {
            var result = stringIds[str10];
            if (result) {
              return result;
            }
            result = stringIds[str10] = stringValues.length;
            stringValues.push(str10);
            return result;
          },
          str: function(id) {
            return stringValues[id];
          }
        };
      }
      function createCanvas2(element, onDone, pixelRatio) {
        var canvas = document.createElement("canvas");
        extend4(canvas.style, {
          border: 0,
          margin: 0,
          padding: 0,
          top: 0,
          left: 0
        });
        element.appendChild(canvas);
        if (element === document.body) {
          canvas.style.position = "absolute";
          extend4(element.style, {
            margin: 0,
            padding: 0
          });
        }
        function resize() {
          var w2 = window.innerWidth;
          var h2 = window.innerHeight;
          if (element !== document.body) {
            var bounds = element.getBoundingClientRect();
            w2 = bounds.right - bounds.left;
            h2 = bounds.bottom - bounds.top;
          }
          canvas.width = pixelRatio * w2;
          canvas.height = pixelRatio * h2;
          extend4(canvas.style, {
            width: w2 + "px",
            height: h2 + "px"
          });
        }
        var resizeObserver;
        if (element !== document.body && typeof ResizeObserver === "function") {
          resizeObserver = new ResizeObserver(function() {
            setTimeout(resize);
          });
          resizeObserver.observe(element);
        } else {
          window.addEventListener("resize", resize, false);
        }
        function onDestroy() {
          if (resizeObserver) {
            resizeObserver.disconnect();
          } else {
            window.removeEventListener("resize", resize);
          }
          element.removeChild(canvas);
        }
        resize();
        return {
          canvas,
          onDestroy
        };
      }
      function createContext(canvas, contextAttributes) {
        function get3(name) {
          try {
            return canvas.getContext(name, contextAttributes);
          } catch (e8) {
            return null;
          }
        }
        return get3("webgl") || get3("experimental-webgl") || get3("webgl-experimental");
      }
      function isHTMLElement(obj) {
        return typeof obj.nodeName === "string" && typeof obj.appendChild === "function" && typeof obj.getBoundingClientRect === "function";
      }
      function isWebGLContext(obj) {
        return typeof obj.drawArrays === "function" || typeof obj.drawElements === "function";
      }
      function parseExtensions(input) {
        if (typeof input === "string") {
          return input.split();
        }
        check$1(Array.isArray(input), "invalid extension array");
        return input;
      }
      function getElement(desc) {
        if (typeof desc === "string") {
          check$1(typeof document !== "undefined", "not supported outside of DOM");
          return document.querySelector(desc);
        }
        return desc;
      }
      function parseArgs(args_) {
        var args = args_ || {};
        var element, container, canvas, gl2;
        var contextAttributes = {};
        var extensions = [];
        var optionalExtensions = [];
        var pixelRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio;
        var profile = false;
        var onDone = function(err) {
          if (err) {
            check$1.raise(err);
          }
        };
        var onDestroy = function() {
        };
        if (typeof args === "string") {
          check$1(
            typeof document !== "undefined",
            "selector queries only supported in DOM enviroments"
          );
          element = document.querySelector(args);
          check$1(element, "invalid query string for element");
        } else if (typeof args === "object") {
          if (isHTMLElement(args)) {
            element = args;
          } else if (isWebGLContext(args)) {
            gl2 = args;
            canvas = gl2.canvas;
          } else {
            check$1.constructor(args);
            if ("gl" in args) {
              gl2 = args.gl;
            } else if ("canvas" in args) {
              canvas = getElement(args.canvas);
            } else if ("container" in args) {
              container = getElement(args.container);
            }
            if ("attributes" in args) {
              contextAttributes = args.attributes;
              check$1.type(contextAttributes, "object", "invalid context attributes");
            }
            if ("extensions" in args) {
              extensions = parseExtensions(args.extensions);
            }
            if ("optionalExtensions" in args) {
              optionalExtensions = parseExtensions(args.optionalExtensions);
            }
            if ("onDone" in args) {
              check$1.type(
                args.onDone,
                "function",
                "invalid or missing onDone callback"
              );
              onDone = args.onDone;
            }
            if ("profile" in args) {
              profile = !!args.profile;
            }
            if ("pixelRatio" in args) {
              pixelRatio = +args.pixelRatio;
              check$1(pixelRatio > 0, "invalid pixel ratio");
            }
          }
        } else {
          check$1.raise("invalid arguments to regl");
        }
        if (element) {
          if (element.nodeName.toLowerCase() === "canvas") {
            canvas = element;
          } else {
            container = element;
          }
        }
        if (!gl2) {
          if (!canvas) {
            check$1(
              typeof document !== "undefined",
              "must manually specify webgl context outside of DOM environments"
            );
            var result = createCanvas2(container || document.body, onDone, pixelRatio);
            if (!result) {
              return null;
            }
            canvas = result.canvas;
            onDestroy = result.onDestroy;
          }
          if (contextAttributes.premultipliedAlpha === void 0) contextAttributes.premultipliedAlpha = true;
          gl2 = createContext(canvas, contextAttributes);
        }
        if (!gl2) {
          onDestroy();
          onDone("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org");
          return null;
        }
        return {
          gl: gl2,
          canvas,
          container,
          extensions,
          optionalExtensions,
          pixelRatio,
          profile,
          onDone,
          onDestroy
        };
      }
      function createExtensionCache(gl2, config) {
        var extensions = {};
        function tryLoadExtension(name_) {
          check$1.type(name_, "string", "extension name must be string");
          var name2 = name_.toLowerCase();
          var ext;
          try {
            ext = extensions[name2] = gl2.getExtension(name2);
          } catch (e8) {
          }
          return !!ext;
        }
        for (var i2 = 0; i2 < config.extensions.length; ++i2) {
          var name = config.extensions[i2];
          if (!tryLoadExtension(name)) {
            config.onDestroy();
            config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
            return null;
          }
        }
        config.optionalExtensions.forEach(tryLoadExtension);
        return {
          extensions,
          restore: function() {
            Object.keys(extensions).forEach(function(name2) {
              if (extensions[name2] && !tryLoadExtension(name2)) {
                throw new Error("(regl): error restoring extension " + name2);
              }
            });
          }
        };
      }
      function loop(n2, f2) {
        var result = Array(n2);
        for (var i2 = 0; i2 < n2; ++i2) {
          result[i2] = f2(i2);
        }
        return result;
      }
      var GL_BYTE$1 = 5120;
      var GL_UNSIGNED_BYTE$2 = 5121;
      var GL_SHORT$1 = 5122;
      var GL_UNSIGNED_SHORT$1 = 5123;
      var GL_INT$1 = 5124;
      var GL_UNSIGNED_INT$1 = 5125;
      var GL_FLOAT$2 = 5126;
      function nextPow16(v2) {
        for (var i2 = 16; i2 <= 1 << 28; i2 *= 16) {
          if (v2 <= i2) {
            return i2;
          }
        }
        return 0;
      }
      function log2(v2) {
        var r2, shift;
        r2 = (v2 > 65535) << 4;
        v2 >>>= r2;
        shift = (v2 > 255) << 3;
        v2 >>>= shift;
        r2 |= shift;
        shift = (v2 > 15) << 2;
        v2 >>>= shift;
        r2 |= shift;
        shift = (v2 > 3) << 1;
        v2 >>>= shift;
        r2 |= shift;
        return r2 | v2 >> 1;
      }
      function createPool() {
        var bufferPool = loop(8, function() {
          return [];
        });
        function alloc(n2) {
          var sz = nextPow16(n2);
          var bin = bufferPool[log2(sz) >> 2];
          if (bin.length > 0) {
            return bin.pop();
          }
          return new ArrayBuffer(sz);
        }
        function free(buf) {
          bufferPool[log2(buf.byteLength) >> 2].push(buf);
        }
        function allocType(type, n2) {
          var result = null;
          switch (type) {
            case GL_BYTE$1:
              result = new Int8Array(alloc(n2), 0, n2);
              break;
            case GL_UNSIGNED_BYTE$2:
              result = new Uint8Array(alloc(n2), 0, n2);
              break;
            case GL_SHORT$1:
              result = new Int16Array(alloc(2 * n2), 0, n2);
              break;
            case GL_UNSIGNED_SHORT$1:
              result = new Uint16Array(alloc(2 * n2), 0, n2);
              break;
            case GL_INT$1:
              result = new Int32Array(alloc(4 * n2), 0, n2);
              break;
            case GL_UNSIGNED_INT$1:
              result = new Uint32Array(alloc(4 * n2), 0, n2);
              break;
            case GL_FLOAT$2:
              result = new Float32Array(alloc(4 * n2), 0, n2);
              break;
            default:
              return null;
          }
          if (result.length !== n2) {
            return result.subarray(0, n2);
          }
          return result;
        }
        function freeType(array) {
          free(array.buffer);
        }
        return {
          alloc,
          free,
          allocType,
          freeType
        };
      }
      var pool = createPool();
      pool.zero = createPool();
      var GL_SUBPIXEL_BITS = 3408;
      var GL_RED_BITS = 3410;
      var GL_GREEN_BITS = 3411;
      var GL_BLUE_BITS = 3412;
      var GL_ALPHA_BITS = 3413;
      var GL_DEPTH_BITS = 3414;
      var GL_STENCIL_BITS = 3415;
      var GL_ALIASED_POINT_SIZE_RANGE = 33901;
      var GL_ALIASED_LINE_WIDTH_RANGE = 33902;
      var GL_MAX_TEXTURE_SIZE = 3379;
      var GL_MAX_VIEWPORT_DIMS = 3386;
      var GL_MAX_VERTEX_ATTRIBS = 34921;
      var GL_MAX_VERTEX_UNIFORM_VECTORS = 36347;
      var GL_MAX_VARYING_VECTORS = 36348;
      var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
      var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
      var GL_MAX_TEXTURE_IMAGE_UNITS = 34930;
      var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
      var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
      var GL_MAX_RENDERBUFFER_SIZE = 34024;
      var GL_VENDOR = 7936;
      var GL_RENDERER = 7937;
      var GL_VERSION = 7938;
      var GL_SHADING_LANGUAGE_VERSION = 35724;
      var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
      var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
      var GL_MAX_DRAW_BUFFERS_WEBGL = 34852;
      var GL_TEXTURE_2D = 3553;
      var GL_TEXTURE_CUBE_MAP = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
      var GL_TEXTURE0 = 33984;
      var GL_RGBA = 6408;
      var GL_FLOAT$1 = 5126;
      var GL_UNSIGNED_BYTE$1 = 5121;
      var GL_FRAMEBUFFER = 36160;
      var GL_FRAMEBUFFER_COMPLETE = 36053;
      var GL_COLOR_ATTACHMENT0 = 36064;
      var GL_COLOR_BUFFER_BIT$1 = 16384;
      var wrapLimits = function(gl2, extensions) {
        var maxAnisotropic = 1;
        if (extensions.ext_texture_filter_anisotropic) {
          maxAnisotropic = gl2.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        }
        var maxDrawbuffers = 1;
        var maxColorAttachments = 1;
        if (extensions.webgl_draw_buffers) {
          maxDrawbuffers = gl2.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
          maxColorAttachments = gl2.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
        }
        var readFloat = !!extensions.oes_texture_float;
        if (readFloat) {
          var readFloatTexture = gl2.createTexture();
          gl2.bindTexture(GL_TEXTURE_2D, readFloatTexture);
          gl2.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null);
          var fbo = gl2.createFramebuffer();
          gl2.bindFramebuffer(GL_FRAMEBUFFER, fbo);
          gl2.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);
          gl2.bindTexture(GL_TEXTURE_2D, null);
          if (gl2.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false;
          else {
            gl2.viewport(0, 0, 1, 1);
            gl2.clearColor(1, 0, 0, 1);
            gl2.clear(GL_COLOR_BUFFER_BIT$1);
            var pixels = pool.allocType(GL_FLOAT$1, 4);
            gl2.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels);
            if (gl2.getError()) readFloat = false;
            else {
              gl2.deleteFramebuffer(fbo);
              gl2.deleteTexture(readFloatTexture);
              readFloat = pixels[0] === 1;
            }
            pool.freeType(pixels);
          }
        }
        var isIE = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));
        var npotTextureCube = true;
        if (!isIE) {
          var cubeTexture = gl2.createTexture();
          var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36);
          gl2.activeTexture(GL_TEXTURE0);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);
          gl2.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data);
          pool.freeType(data);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, null);
          gl2.deleteTexture(cubeTexture);
          npotTextureCube = !gl2.getError();
        }
        return {
          // drawing buffer bit depth
          colorBits: [
            gl2.getParameter(GL_RED_BITS),
            gl2.getParameter(GL_GREEN_BITS),
            gl2.getParameter(GL_BLUE_BITS),
            gl2.getParameter(GL_ALPHA_BITS)
          ],
          depthBits: gl2.getParameter(GL_DEPTH_BITS),
          stencilBits: gl2.getParameter(GL_STENCIL_BITS),
          subpixelBits: gl2.getParameter(GL_SUBPIXEL_BITS),
          // supported extensions
          extensions: Object.keys(extensions).filter(function(ext) {
            return !!extensions[ext];
          }),
          // max aniso samples
          maxAnisotropic,
          // max draw buffers
          maxDrawbuffers,
          maxColorAttachments,
          // point and line size ranges
          pointSizeDims: gl2.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
          lineWidthDims: gl2.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
          maxViewportDims: gl2.getParameter(GL_MAX_VIEWPORT_DIMS),
          maxCombinedTextureUnits: gl2.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
          maxCubeMapSize: gl2.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
          maxRenderbufferSize: gl2.getParameter(GL_MAX_RENDERBUFFER_SIZE),
          maxTextureUnits: gl2.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
          maxTextureSize: gl2.getParameter(GL_MAX_TEXTURE_SIZE),
          maxAttributes: gl2.getParameter(GL_MAX_VERTEX_ATTRIBS),
          maxVertexUniforms: gl2.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
          maxVertexTextureUnits: gl2.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          maxVaryingVectors: gl2.getParameter(GL_MAX_VARYING_VECTORS),
          maxFragmentUniforms: gl2.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),
          // vendor info
          glsl: gl2.getParameter(GL_SHADING_LANGUAGE_VERSION),
          renderer: gl2.getParameter(GL_RENDERER),
          vendor: gl2.getParameter(GL_VENDOR),
          version: gl2.getParameter(GL_VERSION),
          // quirks
          readFloat,
          npotTextureCube
        };
      };
      function isNDArrayLike(obj) {
        return !!obj && typeof obj === "object" && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === "number" && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray(obj.data));
      }
      var values3 = function(obj) {
        return Object.keys(obj).map(function(key) {
          return obj[key];
        });
      };
      var flattenUtils = {
        shape: arrayShape$1,
        flatten: flattenArray
      };
      function flatten1D(array, nx, out) {
        for (var i2 = 0; i2 < nx; ++i2) {
          out[i2] = array[i2];
        }
      }
      function flatten2D(array, nx, ny, out) {
        var ptr = 0;
        for (var i2 = 0; i2 < nx; ++i2) {
          var row = array[i2];
          for (var j2 = 0; j2 < ny; ++j2) {
            out[ptr++] = row[j2];
          }
        }
      }
      function flatten3D(array, nx, ny, nz, out, ptr_) {
        var ptr = ptr_;
        for (var i2 = 0; i2 < nx; ++i2) {
          var row = array[i2];
          for (var j2 = 0; j2 < ny; ++j2) {
            var col = row[j2];
            for (var k2 = 0; k2 < nz; ++k2) {
              out[ptr++] = col[k2];
            }
          }
        }
      }
      function flattenRec(array, shape, level, out, ptr) {
        var stride = 1;
        for (var i2 = level + 1; i2 < shape.length; ++i2) {
          stride *= shape[i2];
        }
        var n2 = shape[level];
        if (shape.length - level === 4) {
          var nx = shape[level + 1];
          var ny = shape[level + 2];
          var nz = shape[level + 3];
          for (i2 = 0; i2 < n2; ++i2) {
            flatten3D(array[i2], nx, ny, nz, out, ptr);
            ptr += stride;
          }
        } else {
          for (i2 = 0; i2 < n2; ++i2) {
            flattenRec(array[i2], shape, level + 1, out, ptr);
            ptr += stride;
          }
        }
      }
      function flattenArray(array, shape, type, out_) {
        var sz = 1;
        if (shape.length) {
          for (var i2 = 0; i2 < shape.length; ++i2) {
            sz *= shape[i2];
          }
        } else {
          sz = 0;
        }
        var out = out_ || pool.allocType(type, sz);
        switch (shape.length) {
          case 0:
            break;
          case 1:
            flatten1D(array, shape[0], out);
            break;
          case 2:
            flatten2D(array, shape[0], shape[1], out);
            break;
          case 3:
            flatten3D(array, shape[0], shape[1], shape[2], out, 0);
            break;
          default:
            flattenRec(array, shape, 0, out, 0);
        }
        return out;
      }
      function arrayShape$1(array_) {
        var shape = [];
        for (var array = array_; array.length; array = array[0]) {
          shape.push(array.length);
        }
        return shape;
      }
      var arrayTypes = {
        "[object Int8Array]": 5120,
        "[object Int16Array]": 5122,
        "[object Int32Array]": 5124,
        "[object Uint8Array]": 5121,
        "[object Uint8ClampedArray]": 5121,
        "[object Uint16Array]": 5123,
        "[object Uint32Array]": 5125,
        "[object Float32Array]": 5126,
        "[object Float64Array]": 5121,
        "[object ArrayBuffer]": 5121
      };
      var int8 = 5120;
      var int16 = 5122;
      var int32 = 5124;
      var uint8 = 5121;
      var uint16 = 5123;
      var uint32 = 5125;
      var float = 5126;
      var float32 = 5126;
      var glTypes = {
        int8,
        int16,
        int32,
        uint8,
        uint16,
        uint32,
        float,
        float32
      };
      var dynamic$1 = 35048;
      var stream = 35040;
      var usageTypes = {
        dynamic: dynamic$1,
        stream,
        "static": 35044
      };
      var arrayFlatten = flattenUtils.flatten;
      var arrayShape = flattenUtils.shape;
      var GL_STATIC_DRAW = 35044;
      var GL_STREAM_DRAW = 35040;
      var GL_UNSIGNED_BYTE$3 = 5121;
      var GL_FLOAT$3 = 5126;
      var DTYPES_SIZES = [];
      DTYPES_SIZES[5120] = 1;
      DTYPES_SIZES[5122] = 2;
      DTYPES_SIZES[5124] = 4;
      DTYPES_SIZES[5121] = 1;
      DTYPES_SIZES[5123] = 2;
      DTYPES_SIZES[5125] = 4;
      DTYPES_SIZES[5126] = 4;
      function typedArrayCode(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function copyArray(out, inp) {
        for (var i2 = 0; i2 < inp.length; ++i2) {
          out[i2] = inp[i2];
        }
      }
      function transpose4(result, data, shapeX, shapeY, strideX, strideY, offset) {
        var ptr = 0;
        for (var i2 = 0; i2 < shapeX; ++i2) {
          for (var j2 = 0; j2 < shapeY; ++j2) {
            result[ptr++] = data[strideX * i2 + strideY * j2 + offset];
          }
        }
      }
      function wrapBufferState(gl2, stats2, config, destroyBuffer) {
        var bufferCount = 0;
        var bufferSet = {};
        function REGLBuffer(type) {
          this.id = bufferCount++;
          this.buffer = gl2.createBuffer();
          this.type = type;
          this.usage = GL_STATIC_DRAW;
          this.byteLength = 0;
          this.dimension = 1;
          this.dtype = GL_UNSIGNED_BYTE$3;
          this.persistentData = null;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLBuffer.prototype.bind = function() {
          gl2.bindBuffer(this.type, this.buffer);
        };
        REGLBuffer.prototype.destroy = function() {
          destroy(this);
        };
        var streamPool = [];
        function createStream(type, data) {
          var buffer = streamPool.pop();
          if (!buffer) {
            buffer = new REGLBuffer(type);
          }
          buffer.bind();
          initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
          return buffer;
        }
        function destroyStream(stream$$1) {
          streamPool.push(stream$$1);
        }
        function initBufferFromTypedArray(buffer, data, usage) {
          buffer.byteLength = data.byteLength;
          gl2.bufferData(buffer.type, data, usage);
        }
        function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {
          var shape;
          buffer.usage = usage;
          if (Array.isArray(data)) {
            buffer.dtype = dtype || GL_FLOAT$3;
            if (data.length > 0) {
              var flatData;
              if (Array.isArray(data[0])) {
                shape = arrayShape(data);
                var dim = 1;
                for (var i2 = 1; i2 < shape.length; ++i2) {
                  dim *= shape[i2];
                }
                buffer.dimension = dim;
                flatData = arrayFlatten(data, shape, buffer.dtype);
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else if (typeof data[0] === "number") {
                buffer.dimension = dimension;
                var typedData = pool.allocType(buffer.dtype, data.length);
                copyArray(typedData, data);
                initBufferFromTypedArray(buffer, typedData, usage);
                if (persist) {
                  buffer.persistentData = typedData;
                } else {
                  pool.freeType(typedData);
                }
              } else if (isTypedArray(data[0])) {
                buffer.dimension = data[0].length;
                buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3;
                flatData = arrayFlatten(
                  data,
                  [data.length, data[0].length],
                  buffer.dtype
                );
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else {
                check$1.raise("invalid buffer data");
              }
            }
          } else if (isTypedArray(data)) {
            buffer.dtype = dtype || typedArrayCode(data);
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
            }
          } else if (isNDArrayLike(data)) {
            shape = data.shape;
            var stride = data.stride;
            var offset = data.offset;
            var shapeX = 0;
            var shapeY = 0;
            var strideX = 0;
            var strideY = 0;
            if (shape.length === 1) {
              shapeX = shape[0];
              shapeY = 1;
              strideX = stride[0];
              strideY = 0;
            } else if (shape.length === 2) {
              shapeX = shape[0];
              shapeY = shape[1];
              strideX = stride[0];
              strideY = stride[1];
            } else {
              check$1.raise("invalid shape");
            }
            buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3;
            buffer.dimension = shapeY;
            var transposeData2 = pool.allocType(buffer.dtype, shapeX * shapeY);
            transpose4(
              transposeData2,
              data.data,
              shapeX,
              shapeY,
              strideX,
              strideY,
              offset
            );
            initBufferFromTypedArray(buffer, transposeData2, usage);
            if (persist) {
              buffer.persistentData = transposeData2;
            } else {
              pool.freeType(transposeData2);
            }
          } else if (data instanceof ArrayBuffer) {
            buffer.dtype = GL_UNSIGNED_BYTE$3;
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data));
            }
          } else {
            check$1.raise("invalid buffer data");
          }
        }
        function destroy(buffer) {
          stats2.bufferCount--;
          destroyBuffer(buffer);
          var handle = buffer.buffer;
          check$1(handle, "buffer must not be deleted already");
          gl2.deleteBuffer(handle);
          buffer.buffer = null;
          delete bufferSet[buffer.id];
        }
        function createBuffer(options, type, deferInit, persistent) {
          stats2.bufferCount++;
          var buffer = new REGLBuffer(type);
          bufferSet[buffer.id] = buffer;
          function reglBuffer(options2) {
            var usage = GL_STATIC_DRAW;
            var data = null;
            var byteLength = 0;
            var dtype = 0;
            var dimension = 1;
            if (Array.isArray(options2) || isTypedArray(options2) || isNDArrayLike(options2) || options2 instanceof ArrayBuffer) {
              data = options2;
            } else if (typeof options2 === "number") {
              byteLength = options2 | 0;
            } else if (options2) {
              check$1.type(
                options2,
                "object",
                "buffer arguments must be an object, a number or an array"
              );
              if ("data" in options2) {
                check$1(
                  data === null || Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data),
                  "invalid data for buffer"
                );
                data = options2.data;
              }
              if ("usage" in options2) {
                check$1.parameter(options2.usage, usageTypes, "invalid buffer usage");
                usage = usageTypes[options2.usage];
              }
              if ("type" in options2) {
                check$1.parameter(options2.type, glTypes, "invalid buffer type");
                dtype = glTypes[options2.type];
              }
              if ("dimension" in options2) {
                check$1.type(options2.dimension, "number", "invalid dimension");
                dimension = options2.dimension | 0;
              }
              if ("length" in options2) {
                check$1.nni(byteLength, "buffer length must be a nonnegative integer");
                byteLength = options2.length | 0;
              }
            }
            buffer.bind();
            if (!data) {
              if (byteLength) gl2.bufferData(buffer.type, byteLength, usage);
              buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
              buffer.usage = usage;
              buffer.dimension = dimension;
              buffer.byteLength = byteLength;
            } else {
              initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
            }
            if (config.profile) {
              buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
            }
            return reglBuffer;
          }
          function setSubData(data, offset) {
            check$1(
              offset + data.byteLength <= buffer.byteLength,
              "invalid buffer subdata call, buffer is too small.  Can't write data of size " + data.byteLength + " starting from offset " + offset + " to a buffer of size " + buffer.byteLength
            );
            gl2.bufferSubData(buffer.type, offset, data);
          }
          function subdata(data, offset_) {
            var offset = (offset_ || 0) | 0;
            var shape;
            buffer.bind();
            if (isTypedArray(data) || data instanceof ArrayBuffer) {
              setSubData(data, offset);
            } else if (Array.isArray(data)) {
              if (data.length > 0) {
                if (typeof data[0] === "number") {
                  var converted = pool.allocType(buffer.dtype, data.length);
                  copyArray(converted, data);
                  setSubData(converted, offset);
                  pool.freeType(converted);
                } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
                  shape = arrayShape(data);
                  var flatData = arrayFlatten(data, shape, buffer.dtype);
                  setSubData(flatData, offset);
                  pool.freeType(flatData);
                } else {
                  check$1.raise("invalid buffer data");
                }
              }
            } else if (isNDArrayLike(data)) {
              shape = data.shape;
              var stride = data.stride;
              var shapeX = 0;
              var shapeY = 0;
              var strideX = 0;
              var strideY = 0;
              if (shape.length === 1) {
                shapeX = shape[0];
                shapeY = 1;
                strideX = stride[0];
                strideY = 0;
              } else if (shape.length === 2) {
                shapeX = shape[0];
                shapeY = shape[1];
                strideX = stride[0];
                strideY = stride[1];
              } else {
                check$1.raise("invalid shape");
              }
              var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);
              var transposeData2 = pool.allocType(dtype, shapeX * shapeY);
              transpose4(
                transposeData2,
                data.data,
                shapeX,
                shapeY,
                strideX,
                strideY,
                data.offset
              );
              setSubData(transposeData2, offset);
              pool.freeType(transposeData2);
            } else {
              check$1.raise("invalid data for buffer subdata");
            }
            return reglBuffer;
          }
          if (!deferInit) {
            reglBuffer(options);
          }
          reglBuffer._reglType = "buffer";
          reglBuffer._buffer = buffer;
          reglBuffer.subdata = subdata;
          if (config.profile) {
            reglBuffer.stats = buffer.stats;
          }
          reglBuffer.destroy = function() {
            destroy(buffer);
          };
          return reglBuffer;
        }
        function restoreBuffers() {
          values3(bufferSet).forEach(function(buffer) {
            buffer.buffer = gl2.createBuffer();
            gl2.bindBuffer(buffer.type, buffer.buffer);
            gl2.bufferData(
              buffer.type,
              buffer.persistentData || buffer.byteLength,
              buffer.usage
            );
          });
        }
        if (config.profile) {
          stats2.getTotalBufferSize = function() {
            var total = 0;
            Object.keys(bufferSet).forEach(function(key) {
              total += bufferSet[key].stats.size;
            });
            return total;
          };
        }
        return {
          create: createBuffer,
          createStream,
          destroyStream,
          clear: function() {
            values3(bufferSet).forEach(destroy);
            streamPool.forEach(destroy);
          },
          getBuffer: function(wrapper) {
            if (wrapper && wrapper._buffer instanceof REGLBuffer) {
              return wrapper._buffer;
            }
            return null;
          },
          restore: restoreBuffers,
          _initBuffer: initBufferFromData
        };
      }
      var points = 0;
      var point = 0;
      var lines = 1;
      var line = 1;
      var triangles = 4;
      var triangle2 = 4;
      var primTypes = {
        points,
        point,
        lines,
        line,
        triangles,
        triangle: triangle2,
        "line loop": 2,
        "line strip": 3,
        "triangle strip": 5,
        "triangle fan": 6
      };
      var GL_POINTS = 0;
      var GL_LINES = 1;
      var GL_TRIANGLES = 4;
      var GL_BYTE$2 = 5120;
      var GL_UNSIGNED_BYTE$4 = 5121;
      var GL_SHORT$2 = 5122;
      var GL_UNSIGNED_SHORT$2 = 5123;
      var GL_INT$2 = 5124;
      var GL_UNSIGNED_INT$2 = 5125;
      var GL_ELEMENT_ARRAY_BUFFER = 34963;
      var GL_STREAM_DRAW$1 = 35040;
      var GL_STATIC_DRAW$1 = 35044;
      function wrapElementsState(gl2, extensions, bufferState, stats2) {
        var elementSet = {};
        var elementCount = 0;
        var elementTypes = {
          "uint8": GL_UNSIGNED_BYTE$4,
          "uint16": GL_UNSIGNED_SHORT$2
        };
        if (extensions.oes_element_index_uint) {
          elementTypes.uint32 = GL_UNSIGNED_INT$2;
        }
        function REGLElementBuffer(buffer) {
          this.id = elementCount++;
          elementSet[this.id] = this;
          this.buffer = buffer;
          this.primType = GL_TRIANGLES;
          this.vertCount = 0;
          this.type = 0;
        }
        REGLElementBuffer.prototype.bind = function() {
          this.buffer.bind();
        };
        var bufferPool = [];
        function createElementStream(data) {
          var result = bufferPool.pop();
          if (!result) {
            result = new REGLElementBuffer(bufferState.create(
              null,
              GL_ELEMENT_ARRAY_BUFFER,
              true,
              false
            )._buffer);
          }
          initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
          return result;
        }
        function destroyElementStream(elements) {
          bufferPool.push(elements);
        }
        function initElements(elements, data, usage, prim3, count, byteLength, type) {
          elements.buffer.bind();
          var dtype;
          if (data) {
            var predictedType = type;
            if (!type && (!isTypedArray(data) || isNDArrayLike(data) && !isTypedArray(data.data))) {
              predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$2 : GL_UNSIGNED_SHORT$2;
            }
            bufferState._initBuffer(
              elements.buffer,
              data,
              usage,
              predictedType,
              3
            );
          } else {
            gl2.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
            elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4;
            elements.buffer.usage = usage;
            elements.buffer.dimension = 3;
            elements.buffer.byteLength = byteLength;
          }
          dtype = type;
          if (!type) {
            switch (elements.buffer.dtype) {
              case GL_UNSIGNED_BYTE$4:
              case GL_BYTE$2:
                dtype = GL_UNSIGNED_BYTE$4;
                break;
              case GL_UNSIGNED_SHORT$2:
              case GL_SHORT$2:
                dtype = GL_UNSIGNED_SHORT$2;
                break;
              case GL_UNSIGNED_INT$2:
              case GL_INT$2:
                dtype = GL_UNSIGNED_INT$2;
                break;
              default:
                check$1.raise("unsupported type for element array");
            }
            elements.buffer.dtype = dtype;
          }
          elements.type = dtype;
          check$1(
            dtype !== GL_UNSIGNED_INT$2 || !!extensions.oes_element_index_uint,
            "32 bit element buffers not supported, enable oes_element_index_uint first"
          );
          var vertCount = count;
          if (vertCount < 0) {
            vertCount = elements.buffer.byteLength;
            if (dtype === GL_UNSIGNED_SHORT$2) {
              vertCount >>= 1;
            } else if (dtype === GL_UNSIGNED_INT$2) {
              vertCount >>= 2;
            }
          }
          elements.vertCount = vertCount;
          var primType = prim3;
          if (prim3 < 0) {
            primType = GL_TRIANGLES;
            var dimension = elements.buffer.dimension;
            if (dimension === 1) primType = GL_POINTS;
            if (dimension === 2) primType = GL_LINES;
            if (dimension === 3) primType = GL_TRIANGLES;
          }
          elements.primType = primType;
        }
        function destroyElements(elements) {
          stats2.elementsCount--;
          check$1(elements.buffer !== null, "must not double destroy elements");
          delete elementSet[elements.id];
          elements.buffer.destroy();
          elements.buffer = null;
        }
        function createElements(options, persistent) {
          var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
          var elements = new REGLElementBuffer(buffer._buffer);
          stats2.elementsCount++;
          function reglElements(options2) {
            if (!options2) {
              buffer();
              elements.primType = GL_TRIANGLES;
              elements.vertCount = 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else if (typeof options2 === "number") {
              buffer(options2);
              elements.primType = GL_TRIANGLES;
              elements.vertCount = options2 | 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else {
              var data = null;
              var usage = GL_STATIC_DRAW$1;
              var primType = -1;
              var vertCount = -1;
              var byteLength = 0;
              var dtype = 0;
              if (Array.isArray(options2) || isTypedArray(options2) || isNDArrayLike(options2)) {
                data = options2;
              } else {
                check$1.type(options2, "object", "invalid arguments for elements");
                if ("data" in options2) {
                  data = options2.data;
                  check$1(
                    Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data),
                    "invalid data for element buffer"
                  );
                }
                if ("usage" in options2) {
                  check$1.parameter(
                    options2.usage,
                    usageTypes,
                    "invalid element buffer usage"
                  );
                  usage = usageTypes[options2.usage];
                }
                if ("primitive" in options2) {
                  check$1.parameter(
                    options2.primitive,
                    primTypes,
                    "invalid element buffer primitive"
                  );
                  primType = primTypes[options2.primitive];
                }
                if ("count" in options2) {
                  check$1(
                    typeof options2.count === "number" && options2.count >= 0,
                    "invalid vertex count for elements"
                  );
                  vertCount = options2.count | 0;
                }
                if ("type" in options2) {
                  check$1.parameter(
                    options2.type,
                    elementTypes,
                    "invalid buffer type"
                  );
                  dtype = elementTypes[options2.type];
                }
                if ("length" in options2) {
                  byteLength = options2.length | 0;
                } else {
                  byteLength = vertCount;
                  if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
                    byteLength *= 2;
                  } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
                    byteLength *= 4;
                  }
                }
              }
              initElements(
                elements,
                data,
                usage,
                primType,
                vertCount,
                byteLength,
                dtype
              );
            }
            return reglElements;
          }
          reglElements(options);
          reglElements._reglType = "elements";
          reglElements._elements = elements;
          reglElements.subdata = function(data, offset) {
            buffer.subdata(data, offset);
            return reglElements;
          };
          reglElements.destroy = function() {
            destroyElements(elements);
          };
          return reglElements;
        }
        return {
          create: createElements,
          createStream: createElementStream,
          destroyStream: destroyElementStream,
          getElements: function(elements) {
            if (typeof elements === "function" && elements._elements instanceof REGLElementBuffer) {
              return elements._elements;
            }
            return null;
          },
          clear: function() {
            values3(elementSet).forEach(destroyElements);
          }
        };
      }
      var FLOAT = new Float32Array(1);
      var INT = new Uint32Array(FLOAT.buffer);
      var GL_UNSIGNED_SHORT$4 = 5123;
      function convertToHalfFloat(array) {
        var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);
        for (var i2 = 0; i2 < array.length; ++i2) {
          if (isNaN(array[i2])) {
            ushorts[i2] = 65535;
          } else if (array[i2] === Infinity) {
            ushorts[i2] = 31744;
          } else if (array[i2] === -Infinity) {
            ushorts[i2] = 64512;
          } else {
            FLOAT[0] = array[i2];
            var x4 = INT[0];
            var sgn = x4 >>> 31 << 15;
            var exp2 = (x4 << 1 >>> 24) - 127;
            var frac = x4 >> 13 & (1 << 10) - 1;
            if (exp2 < -24) {
              ushorts[i2] = sgn;
            } else if (exp2 < -14) {
              var s2 = -14 - exp2;
              ushorts[i2] = sgn + (frac + (1 << 10) >> s2);
            } else if (exp2 > 15) {
              ushorts[i2] = sgn + 31744;
            } else {
              ushorts[i2] = sgn + (exp2 + 15 << 10) + frac;
            }
          }
        }
        return ushorts;
      }
      function isArrayLike3(s2) {
        return Array.isArray(s2) || isTypedArray(s2);
      }
      var isPow2$1 = function(v2) {
        return !(v2 & v2 - 1) && !!v2;
      };
      var GL_COMPRESSED_TEXTURE_FORMATS = 34467;
      var GL_TEXTURE_2D$1 = 3553;
      var GL_TEXTURE_CUBE_MAP$1 = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 34069;
      var GL_RGBA$1 = 6408;
      var GL_ALPHA = 6406;
      var GL_RGB = 6407;
      var GL_LUMINANCE = 6409;
      var GL_LUMINANCE_ALPHA = 6410;
      var GL_RGBA4 = 32854;
      var GL_RGB5_A1 = 32855;
      var GL_RGB565 = 36194;
      var GL_UNSIGNED_SHORT_4_4_4_4$1 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1$1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5$1 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL$1 = 34042;
      var GL_DEPTH_COMPONENT = 6402;
      var GL_DEPTH_STENCIL = 34041;
      var GL_SRGB_EXT = 35904;
      var GL_SRGB_ALPHA_EXT = 35906;
      var GL_HALF_FLOAT_OES$1 = 36193;
      var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
      var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
      var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
      var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
      var GL_COMPRESSED_RGB_ATC_WEBGL = 35986;
      var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987;
      var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
      var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
      var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
      var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
      var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
      var GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
      var GL_UNSIGNED_BYTE$5 = 5121;
      var GL_UNSIGNED_SHORT$3 = 5123;
      var GL_UNSIGNED_INT$3 = 5125;
      var GL_FLOAT$4 = 5126;
      var GL_TEXTURE_WRAP_S = 10242;
      var GL_TEXTURE_WRAP_T = 10243;
      var GL_REPEAT = 10497;
      var GL_CLAMP_TO_EDGE$1 = 33071;
      var GL_MIRRORED_REPEAT = 33648;
      var GL_TEXTURE_MAG_FILTER = 10240;
      var GL_TEXTURE_MIN_FILTER = 10241;
      var GL_NEAREST$1 = 9728;
      var GL_LINEAR = 9729;
      var GL_NEAREST_MIPMAP_NEAREST$1 = 9984;
      var GL_LINEAR_MIPMAP_NEAREST$1 = 9985;
      var GL_NEAREST_MIPMAP_LINEAR$1 = 9986;
      var GL_LINEAR_MIPMAP_LINEAR$1 = 9987;
      var GL_GENERATE_MIPMAP_HINT = 33170;
      var GL_DONT_CARE = 4352;
      var GL_FASTEST = 4353;
      var GL_NICEST = 4354;
      var GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046;
      var GL_UNPACK_ALIGNMENT = 3317;
      var GL_UNPACK_FLIP_Y_WEBGL = 37440;
      var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
      var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
      var GL_BROWSER_DEFAULT_WEBGL = 37444;
      var GL_TEXTURE0$1 = 33984;
      var MIPMAP_FILTERS = [
        GL_NEAREST_MIPMAP_NEAREST$1,
        GL_NEAREST_MIPMAP_LINEAR$1,
        GL_LINEAR_MIPMAP_NEAREST$1,
        GL_LINEAR_MIPMAP_LINEAR$1
      ];
      var CHANNELS_FORMAT = [
        0,
        GL_LUMINANCE,
        GL_LUMINANCE_ALPHA,
        GL_RGB,
        GL_RGBA$1
      ];
      var FORMAT_CHANNELS = {};
      FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
      FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
      FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
      FORMAT_CHANNELS[GL_RGBA$1] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;
      function objectName(str10) {
        return "[object " + str10 + "]";
      }
      var CANVAS_CLASS = objectName("HTMLCanvasElement");
      var OFFSCREENCANVAS_CLASS = objectName("OffscreenCanvas");
      var CONTEXT2D_CLASS = objectName("CanvasRenderingContext2D");
      var BITMAP_CLASS = objectName("ImageBitmap");
      var IMAGE_CLASS = objectName("HTMLImageElement");
      var VIDEO_CLASS = objectName("HTMLVideoElement");
      var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
        CANVAS_CLASS,
        OFFSCREENCANVAS_CLASS,
        CONTEXT2D_CLASS,
        BITMAP_CLASS,
        IMAGE_CLASS,
        VIDEO_CLASS
      ]);
      var TYPE_SIZES = [];
      TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1;
      TYPE_SIZES[GL_FLOAT$4] = 4;
      TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;
      TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
      TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;
      var FORMAT_SIZES_SPECIAL = [];
      FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
      FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;
      function isNumericArray(arr) {
        return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === "number");
      }
      function isRectArray(arr) {
        if (!Array.isArray(arr)) {
          return false;
        }
        var width = arr.length;
        if (width === 0 || !isArrayLike3(arr[0])) {
          return false;
        }
        return true;
      }
      function classString(x4) {
        return Object.prototype.toString.call(x4);
      }
      function isCanvasElement(object) {
        return classString(object) === CANVAS_CLASS;
      }
      function isOffscreenCanvas(object) {
        return classString(object) === OFFSCREENCANVAS_CLASS;
      }
      function isContext2D(object) {
        return classString(object) === CONTEXT2D_CLASS;
      }
      function isBitmap(object) {
        return classString(object) === BITMAP_CLASS;
      }
      function isImageElement(object) {
        return classString(object) === IMAGE_CLASS;
      }
      function isVideoElement(object) {
        return classString(object) === VIDEO_CLASS;
      }
      function isPixelData(object) {
        if (!object) {
          return false;
        }
        var className = classString(object);
        if (PIXEL_CLASSES.indexOf(className) >= 0) {
          return true;
        }
        return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);
      }
      function typedArrayCode$1(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function convertData(result, data) {
        var n2 = data.length;
        switch (result.type) {
          case GL_UNSIGNED_BYTE$5:
          case GL_UNSIGNED_SHORT$3:
          case GL_UNSIGNED_INT$3:
          case GL_FLOAT$4:
            var converted = pool.allocType(result.type, n2);
            converted.set(data);
            result.data = converted;
            break;
          case GL_HALF_FLOAT_OES$1:
            result.data = convertToHalfFloat(data);
            break;
          default:
            check$1.raise("unsupported texture type, must specify a typed array");
        }
      }
      function preConvert(image, n2) {
        return pool.allocType(
          image.type === GL_HALF_FLOAT_OES$1 ? GL_FLOAT$4 : image.type,
          n2
        );
      }
      function postConvert(image, data) {
        if (image.type === GL_HALF_FLOAT_OES$1) {
          image.data = convertToHalfFloat(data);
          pool.freeType(data);
        } else {
          image.data = data;
        }
      }
      function transposeData(image, array, strideX, strideY, strideC, offset) {
        var w2 = image.width;
        var h2 = image.height;
        var c3 = image.channels;
        var n2 = w2 * h2 * c3;
        var data = preConvert(image, n2);
        var p2 = 0;
        for (var i2 = 0; i2 < h2; ++i2) {
          for (var j2 = 0; j2 < w2; ++j2) {
            for (var k2 = 0; k2 < c3; ++k2) {
              data[p2++] = array[strideX * j2 + strideY * i2 + strideC * k2 + offset];
            }
          }
        }
        postConvert(image, data);
      }
      function getTextureSize(format2, type, width, height, isMipmap, isCube) {
        var s2;
        if (typeof FORMAT_SIZES_SPECIAL[format2] !== "undefined") {
          s2 = FORMAT_SIZES_SPECIAL[format2];
        } else {
          s2 = FORMAT_CHANNELS[format2] * TYPE_SIZES[type];
        }
        if (isCube) {
          s2 *= 6;
        }
        if (isMipmap) {
          var total = 0;
          var w2 = width;
          while (w2 >= 1) {
            total += s2 * w2 * w2;
            w2 /= 2;
          }
          return total;
        } else {
          return s2 * width * height;
        }
      }
      function createTextureSet(gl2, extensions, limits, reglPoll, contextState, stats2, config) {
        var mipmapHint = {
          "don't care": GL_DONT_CARE,
          "dont care": GL_DONT_CARE,
          "nice": GL_NICEST,
          "fast": GL_FASTEST
        };
        var wrapModes = {
          "repeat": GL_REPEAT,
          "clamp": GL_CLAMP_TO_EDGE$1,
          "mirror": GL_MIRRORED_REPEAT
        };
        var magFilters = {
          "nearest": GL_NEAREST$1,
          "linear": GL_LINEAR
        };
        var minFilters = extend4({
          "mipmap": GL_LINEAR_MIPMAP_LINEAR$1,
          "nearest mipmap nearest": GL_NEAREST_MIPMAP_NEAREST$1,
          "linear mipmap nearest": GL_LINEAR_MIPMAP_NEAREST$1,
          "nearest mipmap linear": GL_NEAREST_MIPMAP_LINEAR$1,
          "linear mipmap linear": GL_LINEAR_MIPMAP_LINEAR$1
        }, magFilters);
        var colorSpace = {
          "none": 0,
          "browser": GL_BROWSER_DEFAULT_WEBGL
        };
        var textureTypes = {
          "uint8": GL_UNSIGNED_BYTE$5,
          "rgba4": GL_UNSIGNED_SHORT_4_4_4_4$1,
          "rgb565": GL_UNSIGNED_SHORT_5_6_5$1,
          "rgb5 a1": GL_UNSIGNED_SHORT_5_5_5_1$1
        };
        var textureFormats = {
          "alpha": GL_ALPHA,
          "luminance": GL_LUMINANCE,
          "luminance alpha": GL_LUMINANCE_ALPHA,
          "rgb": GL_RGB,
          "rgba": GL_RGBA$1,
          "rgba4": GL_RGBA4,
          "rgb5 a1": GL_RGB5_A1,
          "rgb565": GL_RGB565
        };
        var compressedTextureFormats = {};
        if (extensions.ext_srgb) {
          textureFormats.srgb = GL_SRGB_EXT;
          textureFormats.srgba = GL_SRGB_ALPHA_EXT;
        }
        if (extensions.oes_texture_float) {
          textureTypes.float32 = textureTypes.float = GL_FLOAT$4;
        }
        if (extensions.oes_texture_half_float) {
          textureTypes["float16"] = textureTypes["half float"] = GL_HALF_FLOAT_OES$1;
        }
        if (extensions.webgl_depth_texture) {
          extend4(textureFormats, {
            "depth": GL_DEPTH_COMPONENT,
            "depth stencil": GL_DEPTH_STENCIL
          });
          extend4(textureTypes, {
            "uint16": GL_UNSIGNED_SHORT$3,
            "uint32": GL_UNSIGNED_INT$3,
            "depth stencil": GL_UNSIGNED_INT_24_8_WEBGL$1
          });
        }
        if (extensions.webgl_compressed_texture_s3tc) {
          extend4(compressedTextureFormats, {
            "rgb s3tc dxt1": GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
            "rgba s3tc dxt1": GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "rgba s3tc dxt3": GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "rgba s3tc dxt5": GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
          });
        }
        if (extensions.webgl_compressed_texture_atc) {
          extend4(compressedTextureFormats, {
            "rgb atc": GL_COMPRESSED_RGB_ATC_WEBGL,
            "rgba atc explicit alpha": GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
            "rgba atc interpolated alpha": GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
          });
        }
        if (extensions.webgl_compressed_texture_pvrtc) {
          extend4(compressedTextureFormats, {
            "rgb pvrtc 4bppv1": GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
            "rgb pvrtc 2bppv1": GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
            "rgba pvrtc 4bppv1": GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
            "rgba pvrtc 2bppv1": GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
          });
        }
        if (extensions.webgl_compressed_texture_etc1) {
          compressedTextureFormats["rgb etc1"] = GL_COMPRESSED_RGB_ETC1_WEBGL;
        }
        var supportedCompressedFormats = Array.prototype.slice.call(
          gl2.getParameter(GL_COMPRESSED_TEXTURE_FORMATS)
        );
        Object.keys(compressedTextureFormats).forEach(function(name) {
          var format2 = compressedTextureFormats[name];
          if (supportedCompressedFormats.indexOf(format2) >= 0) {
            textureFormats[name] = format2;
          }
        });
        var supportedFormats = Object.keys(textureFormats);
        limits.textureFormats = supportedFormats;
        var textureFormatsInvert = [];
        Object.keys(textureFormats).forEach(function(key) {
          var val = textureFormats[key];
          textureFormatsInvert[val] = key;
        });
        var textureTypesInvert = [];
        Object.keys(textureTypes).forEach(function(key) {
          var val = textureTypes[key];
          textureTypesInvert[val] = key;
        });
        var magFiltersInvert = [];
        Object.keys(magFilters).forEach(function(key) {
          var val = magFilters[key];
          magFiltersInvert[val] = key;
        });
        var minFiltersInvert = [];
        Object.keys(minFilters).forEach(function(key) {
          var val = minFilters[key];
          minFiltersInvert[val] = key;
        });
        var wrapModesInvert = [];
        Object.keys(wrapModes).forEach(function(key) {
          var val = wrapModes[key];
          wrapModesInvert[val] = key;
        });
        var colorFormats = supportedFormats.reduce(function(color3, key) {
          var glenum = textureFormats[key];
          if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL || extensions.ext_srgb && (glenum === GL_SRGB_EXT || glenum === GL_SRGB_ALPHA_EXT)) {
            color3[glenum] = glenum;
          } else if (glenum === GL_RGB5_A1 || key.indexOf("rgba") >= 0) {
            color3[glenum] = GL_RGBA$1;
          } else {
            color3[glenum] = GL_RGB;
          }
          return color3;
        }, {});
        function TexFlags() {
          this.internalformat = GL_RGBA$1;
          this.format = GL_RGBA$1;
          this.type = GL_UNSIGNED_BYTE$5;
          this.compressed = false;
          this.premultiplyAlpha = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;
          this.width = 0;
          this.height = 0;
          this.channels = 0;
        }
        function copyFlags(result, other) {
          result.internalformat = other.internalformat;
          result.format = other.format;
          result.type = other.type;
          result.compressed = other.compressed;
          result.premultiplyAlpha = other.premultiplyAlpha;
          result.flipY = other.flipY;
          result.unpackAlignment = other.unpackAlignment;
          result.colorSpace = other.colorSpace;
          result.width = other.width;
          result.height = other.height;
          result.channels = other.channels;
        }
        function parseFlags2(flags, options) {
          if (typeof options !== "object" || !options) {
            return;
          }
          if ("premultiplyAlpha" in options) {
            check$1.type(
              options.premultiplyAlpha,
              "boolean",
              "invalid premultiplyAlpha"
            );
            flags.premultiplyAlpha = options.premultiplyAlpha;
          }
          if ("flipY" in options) {
            check$1.type(
              options.flipY,
              "boolean",
              "invalid texture flip"
            );
            flags.flipY = options.flipY;
          }
          if ("alignment" in options) {
            check$1.oneOf(
              options.alignment,
              [1, 2, 4, 8],
              "invalid texture unpack alignment"
            );
            flags.unpackAlignment = options.alignment;
          }
          if ("colorSpace" in options) {
            check$1.parameter(
              options.colorSpace,
              colorSpace,
              "invalid colorSpace"
            );
            flags.colorSpace = colorSpace[options.colorSpace];
          }
          if ("type" in options) {
            var type = options.type;
            check$1(
              extensions.oes_texture_float || !(type === "float" || type === "float32"),
              "you must enable the OES_texture_float extension in order to use floating point textures."
            );
            check$1(
              extensions.oes_texture_half_float || !(type === "half float" || type === "float16"),
              "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."
            );
            check$1(
              extensions.webgl_depth_texture || !(type === "uint16" || type === "uint32" || type === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            );
            check$1.parameter(
              type,
              textureTypes,
              "invalid texture type"
            );
            flags.type = textureTypes[type];
          }
          var w2 = flags.width;
          var h2 = flags.height;
          var c3 = flags.channels;
          var hasChannels = false;
          if ("shape" in options) {
            check$1(
              Array.isArray(options.shape) && options.shape.length >= 2,
              "shape must be an array"
            );
            w2 = options.shape[0];
            h2 = options.shape[1];
            if (options.shape.length === 3) {
              c3 = options.shape[2];
              check$1(c3 > 0 && c3 <= 4, "invalid number of channels");
              hasChannels = true;
            }
            check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid width");
            check$1(h2 >= 0 && h2 <= limits.maxTextureSize, "invalid height");
          } else {
            if ("radius" in options) {
              w2 = h2 = options.radius;
              check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid radius");
            }
            if ("width" in options) {
              w2 = options.width;
              check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid width");
            }
            if ("height" in options) {
              h2 = options.height;
              check$1(h2 >= 0 && h2 <= limits.maxTextureSize, "invalid height");
            }
            if ("channels" in options) {
              c3 = options.channels;
              check$1(c3 > 0 && c3 <= 4, "invalid number of channels");
              hasChannels = true;
            }
          }
          flags.width = w2 | 0;
          flags.height = h2 | 0;
          flags.channels = c3 | 0;
          var hasFormat = false;
          if ("format" in options) {
            var formatStr = options.format;
            check$1(
              extensions.webgl_depth_texture || !(formatStr === "depth" || formatStr === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            );
            check$1.parameter(
              formatStr,
              textureFormats,
              "invalid texture format"
            );
            var internalformat = flags.internalformat = textureFormats[formatStr];
            flags.format = colorFormats[internalformat];
            if (formatStr in textureTypes) {
              if (!("type" in options)) {
                flags.type = textureTypes[formatStr];
              }
            }
            if (formatStr in compressedTextureFormats) {
              flags.compressed = true;
            }
            hasFormat = true;
          }
          if (!hasChannels && hasFormat) {
            flags.channels = FORMAT_CHANNELS[flags.format];
          } else if (hasChannels && !hasFormat) {
            if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
              flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
            }
          } else if (hasFormat && hasChannels) {
            check$1(
              flags.channels === FORMAT_CHANNELS[flags.format],
              "number of channels inconsistent with specified format"
            );
          }
        }
        function setFlags(flags) {
          gl2.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
          gl2.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
          gl2.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
          gl2.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
        }
        function TexImage() {
          TexFlags.call(this);
          this.xOffset = 0;
          this.yOffset = 0;
          this.data = null;
          this.needsFree = false;
          this.element = null;
          this.needsCopy = false;
        }
        function parseImage(image, options) {
          var data = null;
          if (isPixelData(options)) {
            data = options;
          } else if (options) {
            check$1.type(options, "object", "invalid pixel data type");
            parseFlags2(image, options);
            if ("x" in options) {
              image.xOffset = options.x | 0;
            }
            if ("y" in options) {
              image.yOffset = options.y | 0;
            }
            if (isPixelData(options.data)) {
              data = options.data;
            }
          }
          check$1(
            !image.compressed || data instanceof Uint8Array,
            "compressed texture data must be stored in a uint8array"
          );
          if (options.copy) {
            check$1(!data, "can not specify copy and data field for the same texture");
            var viewW = contextState.viewportWidth;
            var viewH = contextState.viewportHeight;
            image.width = image.width || viewW - image.xOffset;
            image.height = image.height || viewH - image.yOffset;
            image.needsCopy = true;
            check$1(
              image.xOffset >= 0 && image.xOffset < viewW && image.yOffset >= 0 && image.yOffset < viewH && image.width > 0 && image.width <= viewW && image.height > 0 && image.height <= viewH,
              "copy texture read out of bounds"
            );
          } else if (!data) {
            image.width = image.width || 1;
            image.height = image.height || 1;
            image.channels = image.channels || 4;
          } else if (isTypedArray(data)) {
            image.channels = image.channels || 4;
            image.data = data;
            if (!("type" in options) && image.type === GL_UNSIGNED_BYTE$5) {
              image.type = typedArrayCode$1(data);
            }
          } else if (isNumericArray(data)) {
            image.channels = image.channels || 4;
            convertData(image, data);
            image.alignment = 1;
            image.needsFree = true;
          } else if (isNDArrayLike(data)) {
            var array = data.data;
            if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
              image.type = typedArrayCode$1(array);
            }
            var shape = data.shape;
            var stride = data.stride;
            var shapeX, shapeY, shapeC, strideX, strideY, strideC;
            if (shape.length === 3) {
              shapeC = shape[2];
              strideC = stride[2];
            } else {
              check$1(shape.length === 2, "invalid ndarray pixel data, must be 2 or 3D");
              shapeC = 1;
              strideC = 1;
            }
            shapeX = shape[0];
            shapeY = shape[1];
            strideX = stride[0];
            strideY = stride[1];
            image.alignment = 1;
            image.width = shapeX;
            image.height = shapeY;
            image.channels = shapeC;
            image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
            image.needsFree = true;
            transposeData(image, array, strideX, strideY, strideC, data.offset);
          } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
            if (isCanvasElement(data) || isOffscreenCanvas(data)) {
              image.element = data;
            } else {
              image.element = data.canvas;
            }
            image.width = image.element.width;
            image.height = image.element.height;
            image.channels = 4;
          } else if (isBitmap(data)) {
            image.element = data;
            image.width = data.width;
            image.height = data.height;
            image.channels = 4;
          } else if (isImageElement(data)) {
            image.element = data;
            image.width = data.naturalWidth;
            image.height = data.naturalHeight;
            image.channels = 4;
          } else if (isVideoElement(data)) {
            image.element = data;
            image.width = data.videoWidth;
            image.height = data.videoHeight;
            image.channels = 4;
          } else if (isRectArray(data)) {
            var w2 = image.width || data[0].length;
            var h2 = image.height || data.length;
            var c3 = image.channels;
            if (isArrayLike3(data[0][0])) {
              c3 = c3 || data[0][0].length;
            } else {
              c3 = c3 || 1;
            }
            var arrayShape2 = flattenUtils.shape(data);
            var n2 = 1;
            for (var dd = 0; dd < arrayShape2.length; ++dd) {
              n2 *= arrayShape2[dd];
            }
            var allocData = preConvert(image, n2);
            flattenUtils.flatten(data, arrayShape2, "", allocData);
            postConvert(image, allocData);
            image.alignment = 1;
            image.width = w2;
            image.height = h2;
            image.channels = c3;
            image.format = image.internalformat = CHANNELS_FORMAT[c3];
            image.needsFree = true;
          }
          if (image.type === GL_FLOAT$4) {
            check$1(
              limits.extensions.indexOf("oes_texture_float") >= 0,
              "oes_texture_float extension not enabled"
            );
          } else if (image.type === GL_HALF_FLOAT_OES$1) {
            check$1(
              limits.extensions.indexOf("oes_texture_half_float") >= 0,
              "oes_texture_half_float extension not enabled"
            );
          }
        }
        function setImage(info, target, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format2 = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texImage2D(target, miplevel, format2, format2, type, element);
          } else if (info.compressed) {
            gl2.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexImage2D(
              target,
              miplevel,
              format2,
              info.xOffset,
              info.yOffset,
              width,
              height,
              0
            );
          } else {
            gl2.texImage2D(target, miplevel, format2, width, height, 0, format2, type, data || null);
          }
        }
        function setSubImage(info, target, x4, y4, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format2 = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              format2,
              type,
              element
            );
          } else if (info.compressed) {
            gl2.compressedTexSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              internalformat,
              width,
              height,
              data
            );
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              info.xOffset,
              info.yOffset,
              width,
              height
            );
          } else {
            gl2.texSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              width,
              height,
              format2,
              type,
              data
            );
          }
        }
        var imagePool = [];
        function allocImage() {
          return imagePool.pop() || new TexImage();
        }
        function freeImage(image) {
          if (image.needsFree) {
            pool.freeType(image.data);
          }
          TexImage.call(image);
          imagePool.push(image);
        }
        function MipMap() {
          TexFlags.call(this);
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
          this.mipmask = 0;
          this.images = Array(16);
        }
        function parseMipMapFromShape(mipmap, width, height) {
          var img = mipmap.images[0] = allocImage();
          mipmap.mipmask = 1;
          img.width = mipmap.width = width;
          img.height = mipmap.height = height;
          img.channels = mipmap.channels = 4;
        }
        function parseMipMapFromObject(mipmap, options) {
          var imgData = null;
          if (isPixelData(options)) {
            imgData = mipmap.images[0] = allocImage();
            copyFlags(imgData, mipmap);
            parseImage(imgData, options);
            mipmap.mipmask = 1;
          } else {
            parseFlags2(mipmap, options);
            if (Array.isArray(options.mipmap)) {
              var mipData = options.mipmap;
              for (var i2 = 0; i2 < mipData.length; ++i2) {
                imgData = mipmap.images[i2] = allocImage();
                copyFlags(imgData, mipmap);
                imgData.width >>= i2;
                imgData.height >>= i2;
                parseImage(imgData, mipData[i2]);
                mipmap.mipmask |= 1 << i2;
              }
            } else {
              imgData = mipmap.images[0] = allocImage();
              copyFlags(imgData, mipmap);
              parseImage(imgData, options);
              mipmap.mipmask = 1;
            }
          }
          copyFlags(mipmap, mipmap.images[0]);
          if (mipmap.compressed && (mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT)) {
            check$1(
              mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
              "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4"
            );
          }
        }
        function setMipMap(mipmap, target) {
          var images = mipmap.images;
          for (var i2 = 0; i2 < images.length; ++i2) {
            if (!images[i2]) {
              return;
            }
            setImage(images[i2], target, i2);
          }
        }
        var mipPool = [];
        function allocMipMap() {
          var result = mipPool.pop() || new MipMap();
          TexFlags.call(result);
          result.mipmask = 0;
          for (var i2 = 0; i2 < 16; ++i2) {
            result.images[i2] = null;
          }
          return result;
        }
        function freeMipMap(mipmap) {
          var images = mipmap.images;
          for (var i2 = 0; i2 < images.length; ++i2) {
            if (images[i2]) {
              freeImage(images[i2]);
            }
            images[i2] = null;
          }
          mipPool.push(mipmap);
        }
        function TexInfo() {
          this.minFilter = GL_NEAREST$1;
          this.magFilter = GL_NEAREST$1;
          this.wrapS = GL_CLAMP_TO_EDGE$1;
          this.wrapT = GL_CLAMP_TO_EDGE$1;
          this.anisotropic = 1;
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
        }
        function parseTexInfo(info, options) {
          if ("min" in options) {
            var minFilter = options.min;
            check$1.parameter(minFilter, minFilters);
            info.minFilter = minFilters[minFilter];
            if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !("faces" in options)) {
              info.genMipmaps = true;
            }
          }
          if ("mag" in options) {
            var magFilter = options.mag;
            check$1.parameter(magFilter, magFilters);
            info.magFilter = magFilters[magFilter];
          }
          var wrapS = info.wrapS;
          var wrapT = info.wrapT;
          if ("wrap" in options) {
            var wrap2 = options.wrap;
            if (typeof wrap2 === "string") {
              check$1.parameter(wrap2, wrapModes);
              wrapS = wrapT = wrapModes[wrap2];
            } else if (Array.isArray(wrap2)) {
              check$1.parameter(wrap2[0], wrapModes);
              check$1.parameter(wrap2[1], wrapModes);
              wrapS = wrapModes[wrap2[0]];
              wrapT = wrapModes[wrap2[1]];
            }
          } else {
            if ("wrapS" in options) {
              var optWrapS = options.wrapS;
              check$1.parameter(optWrapS, wrapModes);
              wrapS = wrapModes[optWrapS];
            }
            if ("wrapT" in options) {
              var optWrapT = options.wrapT;
              check$1.parameter(optWrapT, wrapModes);
              wrapT = wrapModes[optWrapT];
            }
          }
          info.wrapS = wrapS;
          info.wrapT = wrapT;
          if ("anisotropic" in options) {
            var anisotropic = options.anisotropic;
            check$1(
              typeof anisotropic === "number" && anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
              "aniso samples must be between 1 and "
            );
            info.anisotropic = options.anisotropic;
          }
          if ("mipmap" in options) {
            var hasMipMap = false;
            switch (typeof options.mipmap) {
              case "string":
                check$1.parameter(
                  options.mipmap,
                  mipmapHint,
                  "invalid mipmap hint"
                );
                info.mipmapHint = mipmapHint[options.mipmap];
                info.genMipmaps = true;
                hasMipMap = true;
                break;
              case "boolean":
                hasMipMap = info.genMipmaps = options.mipmap;
                break;
              case "object":
                check$1(Array.isArray(options.mipmap), "invalid mipmap type");
                info.genMipmaps = false;
                hasMipMap = true;
                break;
              default:
                check$1.raise("invalid mipmap type");
            }
            if (hasMipMap && !("min" in options)) {
              info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
            }
          }
        }
        function setTexInfo(info, target) {
          gl2.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
          gl2.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
          if (extensions.ext_texture_filter_anisotropic) {
            gl2.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
          }
          if (info.genMipmaps) {
            gl2.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
            gl2.generateMipmap(target);
          }
        }
        var textureCount = 0;
        var textureSet = {};
        var numTexUnits = limits.maxTextureUnits;
        var textureUnits = Array(numTexUnits).map(function() {
          return null;
        });
        function REGLTexture(target) {
          TexFlags.call(this);
          this.mipmask = 0;
          this.internalformat = GL_RGBA$1;
          this.id = textureCount++;
          this.refCount = 1;
          this.target = target;
          this.texture = gl2.createTexture();
          this.unit = -1;
          this.bindCount = 0;
          this.texInfo = new TexInfo();
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        function tempBind(texture) {
          gl2.activeTexture(GL_TEXTURE0$1);
          gl2.bindTexture(texture.target, texture.texture);
        }
        function tempRestore() {
          var prev = textureUnits[0];
          if (prev) {
            gl2.bindTexture(prev.target, prev.texture);
          } else {
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
          }
        }
        function destroy(texture) {
          var handle = texture.texture;
          check$1(handle, "must not double destroy texture");
          var unit = texture.unit;
          var target = texture.target;
          if (unit >= 0) {
            gl2.activeTexture(GL_TEXTURE0$1 + unit);
            gl2.bindTexture(target, null);
            textureUnits[unit] = null;
          }
          gl2.deleteTexture(handle);
          texture.texture = null;
          texture.params = null;
          texture.pixels = null;
          texture.refCount = 0;
          delete textureSet[texture.id];
          stats2.textureCount--;
        }
        extend4(REGLTexture.prototype, {
          bind: function() {
            var texture = this;
            texture.bindCount += 1;
            var unit = texture.unit;
            if (unit < 0) {
              for (var i2 = 0; i2 < numTexUnits; ++i2) {
                var other = textureUnits[i2];
                if (other) {
                  if (other.bindCount > 0) {
                    continue;
                  }
                  other.unit = -1;
                }
                textureUnits[i2] = texture;
                unit = i2;
                break;
              }
              if (unit >= numTexUnits) {
                check$1.raise("insufficient number of texture units");
              }
              if (config.profile && stats2.maxTextureUnits < unit + 1) {
                stats2.maxTextureUnits = unit + 1;
              }
              texture.unit = unit;
              gl2.activeTexture(GL_TEXTURE0$1 + unit);
              gl2.bindTexture(texture.target, texture.texture);
            }
            return unit;
          },
          unbind: function() {
            this.bindCount -= 1;
          },
          decRef: function() {
            if (--this.refCount <= 0) {
              destroy(this);
            }
          }
        });
        function createTexture2D(a3, b10) {
          var texture = new REGLTexture(GL_TEXTURE_2D$1);
          textureSet[texture.id] = texture;
          stats2.textureCount++;
          function reglTexture2D(a4, b11) {
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            var mipData = allocMipMap();
            if (typeof a4 === "number") {
              if (typeof b11 === "number") {
                parseMipMapFromShape(mipData, a4 | 0, b11 | 0);
              } else {
                parseMipMapFromShape(mipData, a4 | 0, a4 | 0);
              }
            } else if (a4) {
              check$1.type(a4, "object", "invalid arguments to regl.texture");
              parseTexInfo(texInfo, a4);
              parseMipMapFromObject(mipData, a4);
            } else {
              parseMipMapFromShape(mipData, 1, 1);
            }
            if (texInfo.genMipmaps) {
              mipData.mipmask = (mipData.width << 1) - 1;
            }
            texture.mipmask = mipData.mipmask;
            copyFlags(texture, mipData);
            check$1.texture2D(texInfo, mipData, limits);
            texture.internalformat = mipData.internalformat;
            reglTexture2D.width = mipData.width;
            reglTexture2D.height = mipData.height;
            tempBind(texture);
            setMipMap(mipData, GL_TEXTURE_2D$1);
            setTexInfo(texInfo, GL_TEXTURE_2D$1);
            tempRestore();
            freeMipMap(mipData);
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                mipData.width,
                mipData.height,
                texInfo.genMipmaps,
                false
              );
            }
            reglTexture2D.format = textureFormatsInvert[texture.internalformat];
            reglTexture2D.type = textureTypesInvert[texture.type];
            reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
            reglTexture2D.min = minFiltersInvert[texInfo.minFilter];
            reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];
            return reglTexture2D;
          }
          function subimage(image, x_, y_, level_) {
            check$1(!!image, "must specify image data");
            var x4 = x_ | 0;
            var y4 = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image);
            imageData.width = imageData.width || (texture.width >> level) - x4;
            imageData.height = imageData.height || (texture.height >> level) - y4;
            check$1(
              texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat,
              "incompatible format for texture.subimage"
            );
            check$1(
              x4 >= 0 && y4 >= 0 && x4 + imageData.width <= texture.width && y4 + imageData.height <= texture.height,
              "texture.subimage write out of bounds"
            );
            check$1(
              texture.mipmask & 1 << level,
              "missing mipmap data"
            );
            check$1(
              imageData.data || imageData.element || imageData.needsCopy,
              "missing image data"
            );
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_2D$1, x4, y4, level);
            tempRestore();
            freeImage(imageData);
            return reglTexture2D;
          }
          function resize(w_, h_) {
            var w2 = w_ | 0;
            var h2 = h_ | 0 || w2;
            if (w2 === texture.width && h2 === texture.height) {
              return reglTexture2D;
            }
            reglTexture2D.width = texture.width = w2;
            reglTexture2D.height = texture.height = h2;
            tempBind(texture);
            for (var i2 = 0; texture.mipmask >> i2; ++i2) {
              var _w = w2 >> i2;
              var _h = h2 >> i2;
              if (!_w || !_h) break;
              gl2.texImage2D(
                GL_TEXTURE_2D$1,
                i2,
                texture.format,
                _w,
                _h,
                0,
                texture.format,
                texture.type,
                null
              );
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                w2,
                h2,
                false,
                false
              );
            }
            return reglTexture2D;
          }
          reglTexture2D(a3, b10);
          reglTexture2D.subimage = subimage;
          reglTexture2D.resize = resize;
          reglTexture2D._reglType = "texture2d";
          reglTexture2D._texture = texture;
          if (config.profile) {
            reglTexture2D.stats = texture.stats;
          }
          reglTexture2D.destroy = function() {
            texture.decRef();
          };
          return reglTexture2D;
        }
        function createTextureCube(a0, a1, a22, a3, a4, a5) {
          var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);
          textureSet[texture.id] = texture;
          stats2.cubeCount++;
          var faces = new Array(6);
          function reglTextureCube(a02, a12, a23, a32, a42, a52) {
            var i2;
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            for (i2 = 0; i2 < 6; ++i2) {
              faces[i2] = allocMipMap();
            }
            if (typeof a02 === "number" || !a02) {
              var s2 = a02 | 0 || 1;
              for (i2 = 0; i2 < 6; ++i2) {
                parseMipMapFromShape(faces[i2], s2, s2);
              }
            } else if (typeof a02 === "object") {
              if (a12) {
                parseMipMapFromObject(faces[0], a02);
                parseMipMapFromObject(faces[1], a12);
                parseMipMapFromObject(faces[2], a23);
                parseMipMapFromObject(faces[3], a32);
                parseMipMapFromObject(faces[4], a42);
                parseMipMapFromObject(faces[5], a52);
              } else {
                parseTexInfo(texInfo, a02);
                parseFlags2(texture, a02);
                if ("faces" in a02) {
                  var faceInput = a02.faces;
                  check$1(
                    Array.isArray(faceInput) && faceInput.length === 6,
                    "cube faces must be a length 6 array"
                  );
                  for (i2 = 0; i2 < 6; ++i2) {
                    check$1(
                      typeof faceInput[i2] === "object" && !!faceInput[i2],
                      "invalid input for cube map face"
                    );
                    copyFlags(faces[i2], texture);
                    parseMipMapFromObject(faces[i2], faceInput[i2]);
                  }
                } else {
                  for (i2 = 0; i2 < 6; ++i2) {
                    parseMipMapFromObject(faces[i2], a02);
                  }
                }
              }
            } else {
              check$1.raise("invalid arguments to cube map");
            }
            copyFlags(texture, faces[0]);
            if (!limits.npotTextureCube) {
              check$1(isPow2$1(texture.width) && isPow2$1(texture.height), "your browser does not support non power or two texture dimensions");
            }
            if (texInfo.genMipmaps) {
              texture.mipmask = (faces[0].width << 1) - 1;
            } else {
              texture.mipmask = faces[0].mipmask;
            }
            check$1.textureCube(texture, texInfo, faces, limits);
            texture.internalformat = faces[0].internalformat;
            reglTextureCube.width = faces[0].width;
            reglTextureCube.height = faces[0].height;
            tempBind(texture);
            for (i2 = 0; i2 < 6; ++i2) {
              setMipMap(faces[i2], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i2);
            }
            setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                reglTextureCube.width,
                reglTextureCube.height,
                texInfo.genMipmaps,
                true
              );
            }
            reglTextureCube.format = textureFormatsInvert[texture.internalformat];
            reglTextureCube.type = textureTypesInvert[texture.type];
            reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
            reglTextureCube.min = minFiltersInvert[texInfo.minFilter];
            reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];
            for (i2 = 0; i2 < 6; ++i2) {
              freeMipMap(faces[i2]);
            }
            return reglTextureCube;
          }
          function subimage(face, image, x_, y_, level_) {
            check$1(!!image, "must specify image data");
            check$1(typeof face === "number" && face === (face | 0) && face >= 0 && face < 6, "invalid face");
            var x4 = x_ | 0;
            var y4 = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image);
            imageData.width = imageData.width || (texture.width >> level) - x4;
            imageData.height = imageData.height || (texture.height >> level) - y4;
            check$1(
              texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat,
              "incompatible format for texture.subimage"
            );
            check$1(
              x4 >= 0 && y4 >= 0 && x4 + imageData.width <= texture.width && y4 + imageData.height <= texture.height,
              "texture.subimage write out of bounds"
            );
            check$1(
              texture.mipmask & 1 << level,
              "missing mipmap data"
            );
            check$1(
              imageData.data || imageData.element || imageData.needsCopy,
              "missing image data"
            );
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x4, y4, level);
            tempRestore();
            freeImage(imageData);
            return reglTextureCube;
          }
          function resize(radius_) {
            var radius = radius_ | 0;
            if (radius === texture.width) {
              return;
            }
            reglTextureCube.width = texture.width = radius;
            reglTextureCube.height = texture.height = radius;
            tempBind(texture);
            for (var i2 = 0; i2 < 6; ++i2) {
              for (var j2 = 0; texture.mipmask >> j2; ++j2) {
                gl2.texImage2D(
                  GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i2,
                  j2,
                  texture.format,
                  radius >> j2,
                  radius >> j2,
                  0,
                  texture.format,
                  texture.type,
                  null
                );
              }
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                reglTextureCube.width,
                reglTextureCube.height,
                false,
                true
              );
            }
            return reglTextureCube;
          }
          reglTextureCube(a0, a1, a22, a3, a4, a5);
          reglTextureCube.subimage = subimage;
          reglTextureCube.resize = resize;
          reglTextureCube._reglType = "textureCube";
          reglTextureCube._texture = texture;
          if (config.profile) {
            reglTextureCube.stats = texture.stats;
          }
          reglTextureCube.destroy = function() {
            texture.decRef();
          };
          return reglTextureCube;
        }
        function destroyTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            gl2.activeTexture(GL_TEXTURE0$1 + i2);
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
            textureUnits[i2] = null;
          }
          values3(textureSet).forEach(destroy);
          stats2.cubeCount = 0;
          stats2.textureCount = 0;
        }
        if (config.profile) {
          stats2.getTotalTextureSize = function() {
            var total = 0;
            Object.keys(textureSet).forEach(function(key) {
              total += textureSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            var tex = textureUnits[i2];
            if (tex) {
              tex.bindCount = 0;
              tex.unit = -1;
              textureUnits[i2] = null;
            }
          }
          values3(textureSet).forEach(function(texture) {
            texture.texture = gl2.createTexture();
            gl2.bindTexture(texture.target, texture.texture);
            for (var i3 = 0; i3 < 32; ++i3) {
              if ((texture.mipmask & 1 << i3) === 0) {
                continue;
              }
              if (texture.target === GL_TEXTURE_2D$1) {
                gl2.texImage2D(
                  GL_TEXTURE_2D$1,
                  i3,
                  texture.internalformat,
                  texture.width >> i3,
                  texture.height >> i3,
                  0,
                  texture.internalformat,
                  texture.type,
                  null
                );
              } else {
                for (var j2 = 0; j2 < 6; ++j2) {
                  gl2.texImage2D(
                    GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j2,
                    i3,
                    texture.internalformat,
                    texture.width >> i3,
                    texture.height >> i3,
                    0,
                    texture.internalformat,
                    texture.type,
                    null
                  );
                }
              }
            }
            setTexInfo(texture.texInfo, texture.target);
          });
        }
        function refreshTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            var tex = textureUnits[i2];
            if (tex) {
              tex.bindCount = 0;
              tex.unit = -1;
              textureUnits[i2] = null;
            }
            gl2.activeTexture(GL_TEXTURE0$1 + i2);
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
            gl2.bindTexture(GL_TEXTURE_CUBE_MAP$1, null);
          }
        }
        return {
          create2D: createTexture2D,
          createCube: createTextureCube,
          clear: destroyTextures,
          getTexture: function(wrapper) {
            return null;
          },
          restore: restoreTextures,
          refresh: refreshTextures
        };
      }
      var GL_RENDERBUFFER = 36161;
      var GL_RGBA4$1 = 32854;
      var GL_RGB5_A1$1 = 32855;
      var GL_RGB565$1 = 36194;
      var GL_DEPTH_COMPONENT16 = 33189;
      var GL_STENCIL_INDEX8 = 36168;
      var GL_DEPTH_STENCIL$1 = 34041;
      var GL_SRGB8_ALPHA8_EXT = 35907;
      var GL_RGBA32F_EXT = 34836;
      var GL_RGBA16F_EXT = 34842;
      var GL_RGB16F_EXT = 34843;
      var FORMAT_SIZES = [];
      FORMAT_SIZES[GL_RGBA4$1] = 2;
      FORMAT_SIZES[GL_RGB5_A1$1] = 2;
      FORMAT_SIZES[GL_RGB565$1] = 2;
      FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
      FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
      FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;
      FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
      FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
      FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
      FORMAT_SIZES[GL_RGB16F_EXT] = 6;
      function getRenderbufferSize(format2, width, height) {
        return FORMAT_SIZES[format2] * width * height;
      }
      var wrapRenderbuffers = function(gl2, extensions, limits, stats2, config) {
        var formatTypes = {
          "rgba4": GL_RGBA4$1,
          "rgb565": GL_RGB565$1,
          "rgb5 a1": GL_RGB5_A1$1,
          "depth": GL_DEPTH_COMPONENT16,
          "stencil": GL_STENCIL_INDEX8,
          "depth stencil": GL_DEPTH_STENCIL$1
        };
        if (extensions.ext_srgb) {
          formatTypes["srgba"] = GL_SRGB8_ALPHA8_EXT;
        }
        if (extensions.ext_color_buffer_half_float) {
          formatTypes["rgba16f"] = GL_RGBA16F_EXT;
          formatTypes["rgb16f"] = GL_RGB16F_EXT;
        }
        if (extensions.webgl_color_buffer_float) {
          formatTypes["rgba32f"] = GL_RGBA32F_EXT;
        }
        var formatTypesInvert = [];
        Object.keys(formatTypes).forEach(function(key) {
          var val = formatTypes[key];
          formatTypesInvert[val] = key;
        });
        var renderbufferCount = 0;
        var renderbufferSet = {};
        function REGLRenderbuffer(renderbuffer) {
          this.id = renderbufferCount++;
          this.refCount = 1;
          this.renderbuffer = renderbuffer;
          this.format = GL_RGBA4$1;
          this.width = 0;
          this.height = 0;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLRenderbuffer.prototype.decRef = function() {
          if (--this.refCount <= 0) {
            destroy(this);
          }
        };
        function destroy(rb) {
          var handle = rb.renderbuffer;
          check$1(handle, "must not double destroy renderbuffer");
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
          gl2.deleteRenderbuffer(handle);
          rb.renderbuffer = null;
          rb.refCount = 0;
          delete renderbufferSet[rb.id];
          stats2.renderbufferCount--;
        }
        function createRenderbuffer(a3, b10) {
          var renderbuffer = new REGLRenderbuffer(gl2.createRenderbuffer());
          renderbufferSet[renderbuffer.id] = renderbuffer;
          stats2.renderbufferCount++;
          function reglRenderbuffer(a4, b11) {
            var w2 = 0;
            var h2 = 0;
            var format2 = GL_RGBA4$1;
            if (typeof a4 === "object" && a4) {
              var options = a4;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid renderbuffer shape"
                );
                w2 = shape[0] | 0;
                h2 = shape[1] | 0;
              } else {
                if ("radius" in options) {
                  w2 = h2 = options.radius | 0;
                }
                if ("width" in options) {
                  w2 = options.width | 0;
                }
                if ("height" in options) {
                  h2 = options.height | 0;
                }
              }
              if ("format" in options) {
                check$1.parameter(
                  options.format,
                  formatTypes,
                  "invalid renderbuffer format"
                );
                format2 = formatTypes[options.format];
              }
            } else if (typeof a4 === "number") {
              w2 = a4 | 0;
              if (typeof b11 === "number") {
                h2 = b11 | 0;
              } else {
                h2 = w2;
              }
            } else if (!a4) {
              w2 = h2 = 1;
            } else {
              check$1.raise("invalid arguments to renderbuffer constructor");
            }
            check$1(
              w2 > 0 && h2 > 0 && w2 <= limits.maxRenderbufferSize && h2 <= limits.maxRenderbufferSize,
              "invalid renderbuffer size"
            );
            if (w2 === renderbuffer.width && h2 === renderbuffer.height && format2 === renderbuffer.format) {
              return;
            }
            reglRenderbuffer.width = renderbuffer.width = w2;
            reglRenderbuffer.height = renderbuffer.height = h2;
            renderbuffer.format = format2;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, format2, w2, h2);
            check$1(
              gl2.getError() === 0,
              "invalid render buffer format"
            );
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
            }
            reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];
            return reglRenderbuffer;
          }
          function resize(w_, h_) {
            var w2 = w_ | 0;
            var h2 = h_ | 0 || w2;
            if (w2 === renderbuffer.width && h2 === renderbuffer.height) {
              return reglRenderbuffer;
            }
            check$1(
              w2 > 0 && h2 > 0 && w2 <= limits.maxRenderbufferSize && h2 <= limits.maxRenderbufferSize,
              "invalid renderbuffer size"
            );
            reglRenderbuffer.width = renderbuffer.width = w2;
            reglRenderbuffer.height = renderbuffer.height = h2;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w2, h2);
            check$1(
              gl2.getError() === 0,
              "invalid render buffer format"
            );
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(
                renderbuffer.format,
                renderbuffer.width,
                renderbuffer.height
              );
            }
            return reglRenderbuffer;
          }
          reglRenderbuffer(a3, b10);
          reglRenderbuffer.resize = resize;
          reglRenderbuffer._reglType = "renderbuffer";
          reglRenderbuffer._renderbuffer = renderbuffer;
          if (config.profile) {
            reglRenderbuffer.stats = renderbuffer.stats;
          }
          reglRenderbuffer.destroy = function() {
            renderbuffer.decRef();
          };
          return reglRenderbuffer;
        }
        if (config.profile) {
          stats2.getTotalRenderbufferSize = function() {
            var total = 0;
            Object.keys(renderbufferSet).forEach(function(key) {
              total += renderbufferSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreRenderbuffers() {
          values3(renderbufferSet).forEach(function(rb) {
            rb.renderbuffer = gl2.createRenderbuffer();
            gl2.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
          });
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
        }
        return {
          create: createRenderbuffer,
          clear: function() {
            values3(renderbufferSet).forEach(destroy);
          },
          restore: restoreRenderbuffers
        };
      };
      var GL_FRAMEBUFFER$1 = 36160;
      var GL_RENDERBUFFER$1 = 36161;
      var GL_TEXTURE_2D$2 = 3553;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 34069;
      var GL_COLOR_ATTACHMENT0$1 = 36064;
      var GL_DEPTH_ATTACHMENT = 36096;
      var GL_STENCIL_ATTACHMENT = 36128;
      var GL_DEPTH_STENCIL_ATTACHMENT = 33306;
      var GL_FRAMEBUFFER_COMPLETE$1 = 36053;
      var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
      var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
      var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
      var GL_FRAMEBUFFER_UNSUPPORTED = 36061;
      var GL_HALF_FLOAT_OES$2 = 36193;
      var GL_UNSIGNED_BYTE$6 = 5121;
      var GL_FLOAT$5 = 5126;
      var GL_RGB$1 = 6407;
      var GL_RGBA$2 = 6408;
      var GL_DEPTH_COMPONENT$1 = 6402;
      var colorTextureFormatEnums = [
        GL_RGB$1,
        GL_RGBA$2
      ];
      var textureFormatChannels = [];
      textureFormatChannels[GL_RGBA$2] = 4;
      textureFormatChannels[GL_RGB$1] = 3;
      var textureTypeSizes = [];
      textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1;
      textureTypeSizes[GL_FLOAT$5] = 4;
      textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;
      var GL_RGBA4$2 = 32854;
      var GL_RGB5_A1$2 = 32855;
      var GL_RGB565$2 = 36194;
      var GL_DEPTH_COMPONENT16$1 = 33189;
      var GL_STENCIL_INDEX8$1 = 36168;
      var GL_DEPTH_STENCIL$2 = 34041;
      var GL_SRGB8_ALPHA8_EXT$1 = 35907;
      var GL_RGBA32F_EXT$1 = 34836;
      var GL_RGBA16F_EXT$1 = 34842;
      var GL_RGB16F_EXT$1 = 34843;
      var colorRenderbufferFormatEnums = [
        GL_RGBA4$2,
        GL_RGB5_A1$2,
        GL_RGB565$2,
        GL_SRGB8_ALPHA8_EXT$1,
        GL_RGBA16F_EXT$1,
        GL_RGB16F_EXT$1,
        GL_RGBA32F_EXT$1
      ];
      var statusCode = {};
      statusCode[GL_FRAMEBUFFER_COMPLETE$1] = "complete";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = "incomplete attachment";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = "incomplete dimensions";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = "incomplete, missing attachment";
      statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = "unsupported";
      function wrapFBOState(gl2, extensions, limits, textureState, renderbufferState, stats2) {
        var framebufferState = {
          cur: null,
          next: null,
          dirty: false,
          setFBO: null
        };
        var colorTextureFormats = ["rgba"];
        var colorRenderbufferFormats = ["rgba4", "rgb565", "rgb5 a1"];
        if (extensions.ext_srgb) {
          colorRenderbufferFormats.push("srgba");
        }
        if (extensions.ext_color_buffer_half_float) {
          colorRenderbufferFormats.push("rgba16f", "rgb16f");
        }
        if (extensions.webgl_color_buffer_float) {
          colorRenderbufferFormats.push("rgba32f");
        }
        var colorTypes = ["uint8"];
        if (extensions.oes_texture_half_float) {
          colorTypes.push("half float", "float16");
        }
        if (extensions.oes_texture_float) {
          colorTypes.push("float", "float32");
        }
        function FramebufferAttachment(target, texture, renderbuffer) {
          this.target = target;
          this.texture = texture;
          this.renderbuffer = renderbuffer;
          var w2 = 0;
          var h2 = 0;
          if (texture) {
            w2 = texture.width;
            h2 = texture.height;
          } else if (renderbuffer) {
            w2 = renderbuffer.width;
            h2 = renderbuffer.height;
          }
          this.width = w2;
          this.height = h2;
        }
        function decRef(attachment) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture._texture.decRef();
            }
            if (attachment.renderbuffer) {
              attachment.renderbuffer._renderbuffer.decRef();
            }
          }
        }
        function incRefAndCheckShape(attachment, width, height) {
          if (!attachment) {
            return;
          }
          if (attachment.texture) {
            var texture = attachment.texture._texture;
            var tw = Math.max(1, texture.width);
            var th = Math.max(1, texture.height);
            check$1(
              tw === width && th === height,
              "inconsistent width/height for supplied texture"
            );
            texture.refCount += 1;
          } else {
            var renderbuffer = attachment.renderbuffer._renderbuffer;
            check$1(
              renderbuffer.width === width && renderbuffer.height === height,
              "inconsistent width/height for renderbuffer"
            );
            renderbuffer.refCount += 1;
          }
        }
        function attach(location, attachment) {
          if (attachment) {
            if (attachment.texture) {
              gl2.framebufferTexture2D(
                GL_FRAMEBUFFER$1,
                location,
                attachment.target,
                attachment.texture._texture.texture,
                0
              );
            } else {
              gl2.framebufferRenderbuffer(
                GL_FRAMEBUFFER$1,
                location,
                GL_RENDERBUFFER$1,
                attachment.renderbuffer._renderbuffer.renderbuffer
              );
            }
          }
        }
        function parseAttachment(attachment) {
          var target = GL_TEXTURE_2D$2;
          var texture = null;
          var renderbuffer = null;
          var data = attachment;
          if (typeof attachment === "object") {
            data = attachment.data;
            if ("target" in attachment) {
              target = attachment.target | 0;
            }
          }
          check$1.type(data, "function", "invalid attachment data");
          var type = data._reglType;
          if (type === "texture2d") {
            texture = data;
            check$1(target === GL_TEXTURE_2D$2);
          } else if (type === "textureCube") {
            texture = data;
            check$1(
              target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 && target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
              "invalid cube map target"
            );
          } else if (type === "renderbuffer") {
            renderbuffer = data;
            target = GL_RENDERBUFFER$1;
          } else {
            check$1.raise("invalid regl object for attachment");
          }
          return new FramebufferAttachment(target, texture, renderbuffer);
        }
        function allocAttachment(width, height, isTexture, format2, type) {
          if (isTexture) {
            var texture = textureState.create2D({
              width,
              height,
              format: format2,
              type
            });
            texture._texture.refCount = 0;
            return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null);
          } else {
            var rb = renderbufferState.create({
              width,
              height,
              format: format2
            });
            rb._renderbuffer.refCount = 0;
            return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);
          }
        }
        function unwrapAttachment(attachment) {
          return attachment && (attachment.texture || attachment.renderbuffer);
        }
        function resizeAttachment(attachment, w2, h2) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture.resize(w2, h2);
            } else if (attachment.renderbuffer) {
              attachment.renderbuffer.resize(w2, h2);
            }
            attachment.width = w2;
            attachment.height = h2;
          }
        }
        var framebufferCount = 0;
        var framebufferSet = {};
        function REGLFramebuffer() {
          this.id = framebufferCount++;
          framebufferSet[this.id] = this;
          this.framebuffer = gl2.createFramebuffer();
          this.width = 0;
          this.height = 0;
          this.colorAttachments = [];
          this.depthAttachment = null;
          this.stencilAttachment = null;
          this.depthStencilAttachment = null;
        }
        function decFBORefs(framebuffer) {
          framebuffer.colorAttachments.forEach(decRef);
          decRef(framebuffer.depthAttachment);
          decRef(framebuffer.stencilAttachment);
          decRef(framebuffer.depthStencilAttachment);
        }
        function destroy(framebuffer) {
          var handle = framebuffer.framebuffer;
          check$1(handle, "must not double destroy framebuffer");
          gl2.deleteFramebuffer(handle);
          framebuffer.framebuffer = null;
          stats2.framebufferCount--;
          delete framebufferSet[framebuffer.id];
        }
        function updateFramebuffer(framebuffer) {
          var i2;
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);
          var colorAttachments = framebuffer.colorAttachments;
          for (i2 = 0; i2 < colorAttachments.length; ++i2) {
            attach(GL_COLOR_ATTACHMENT0$1 + i2, colorAttachments[i2]);
          }
          for (i2 = colorAttachments.length; i2 < limits.maxColorAttachments; ++i2) {
            gl2.framebufferTexture2D(
              GL_FRAMEBUFFER$1,
              GL_COLOR_ATTACHMENT0$1 + i2,
              GL_TEXTURE_2D$2,
              null,
              0
            );
          }
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_DEPTH_STENCIL_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_DEPTH_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_STENCIL_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
          attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
          attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);
          var status = gl2.checkFramebufferStatus(GL_FRAMEBUFFER$1);
          if (!gl2.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
            check$1.raise("framebuffer configuration not supported, status = " + statusCode[status]);
          }
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);
          framebufferState.cur = framebufferState.next;
          gl2.getError();
        }
        function createFBO(a0, a1) {
          var framebuffer = new REGLFramebuffer();
          stats2.framebufferCount++;
          function reglFramebuffer(a3, b10) {
            var i2;
            check$1(
              framebufferState.next !== framebuffer,
              "can not update framebuffer which is currently in use"
            );
            var width = 0;
            var height = 0;
            var needsDepth = true;
            var needsStencil = true;
            var colorBuffer = null;
            var colorTexture = true;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            var depthBuffer = null;
            var stencilBuffer = null;
            var depthStencilBuffer = null;
            var depthStencilTexture = false;
            if (typeof a3 === "number") {
              width = a3 | 0;
              height = b10 | 0 || width;
            } else if (!a3) {
              width = height = 1;
            } else {
              check$1.type(a3, "object", "invalid arguments for framebuffer");
              var options = a3;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid shape for framebuffer"
                );
                width = shape[0];
                height = shape[1];
              } else {
                if ("radius" in options) {
                  width = height = options.radius;
                }
                if ("width" in options) {
                  width = options.width;
                }
                if ("height" in options) {
                  height = options.height;
                }
              }
              if ("color" in options || "colors" in options) {
                colorBuffer = options.color || options.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(
                    colorBuffer.length === 1 || extensions.webgl_draw_buffers,
                    "multiple render targets not supported"
                  );
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options) {
                  colorCount = options.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorTexture" in options) {
                  colorTexture = !!options.colorTexture;
                  colorFormat = "rgba4";
                }
                if ("colorType" in options) {
                  colorType = options.colorType;
                  if (!colorTexture) {
                    if (colorType === "half float" || colorType === "float16") {
                      check$1(
                        extensions.ext_color_buffer_half_float,
                        "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"
                      );
                      colorFormat = "rgba16f";
                    } else if (colorType === "float" || colorType === "float32") {
                      check$1(
                        extensions.webgl_color_buffer_float,
                        "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"
                      );
                      colorFormat = "rgba32f";
                    }
                  } else {
                    check$1(
                      extensions.oes_texture_float || !(colorType === "float" || colorType === "float32"),
                      "you must enable OES_texture_float in order to use floating point framebuffer objects"
                    );
                    check$1(
                      extensions.oes_texture_half_float || !(colorType === "half float" || colorType === "float16"),
                      "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects"
                    );
                  }
                  check$1.oneOf(colorType, colorTypes, "invalid color type");
                }
                if ("colorFormat" in options) {
                  colorFormat = options.colorFormat;
                  if (colorTextureFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = true;
                  } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = false;
                  } else {
                    if (colorTexture) {
                      check$1.oneOf(
                        options.colorFormat,
                        colorTextureFormats,
                        "invalid color format for texture"
                      );
                    } else {
                      check$1.oneOf(
                        options.colorFormat,
                        colorRenderbufferFormats,
                        "invalid color format for renderbuffer"
                      );
                    }
                  }
                }
              }
              if ("depthTexture" in options || "depthStencilTexture" in options) {
                depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);
                check$1(
                  !depthStencilTexture || extensions.webgl_depth_texture,
                  "webgl_depth_texture extension not supported"
                );
              }
              if ("depth" in options) {
                if (typeof options.depth === "boolean") {
                  needsDepth = options.depth;
                } else {
                  depthBuffer = options.depth;
                  needsStencil = false;
                }
              }
              if ("stencil" in options) {
                if (typeof options.stencil === "boolean") {
                  needsStencil = options.stencil;
                } else {
                  stencilBuffer = options.stencil;
                  needsDepth = false;
                }
              }
              if ("depthStencil" in options) {
                if (typeof options.depthStencil === "boolean") {
                  needsDepth = needsStencil = options.depthStencil;
                } else {
                  depthStencilBuffer = options.depthStencil;
                  needsDepth = false;
                  needsStencil = false;
                }
              }
            }
            var colorAttachments = null;
            var depthAttachment = null;
            var stencilAttachment = null;
            var depthStencilAttachment = null;
            if (Array.isArray(colorBuffer)) {
              colorAttachments = colorBuffer.map(parseAttachment);
            } else if (colorBuffer) {
              colorAttachments = [parseAttachment(colorBuffer)];
            } else {
              colorAttachments = new Array(colorCount);
              for (i2 = 0; i2 < colorCount; ++i2) {
                colorAttachments[i2] = allocAttachment(
                  width,
                  height,
                  colorTexture,
                  colorFormat,
                  colorType
                );
              }
            }
            check$1(
              extensions.webgl_draw_buffers || colorAttachments.length <= 1,
              "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."
            );
            check$1(
              colorAttachments.length <= limits.maxColorAttachments,
              "too many color attachments, not supported"
            );
            width = width || colorAttachments[0].width;
            height = height || colorAttachments[0].height;
            if (depthBuffer) {
              depthAttachment = parseAttachment(depthBuffer);
            } else if (needsDepth && !needsStencil) {
              depthAttachment = allocAttachment(
                width,
                height,
                depthStencilTexture,
                "depth",
                "uint32"
              );
            }
            if (stencilBuffer) {
              stencilAttachment = parseAttachment(stencilBuffer);
            } else if (needsStencil && !needsDepth) {
              stencilAttachment = allocAttachment(
                width,
                height,
                false,
                "stencil",
                "uint8"
              );
            }
            if (depthStencilBuffer) {
              depthStencilAttachment = parseAttachment(depthStencilBuffer);
            } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
              depthStencilAttachment = allocAttachment(
                width,
                height,
                depthStencilTexture,
                "depth stencil",
                "depth stencil"
              );
            }
            check$1(
              !!depthBuffer + !!stencilBuffer + !!depthStencilBuffer <= 1,
              "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"
            );
            var commonColorAttachmentSize = null;
            for (i2 = 0; i2 < colorAttachments.length; ++i2) {
              incRefAndCheckShape(colorAttachments[i2], width, height);
              check$1(
                !colorAttachments[i2] || colorAttachments[i2].texture && colorTextureFormatEnums.indexOf(colorAttachments[i2].texture._texture.format) >= 0 || colorAttachments[i2].renderbuffer && colorRenderbufferFormatEnums.indexOf(colorAttachments[i2].renderbuffer._renderbuffer.format) >= 0,
                "framebuffer color attachment " + i2 + " is invalid"
              );
              if (colorAttachments[i2] && colorAttachments[i2].texture) {
                var colorAttachmentSize = textureFormatChannels[colorAttachments[i2].texture._texture.format] * textureTypeSizes[colorAttachments[i2].texture._texture.type];
                if (commonColorAttachmentSize === null) {
                  commonColorAttachmentSize = colorAttachmentSize;
                } else {
                  check$1(
                    commonColorAttachmentSize === colorAttachmentSize,
                    "all color attachments much have the same number of bits per pixel."
                  );
                }
              }
            }
            incRefAndCheckShape(depthAttachment, width, height);
            check$1(
              !depthAttachment || depthAttachment.texture && depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1 || depthAttachment.renderbuffer && depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1,
              "invalid depth attachment for framebuffer object"
            );
            incRefAndCheckShape(stencilAttachment, width, height);
            check$1(
              !stencilAttachment || stencilAttachment.renderbuffer && stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1,
              "invalid stencil attachment for framebuffer object"
            );
            incRefAndCheckShape(depthStencilAttachment, width, height);
            check$1(
              !depthStencilAttachment || depthStencilAttachment.texture && depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer && depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2,
              "invalid depth-stencil attachment for framebuffer object"
            );
            decFBORefs(framebuffer);
            framebuffer.width = width;
            framebuffer.height = height;
            framebuffer.colorAttachments = colorAttachments;
            framebuffer.depthAttachment = depthAttachment;
            framebuffer.stencilAttachment = stencilAttachment;
            framebuffer.depthStencilAttachment = depthStencilAttachment;
            reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
            reglFramebuffer.depth = unwrapAttachment(depthAttachment);
            reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
            reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);
            reglFramebuffer.width = framebuffer.width;
            reglFramebuffer.height = framebuffer.height;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          function resize(w_, h_) {
            check$1(
              framebufferState.next !== framebuffer,
              "can not resize a framebuffer which is currently in use"
            );
            var w2 = Math.max(w_ | 0, 1);
            var h2 = Math.max(h_ | 0 || w2, 1);
            if (w2 === framebuffer.width && h2 === framebuffer.height) {
              return reglFramebuffer;
            }
            var colorAttachments = framebuffer.colorAttachments;
            for (var i2 = 0; i2 < colorAttachments.length; ++i2) {
              resizeAttachment(colorAttachments[i2], w2, h2);
            }
            resizeAttachment(framebuffer.depthAttachment, w2, h2);
            resizeAttachment(framebuffer.stencilAttachment, w2, h2);
            resizeAttachment(framebuffer.depthStencilAttachment, w2, h2);
            framebuffer.width = reglFramebuffer.width = w2;
            framebuffer.height = reglFramebuffer.height = h2;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          reglFramebuffer(a0, a1);
          return extend4(reglFramebuffer, {
            resize,
            _reglType: "framebuffer",
            _framebuffer: framebuffer,
            destroy: function() {
              destroy(framebuffer);
              decFBORefs(framebuffer);
            },
            use: function(block) {
              framebufferState.setFBO({
                framebuffer: reglFramebuffer
              }, block);
            }
          });
        }
        function createCubeFBO(options) {
          var faces = Array(6);
          function reglFramebufferCube(a3) {
            var i2;
            check$1(
              faces.indexOf(framebufferState.next) < 0,
              "can not update framebuffer which is currently in use"
            );
            var params = {
              color: null
            };
            var radius = 0;
            var colorBuffer = null;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            if (typeof a3 === "number") {
              radius = a3 | 0;
            } else if (!a3) {
              radius = 1;
            } else {
              check$1.type(a3, "object", "invalid arguments for framebuffer");
              var options2 = a3;
              if ("shape" in options2) {
                var shape = options2.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid shape for framebuffer"
                );
                check$1(
                  shape[0] === shape[1],
                  "cube framebuffer must be square"
                );
                radius = shape[0];
              } else {
                if ("radius" in options2) {
                  radius = options2.radius | 0;
                }
                if ("width" in options2) {
                  radius = options2.width | 0;
                  if ("height" in options2) {
                    check$1(options2.height === radius, "must be square");
                  }
                } else if ("height" in options2) {
                  radius = options2.height | 0;
                }
              }
              if ("color" in options2 || "colors" in options2) {
                colorBuffer = options2.color || options2.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(
                    colorBuffer.length === 1 || extensions.webgl_draw_buffers,
                    "multiple render targets not supported"
                  );
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options2) {
                  colorCount = options2.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorType" in options2) {
                  check$1.oneOf(
                    options2.colorType,
                    colorTypes,
                    "invalid color type"
                  );
                  colorType = options2.colorType;
                }
                if ("colorFormat" in options2) {
                  colorFormat = options2.colorFormat;
                  check$1.oneOf(
                    options2.colorFormat,
                    colorTextureFormats,
                    "invalid color format for texture"
                  );
                }
              }
              if ("depth" in options2) {
                params.depth = options2.depth;
              }
              if ("stencil" in options2) {
                params.stencil = options2.stencil;
              }
              if ("depthStencil" in options2) {
                params.depthStencil = options2.depthStencil;
              }
            }
            var colorCubes;
            if (colorBuffer) {
              if (Array.isArray(colorBuffer)) {
                colorCubes = [];
                for (i2 = 0; i2 < colorBuffer.length; ++i2) {
                  colorCubes[i2] = colorBuffer[i2];
                }
              } else {
                colorCubes = [colorBuffer];
              }
            } else {
              colorCubes = Array(colorCount);
              var cubeMapParams = {
                radius,
                format: colorFormat,
                type: colorType
              };
              for (i2 = 0; i2 < colorCount; ++i2) {
                colorCubes[i2] = textureState.createCube(cubeMapParams);
              }
            }
            params.color = Array(colorCubes.length);
            for (i2 = 0; i2 < colorCubes.length; ++i2) {
              var cube = colorCubes[i2];
              check$1(
                typeof cube === "function" && cube._reglType === "textureCube",
                "invalid cube map"
              );
              radius = radius || cube.width;
              check$1(
                cube.width === radius && cube.height === radius,
                "invalid cube map shape"
              );
              params.color[i2] = {
                target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
                data: colorCubes[i2]
              };
            }
            for (i2 = 0; i2 < 6; ++i2) {
              for (var j2 = 0; j2 < colorCubes.length; ++j2) {
                params.color[j2].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i2;
              }
              if (i2 > 0) {
                params.depth = faces[0].depth;
                params.stencil = faces[0].stencil;
                params.depthStencil = faces[0].depthStencil;
              }
              if (faces[i2]) {
                faces[i2](params);
              } else {
                faces[i2] = createFBO(params);
              }
            }
            return extend4(reglFramebufferCube, {
              width: radius,
              height: radius,
              color: colorCubes
            });
          }
          function resize(radius_) {
            var i2;
            var radius = radius_ | 0;
            check$1(
              radius > 0 && radius <= limits.maxCubeMapSize,
              "invalid radius for cube fbo"
            );
            if (radius === reglFramebufferCube.width) {
              return reglFramebufferCube;
            }
            var colors = reglFramebufferCube.color;
            for (i2 = 0; i2 < colors.length; ++i2) {
              colors[i2].resize(radius);
            }
            for (i2 = 0; i2 < 6; ++i2) {
              faces[i2].resize(radius);
            }
            reglFramebufferCube.width = reglFramebufferCube.height = radius;
            return reglFramebufferCube;
          }
          reglFramebufferCube(options);
          return extend4(reglFramebufferCube, {
            faces,
            resize,
            _reglType: "framebufferCube",
            destroy: function() {
              faces.forEach(function(f2) {
                f2.destroy();
              });
            }
          });
        }
        function restoreFramebuffers() {
          framebufferState.cur = null;
          framebufferState.next = null;
          framebufferState.dirty = true;
          values3(framebufferSet).forEach(function(fb) {
            fb.framebuffer = gl2.createFramebuffer();
            updateFramebuffer(fb);
          });
        }
        return extend4(framebufferState, {
          getFramebuffer: function(object) {
            if (typeof object === "function" && object._reglType === "framebuffer") {
              var fbo = object._framebuffer;
              if (fbo instanceof REGLFramebuffer) {
                return fbo;
              }
            }
            return null;
          },
          create: createFBO,
          createCube: createCubeFBO,
          clear: function() {
            values3(framebufferSet).forEach(destroy);
          },
          restore: restoreFramebuffers
        });
      }
      var GL_FLOAT$6 = 5126;
      var GL_ARRAY_BUFFER$1 = 34962;
      function AttributeRecord() {
        this.state = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        this.buffer = null;
        this.size = 0;
        this.normalized = false;
        this.type = GL_FLOAT$6;
        this.offset = 0;
        this.stride = 0;
        this.divisor = 0;
      }
      function wrapAttributeState(gl2, extensions, limits, stats2, bufferState) {
        var NUM_ATTRIBUTES = limits.maxAttributes;
        var attributeBindings = new Array(NUM_ATTRIBUTES);
        for (var i2 = 0; i2 < NUM_ATTRIBUTES; ++i2) {
          attributeBindings[i2] = new AttributeRecord();
        }
        var vaoCount = 0;
        var vaoSet = {};
        var state = {
          Record: AttributeRecord,
          scope: {},
          state: attributeBindings,
          currentVAO: null,
          targetVAO: null,
          restore: extVAO() ? restoreVAO : function() {
          },
          createVAO,
          getVAO,
          destroyBuffer,
          setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
          clear: extVAO() ? destroyVAOEXT : function() {
          }
        };
        function destroyBuffer(buffer) {
          for (var i3 = 0; i3 < attributeBindings.length; ++i3) {
            var record = attributeBindings[i3];
            if (record.buffer === buffer) {
              gl2.disableVertexAttribArray(i3);
              record.buffer = null;
            }
          }
        }
        function extVAO() {
          return extensions.oes_vertex_array_object;
        }
        function extInstanced() {
          return extensions.angle_instanced_arrays;
        }
        function getVAO(vao) {
          if (typeof vao === "function" && vao._vao) {
            return vao._vao;
          }
          return null;
        }
        function setVAOEXT(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          var ext = extVAO();
          if (vao) {
            ext.bindVertexArrayOES(vao.vao);
          } else {
            ext.bindVertexArrayOES(null);
          }
          state.currentVAO = vao;
        }
        function setVAOEmulated(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          if (vao) {
            vao.bindAttrs();
          } else {
            var exti = extInstanced();
            for (var i3 = 0; i3 < attributeBindings.length; ++i3) {
              var binding = attributeBindings[i3];
              if (binding.buffer) {
                gl2.enableVertexAttribArray(i3);
                gl2.vertexAttribPointer(i3, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);
                if (exti && binding.divisor) {
                  exti.vertexAttribDivisorANGLE(i3, binding.divisor);
                }
              } else {
                gl2.disableVertexAttribArray(i3);
                gl2.vertexAttrib4f(i3, binding.x, binding.y, binding.z, binding.w);
              }
            }
          }
          state.currentVAO = vao;
        }
        function destroyVAOEXT() {
          values3(vaoSet).forEach(function(vao) {
            vao.destroy();
          });
        }
        function REGLVAO() {
          this.id = ++vaoCount;
          this.attributes = [];
          var extension = extVAO();
          if (extension) {
            this.vao = extension.createVertexArrayOES();
          } else {
            this.vao = null;
          }
          vaoSet[this.id] = this;
          this.buffers = [];
        }
        REGLVAO.prototype.bindAttrs = function() {
          var exti = extInstanced();
          var attributes = this.attributes;
          for (var i3 = 0; i3 < attributes.length; ++i3) {
            var attr = attributes[i3];
            if (attr.buffer) {
              gl2.enableVertexAttribArray(i3);
              gl2.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);
              gl2.vertexAttribPointer(i3, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);
              if (exti && attr.divisor) {
                exti.vertexAttribDivisorANGLE(i3, attr.divisor);
              }
            } else {
              gl2.disableVertexAttribArray(i3);
              gl2.vertexAttrib4f(i3, attr.x, attr.y, attr.z, attr.w);
            }
          }
          for (var j2 = attributes.length; j2 < NUM_ATTRIBUTES; ++j2) {
            gl2.disableVertexAttribArray(j2);
          }
        };
        REGLVAO.prototype.refresh = function() {
          var ext = extVAO();
          if (ext) {
            ext.bindVertexArrayOES(this.vao);
            this.bindAttrs();
            state.currentVAO = this;
          }
        };
        REGLVAO.prototype.destroy = function() {
          if (this.vao) {
            var extension = extVAO();
            if (this === state.currentVAO) {
              state.currentVAO = null;
              extension.bindVertexArrayOES(null);
            }
            extension.deleteVertexArrayOES(this.vao);
            this.vao = null;
          }
          if (vaoSet[this.id]) {
            delete vaoSet[this.id];
            stats2.vaoCount -= 1;
          }
        };
        function restoreVAO() {
          var ext = extVAO();
          if (ext) {
            values3(vaoSet).forEach(function(vao) {
              vao.refresh();
            });
          }
        }
        function createVAO(_attr) {
          var vao = new REGLVAO();
          stats2.vaoCount += 1;
          function updateVAO(attributes) {
            check$1(Array.isArray(attributes), "arguments to vertex array constructor must be an array");
            check$1(attributes.length < NUM_ATTRIBUTES, "too many attributes");
            check$1(attributes.length > 0, "must specify at least one attribute");
            var bufUpdated = {};
            var nattributes = vao.attributes;
            nattributes.length = attributes.length;
            for (var i3 = 0; i3 < attributes.length; ++i3) {
              var spec = attributes[i3];
              var rec = nattributes[i3] = new AttributeRecord();
              var data = spec.data || spec;
              if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
                var buf;
                if (vao.buffers[i3]) {
                  buf = vao.buffers[i3];
                  if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
                    buf.subdata(data);
                  } else {
                    buf.destroy();
                    vao.buffers[i3] = null;
                  }
                }
                if (!vao.buffers[i3]) {
                  buf = vao.buffers[i3] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);
                }
                rec.buffer = bufferState.getBuffer(buf);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
                bufUpdated[i3] = 1;
              } else if (bufferState.getBuffer(spec)) {
                rec.buffer = bufferState.getBuffer(spec);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
              } else if (bufferState.getBuffer(spec.buffer)) {
                rec.buffer = bufferState.getBuffer(spec.buffer);
                rec.size = (+spec.size || rec.buffer.dimension) | 0;
                rec.normalized = !!spec.normalized || false;
                if ("type" in spec) {
                  check$1.parameter(spec.type, glTypes, "invalid buffer type");
                  rec.type = glTypes[spec.type];
                } else {
                  rec.type = rec.buffer.dtype;
                }
                rec.offset = (spec.offset || 0) | 0;
                rec.stride = (spec.stride || 0) | 0;
                rec.divisor = (spec.divisor || 0) | 0;
                rec.state = 1;
                check$1(rec.size >= 1 && rec.size <= 4, "size must be between 1 and 4");
                check$1(rec.offset >= 0, "invalid offset");
                check$1(rec.stride >= 0 && rec.stride <= 255, "stride must be between 0 and 255");
                check$1(rec.divisor >= 0, "divisor must be positive");
                check$1(!rec.divisor || !!extensions.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor");
              } else if ("x" in spec) {
                check$1(i3 > 0, "first attribute must not be a constant");
                rec.x = +spec.x || 0;
                rec.y = +spec.y || 0;
                rec.z = +spec.z || 0;
                rec.w = +spec.w || 0;
                rec.state = 2;
              } else {
                check$1(false, "invalid attribute spec for location " + i3);
              }
            }
            for (var j2 = 0; j2 < vao.buffers.length; ++j2) {
              if (!bufUpdated[j2] && vao.buffers[j2]) {
                vao.buffers[j2].destroy();
                vao.buffers[j2] = null;
              }
            }
            vao.refresh();
            return updateVAO;
          }
          updateVAO.destroy = function() {
            for (var j2 = 0; j2 < vao.buffers.length; ++j2) {
              if (vao.buffers[j2]) {
                vao.buffers[j2].destroy();
              }
            }
            vao.buffers.length = 0;
            vao.destroy();
          };
          updateVAO._vao = vao;
          updateVAO._reglType = "vao";
          return updateVAO(_attr);
        }
        return state;
      }
      var GL_FRAGMENT_SHADER = 35632;
      var GL_VERTEX_SHADER = 35633;
      var GL_ACTIVE_UNIFORMS = 35718;
      var GL_ACTIVE_ATTRIBUTES = 35721;
      function wrapShaderState(gl2, stringStore, stats2, config) {
        var fragShaders = {};
        var vertShaders = {};
        function ActiveInfo(name, id, location, info) {
          this.name = name;
          this.id = id;
          this.location = location;
          this.info = info;
        }
        function insertActiveInfo(list, info) {
          for (var i2 = 0; i2 < list.length; ++i2) {
            if (list[i2].id === info.id) {
              list[i2].location = info.location;
              return;
            }
          }
          list.push(info);
        }
        function getShader(type, id, command) {
          var cache3 = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
          var shader = cache3[id];
          if (!shader) {
            var source = stringStore.str(id);
            shader = gl2.createShader(type);
            gl2.shaderSource(shader, source);
            gl2.compileShader(shader);
            check$1.shaderError(gl2, shader, source, type, command);
            cache3[id] = shader;
          }
          return shader;
        }
        var programCache = {};
        var programList = [];
        var PROGRAM_COUNTER = 0;
        function REGLProgram(fragId, vertId) {
          this.id = PROGRAM_COUNTER++;
          this.fragId = fragId;
          this.vertId = vertId;
          this.program = null;
          this.uniforms = [];
          this.attributes = [];
          this.refCount = 1;
          if (config.profile) {
            this.stats = {
              uniformsCount: 0,
              attributesCount: 0
            };
          }
        }
        function linkProgram(desc, command, attributeLocations) {
          var i2, info;
          var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
          var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);
          var program = desc.program = gl2.createProgram();
          gl2.attachShader(program, fragShader);
          gl2.attachShader(program, vertShader);
          if (attributeLocations) {
            for (i2 = 0; i2 < attributeLocations.length; ++i2) {
              var binding = attributeLocations[i2];
              gl2.bindAttribLocation(program, binding[0], binding[1]);
            }
          }
          gl2.linkProgram(program);
          check$1.linkError(
            gl2,
            program,
            stringStore.str(desc.fragId),
            stringStore.str(desc.vertId),
            command
          );
          var numUniforms = gl2.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
          if (config.profile) {
            desc.stats.uniformsCount = numUniforms;
          }
          var uniforms = desc.uniforms;
          for (i2 = 0; i2 < numUniforms; ++i2) {
            info = gl2.getActiveUniform(program, i2);
            if (info) {
              if (info.size > 1) {
                for (var j2 = 0; j2 < info.size; ++j2) {
                  var name = info.name.replace("[0]", "[" + j2 + "]");
                  insertActiveInfo(uniforms, new ActiveInfo(
                    name,
                    stringStore.id(name),
                    gl2.getUniformLocation(program, name),
                    info
                  ));
                }
              } else {
                insertActiveInfo(uniforms, new ActiveInfo(
                  info.name,
                  stringStore.id(info.name),
                  gl2.getUniformLocation(program, info.name),
                  info
                ));
              }
            }
          }
          var numAttributes = gl2.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
          if (config.profile) {
            desc.stats.attributesCount = numAttributes;
          }
          var attributes = desc.attributes;
          for (i2 = 0; i2 < numAttributes; ++i2) {
            info = gl2.getActiveAttrib(program, i2);
            if (info) {
              insertActiveInfo(attributes, new ActiveInfo(
                info.name,
                stringStore.id(info.name),
                gl2.getAttribLocation(program, info.name),
                info
              ));
            }
          }
        }
        if (config.profile) {
          stats2.getMaxUniformsCount = function() {
            var m3 = 0;
            programList.forEach(function(desc) {
              if (desc.stats.uniformsCount > m3) {
                m3 = desc.stats.uniformsCount;
              }
            });
            return m3;
          };
          stats2.getMaxAttributesCount = function() {
            var m3 = 0;
            programList.forEach(function(desc) {
              if (desc.stats.attributesCount > m3) {
                m3 = desc.stats.attributesCount;
              }
            });
            return m3;
          };
        }
        function restoreShaders() {
          fragShaders = {};
          vertShaders = {};
          for (var i2 = 0; i2 < programList.length; ++i2) {
            linkProgram(programList[i2], null, programList[i2].attributes.map(function(info) {
              return [info.location, info.name];
            }));
          }
        }
        return {
          clear: function() {
            var deleteShader = gl2.deleteShader.bind(gl2);
            values3(fragShaders).forEach(deleteShader);
            fragShaders = {};
            values3(vertShaders).forEach(deleteShader);
            vertShaders = {};
            programList.forEach(function(desc) {
              gl2.deleteProgram(desc.program);
            });
            programList.length = 0;
            programCache = {};
            stats2.shaderCount = 0;
          },
          program: function(vertId, fragId, command, attribLocations) {
            check$1.command(vertId >= 0, "missing vertex shader", command);
            check$1.command(fragId >= 0, "missing fragment shader", command);
            var cache3 = programCache[fragId];
            if (!cache3) {
              cache3 = programCache[fragId] = {};
            }
            var prevProgram = cache3[vertId];
            if (prevProgram) {
              prevProgram.refCount++;
              if (!attribLocations) {
                return prevProgram;
              }
            }
            var program = new REGLProgram(fragId, vertId);
            stats2.shaderCount++;
            linkProgram(program, command, attribLocations);
            if (!prevProgram) {
              cache3[vertId] = program;
            }
            programList.push(program);
            return extend4(program, {
              destroy: function() {
                program.refCount--;
                if (program.refCount <= 0) {
                  gl2.deleteProgram(program.program);
                  var idx = programList.indexOf(program);
                  programList.splice(idx, 1);
                  stats2.shaderCount--;
                }
                if (cache3[program.vertId].refCount <= 0) {
                  gl2.deleteShader(vertShaders[program.vertId]);
                  delete vertShaders[program.vertId];
                  delete programCache[program.fragId][program.vertId];
                }
                if (!Object.keys(programCache[program.fragId]).length) {
                  gl2.deleteShader(fragShaders[program.fragId]);
                  delete fragShaders[program.fragId];
                  delete programCache[program.fragId];
                }
              }
            });
          },
          restore: restoreShaders,
          shader: getShader,
          frag: -1,
          vert: -1
        };
      }
      var GL_RGBA$3 = 6408;
      var GL_UNSIGNED_BYTE$7 = 5121;
      var GL_PACK_ALIGNMENT = 3333;
      var GL_FLOAT$7 = 5126;
      function wrapReadPixels(gl2, framebufferState, reglPoll, context, glAttributes, extensions, limits) {
        function readPixelsImpl(input) {
          var type;
          if (framebufferState.next === null) {
            check$1(
              glAttributes.preserveDrawingBuffer,
              'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'
            );
            type = GL_UNSIGNED_BYTE$7;
          } else {
            check$1(
              framebufferState.next.colorAttachments[0].texture !== null,
              "You cannot read from a renderbuffer"
            );
            type = framebufferState.next.colorAttachments[0].texture._texture.type;
            if (extensions.oes_texture_float) {
              check$1(
                type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
                "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"
              );
              if (type === GL_FLOAT$7) {
                check$1(limits.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float");
              }
            } else {
              check$1(
                type === GL_UNSIGNED_BYTE$7,
                "Reading from a framebuffer is only allowed for the type 'uint8'"
              );
            }
          }
          var x4 = 0;
          var y4 = 0;
          var width = context.framebufferWidth;
          var height = context.framebufferHeight;
          var data = null;
          if (isTypedArray(input)) {
            data = input;
          } else if (input) {
            check$1.type(input, "object", "invalid arguments to regl.read()");
            x4 = input.x | 0;
            y4 = input.y | 0;
            check$1(
              x4 >= 0 && x4 < context.framebufferWidth,
              "invalid x offset for regl.read"
            );
            check$1(
              y4 >= 0 && y4 < context.framebufferHeight,
              "invalid y offset for regl.read"
            );
            width = (input.width || context.framebufferWidth - x4) | 0;
            height = (input.height || context.framebufferHeight - y4) | 0;
            data = input.data || null;
          }
          if (data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              check$1(
                data instanceof Uint8Array,
                "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"
              );
            } else if (type === GL_FLOAT$7) {
              check$1(
                data instanceof Float32Array,
                "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'"
              );
            }
          }
          check$1(
            width > 0 && width + x4 <= context.framebufferWidth,
            "invalid width for read pixels"
          );
          check$1(
            height > 0 && height + y4 <= context.framebufferHeight,
            "invalid height for read pixels"
          );
          reglPoll();
          var size3 = width * height * 4;
          if (!data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              data = new Uint8Array(size3);
            } else if (type === GL_FLOAT$7) {
              data = data || new Float32Array(size3);
            }
          }
          check$1.isTypedArray(data, "data buffer for regl.read() must be a typedarray");
          check$1(data.byteLength >= size3, "data buffer for regl.read() too small");
          gl2.pixelStorei(GL_PACK_ALIGNMENT, 4);
          gl2.readPixels(
            x4,
            y4,
            width,
            height,
            GL_RGBA$3,
            type,
            data
          );
          return data;
        }
        function readPixelsFBO(options) {
          var result;
          framebufferState.setFBO({
            framebuffer: options.framebuffer
          }, function() {
            result = readPixelsImpl(options);
          });
          return result;
        }
        function readPixels(options) {
          if (!options || !("framebuffer" in options)) {
            return readPixelsImpl(options);
          } else {
            return readPixelsFBO(options);
          }
        }
        return readPixels;
      }
      function slice(x4) {
        return Array.prototype.slice.call(x4);
      }
      function join(x4) {
        return slice(x4).join("");
      }
      function createEnvironment() {
        var varCounter = 0;
        var linkedNames = [];
        var linkedValues = [];
        function link(value) {
          for (var i2 = 0; i2 < linkedValues.length; ++i2) {
            if (linkedValues[i2] === value) {
              return linkedNames[i2];
            }
          }
          var name = "g" + varCounter++;
          linkedNames.push(name);
          linkedValues.push(value);
          return name;
        }
        function block() {
          var code = [];
          function push() {
            code.push.apply(code, slice(arguments));
          }
          var vars = [];
          function def() {
            var name = "v" + varCounter++;
            vars.push(name);
            if (arguments.length > 0) {
              code.push(name, "=");
              code.push.apply(code, slice(arguments));
              code.push(";");
            }
            return name;
          }
          return extend4(push, {
            def,
            toString: function() {
              return join([
                vars.length > 0 ? "var " + vars.join(",") + ";" : "",
                join(code)
              ]);
            }
          });
        }
        function scope() {
          var entry = block();
          var exit = block();
          var entryToString = entry.toString;
          var exitToString = exit.toString;
          function save(object, prop) {
            exit(object, prop, "=", entry.def(object, prop), ";");
          }
          return extend4(function() {
            entry.apply(entry, slice(arguments));
          }, {
            def: entry.def,
            entry,
            exit,
            save,
            set: function(object, prop, value) {
              save(object, prop);
              entry(object, prop, "=", value, ";");
            },
            toString: function() {
              return entryToString() + exitToString();
            }
          });
        }
        function conditional() {
          var pred = join(arguments);
          var thenBlock = scope();
          var elseBlock = scope();
          var thenToString = thenBlock.toString;
          var elseToString = elseBlock.toString;
          return extend4(thenBlock, {
            then: function() {
              thenBlock.apply(thenBlock, slice(arguments));
              return this;
            },
            else: function() {
              elseBlock.apply(elseBlock, slice(arguments));
              return this;
            },
            toString: function() {
              var elseClause = elseToString();
              if (elseClause) {
                elseClause = "else{" + elseClause + "}";
              }
              return join([
                "if(",
                pred,
                "){",
                thenToString(),
                "}",
                elseClause
              ]);
            }
          });
        }
        var globalBlock = block();
        var procedures = {};
        function proc(name, count) {
          var args = [];
          function arg() {
            var name2 = "a" + args.length;
            args.push(name2);
            return name2;
          }
          count = count || 0;
          for (var i2 = 0; i2 < count; ++i2) {
            arg();
          }
          var body = scope();
          var bodyToString = body.toString;
          var result = procedures[name] = extend4(body, {
            arg,
            toString: function() {
              return join([
                "function(",
                args.join(),
                "){",
                bodyToString(),
                "}"
              ]);
            }
          });
          return result;
        }
        function compile() {
          var code = [
            '"use strict";',
            globalBlock,
            "return {"
          ];
          Object.keys(procedures).forEach(function(name) {
            code.push('"', name, '":', procedures[name].toString(), ",");
          });
          code.push("}");
          var src = join(code).replace(/;/g, ";\n").replace(/}/g, "}\n").replace(/{/g, "{\n");
          var proc2 = Function.apply(null, linkedNames.concat(src));
          return proc2.apply(null, linkedValues);
        }
        return {
          global: globalBlock,
          link,
          block,
          proc,
          scope,
          cond: conditional,
          compile
        };
      }
      var CUTE_COMPONENTS = "xyzw".split("");
      var GL_UNSIGNED_BYTE$8 = 5121;
      var ATTRIB_STATE_POINTER = 1;
      var ATTRIB_STATE_CONSTANT = 2;
      var DYN_FUNC$1 = 0;
      var DYN_PROP$1 = 1;
      var DYN_CONTEXT$1 = 2;
      var DYN_STATE$1 = 3;
      var DYN_THUNK = 4;
      var DYN_CONSTANT$1 = 5;
      var DYN_ARRAY$1 = 6;
      var S_DITHER = "dither";
      var S_BLEND_ENABLE = "blend.enable";
      var S_BLEND_COLOR = "blend.color";
      var S_BLEND_EQUATION = "blend.equation";
      var S_BLEND_FUNC = "blend.func";
      var S_DEPTH_ENABLE = "depth.enable";
      var S_DEPTH_FUNC = "depth.func";
      var S_DEPTH_RANGE = "depth.range";
      var S_DEPTH_MASK = "depth.mask";
      var S_COLOR_MASK = "colorMask";
      var S_CULL_ENABLE = "cull.enable";
      var S_CULL_FACE = "cull.face";
      var S_FRONT_FACE = "frontFace";
      var S_LINE_WIDTH = "lineWidth";
      var S_POLYGON_OFFSET_ENABLE = "polygonOffset.enable";
      var S_POLYGON_OFFSET_OFFSET = "polygonOffset.offset";
      var S_SAMPLE_ALPHA = "sample.alpha";
      var S_SAMPLE_ENABLE = "sample.enable";
      var S_SAMPLE_COVERAGE = "sample.coverage";
      var S_STENCIL_ENABLE = "stencil.enable";
      var S_STENCIL_MASK = "stencil.mask";
      var S_STENCIL_FUNC = "stencil.func";
      var S_STENCIL_OPFRONT = "stencil.opFront";
      var S_STENCIL_OPBACK = "stencil.opBack";
      var S_SCISSOR_ENABLE = "scissor.enable";
      var S_SCISSOR_BOX = "scissor.box";
      var S_VIEWPORT = "viewport";
      var S_PROFILE = "profile";
      var S_FRAMEBUFFER = "framebuffer";
      var S_VERT = "vert";
      var S_FRAG = "frag";
      var S_ELEMENTS = "elements";
      var S_PRIMITIVE = "primitive";
      var S_COUNT = "count";
      var S_OFFSET = "offset";
      var S_INSTANCES = "instances";
      var S_VAO = "vao";
      var SUFFIX_WIDTH = "Width";
      var SUFFIX_HEIGHT = "Height";
      var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
      var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
      var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
      var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
      var S_DRAWINGBUFFER = "drawingBuffer";
      var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
      var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;
      var NESTED_OPTIONS = [
        S_BLEND_FUNC,
        S_BLEND_EQUATION,
        S_STENCIL_FUNC,
        S_STENCIL_OPFRONT,
        S_STENCIL_OPBACK,
        S_SAMPLE_COVERAGE,
        S_VIEWPORT,
        S_SCISSOR_BOX,
        S_POLYGON_OFFSET_OFFSET
      ];
      var GL_ARRAY_BUFFER$2 = 34962;
      var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;
      var GL_FRAGMENT_SHADER$1 = 35632;
      var GL_VERTEX_SHADER$1 = 35633;
      var GL_TEXTURE_2D$3 = 3553;
      var GL_TEXTURE_CUBE_MAP$2 = 34067;
      var GL_CULL_FACE = 2884;
      var GL_BLEND = 3042;
      var GL_DITHER = 3024;
      var GL_STENCIL_TEST = 2960;
      var GL_DEPTH_TEST = 2929;
      var GL_SCISSOR_TEST = 3089;
      var GL_POLYGON_OFFSET_FILL = 32823;
      var GL_SAMPLE_ALPHA_TO_COVERAGE = 32926;
      var GL_SAMPLE_COVERAGE = 32928;
      var GL_FLOAT$8 = 5126;
      var GL_FLOAT_VEC2 = 35664;
      var GL_FLOAT_VEC3 = 35665;
      var GL_FLOAT_VEC4 = 35666;
      var GL_INT$3 = 5124;
      var GL_INT_VEC2 = 35667;
      var GL_INT_VEC3 = 35668;
      var GL_INT_VEC4 = 35669;
      var GL_BOOL = 35670;
      var GL_BOOL_VEC2 = 35671;
      var GL_BOOL_VEC3 = 35672;
      var GL_BOOL_VEC4 = 35673;
      var GL_FLOAT_MAT2 = 35674;
      var GL_FLOAT_MAT3 = 35675;
      var GL_FLOAT_MAT4 = 35676;
      var GL_SAMPLER_2D = 35678;
      var GL_SAMPLER_CUBE = 35680;
      var GL_TRIANGLES$1 = 4;
      var GL_FRONT = 1028;
      var GL_BACK = 1029;
      var GL_CW = 2304;
      var GL_CCW = 2305;
      var GL_MIN_EXT = 32775;
      var GL_MAX_EXT = 32776;
      var GL_ALWAYS = 519;
      var GL_KEEP = 7680;
      var GL_ZERO = 0;
      var GL_ONE = 1;
      var GL_FUNC_ADD = 32774;
      var GL_LESS = 513;
      var GL_FRAMEBUFFER$2 = 36160;
      var GL_COLOR_ATTACHMENT0$2 = 36064;
      var blendFuncs = {
        "0": 0,
        "1": 1,
        "zero": 0,
        "one": 1,
        "src color": 768,
        "one minus src color": 769,
        "src alpha": 770,
        "one minus src alpha": 771,
        "dst color": 774,
        "one minus dst color": 775,
        "dst alpha": 772,
        "one minus dst alpha": 773,
        "constant color": 32769,
        "one minus constant color": 32770,
        "constant alpha": 32771,
        "one minus constant alpha": 32772,
        "src alpha saturate": 776
      };
      var invalidBlendCombinations = [
        "constant color, constant alpha",
        "one minus constant color, constant alpha",
        "constant color, one minus constant alpha",
        "one minus constant color, one minus constant alpha",
        "constant alpha, constant color",
        "constant alpha, one minus constant color",
        "one minus constant alpha, constant color",
        "one minus constant alpha, one minus constant color"
      ];
      var compareFuncs = {
        "never": 512,
        "less": 513,
        "<": 513,
        "equal": 514,
        "=": 514,
        "==": 514,
        "===": 514,
        "lequal": 515,
        "<=": 515,
        "greater": 516,
        ">": 516,
        "notequal": 517,
        "!=": 517,
        "!==": 517,
        "gequal": 518,
        ">=": 518,
        "always": 519
      };
      var stencilOps = {
        "0": 0,
        "zero": 0,
        "keep": 7680,
        "replace": 7681,
        "increment": 7682,
        "decrement": 7683,
        "increment wrap": 34055,
        "decrement wrap": 34056,
        "invert": 5386
      };
      var shaderType = {
        "frag": GL_FRAGMENT_SHADER$1,
        "vert": GL_VERTEX_SHADER$1
      };
      var orientationType = {
        "cw": GL_CW,
        "ccw": GL_CCW
      };
      function isBufferArgs(x4) {
        return Array.isArray(x4) || isTypedArray(x4) || isNDArrayLike(x4);
      }
      function sortState(state) {
        return state.sort(function(a3, b10) {
          if (a3 === S_VIEWPORT) {
            return -1;
          } else if (b10 === S_VIEWPORT) {
            return 1;
          }
          return a3 < b10 ? -1 : 1;
        });
      }
      function Declaration(thisDep, contextDep, propDep, append) {
        this.thisDep = thisDep;
        this.contextDep = contextDep;
        this.propDep = propDep;
        this.append = append;
      }
      function isStatic(decl) {
        return decl && !(decl.thisDep || decl.contextDep || decl.propDep);
      }
      function createStaticDecl(append) {
        return new Declaration(false, false, false, append);
      }
      function createDynamicDecl(dyn, append) {
        var type = dyn.type;
        if (type === DYN_FUNC$1) {
          var numArgs = dyn.data.length;
          return new Declaration(
            true,
            numArgs >= 1,
            numArgs >= 2,
            append
          );
        } else if (type === DYN_THUNK) {
          var data = dyn.data;
          return new Declaration(
            data.thisDep,
            data.contextDep,
            data.propDep,
            append
          );
        } else if (type === DYN_CONSTANT$1) {
          return new Declaration(
            false,
            false,
            false,
            append
          );
        } else if (type === DYN_ARRAY$1) {
          var thisDep = false;
          var contextDep = false;
          var propDep = false;
          for (var i2 = 0; i2 < dyn.data.length; ++i2) {
            var subDyn = dyn.data[i2];
            if (subDyn.type === DYN_PROP$1) {
              propDep = true;
            } else if (subDyn.type === DYN_CONTEXT$1) {
              contextDep = true;
            } else if (subDyn.type === DYN_STATE$1) {
              thisDep = true;
            } else if (subDyn.type === DYN_FUNC$1) {
              thisDep = true;
              var subArgs = subDyn.data;
              if (subArgs >= 1) {
                contextDep = true;
              }
              if (subArgs >= 2) {
                propDep = true;
              }
            } else if (subDyn.type === DYN_THUNK) {
              thisDep = thisDep || subDyn.data.thisDep;
              contextDep = contextDep || subDyn.data.contextDep;
              propDep = propDep || subDyn.data.propDep;
            }
          }
          return new Declaration(
            thisDep,
            contextDep,
            propDep,
            append
          );
        } else {
          return new Declaration(
            type === DYN_STATE$1,
            type === DYN_CONTEXT$1,
            type === DYN_PROP$1,
            append
          );
        }
      }
      var SCOPE_DECL = new Declaration(false, false, false, function() {
      });
      function reglCore(gl2, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer2, config) {
        var AttributeRecord2 = attributeState.Record;
        var blendEquations = {
          "add": 32774,
          "subtract": 32778,
          "reverse subtract": 32779
        };
        if (extensions.ext_blend_minmax) {
          blendEquations.min = GL_MIN_EXT;
          blendEquations.max = GL_MAX_EXT;
        }
        var extInstancing = extensions.angle_instanced_arrays;
        var extDrawBuffers = extensions.webgl_draw_buffers;
        var currentState = {
          dirty: true,
          profile: config.profile
        };
        var nextState = {};
        var GL_STATE_NAMES = [];
        var GL_FLAGS = {};
        var GL_VARIABLES = {};
        function propName(name) {
          return name.replace(".", "_");
        }
        function stateFlag(sname, cap, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          nextState[name] = currentState[name] = !!init;
          GL_FLAGS[name] = cap;
        }
        function stateVariable(sname, func, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          if (Array.isArray(init)) {
            currentState[name] = init.slice();
            nextState[name] = init.slice();
          } else {
            currentState[name] = nextState[name] = init;
          }
          GL_VARIABLES[name] = func;
        }
        stateFlag(S_DITHER, GL_DITHER);
        stateFlag(S_BLEND_ENABLE, GL_BLEND);
        stateVariable(S_BLEND_COLOR, "blendColor", [0, 0, 0, 0]);
        stateVariable(
          S_BLEND_EQUATION,
          "blendEquationSeparate",
          [GL_FUNC_ADD, GL_FUNC_ADD]
        );
        stateVariable(
          S_BLEND_FUNC,
          "blendFuncSeparate",
          [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]
        );
        stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
        stateVariable(S_DEPTH_FUNC, "depthFunc", GL_LESS);
        stateVariable(S_DEPTH_RANGE, "depthRange", [0, 1]);
        stateVariable(S_DEPTH_MASK, "depthMask", true);
        stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);
        stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
        stateVariable(S_CULL_FACE, "cullFace", GL_BACK);
        stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);
        stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);
        stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
        stateVariable(S_POLYGON_OFFSET_OFFSET, "polygonOffset", [0, 0]);
        stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
        stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
        stateVariable(S_SAMPLE_COVERAGE, "sampleCoverage", [1, false]);
        stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
        stateVariable(S_STENCIL_MASK, "stencilMask", -1);
        stateVariable(S_STENCIL_FUNC, "stencilFunc", [GL_ALWAYS, 0, -1]);
        stateVariable(
          S_STENCIL_OPFRONT,
          "stencilOpSeparate",
          [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]
        );
        stateVariable(
          S_STENCIL_OPBACK,
          "stencilOpSeparate",
          [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]
        );
        stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
        stateVariable(
          S_SCISSOR_BOX,
          "scissor",
          [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]
        );
        stateVariable(
          S_VIEWPORT,
          S_VIEWPORT,
          [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]
        );
        var sharedState = {
          gl: gl2,
          context: contextState,
          strings: stringStore,
          next: nextState,
          current: currentState,
          draw: drawState,
          elements: elementState,
          buffer: bufferState,
          shader: shaderState,
          attributes: attributeState.state,
          vao: attributeState,
          uniforms: uniformState,
          framebuffer: framebufferState,
          extensions,
          timer: timer2,
          isBufferArgs
        };
        var sharedConstants = {
          primTypes,
          compareFuncs,
          blendFuncs,
          blendEquations,
          stencilOps,
          glTypes,
          orientationType
        };
        check$1.optional(function() {
          sharedState.isArrayLike = isArrayLike3;
        });
        if (extDrawBuffers) {
          sharedConstants.backBuffer = [GL_BACK];
          sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function(i2) {
            if (i2 === 0) {
              return [0];
            }
            return loop(i2, function(j2) {
              return GL_COLOR_ATTACHMENT0$2 + j2;
            });
          });
        }
        var drawCallCounter = 0;
        function createREGLEnvironment() {
          var env = createEnvironment();
          var link = env.link;
          var global2 = env.global;
          env.id = drawCallCounter++;
          env.batchId = "0";
          var SHARED = link(sharedState);
          var shared = env.shared = {
            props: "a0"
          };
          Object.keys(sharedState).forEach(function(prop) {
            shared[prop] = global2.def(SHARED, ".", prop);
          });
          check$1.optional(function() {
            env.CHECK = link(check$1);
            env.commandStr = check$1.guessCommand();
            env.command = link(env.commandStr);
            env.assert = function(block, pred, message) {
              block(
                "if(!(",
                pred,
                "))",
                this.CHECK,
                ".commandRaise(",
                link(message),
                ",",
                this.command,
                ");"
              );
            };
            sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
          });
          var nextVars = env.next = {};
          var currentVars = env.current = {};
          Object.keys(GL_VARIABLES).forEach(function(variable) {
            if (Array.isArray(currentState[variable])) {
              nextVars[variable] = global2.def(shared.next, ".", variable);
              currentVars[variable] = global2.def(shared.current, ".", variable);
            }
          });
          var constants = env.constants = {};
          Object.keys(sharedConstants).forEach(function(name) {
            constants[name] = global2.def(JSON.stringify(sharedConstants[name]));
          });
          env.invoke = function(block, x4) {
            switch (x4.type) {
              case DYN_FUNC$1:
                var argList = [
                  "this",
                  shared.context,
                  shared.props,
                  env.batchId
                ];
                return block.def(
                  link(x4.data),
                  ".call(",
                  argList.slice(0, Math.max(x4.data.length + 1, 4)),
                  ")"
                );
              case DYN_PROP$1:
                return block.def(shared.props, x4.data);
              case DYN_CONTEXT$1:
                return block.def(shared.context, x4.data);
              case DYN_STATE$1:
                return block.def("this", x4.data);
              case DYN_THUNK:
                x4.data.append(env, block);
                return x4.data.ref;
              case DYN_CONSTANT$1:
                return x4.data.toString();
              case DYN_ARRAY$1:
                return x4.data.map(function(y4) {
                  return env.invoke(block, y4);
                });
            }
          };
          env.attribCache = {};
          var scopeAttribs = {};
          env.scopeAttrib = function(name) {
            var id = stringStore.id(name);
            if (id in scopeAttribs) {
              return scopeAttribs[id];
            }
            var binding = attributeState.scope[id];
            if (!binding) {
              binding = attributeState.scope[id] = new AttributeRecord2();
            }
            var result = scopeAttribs[id] = link(binding);
            return result;
          };
          return env;
        }
        function parseProfile(options) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var profileEnable;
          if (S_PROFILE in staticOptions) {
            var value = !!staticOptions[S_PROFILE];
            profileEnable = createStaticDecl(function(env, scope) {
              return value;
            });
            profileEnable.enable = value;
          } else if (S_PROFILE in dynamicOptions) {
            var dyn = dynamicOptions[S_PROFILE];
            profileEnable = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          }
          return profileEnable;
        }
        function parseFramebuffer(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_FRAMEBUFFER in staticOptions) {
            var framebuffer = staticOptions[S_FRAMEBUFFER];
            if (framebuffer) {
              framebuffer = framebufferState.getFramebuffer(framebuffer);
              check$1.command(framebuffer, "invalid framebuffer object");
              return createStaticDecl(function(env2, block) {
                var FRAMEBUFFER = env2.link(framebuffer);
                var shared = env2.shared;
                block.set(
                  shared.framebuffer,
                  ".next",
                  FRAMEBUFFER
                );
                var CONTEXT = shared.context;
                block.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_WIDTH,
                  FRAMEBUFFER + ".width"
                );
                block.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_HEIGHT,
                  FRAMEBUFFER + ".height"
                );
                return FRAMEBUFFER;
              });
            } else {
              return createStaticDecl(function(env2, scope) {
                var shared = env2.shared;
                scope.set(
                  shared.framebuffer,
                  ".next",
                  "null"
                );
                var CONTEXT = shared.context;
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_WIDTH,
                  CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
                );
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_HEIGHT,
                  CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
                );
                return "null";
              });
            }
          } else if (S_FRAMEBUFFER in dynamicOptions) {
            var dyn = dynamicOptions[S_FRAMEBUFFER];
            return createDynamicDecl(dyn, function(env2, scope) {
              var FRAMEBUFFER_FUNC = env2.invoke(scope, dyn);
              var shared = env2.shared;
              var FRAMEBUFFER_STATE = shared.framebuffer;
              var FRAMEBUFFER = scope.def(
                FRAMEBUFFER_STATE,
                ".getFramebuffer(",
                FRAMEBUFFER_FUNC,
                ")"
              );
              check$1.optional(function() {
                env2.assert(
                  scope,
                  "!" + FRAMEBUFFER_FUNC + "||" + FRAMEBUFFER,
                  "invalid framebuffer object"
                );
              });
              scope.set(
                FRAMEBUFFER_STATE,
                ".next",
                FRAMEBUFFER
              );
              var CONTEXT = shared.context;
              scope.set(
                CONTEXT,
                "." + S_FRAMEBUFFER_WIDTH,
                FRAMEBUFFER + "?" + FRAMEBUFFER + ".width:" + CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
              );
              scope.set(
                CONTEXT,
                "." + S_FRAMEBUFFER_HEIGHT,
                FRAMEBUFFER + "?" + FRAMEBUFFER + ".height:" + CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
              );
              return FRAMEBUFFER;
            });
          } else {
            return null;
          }
        }
        function parseViewportScissor(options, framebuffer, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseBox(param) {
            if (param in staticOptions) {
              var box2 = staticOptions[param];
              check$1.commandType(box2, "object", "invalid " + param, env.commandStr);
              var isStatic2 = true;
              var x4 = box2.x | 0;
              var y4 = box2.y | 0;
              var w2, h2;
              if ("width" in box2) {
                w2 = box2.width | 0;
                check$1.command(w2 >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              if ("height" in box2) {
                h2 = box2.height | 0;
                check$1.command(h2 >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              return new Declaration(
                !isStatic2 && framebuffer && framebuffer.thisDep,
                !isStatic2 && framebuffer && framebuffer.contextDep,
                !isStatic2 && framebuffer && framebuffer.propDep,
                function(env2, scope) {
                  var CONTEXT = env2.shared.context;
                  var BOX_W = w2;
                  if (!("width" in box2)) {
                    BOX_W = scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH, "-", x4);
                  }
                  var BOX_H = h2;
                  if (!("height" in box2)) {
                    BOX_H = scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT, "-", y4);
                  }
                  return [x4, y4, BOX_W, BOX_H];
                }
              );
            } else if (param in dynamicOptions) {
              var dynBox = dynamicOptions[param];
              var result = createDynamicDecl(dynBox, function(env2, scope) {
                var BOX = env2.invoke(scope, dynBox);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    BOX + "&&typeof " + BOX + '==="object"',
                    "invalid " + param
                  );
                });
                var CONTEXT = env2.shared.context;
                var BOX_X = scope.def(BOX, ".x|0");
                var BOX_Y = scope.def(BOX, ".y|0");
                var BOX_W = scope.def(
                  '"width" in ',
                  BOX,
                  "?",
                  BOX,
                  ".width|0:",
                  "(",
                  CONTEXT,
                  ".",
                  S_FRAMEBUFFER_WIDTH,
                  "-",
                  BOX_X,
                  ")"
                );
                var BOX_H = scope.def(
                  '"height" in ',
                  BOX,
                  "?",
                  BOX,
                  ".height|0:",
                  "(",
                  CONTEXT,
                  ".",
                  S_FRAMEBUFFER_HEIGHT,
                  "-",
                  BOX_Y,
                  ")"
                );
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    BOX_W + ">=0&&" + BOX_H + ">=0",
                    "invalid " + param
                  );
                });
                return [BOX_X, BOX_Y, BOX_W, BOX_H];
              });
              if (framebuffer) {
                result.thisDep = result.thisDep || framebuffer.thisDep;
                result.contextDep = result.contextDep || framebuffer.contextDep;
                result.propDep = result.propDep || framebuffer.propDep;
              }
              return result;
            } else if (framebuffer) {
              return new Declaration(
                framebuffer.thisDep,
                framebuffer.contextDep,
                framebuffer.propDep,
                function(env2, scope) {
                  var CONTEXT = env2.shared.context;
                  return [
                    0,
                    0,
                    scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH),
                    scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT)
                  ];
                }
              );
            } else {
              return null;
            }
          }
          var viewport = parseBox(S_VIEWPORT);
          if (viewport) {
            var prevViewport = viewport;
            viewport = new Declaration(
              viewport.thisDep,
              viewport.contextDep,
              viewport.propDep,
              function(env2, scope) {
                var VIEWPORT = prevViewport.append(env2, scope);
                var CONTEXT = env2.shared.context;
                scope.set(
                  CONTEXT,
                  "." + S_VIEWPORT_WIDTH,
                  VIEWPORT[2]
                );
                scope.set(
                  CONTEXT,
                  "." + S_VIEWPORT_HEIGHT,
                  VIEWPORT[3]
                );
                return VIEWPORT;
              }
            );
          }
          return {
            viewport,
            scissor_box: parseBox(S_SCISSOR_BOX)
          };
        }
        function parseAttribLocations(options, attributes) {
          var staticOptions = options.static;
          var staticProgram = typeof staticOptions[S_FRAG] === "string" && typeof staticOptions[S_VERT] === "string";
          if (staticProgram) {
            if (Object.keys(attributes.dynamic).length > 0) {
              return null;
            }
            var staticAttributes = attributes.static;
            var sAttributes = Object.keys(staticAttributes);
            if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === "number") {
              var bindings = [];
              for (var i2 = 0; i2 < sAttributes.length; ++i2) {
                check$1(typeof staticAttributes[sAttributes[i2]] === "number", "must specify all vertex attribute locations when using vaos");
                bindings.push([staticAttributes[sAttributes[i2]] | 0, sAttributes[i2]]);
              }
              return bindings;
            }
          }
          return null;
        }
        function parseProgram(options, env, attribLocations) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseShader(name) {
            if (name in staticOptions) {
              var id = stringStore.id(staticOptions[name]);
              check$1.optional(function() {
                shaderState.shader(shaderType[name], id, check$1.guessCommand());
              });
              var result = createStaticDecl(function() {
                return id;
              });
              result.id = id;
              return result;
            } else if (name in dynamicOptions) {
              var dyn = dynamicOptions[name];
              return createDynamicDecl(dyn, function(env2, scope) {
                var str10 = env2.invoke(scope, dyn);
                var id2 = scope.def(env2.shared.strings, ".id(", str10, ")");
                check$1.optional(function() {
                  scope(
                    env2.shared.shader,
                    ".shader(",
                    shaderType[name],
                    ",",
                    id2,
                    ",",
                    env2.command,
                    ");"
                  );
                });
                return id2;
              });
            }
            return null;
          }
          var frag = parseShader(S_FRAG);
          var vert = parseShader(S_VERT);
          var program = null;
          var progVar;
          if (isStatic(frag) && isStatic(vert)) {
            program = shaderState.program(vert.id, frag.id, null, attribLocations);
            progVar = createStaticDecl(function(env2, scope) {
              return env2.link(program);
            });
          } else {
            progVar = new Declaration(
              frag && frag.thisDep || vert && vert.thisDep,
              frag && frag.contextDep || vert && vert.contextDep,
              frag && frag.propDep || vert && vert.propDep,
              function(env2, scope) {
                var SHADER_STATE = env2.shared.shader;
                var fragId;
                if (frag) {
                  fragId = frag.append(env2, scope);
                } else {
                  fragId = scope.def(SHADER_STATE, ".", S_FRAG);
                }
                var vertId;
                if (vert) {
                  vertId = vert.append(env2, scope);
                } else {
                  vertId = scope.def(SHADER_STATE, ".", S_VERT);
                }
                var progDef = SHADER_STATE + ".program(" + vertId + "," + fragId;
                check$1.optional(function() {
                  progDef += "," + env2.command;
                });
                return scope.def(progDef + ")");
              }
            );
          }
          return {
            frag,
            vert,
            progVar,
            program
          };
        }
        function parseDraw(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseElements() {
            if (S_ELEMENTS in staticOptions) {
              var elements2 = staticOptions[S_ELEMENTS];
              if (isBufferArgs(elements2)) {
                elements2 = elementState.getElements(elementState.create(elements2, true));
              } else if (elements2) {
                elements2 = elementState.getElements(elements2);
                check$1.command(elements2, "invalid elements", env.commandStr);
              }
              var result = createStaticDecl(function(env2, scope) {
                if (elements2) {
                  var result2 = env2.link(elements2);
                  env2.ELEMENTS = result2;
                  return result2;
                }
                env2.ELEMENTS = null;
                return null;
              });
              result.value = elements2;
              return result;
            } else if (S_ELEMENTS in dynamicOptions) {
              var dyn = dynamicOptions[S_ELEMENTS];
              return createDynamicDecl(dyn, function(env2, scope) {
                var shared = env2.shared;
                var IS_BUFFER_ARGS = shared.isBufferArgs;
                var ELEMENT_STATE = shared.elements;
                var elementDefn = env2.invoke(scope, dyn);
                var elements3 = scope.def("null");
                var elementStream = scope.def(IS_BUFFER_ARGS, "(", elementDefn, ")");
                var ifte = env2.cond(elementStream).then(elements3, "=", ELEMENT_STATE, ".createStream(", elementDefn, ");").else(elements3, "=", ELEMENT_STATE, ".getElements(", elementDefn, ");");
                check$1.optional(function() {
                  env2.assert(
                    ifte.else,
                    "!" + elementDefn + "||" + elements3,
                    "invalid elements"
                  );
                });
                scope.entry(ifte);
                scope.exit(
                  env2.cond(elementStream).then(ELEMENT_STATE, ".destroyStream(", elements3, ");")
                );
                env2.ELEMENTS = elements3;
                return elements3;
              });
            }
            return null;
          }
          var elements = parseElements();
          function parsePrimitive() {
            if (S_PRIMITIVE in staticOptions) {
              var primitive = staticOptions[S_PRIMITIVE];
              check$1.commandParameter(primitive, primTypes, "invalid primitve", env.commandStr);
              return createStaticDecl(function(env2, scope) {
                return primTypes[primitive];
              });
            } else if (S_PRIMITIVE in dynamicOptions) {
              var dynPrimitive = dynamicOptions[S_PRIMITIVE];
              return createDynamicDecl(dynPrimitive, function(env2, scope) {
                var PRIM_TYPES = env2.constants.primTypes;
                var prim3 = env2.invoke(scope, dynPrimitive);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    prim3 + " in " + PRIM_TYPES,
                    "invalid primitive, must be one of " + Object.keys(primTypes)
                  );
                });
                return scope.def(PRIM_TYPES, "[", prim3, "]");
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements.value) {
                  return createStaticDecl(function(env2, scope) {
                    return scope.def(env2.ELEMENTS, ".primType");
                  });
                } else {
                  return createStaticDecl(function() {
                    return GL_TRIANGLES$1;
                  });
                }
              } else {
                return new Declaration(
                  elements.thisDep,
                  elements.contextDep,
                  elements.propDep,
                  function(env2, scope) {
                    var elements2 = env2.ELEMENTS;
                    return scope.def(elements2, "?", elements2, ".primType:", GL_TRIANGLES$1);
                  }
                );
              }
            }
            return null;
          }
          function parseParam(param, isOffset) {
            if (param in staticOptions) {
              var value = staticOptions[param] | 0;
              check$1.command(!isOffset || value >= 0, "invalid " + param, env.commandStr);
              return createStaticDecl(function(env2, scope) {
                if (isOffset) {
                  env2.OFFSET = value;
                }
                return value;
              });
            } else if (param in dynamicOptions) {
              var dynValue = dynamicOptions[param];
              return createDynamicDecl(dynValue, function(env2, scope) {
                var result = env2.invoke(scope, dynValue);
                if (isOffset) {
                  env2.OFFSET = result;
                  check$1.optional(function() {
                    env2.assert(
                      scope,
                      result + ">=0",
                      "invalid " + param
                    );
                  });
                }
                return result;
              });
            } else if (isOffset && elements) {
              return createStaticDecl(function(env2, scope) {
                env2.OFFSET = "0";
                return 0;
              });
            }
            return null;
          }
          var OFFSET = parseParam(S_OFFSET, true);
          function parseVertCount() {
            if (S_COUNT in staticOptions) {
              var count = staticOptions[S_COUNT] | 0;
              check$1.command(
                typeof count === "number" && count >= 0,
                "invalid vertex count",
                env.commandStr
              );
              return createStaticDecl(function() {
                return count;
              });
            } else if (S_COUNT in dynamicOptions) {
              var dynCount = dynamicOptions[S_COUNT];
              return createDynamicDecl(dynCount, function(env2, scope) {
                var result2 = env2.invoke(scope, dynCount);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    "typeof " + result2 + '==="number"&&' + result2 + ">=0&&" + result2 + "===(" + result2 + "|0)",
                    "invalid vertex count"
                  );
                });
                return result2;
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements) {
                  if (OFFSET) {
                    return new Declaration(
                      OFFSET.thisDep,
                      OFFSET.contextDep,
                      OFFSET.propDep,
                      function(env2, scope) {
                        var result2 = scope.def(
                          env2.ELEMENTS,
                          ".vertCount-",
                          env2.OFFSET
                        );
                        check$1.optional(function() {
                          env2.assert(
                            scope,
                            result2 + ">=0",
                            "invalid vertex offset/element buffer too small"
                          );
                        });
                        return result2;
                      }
                    );
                  } else {
                    return createStaticDecl(function(env2, scope) {
                      return scope.def(env2.ELEMENTS, ".vertCount");
                    });
                  }
                } else {
                  var result = createStaticDecl(function() {
                    return -1;
                  });
                  check$1.optional(function() {
                    result.MISSING = true;
                  });
                  return result;
                }
              } else {
                var variable = new Declaration(
                  elements.thisDep || OFFSET.thisDep,
                  elements.contextDep || OFFSET.contextDep,
                  elements.propDep || OFFSET.propDep,
                  function(env2, scope) {
                    var elements2 = env2.ELEMENTS;
                    if (env2.OFFSET) {
                      return scope.def(
                        elements2,
                        "?",
                        elements2,
                        ".vertCount-",
                        env2.OFFSET,
                        ":-1"
                      );
                    }
                    return scope.def(elements2, "?", elements2, ".vertCount:-1");
                  }
                );
                check$1.optional(function() {
                  variable.DYNAMIC = true;
                });
                return variable;
              }
            }
            return null;
          }
          return {
            elements,
            primitive: parsePrimitive(),
            count: parseVertCount(),
            instances: parseParam(S_INSTANCES, false),
            offset: OFFSET
          };
        }
        function parseGLState(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var STATE = {};
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            function parseParam(parseStatic, parseDynamic) {
              if (prop in staticOptions) {
                var value = parseStatic(staticOptions[prop]);
                STATE[param] = createStaticDecl(function() {
                  return value;
                });
              } else if (prop in dynamicOptions) {
                var dyn = dynamicOptions[prop];
                STATE[param] = createDynamicDecl(dyn, function(env2, scope) {
                  return parseDynamic(env2, scope, env2.invoke(scope, dyn));
                });
              }
            }
            switch (prop) {
              case S_CULL_ENABLE:
              case S_BLEND_ENABLE:
              case S_DITHER:
              case S_STENCIL_ENABLE:
              case S_DEPTH_ENABLE:
              case S_SCISSOR_ENABLE:
              case S_POLYGON_OFFSET_ENABLE:
              case S_SAMPLE_ALPHA:
              case S_SAMPLE_ENABLE:
              case S_DEPTH_MASK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "boolean", prop, env.commandStr);
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="boolean"',
                        "invalid flag " + prop,
                        env2.commandStr
                      );
                    });
                    return value;
                  }
                );
              case S_DEPTH_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandParameter(value, compareFuncs, "invalid " + prop, env.commandStr);
                    return compareFuncs[value];
                  },
                  function(env2, scope, value) {
                    var COMPARE_FUNCS = env2.constants.compareFuncs;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + " in " + COMPARE_FUNCS,
                        "invalid " + prop + ", must be one of " + Object.keys(compareFuncs)
                      );
                    });
                    return scope.def(COMPARE_FUNCS, "[", value, "]");
                  }
                );
              case S_DEPTH_RANGE:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike3(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number" && value[0] <= value[1],
                      "depth range is 2d array",
                      env.commandStr
                    );
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===2&&typeof " + value + '[0]==="number"&&typeof ' + value + '[1]==="number"&&' + value + "[0]<=" + value + "[1]",
                        "depth range must be a 2d array"
                      );
                    });
                    var Z_NEAR = scope.def("+", value, "[0]");
                    var Z_FAR = scope.def("+", value, "[1]");
                    return [Z_NEAR, Z_FAR];
                  }
                );
              case S_BLEND_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", "blend.func", env.commandStr);
                    var srcRGB = "srcRGB" in value ? value.srcRGB : value.src;
                    var srcAlpha = "srcAlpha" in value ? value.srcAlpha : value.src;
                    var dstRGB = "dstRGB" in value ? value.dstRGB : value.dst;
                    var dstAlpha = "dstAlpha" in value ? value.dstAlpha : value.dst;
                    check$1.commandParameter(srcRGB, blendFuncs, param + ".srcRGB", env.commandStr);
                    check$1.commandParameter(srcAlpha, blendFuncs, param + ".srcAlpha", env.commandStr);
                    check$1.commandParameter(dstRGB, blendFuncs, param + ".dstRGB", env.commandStr);
                    check$1.commandParameter(dstAlpha, blendFuncs, param + ".dstAlpha", env.commandStr);
                    check$1.command(
                      invalidBlendCombinations.indexOf(srcRGB + ", " + dstRGB) === -1,
                      "unallowed blending combination (srcRGB, dstRGB) = (" + srcRGB + ", " + dstRGB + ")",
                      env.commandStr
                    );
                    return [
                      blendFuncs[srcRGB],
                      blendFuncs[dstRGB],
                      blendFuncs[srcAlpha],
                      blendFuncs[dstAlpha]
                    ];
                  },
                  function(env2, scope, value) {
                    var BLEND_FUNCS = env2.constants.blendFuncs;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid blend func, must be an object"
                      );
                    });
                    function read3(prefix, suffix) {
                      var func = scope.def(
                        '"',
                        prefix,
                        suffix,
                        '" in ',
                        value,
                        "?",
                        value,
                        ".",
                        prefix,
                        suffix,
                        ":",
                        value,
                        ".",
                        prefix
                      );
                      check$1.optional(function() {
                        env2.assert(
                          scope,
                          func + " in " + BLEND_FUNCS,
                          "invalid " + prop + "." + prefix + suffix + ", must be one of " + Object.keys(blendFuncs)
                        );
                      });
                      return func;
                    }
                    var srcRGB = read3("src", "RGB");
                    var dstRGB = read3("dst", "RGB");
                    check$1.optional(function() {
                      var INVALID_BLEND_COMBINATIONS = env2.constants.invalidBlendCombinations;
                      env2.assert(
                        scope,
                        INVALID_BLEND_COMBINATIONS + ".indexOf(" + srcRGB + '+", "+' + dstRGB + ") === -1 ",
                        "unallowed blending combination for (srcRGB, dstRGB)"
                      );
                    });
                    var SRC_RGB = scope.def(BLEND_FUNCS, "[", srcRGB, "]");
                    var SRC_ALPHA = scope.def(BLEND_FUNCS, "[", read3("src", "Alpha"), "]");
                    var DST_RGB = scope.def(BLEND_FUNCS, "[", dstRGB, "]");
                    var DST_ALPHA = scope.def(BLEND_FUNCS, "[", read3("dst", "Alpha"), "]");
                    return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];
                  }
                );
              case S_BLEND_EQUATION:
                return parseParam(
                  function(value) {
                    if (typeof value === "string") {
                      check$1.commandParameter(value, blendEquations, "invalid " + prop, env.commandStr);
                      return [
                        blendEquations[value],
                        blendEquations[value]
                      ];
                    } else if (typeof value === "object") {
                      check$1.commandParameter(
                        value.rgb,
                        blendEquations,
                        prop + ".rgb",
                        env.commandStr
                      );
                      check$1.commandParameter(
                        value.alpha,
                        blendEquations,
                        prop + ".alpha",
                        env.commandStr
                      );
                      return [
                        blendEquations[value.rgb],
                        blendEquations[value.alpha]
                      ];
                    } else {
                      check$1.commandRaise("invalid blend.equation", env.commandStr);
                    }
                  },
                  function(env2, scope, value) {
                    var BLEND_EQUATIONS = env2.constants.blendEquations;
                    var RGB = scope.def();
                    var ALPHA = scope.def();
                    var ifte = env2.cond("typeof ", value, '==="string"');
                    check$1.optional(function() {
                      function checkProp(block, name, value2) {
                        env2.assert(
                          block,
                          value2 + " in " + BLEND_EQUATIONS,
                          "invalid " + name + ", must be one of " + Object.keys(blendEquations)
                        );
                      }
                      checkProp(ifte.then, prop, value);
                      env2.assert(
                        ifte.else,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                      checkProp(ifte.else, prop + ".rgb", value + ".rgb");
                      checkProp(ifte.else, prop + ".alpha", value + ".alpha");
                    });
                    ifte.then(
                      RGB,
                      "=",
                      ALPHA,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      "];"
                    );
                    ifte.else(
                      RGB,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      ".rgb];",
                      ALPHA,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      ".alpha];"
                    );
                    scope(ifte);
                    return [RGB, ALPHA];
                  }
                );
              case S_BLEND_COLOR:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike3(value) && value.length === 4,
                      "blend.color must be a 4d array",
                      env.commandStr
                    );
                    return loop(4, function(i2) {
                      return +value[i2];
                    });
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4",
                        "blend.color must be a 4d array"
                      );
                    });
                    return loop(4, function(i2) {
                      return scope.def("+", value, "[", i2, "]");
                    });
                  }
                );
              case S_STENCIL_MASK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "number", param, env.commandStr);
                    return value | 0;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="number"',
                        "invalid stencil.mask"
                      );
                    });
                    return scope.def(value, "|0");
                  }
                );
              case S_STENCIL_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var cmp = value.cmp || "keep";
                    var ref = value.ref || 0;
                    var mask = "mask" in value ? value.mask : -1;
                    check$1.commandParameter(cmp, compareFuncs, prop + ".cmp", env.commandStr);
                    check$1.commandType(ref, "number", prop + ".ref", env.commandStr);
                    check$1.commandType(mask, "number", prop + ".mask", env.commandStr);
                    return [
                      compareFuncs[cmp],
                      ref,
                      mask
                    ];
                  },
                  function(env2, scope, value) {
                    var COMPARE_FUNCS = env2.constants.compareFuncs;
                    check$1.optional(function() {
                      function assert() {
                        env2.assert(
                          scope,
                          Array.prototype.join.call(arguments, ""),
                          "invalid stencil.func"
                        );
                      }
                      assert(value + "&&typeof ", value, '==="object"');
                      assert(
                        '!("cmp" in ',
                        value,
                        ")||(",
                        value,
                        ".cmp in ",
                        COMPARE_FUNCS,
                        ")"
                      );
                    });
                    var cmp = scope.def(
                      '"cmp" in ',
                      value,
                      "?",
                      COMPARE_FUNCS,
                      "[",
                      value,
                      ".cmp]",
                      ":",
                      GL_KEEP
                    );
                    var ref = scope.def(value, ".ref|0");
                    var mask = scope.def(
                      '"mask" in ',
                      value,
                      "?",
                      value,
                      ".mask|0:-1"
                    );
                    return [cmp, ref, mask];
                  }
                );
              case S_STENCIL_OPFRONT:
              case S_STENCIL_OPBACK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var fail = value.fail || "keep";
                    var zfail = value.zfail || "keep";
                    var zpass = value.zpass || "keep";
                    check$1.commandParameter(fail, stencilOps, prop + ".fail", env.commandStr);
                    check$1.commandParameter(zfail, stencilOps, prop + ".zfail", env.commandStr);
                    check$1.commandParameter(zpass, stencilOps, prop + ".zpass", env.commandStr);
                    return [
                      prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                      stencilOps[fail],
                      stencilOps[zfail],
                      stencilOps[zpass]
                    ];
                  },
                  function(env2, scope, value) {
                    var STENCIL_OPS = env2.constants.stencilOps;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                    });
                    function read3(name) {
                      check$1.optional(function() {
                        env2.assert(
                          scope,
                          '!("' + name + '" in ' + value + ")||(" + value + "." + name + " in " + STENCIL_OPS + ")",
                          "invalid " + prop + "." + name + ", must be one of " + Object.keys(stencilOps)
                        );
                      });
                      return scope.def(
                        '"',
                        name,
                        '" in ',
                        value,
                        "?",
                        STENCIL_OPS,
                        "[",
                        value,
                        ".",
                        name,
                        "]:",
                        GL_KEEP
                      );
                    }
                    return [
                      prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                      read3("fail"),
                      read3("zfail"),
                      read3("zpass")
                    ];
                  }
                );
              case S_POLYGON_OFFSET_OFFSET:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var factor = value.factor | 0;
                    var units = value.units | 0;
                    check$1.commandType(factor, "number", param + ".factor", env.commandStr);
                    check$1.commandType(units, "number", param + ".units", env.commandStr);
                    return [factor, units];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                    });
                    var FACTOR = scope.def(value, ".factor|0");
                    var UNITS = scope.def(value, ".units|0");
                    return [FACTOR, UNITS];
                  }
                );
              case S_CULL_FACE:
                return parseParam(
                  function(value) {
                    var face = 0;
                    if (value === "front") {
                      face = GL_FRONT;
                    } else if (value === "back") {
                      face = GL_BACK;
                    }
                    check$1.command(!!face, param, env.commandStr);
                    return face;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + '==="front"||' + value + '==="back"',
                        "invalid cull.face"
                      );
                    });
                    return scope.def(value, '==="front"?', GL_FRONT, ":", GL_BACK);
                  }
                );
              case S_LINE_WIDTH:
                return parseParam(
                  function(value) {
                    check$1.command(
                      typeof value === "number" && value >= limits.lineWidthDims[0] && value <= limits.lineWidthDims[1],
                      "invalid line width, must be a positive number between " + limits.lineWidthDims[0] + " and " + limits.lineWidthDims[1],
                      env.commandStr
                    );
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="number"&&' + value + ">=" + limits.lineWidthDims[0] + "&&" + value + "<=" + limits.lineWidthDims[1],
                        "invalid line width"
                      );
                    });
                    return value;
                  }
                );
              case S_FRONT_FACE:
                return parseParam(
                  function(value) {
                    check$1.commandParameter(value, orientationType, param, env.commandStr);
                    return orientationType[value];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + '==="cw"||' + value + '==="ccw"',
                        "invalid frontFace, must be one of cw,ccw"
                      );
                    });
                    return scope.def(value + '==="cw"?' + GL_CW + ":" + GL_CCW);
                  }
                );
              case S_COLOR_MASK:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike3(value) && value.length === 4,
                      "color.mask must be length 4 array",
                      env.commandStr
                    );
                    return value.map(function(v2) {
                      return !!v2;
                    });
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4",
                        "invalid color.mask"
                      );
                    });
                    return loop(4, function(i2) {
                      return "!!" + value + "[" + i2 + "]";
                    });
                  }
                );
              case S_SAMPLE_COVERAGE:
                return parseParam(
                  function(value) {
                    check$1.command(typeof value === "object" && value, param, env.commandStr);
                    var sampleValue = "value" in value ? value.value : 1;
                    var sampleInvert = !!value.invert;
                    check$1.command(
                      typeof sampleValue === "number" && sampleValue >= 0 && sampleValue <= 1,
                      "sample.coverage.value must be a number between 0 and 1",
                      env.commandStr
                    );
                    return [sampleValue, sampleInvert];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid sample.coverage"
                      );
                    });
                    var VALUE = scope.def(
                      '"value" in ',
                      value,
                      "?+",
                      value,
                      ".value:1"
                    );
                    var INVERT = scope.def("!!", value, ".invert");
                    return [VALUE, INVERT];
                  }
                );
            }
          });
          return STATE;
        }
        function parseUniforms(uniforms, env) {
          var staticUniforms = uniforms.static;
          var dynamicUniforms = uniforms.dynamic;
          var UNIFORMS = {};
          Object.keys(staticUniforms).forEach(function(name) {
            var value = staticUniforms[name];
            var result;
            if (typeof value === "number" || typeof value === "boolean") {
              result = createStaticDecl(function() {
                return value;
              });
            } else if (typeof value === "function") {
              var reglType = value._reglType;
              if (reglType === "texture2d" || reglType === "textureCube") {
                result = createStaticDecl(function(env2) {
                  return env2.link(value);
                });
              } else if (reglType === "framebuffer" || reglType === "framebufferCube") {
                check$1.command(
                  value.color.length > 0,
                  'missing color attachment for framebuffer sent to uniform "' + name + '"',
                  env.commandStr
                );
                result = createStaticDecl(function(env2) {
                  return env2.link(value.color[0]);
                });
              } else {
                check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
              }
            } else if (isArrayLike3(value)) {
              result = createStaticDecl(function(env2) {
                var ITEM = env2.global.def(
                  "[",
                  loop(value.length, function(i2) {
                    check$1.command(
                      typeof value[i2] === "number" || typeof value[i2] === "boolean",
                      "invalid uniform " + name,
                      env2.commandStr
                    );
                    return value[i2];
                  }),
                  "]"
                );
                return ITEM;
              });
            } else {
              check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
            }
            result.value = value;
            UNIFORMS[name] = result;
          });
          Object.keys(dynamicUniforms).forEach(function(key) {
            var dyn = dynamicUniforms[key];
            UNIFORMS[key] = createDynamicDecl(dyn, function(env2, scope) {
              return env2.invoke(scope, dyn);
            });
          });
          return UNIFORMS;
        }
        function parseAttributes(attributes, env) {
          var staticAttributes = attributes.static;
          var dynamicAttributes = attributes.dynamic;
          var attributeDefs = {};
          Object.keys(staticAttributes).forEach(function(attribute) {
            var value = staticAttributes[attribute];
            var id = stringStore.id(attribute);
            var record = new AttributeRecord2();
            if (isBufferArgs(value)) {
              record.state = ATTRIB_STATE_POINTER;
              record.buffer = bufferState.getBuffer(
                bufferState.create(value, GL_ARRAY_BUFFER$2, false, true)
              );
              record.type = 0;
            } else {
              var buffer = bufferState.getBuffer(value);
              if (buffer) {
                record.state = ATTRIB_STATE_POINTER;
                record.buffer = buffer;
                record.type = 0;
              } else {
                check$1.command(
                  typeof value === "object" && value,
                  "invalid data for attribute " + attribute,
                  env.commandStr
                );
                if ("constant" in value) {
                  var constant = value.constant;
                  record.buffer = "null";
                  record.state = ATTRIB_STATE_CONSTANT;
                  if (typeof constant === "number") {
                    record.x = constant;
                  } else {
                    check$1.command(
                      isArrayLike3(constant) && constant.length > 0 && constant.length <= 4,
                      "invalid constant for attribute " + attribute,
                      env.commandStr
                    );
                    CUTE_COMPONENTS.forEach(function(c3, i2) {
                      if (i2 < constant.length) {
                        record[c3] = constant[i2];
                      }
                    });
                  }
                } else {
                  if (isBufferArgs(value.buffer)) {
                    buffer = bufferState.getBuffer(
                      bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true)
                    );
                  } else {
                    buffer = bufferState.getBuffer(value.buffer);
                  }
                  check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);
                  var offset = value.offset | 0;
                  check$1.command(
                    offset >= 0,
                    'invalid offset for attribute "' + attribute + '"',
                    env.commandStr
                  );
                  var stride = value.stride | 0;
                  check$1.command(
                    stride >= 0 && stride < 256,
                    'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]',
                    env.commandStr
                  );
                  var size3 = value.size | 0;
                  check$1.command(
                    !("size" in value) || size3 > 0 && size3 <= 4,
                    'invalid size for attribute "' + attribute + '", must be 1,2,3,4',
                    env.commandStr
                  );
                  var normalized = !!value.normalized;
                  var type = 0;
                  if ("type" in value) {
                    check$1.commandParameter(
                      value.type,
                      glTypes,
                      "invalid type for attribute " + attribute,
                      env.commandStr
                    );
                    type = glTypes[value.type];
                  }
                  var divisor = value.divisor | 0;
                  if ("divisor" in value) {
                    check$1.command(
                      divisor === 0 || extInstancing,
                      'cannot specify divisor for attribute "' + attribute + '", instancing not supported',
                      env.commandStr
                    );
                    check$1.command(
                      divisor >= 0,
                      'invalid divisor for attribute "' + attribute + '"',
                      env.commandStr
                    );
                  }
                  check$1.optional(function() {
                    var command = env.commandStr;
                    var VALID_KEYS = [
                      "buffer",
                      "offset",
                      "divisor",
                      "normalized",
                      "type",
                      "size",
                      "stride"
                    ];
                    Object.keys(value).forEach(function(prop) {
                      check$1.command(
                        VALID_KEYS.indexOf(prop) >= 0,
                        'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ")",
                        command
                      );
                    });
                  });
                  record.buffer = buffer;
                  record.state = ATTRIB_STATE_POINTER;
                  record.size = size3;
                  record.normalized = normalized;
                  record.type = type || buffer.dtype;
                  record.offset = offset;
                  record.stride = stride;
                  record.divisor = divisor;
                }
              }
            }
            attributeDefs[attribute] = createStaticDecl(function(env2, scope) {
              var cache3 = env2.attribCache;
              if (id in cache3) {
                return cache3[id];
              }
              var result = {
                isStream: false
              };
              Object.keys(record).forEach(function(key) {
                result[key] = record[key];
              });
              if (record.buffer) {
                result.buffer = env2.link(record.buffer);
                result.type = result.type || result.buffer + ".dtype";
              }
              cache3[id] = result;
              return result;
            });
          });
          Object.keys(dynamicAttributes).forEach(function(attribute) {
            var dyn = dynamicAttributes[attribute];
            function appendAttributeCode(env2, block) {
              var VALUE = env2.invoke(block, dyn);
              var shared = env2.shared;
              var constants = env2.constants;
              var IS_BUFFER_ARGS = shared.isBufferArgs;
              var BUFFER_STATE = shared.buffer;
              check$1.optional(function() {
                env2.assert(
                  block,
                  VALUE + "&&(typeof " + VALUE + '==="object"||typeof ' + VALUE + '==="function")&&(' + IS_BUFFER_ARGS + "(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ".buffer)||" + IS_BUFFER_ARGS + "(" + VALUE + '.buffer)||("constant" in ' + VALUE + "&&(typeof " + VALUE + '.constant==="number"||' + shared.isArrayLike + "(" + VALUE + ".constant))))",
                  'invalid dynamic attribute "' + attribute + '"'
                );
              });
              var result = {
                isStream: block.def(false)
              };
              var defaultRecord = new AttributeRecord2();
              defaultRecord.state = ATTRIB_STATE_POINTER;
              Object.keys(defaultRecord).forEach(function(key) {
                result[key] = block.def("" + defaultRecord[key]);
              });
              var BUFFER = result.buffer;
              var TYPE = result.type;
              block(
                "if(",
                IS_BUFFER_ARGS,
                "(",
                VALUE,
                ")){",
                result.isStream,
                "=true;",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".createStream(",
                GL_ARRAY_BUFFER$2,
                ",",
                VALUE,
                ");",
                TYPE,
                "=",
                BUFFER,
                ".dtype;",
                "}else{",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".getBuffer(",
                VALUE,
                ");",
                "if(",
                BUFFER,
                "){",
                TYPE,
                "=",
                BUFFER,
                ".dtype;",
                '}else if("constant" in ',
                VALUE,
                "){",
                result.state,
                "=",
                ATTRIB_STATE_CONSTANT,
                ";",
                "if(typeof " + VALUE + '.constant === "number"){',
                result[CUTE_COMPONENTS[0]],
                "=",
                VALUE,
                ".constant;",
                CUTE_COMPONENTS.slice(1).map(function(n2) {
                  return result[n2];
                }).join("="),
                "=0;",
                "}else{",
                CUTE_COMPONENTS.map(function(name, i2) {
                  return result[name] + "=" + VALUE + ".constant.length>" + i2 + "?" + VALUE + ".constant[" + i2 + "]:0;";
                }).join(""),
                "}}else{",
                "if(",
                IS_BUFFER_ARGS,
                "(",
                VALUE,
                ".buffer)){",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".createStream(",
                GL_ARRAY_BUFFER$2,
                ",",
                VALUE,
                ".buffer);",
                "}else{",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".getBuffer(",
                VALUE,
                ".buffer);",
                "}",
                TYPE,
                '="type" in ',
                VALUE,
                "?",
                constants.glTypes,
                "[",
                VALUE,
                ".type]:",
                BUFFER,
                ".dtype;",
                result.normalized,
                "=!!",
                VALUE,
                ".normalized;"
              );
              function emitReadRecord(name) {
                block(result[name], "=", VALUE, ".", name, "|0;");
              }
              emitReadRecord("size");
              emitReadRecord("offset");
              emitReadRecord("stride");
              emitReadRecord("divisor");
              block("}}");
              block.exit(
                "if(",
                result.isStream,
                "){",
                BUFFER_STATE,
                ".destroyStream(",
                BUFFER,
                ");",
                "}"
              );
              return result;
            }
            attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
          });
          return attributeDefs;
        }
        function parseVAO(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_VAO in staticOptions) {
            var vao = staticOptions[S_VAO];
            if (vao !== null && attributeState.getVAO(vao) === null) {
              vao = attributeState.createVAO(vao);
            }
            return createStaticDecl(function(env2) {
              return env2.link(attributeState.getVAO(vao));
            });
          } else if (S_VAO in dynamicOptions) {
            var dyn = dynamicOptions[S_VAO];
            return createDynamicDecl(dyn, function(env2, scope) {
              var vaoRef = env2.invoke(scope, dyn);
              return scope.def(env2.shared.vao + ".getVAO(" + vaoRef + ")");
            });
          }
          return null;
        }
        function parseContext(context) {
          var staticContext = context.static;
          var dynamicContext = context.dynamic;
          var result = {};
          Object.keys(staticContext).forEach(function(name) {
            var value = staticContext[name];
            result[name] = createStaticDecl(function(env, scope) {
              if (typeof value === "number" || typeof value === "boolean") {
                return "" + value;
              } else {
                return env.link(value);
              }
            });
          });
          Object.keys(dynamicContext).forEach(function(name) {
            var dyn = dynamicContext[name];
            result[name] = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          });
          return result;
        }
        function parseArguments(options, attributes, uniforms, context, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          check$1.optional(function() {
            var KEY_NAMES = [
              S_FRAMEBUFFER,
              S_VERT,
              S_FRAG,
              S_ELEMENTS,
              S_PRIMITIVE,
              S_OFFSET,
              S_COUNT,
              S_INSTANCES,
              S_PROFILE,
              S_VAO
            ].concat(GL_STATE_NAMES);
            function checkKeys(dict) {
              Object.keys(dict).forEach(function(key) {
                check$1.command(
                  KEY_NAMES.indexOf(key) >= 0,
                  'unknown parameter "' + key + '"',
                  env.commandStr
                );
              });
            }
            checkKeys(staticOptions);
            checkKeys(dynamicOptions);
          });
          var attribLocations = parseAttribLocations(options, attributes);
          var framebuffer = parseFramebuffer(options, env);
          var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
          var draw4 = parseDraw(options, env);
          var state = parseGLState(options, env);
          var shader = parseProgram(options, env, attribLocations);
          function copyBox(name) {
            var defn = viewportAndScissor[name];
            if (defn) {
              state[name] = defn;
            }
          }
          copyBox(S_VIEWPORT);
          copyBox(propName(S_SCISSOR_BOX));
          var dirty = Object.keys(state).length > 0;
          var result = {
            framebuffer,
            draw: draw4,
            shader,
            state,
            dirty,
            scopeVAO: null,
            drawVAO: null,
            useVAO: false,
            attributes: {}
          };
          result.profile = parseProfile(options, env);
          result.uniforms = parseUniforms(uniforms, env);
          result.drawVAO = result.scopeVAO = parseVAO(options, env);
          if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
            var useVAO = true;
            var staticBindings = shader.program.attributes.map(function(attr) {
              var binding = attributes.static[attr];
              useVAO = useVAO && !!binding;
              return binding;
            });
            if (useVAO && staticBindings.length > 0) {
              var vao = attributeState.getVAO(attributeState.createVAO(staticBindings));
              result.drawVAO = new Declaration(null, null, null, function(env2, scope) {
                return env2.link(vao);
              });
              result.useVAO = true;
            }
          }
          if (attribLocations) {
            result.useVAO = true;
          } else {
            result.attributes = parseAttributes(attributes, env);
          }
          result.context = parseContext(context, env);
          return result;
        }
        function emitContext(env, scope, context) {
          var shared = env.shared;
          var CONTEXT = shared.context;
          var contextEnter = env.scope();
          Object.keys(context).forEach(function(name) {
            scope.save(CONTEXT, "." + name);
            var defn = context[name];
            var value = defn.append(env, scope);
            if (Array.isArray(value)) {
              contextEnter(CONTEXT, ".", name, "=[", value.join(), "];");
            } else {
              contextEnter(CONTEXT, ".", name, "=", value, ";");
            }
          });
          scope(contextEnter);
        }
        function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {
          var shared = env.shared;
          var GL = shared.gl;
          var FRAMEBUFFER_STATE = shared.framebuffer;
          var EXT_DRAW_BUFFERS;
          if (extDrawBuffers) {
            EXT_DRAW_BUFFERS = scope.def(shared.extensions, ".webgl_draw_buffers");
          }
          var constants = env.constants;
          var DRAW_BUFFERS = constants.drawBuffer;
          var BACK_BUFFER = constants.backBuffer;
          var NEXT;
          if (framebuffer) {
            NEXT = framebuffer.append(env, scope);
          } else {
            NEXT = scope.def(FRAMEBUFFER_STATE, ".next");
          }
          if (!skipCheck) {
            scope("if(", NEXT, "!==", FRAMEBUFFER_STATE, ".cur){");
          }
          scope(
            "if(",
            NEXT,
            "){",
            GL,
            ".bindFramebuffer(",
            GL_FRAMEBUFFER$2,
            ",",
            NEXT,
            ".framebuffer);"
          );
          if (extDrawBuffers) {
            scope(
              EXT_DRAW_BUFFERS,
              ".drawBuffersWEBGL(",
              DRAW_BUFFERS,
              "[",
              NEXT,
              ".colorAttachments.length]);"
            );
          }
          scope(
            "}else{",
            GL,
            ".bindFramebuffer(",
            GL_FRAMEBUFFER$2,
            ",null);"
          );
          if (extDrawBuffers) {
            scope(EXT_DRAW_BUFFERS, ".drawBuffersWEBGL(", BACK_BUFFER, ");");
          }
          scope(
            "}",
            FRAMEBUFFER_STATE,
            ".cur=",
            NEXT,
            ";"
          );
          if (!skipCheck) {
            scope("}");
          }
        }
        function emitPollState(env, scope, args) {
          var shared = env.shared;
          var GL = shared.gl;
          var CURRENT_VARS = env.current;
          var NEXT_VARS = env.next;
          var CURRENT_STATE = shared.current;
          var NEXT_STATE = shared.next;
          var block = env.cond(CURRENT_STATE, ".dirty");
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            if (param in args.state) {
              return;
            }
            var NEXT, CURRENT;
            if (param in NEXT_VARS) {
              NEXT = NEXT_VARS[param];
              CURRENT = CURRENT_VARS[param];
              var parts = loop(currentState[param].length, function(i2) {
                return block.def(NEXT, "[", i2, "]");
              });
              block(env.cond(parts.map(function(p2, i2) {
                return p2 + "!==" + CURRENT + "[" + i2 + "]";
              }).join("||")).then(
                GL,
                ".",
                GL_VARIABLES[param],
                "(",
                parts,
                ");",
                parts.map(function(p2, i2) {
                  return CURRENT + "[" + i2 + "]=" + p2;
                }).join(";"),
                ";"
              ));
            } else {
              NEXT = block.def(NEXT_STATE, ".", param);
              var ifte = env.cond(NEXT, "!==", CURRENT_STATE, ".", param);
              block(ifte);
              if (param in GL_FLAGS) {
                ifte(
                  env.cond(NEXT).then(GL, ".enable(", GL_FLAGS[param], ");").else(GL, ".disable(", GL_FLAGS[param], ");"),
                  CURRENT_STATE,
                  ".",
                  param,
                  "=",
                  NEXT,
                  ";"
                );
              } else {
                ifte(
                  GL,
                  ".",
                  GL_VARIABLES[param],
                  "(",
                  NEXT,
                  ");",
                  CURRENT_STATE,
                  ".",
                  param,
                  "=",
                  NEXT,
                  ";"
                );
              }
            }
          });
          if (Object.keys(args.state).length === 0) {
            block(CURRENT_STATE, ".dirty=false;");
          }
          scope(block);
        }
        function emitSetOptions(env, scope, options, filter3) {
          var shared = env.shared;
          var CURRENT_VARS = env.current;
          var CURRENT_STATE = shared.current;
          var GL = shared.gl;
          sortState(Object.keys(options)).forEach(function(param) {
            var defn = options[param];
            if (filter3 && !filter3(defn)) {
              return;
            }
            var variable = defn.append(env, scope);
            if (GL_FLAGS[param]) {
              var flag = GL_FLAGS[param];
              if (isStatic(defn)) {
                if (variable) {
                  scope(GL, ".enable(", flag, ");");
                } else {
                  scope(GL, ".disable(", flag, ");");
                }
              } else {
                scope(env.cond(variable).then(GL, ".enable(", flag, ");").else(GL, ".disable(", flag, ");"));
              }
              scope(CURRENT_STATE, ".", param, "=", variable, ";");
            } else if (isArrayLike3(variable)) {
              var CURRENT = CURRENT_VARS[param];
              scope(
                GL,
                ".",
                GL_VARIABLES[param],
                "(",
                variable,
                ");",
                variable.map(function(v2, i2) {
                  return CURRENT + "[" + i2 + "]=" + v2;
                }).join(";"),
                ";"
              );
            } else {
              scope(
                GL,
                ".",
                GL_VARIABLES[param],
                "(",
                variable,
                ");",
                CURRENT_STATE,
                ".",
                param,
                "=",
                variable,
                ";"
              );
            }
          });
        }
        function injectExtensions(env, scope) {
          if (extInstancing) {
            env.instancing = scope.def(
              env.shared.extensions,
              ".angle_instanced_arrays"
            );
          }
        }
        function emitProfile(env, scope, args, useScope, incrementCounter) {
          var shared = env.shared;
          var STATS = env.stats;
          var CURRENT_STATE = shared.current;
          var TIMER = shared.timer;
          var profileArg = args.profile;
          function perfCounter() {
            if (typeof performance === "undefined") {
              return "Date.now()";
            } else {
              return "performance.now()";
            }
          }
          var CPU_START, QUERY_COUNTER;
          function emitProfileStart(block) {
            CPU_START = scope.def();
            block(CPU_START, "=", perfCounter(), ";");
            if (typeof incrementCounter === "string") {
              block(STATS, ".count+=", incrementCounter, ";");
            } else {
              block(STATS, ".count++;");
            }
            if (timer2) {
              if (useScope) {
                QUERY_COUNTER = scope.def();
                block(QUERY_COUNTER, "=", TIMER, ".getNumPendingQueries();");
              } else {
                block(TIMER, ".beginQuery(", STATS, ");");
              }
            }
          }
          function emitProfileEnd(block) {
            block(STATS, ".cpuTime+=", perfCounter(), "-", CPU_START, ";");
            if (timer2) {
              if (useScope) {
                block(
                  TIMER,
                  ".pushScopeStats(",
                  QUERY_COUNTER,
                  ",",
                  TIMER,
                  ".getNumPendingQueries(),",
                  STATS,
                  ");"
                );
              } else {
                block(TIMER, ".endQuery();");
              }
            }
          }
          function scopeProfile(value) {
            var prev = scope.def(CURRENT_STATE, ".profile");
            scope(CURRENT_STATE, ".profile=", value, ";");
            scope.exit(CURRENT_STATE, ".profile=", prev, ";");
          }
          var USE_PROFILE;
          if (profileArg) {
            if (isStatic(profileArg)) {
              if (profileArg.enable) {
                emitProfileStart(scope);
                emitProfileEnd(scope.exit);
                scopeProfile("true");
              } else {
                scopeProfile("false");
              }
              return;
            }
            USE_PROFILE = profileArg.append(env, scope);
            scopeProfile(USE_PROFILE);
          } else {
            USE_PROFILE = scope.def(CURRENT_STATE, ".profile");
          }
          var start = env.block();
          emitProfileStart(start);
          scope("if(", USE_PROFILE, "){", start, "}");
          var end2 = env.block();
          emitProfileEnd(end2);
          scope.exit("if(", USE_PROFILE, "){", end2, "}");
        }
        function emitAttributes(env, scope, args, attributes, filter3) {
          var shared = env.shared;
          function typeLength(x4) {
            switch (x4) {
              case GL_FLOAT_VEC2:
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                return 2;
              case GL_FLOAT_VEC3:
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                return 3;
              case GL_FLOAT_VEC4:
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                return 4;
              default:
                return 1;
            }
          }
          function emitBindAttribute(ATTRIBUTE, size3, record) {
            var GL = shared.gl;
            var LOCATION = scope.def(ATTRIBUTE, ".location");
            var BINDING = scope.def(shared.attributes, "[", LOCATION, "]");
            var STATE = record.state;
            var BUFFER = record.buffer;
            var CONST_COMPONENTS = [
              record.x,
              record.y,
              record.z,
              record.w
            ];
            var COMMON_KEYS = [
              "buffer",
              "normalized",
              "offset",
              "stride"
            ];
            function emitBuffer() {
              scope(
                "if(!",
                BINDING,
                ".buffer){",
                GL,
                ".enableVertexAttribArray(",
                LOCATION,
                ");}"
              );
              var TYPE = record.type;
              var SIZE;
              if (!record.size) {
                SIZE = size3;
              } else {
                SIZE = scope.def(record.size, "||", size3);
              }
              scope(
                "if(",
                BINDING,
                ".type!==",
                TYPE,
                "||",
                BINDING,
                ".size!==",
                SIZE,
                "||",
                COMMON_KEYS.map(function(key) {
                  return BINDING + "." + key + "!==" + record[key];
                }).join("||"),
                "){",
                GL,
                ".bindBuffer(",
                GL_ARRAY_BUFFER$2,
                ",",
                BUFFER,
                ".buffer);",
                GL,
                ".vertexAttribPointer(",
                [
                  LOCATION,
                  SIZE,
                  TYPE,
                  record.normalized,
                  record.stride,
                  record.offset
                ],
                ");",
                BINDING,
                ".type=",
                TYPE,
                ";",
                BINDING,
                ".size=",
                SIZE,
                ";",
                COMMON_KEYS.map(function(key) {
                  return BINDING + "." + key + "=" + record[key] + ";";
                }).join(""),
                "}"
              );
              if (extInstancing) {
                var DIVISOR = record.divisor;
                scope(
                  "if(",
                  BINDING,
                  ".divisor!==",
                  DIVISOR,
                  "){",
                  env.instancing,
                  ".vertexAttribDivisorANGLE(",
                  [LOCATION, DIVISOR],
                  ");",
                  BINDING,
                  ".divisor=",
                  DIVISOR,
                  ";}"
                );
              }
            }
            function emitConstant() {
              scope(
                "if(",
                BINDING,
                ".buffer){",
                GL,
                ".disableVertexAttribArray(",
                LOCATION,
                ");",
                BINDING,
                ".buffer=null;",
                "}if(",
                CUTE_COMPONENTS.map(function(c3, i2) {
                  return BINDING + "." + c3 + "!==" + CONST_COMPONENTS[i2];
                }).join("||"),
                "){",
                GL,
                ".vertexAttrib4f(",
                LOCATION,
                ",",
                CONST_COMPONENTS,
                ");",
                CUTE_COMPONENTS.map(function(c3, i2) {
                  return BINDING + "." + c3 + "=" + CONST_COMPONENTS[i2] + ";";
                }).join(""),
                "}"
              );
            }
            if (STATE === ATTRIB_STATE_POINTER) {
              emitBuffer();
            } else if (STATE === ATTRIB_STATE_CONSTANT) {
              emitConstant();
            } else {
              scope("if(", STATE, "===", ATTRIB_STATE_POINTER, "){");
              emitBuffer();
              scope("}else{");
              emitConstant();
              scope("}");
            }
          }
          attributes.forEach(function(attribute) {
            var name = attribute.name;
            var arg = args.attributes[name];
            var record;
            if (arg) {
              if (!filter3(arg)) {
                return;
              }
              record = arg.append(env, scope);
            } else {
              if (!filter3(SCOPE_DECL)) {
                return;
              }
              var scopeAttrib = env.scopeAttrib(name);
              check$1.optional(function() {
                env.assert(
                  scope,
                  scopeAttrib + ".state",
                  "missing attribute " + name
                );
              });
              record = {};
              Object.keys(new AttributeRecord2()).forEach(function(key) {
                record[key] = scope.def(scopeAttrib, ".", key);
              });
            }
            emitBindAttribute(
              env.link(attribute),
              typeLength(attribute.info.type),
              record
            );
          });
        }
        function emitUniforms(env, scope, args, uniforms, filter3) {
          var shared = env.shared;
          var GL = shared.gl;
          var infix;
          for (var i2 = 0; i2 < uniforms.length; ++i2) {
            var uniform = uniforms[i2];
            var name = uniform.name;
            var type = uniform.info.type;
            var arg = args.uniforms[name];
            var UNIFORM = env.link(uniform);
            var LOCATION = UNIFORM + ".location";
            var VALUE;
            if (arg) {
              if (!filter3(arg)) {
                continue;
              }
              if (isStatic(arg)) {
                var value = arg.value;
                check$1.command(
                  value !== null && typeof value !== "undefined",
                  'missing uniform "' + name + '"',
                  env.commandStr
                );
                if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
                  check$1.command(
                    typeof value === "function" && (type === GL_SAMPLER_2D && (value._reglType === "texture2d" || value._reglType === "framebuffer") || type === GL_SAMPLER_CUBE && (value._reglType === "textureCube" || value._reglType === "framebufferCube")),
                    "invalid texture for uniform " + name,
                    env.commandStr
                  );
                  var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
                  scope(GL, ".uniform1i(", LOCATION, ",", TEX_VALUE + ".bind());");
                  scope.exit(TEX_VALUE, ".unbind();");
                } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {
                  check$1.optional(function() {
                    check$1.command(
                      isArrayLike3(value),
                      "invalid matrix for uniform " + name,
                      env.commandStr
                    );
                    check$1.command(
                      type === GL_FLOAT_MAT2 && value.length === 4 || type === GL_FLOAT_MAT3 && value.length === 9 || type === GL_FLOAT_MAT4 && value.length === 16,
                      "invalid length for matrix uniform " + name,
                      env.commandStr
                    );
                  });
                  var MAT_VALUE = env.global.def("new Float32Array([" + Array.prototype.slice.call(value) + "])");
                  var dim = 2;
                  if (type === GL_FLOAT_MAT3) {
                    dim = 3;
                  } else if (type === GL_FLOAT_MAT4) {
                    dim = 4;
                  }
                  scope(
                    GL,
                    ".uniformMatrix",
                    dim,
                    "fv(",
                    LOCATION,
                    ",false,",
                    MAT_VALUE,
                    ");"
                  );
                } else {
                  switch (type) {
                    case GL_FLOAT$8:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1f";
                      break;
                    case GL_FLOAT_VEC2:
                      check$1.command(
                        isArrayLike3(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2f";
                      break;
                    case GL_FLOAT_VEC3:
                      check$1.command(
                        isArrayLike3(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3f";
                      break;
                    case GL_FLOAT_VEC4:
                      check$1.command(
                        isArrayLike3(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4f";
                      break;
                    case GL_BOOL:
                      check$1.commandType(value, "boolean", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_INT$3:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_BOOL_VEC2:
                      check$1.command(
                        isArrayLike3(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2i";
                      break;
                    case GL_INT_VEC2:
                      check$1.command(
                        isArrayLike3(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2i";
                      break;
                    case GL_BOOL_VEC3:
                      check$1.command(
                        isArrayLike3(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3i";
                      break;
                    case GL_INT_VEC3:
                      check$1.command(
                        isArrayLike3(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3i";
                      break;
                    case GL_BOOL_VEC4:
                      check$1.command(
                        isArrayLike3(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4i";
                      break;
                    case GL_INT_VEC4:
                      check$1.command(
                        isArrayLike3(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4i";
                      break;
                  }
                  scope(
                    GL,
                    ".uniform",
                    infix,
                    "(",
                    LOCATION,
                    ",",
                    isArrayLike3(value) ? Array.prototype.slice.call(value) : value,
                    ");"
                  );
                }
                continue;
              } else {
                VALUE = arg.append(env, scope);
              }
            } else {
              if (!filter3(SCOPE_DECL)) {
                continue;
              }
              VALUE = scope.def(shared.uniforms, "[", stringStore.id(name), "]");
            }
            if (type === GL_SAMPLER_2D) {
              check$1(!Array.isArray(VALUE), "must specify a scalar prop for textures");
              scope(
                "if(",
                VALUE,
                "&&",
                VALUE,
                '._reglType==="framebuffer"){',
                VALUE,
                "=",
                VALUE,
                ".color[0];",
                "}"
              );
            } else if (type === GL_SAMPLER_CUBE) {
              check$1(!Array.isArray(VALUE), "must specify a scalar prop for cube maps");
              scope(
                "if(",
                VALUE,
                "&&",
                VALUE,
                '._reglType==="framebufferCube"){',
                VALUE,
                "=",
                VALUE,
                ".color[0];",
                "}"
              );
            }
            check$1.optional(function() {
              function emitCheck(pred, message) {
                env.assert(
                  scope,
                  pred,
                  'bad data or missing for uniform "' + name + '".  ' + message
                );
              }
              function checkType(type2) {
                check$1(!Array.isArray(VALUE), "must not specify an array type for uniform");
                emitCheck(
                  "typeof " + VALUE + '==="' + type2 + '"',
                  "invalid type, expected " + type2
                );
              }
              function checkVector(n2, type2) {
                if (Array.isArray(VALUE)) {
                  check$1(VALUE.length === n2, "must have length " + n2);
                } else {
                  emitCheck(
                    shared.isArrayLike + "(" + VALUE + ")&&" + VALUE + ".length===" + n2,
                    "invalid vector, should have length " + n2,
                    env.commandStr
                  );
                }
              }
              function checkTexture(target) {
                check$1(!Array.isArray(VALUE), "must not specify a value type");
                emitCheck(
                  "typeof " + VALUE + '==="function"&&' + VALUE + '._reglType==="texture' + (target === GL_TEXTURE_2D$3 ? "2d" : "Cube") + '"',
                  "invalid texture type",
                  env.commandStr
                );
              }
              switch (type) {
                case GL_INT$3:
                  checkType("number");
                  break;
                case GL_INT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_INT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_INT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT$8:
                  checkType("number");
                  break;
                case GL_FLOAT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_FLOAT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_FLOAT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_BOOL:
                  checkType("boolean");
                  break;
                case GL_BOOL_VEC2:
                  checkVector(2, "boolean");
                  break;
                case GL_BOOL_VEC3:
                  checkVector(3, "boolean");
                  break;
                case GL_BOOL_VEC4:
                  checkVector(4, "boolean");
                  break;
                case GL_FLOAT_MAT2:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT_MAT3:
                  checkVector(9, "number");
                  break;
                case GL_FLOAT_MAT4:
                  checkVector(16, "number");
                  break;
                case GL_SAMPLER_2D:
                  checkTexture(GL_TEXTURE_2D$3);
                  break;
                case GL_SAMPLER_CUBE:
                  checkTexture(GL_TEXTURE_CUBE_MAP$2);
                  break;
              }
            });
            var unroll = 1;
            switch (type) {
              case GL_SAMPLER_2D:
              case GL_SAMPLER_CUBE:
                var TEX = scope.def(VALUE, "._texture");
                scope(GL, ".uniform1i(", LOCATION, ",", TEX, ".bind());");
                scope.exit(TEX, ".unbind();");
                continue;
              case GL_INT$3:
              case GL_BOOL:
                infix = "1i";
                break;
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                infix = "2i";
                unroll = 2;
                break;
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                infix = "3i";
                unroll = 3;
                break;
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                infix = "4i";
                unroll = 4;
                break;
              case GL_FLOAT$8:
                infix = "1f";
                break;
              case GL_FLOAT_VEC2:
                infix = "2f";
                unroll = 2;
                break;
              case GL_FLOAT_VEC3:
                infix = "3f";
                unroll = 3;
                break;
              case GL_FLOAT_VEC4:
                infix = "4f";
                unroll = 4;
                break;
              case GL_FLOAT_MAT2:
                infix = "Matrix2fv";
                break;
              case GL_FLOAT_MAT3:
                infix = "Matrix3fv";
                break;
              case GL_FLOAT_MAT4:
                infix = "Matrix4fv";
                break;
            }
            scope(GL, ".uniform", infix, "(", LOCATION, ",");
            if (infix.charAt(0) === "M") {
              var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
              var STORAGE = env.global.def("new Float32Array(", matSize, ")");
              if (Array.isArray(VALUE)) {
                scope(
                  "false,(",
                  loop(matSize, function(i3) {
                    return STORAGE + "[" + i3 + "]=" + VALUE[i3];
                  }),
                  ",",
                  STORAGE,
                  ")"
                );
              } else {
                scope(
                  "false,(Array.isArray(",
                  VALUE,
                  ")||",
                  VALUE,
                  " instanceof Float32Array)?",
                  VALUE,
                  ":(",
                  loop(matSize, function(i3) {
                    return STORAGE + "[" + i3 + "]=" + VALUE + "[" + i3 + "]";
                  }),
                  ",",
                  STORAGE,
                  ")"
                );
              }
            } else if (unroll > 1) {
              scope(loop(unroll, function(i3) {
                return Array.isArray(VALUE) ? VALUE[i3] : VALUE + "[" + i3 + "]";
              }));
            } else {
              check$1(!Array.isArray(VALUE), "uniform value must not be an array");
              scope(VALUE);
            }
            scope(");");
          }
        }
        function emitDraw(env, outer, inner, args) {
          var shared = env.shared;
          var GL = shared.gl;
          var DRAW_STATE = shared.draw;
          var drawOptions = args.draw;
          function emitElements() {
            var defn = drawOptions.elements;
            var ELEMENTS2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              ELEMENTS2 = defn.append(env, scope);
            } else {
              ELEMENTS2 = scope.def(DRAW_STATE, ".", S_ELEMENTS);
            }
            if (ELEMENTS2) {
              scope(
                "if(" + ELEMENTS2 + ")" + GL + ".bindBuffer(" + GL_ELEMENT_ARRAY_BUFFER$1 + "," + ELEMENTS2 + ".buffer.buffer);"
              );
            }
            return ELEMENTS2;
          }
          function emitCount() {
            var defn = drawOptions.count;
            var COUNT2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              COUNT2 = defn.append(env, scope);
              check$1.optional(function() {
                if (defn.MISSING) {
                  env.assert(outer, "false", "missing vertex count");
                }
                if (defn.DYNAMIC) {
                  env.assert(scope, COUNT2 + ">=0", "missing vertex count");
                }
              });
            } else {
              COUNT2 = scope.def(DRAW_STATE, ".", S_COUNT);
              check$1.optional(function() {
                env.assert(scope, COUNT2 + ">=0", "missing vertex count");
              });
            }
            return COUNT2;
          }
          var ELEMENTS = emitElements();
          function emitValue(name) {
            var defn = drawOptions[name];
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                return defn.append(env, inner);
              } else {
                return defn.append(env, outer);
              }
            } else {
              return outer.def(DRAW_STATE, ".", name);
            }
          }
          var PRIMITIVE = emitValue(S_PRIMITIVE);
          var OFFSET = emitValue(S_OFFSET);
          var COUNT = emitCount();
          if (typeof COUNT === "number") {
            if (COUNT === 0) {
              return;
            }
          } else {
            inner("if(", COUNT, "){");
            inner.exit("}");
          }
          var INSTANCES, EXT_INSTANCING;
          if (extInstancing) {
            INSTANCES = emitValue(S_INSTANCES);
            EXT_INSTANCING = env.instancing;
          }
          var ELEMENT_TYPE = ELEMENTS + ".type";
          var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements);
          function emitInstancing() {
            function drawElements() {
              inner(EXT_INSTANCING, ".drawElementsInstancedANGLE(", [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)",
                INSTANCES
              ], ");");
            }
            function drawArrays() {
              inner(
                EXT_INSTANCING,
                ".drawArraysInstancedANGLE(",
                [PRIMITIVE, OFFSET, COUNT, INSTANCES],
                ");"
              );
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          function emitRegular() {
            function drawElements() {
              inner(GL + ".drawElements(" + [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)"
              ] + ");");
            }
            function drawArrays() {
              inner(GL + ".drawArrays(" + [PRIMITIVE, OFFSET, COUNT] + ");");
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          if (extInstancing && (typeof INSTANCES !== "number" || INSTANCES >= 0)) {
            if (typeof INSTANCES === "string") {
              inner("if(", INSTANCES, ">0){");
              emitInstancing();
              inner("}else if(", INSTANCES, "<0){");
              emitRegular();
              inner("}");
            } else {
              emitInstancing();
            }
          } else {
            emitRegular();
          }
        }
        function createBody(emitBody, parentEnv, args, program, count) {
          var env = createREGLEnvironment();
          var scope = env.proc("body", count);
          check$1.optional(function() {
            env.commandStr = parentEnv.commandStr;
            env.command = env.link(parentEnv.commandStr);
          });
          if (extInstancing) {
            env.instancing = scope.def(
              env.shared.extensions,
              ".angle_instanced_arrays"
            );
          }
          emitBody(env, scope, args, program);
          return env.compile().body;
        }
        function emitDrawBody(env, draw4, args, program) {
          injectExtensions(env, draw4);
          if (args.useVAO) {
            if (args.drawVAO) {
              draw4(env.shared.vao, ".setVAO(", args.drawVAO.append(env, draw4), ");");
            } else {
              draw4(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
            }
          } else {
            draw4(env.shared.vao, ".setVAO(null);");
            emitAttributes(env, draw4, args, program.attributes, function() {
              return true;
            });
          }
          emitUniforms(env, draw4, args, program.uniforms, function() {
            return true;
          });
          emitDraw(env, draw4, draw4, args);
        }
        function emitDrawProc(env, args) {
          var draw4 = env.proc("draw", 1);
          injectExtensions(env, draw4);
          emitContext(env, draw4, args.context);
          emitPollFramebuffer(env, draw4, args.framebuffer);
          emitPollState(env, draw4, args);
          emitSetOptions(env, draw4, args.state);
          emitProfile(env, draw4, args, false, true);
          var program = args.shader.progVar.append(env, draw4);
          draw4(env.shared.gl, ".useProgram(", program, ".program);");
          if (args.shader.program) {
            emitDrawBody(env, draw4, args, args.shader.program);
          } else {
            draw4(env.shared.vao, ".setVAO(null);");
            var drawCache = env.global.def("{}");
            var PROG_ID = draw4.def(program, ".id");
            var CACHED_PROC = draw4.def(drawCache, "[", PROG_ID, "]");
            draw4(
              env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0);").else(
                CACHED_PROC,
                "=",
                drawCache,
                "[",
                PROG_ID,
                "]=",
                env.link(function(program2) {
                  return createBody(emitDrawBody, env, args, program2, 1);
                }),
                "(",
                program,
                ");",
                CACHED_PROC,
                ".call(this,a0);"
              )
            );
          }
          if (Object.keys(args.state).length > 0) {
            draw4(env.shared.current, ".dirty=true;");
          }
        }
        function emitBatchDynamicShaderBody(env, scope, args, program) {
          env.batchId = "a1";
          injectExtensions(env, scope);
          function all() {
            return true;
          }
          emitAttributes(env, scope, args, program.attributes, all);
          emitUniforms(env, scope, args, program.uniforms, all);
          emitDraw(env, scope, scope, args);
        }
        function emitBatchBody(env, scope, args, program) {
          injectExtensions(env, scope);
          var contextDynamic = args.contextDep;
          var BATCH_ID = scope.def();
          var PROP_LIST = "a0";
          var NUM_PROPS = "a1";
          var PROPS = scope.def();
          env.shared.props = PROPS;
          env.batchId = BATCH_ID;
          var outer = env.scope();
          var inner = env.scope();
          scope(
            outer.entry,
            "for(",
            BATCH_ID,
            "=0;",
            BATCH_ID,
            "<",
            NUM_PROPS,
            ";++",
            BATCH_ID,
            "){",
            PROPS,
            "=",
            PROP_LIST,
            "[",
            BATCH_ID,
            "];",
            inner,
            "}",
            outer.exit
          );
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          function isOuterDefn(defn) {
            return !isInnerDefn(defn);
          }
          if (args.needsContext) {
            emitContext(env, inner, args.context);
          }
          if (args.needsFramebuffer) {
            emitPollFramebuffer(env, inner, args.framebuffer);
          }
          emitSetOptions(env, inner, args.state, isInnerDefn);
          if (args.profile && isInnerDefn(args.profile)) {
            emitProfile(env, inner, args, false, true);
          }
          if (!program) {
            var progCache = env.global.def("{}");
            var PROGRAM = args.shader.progVar.append(env, inner);
            var PROG_ID = inner.def(PROGRAM, ".id");
            var CACHED_PROC = inner.def(progCache, "[", PROG_ID, "]");
            inner(
              env.shared.gl,
              ".useProgram(",
              PROGRAM,
              ".program);",
              "if(!",
              CACHED_PROC,
              "){",
              CACHED_PROC,
              "=",
              progCache,
              "[",
              PROG_ID,
              "]=",
              env.link(function(program2) {
                return createBody(
                  emitBatchDynamicShaderBody,
                  env,
                  args,
                  program2,
                  2
                );
              }),
              "(",
              PROGRAM,
              ");}",
              CACHED_PROC,
              ".call(this,a0[",
              BATCH_ID,
              "],",
              BATCH_ID,
              ");"
            );
          } else {
            if (args.useVAO) {
              if (args.drawVAO) {
                if (isInnerDefn(args.drawVAO)) {
                  inner(env.shared.vao, ".setVAO(", args.drawVAO.append(env, inner), ");");
                } else {
                  outer(env.shared.vao, ".setVAO(", args.drawVAO.append(env, outer), ");");
                }
              } else {
                outer(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
              }
            } else {
              outer(env.shared.vao, ".setVAO(null);");
              emitAttributes(env, outer, args, program.attributes, isOuterDefn);
              emitAttributes(env, inner, args, program.attributes, isInnerDefn);
            }
            emitUniforms(env, outer, args, program.uniforms, isOuterDefn);
            emitUniforms(env, inner, args, program.uniforms, isInnerDefn);
            emitDraw(env, outer, inner, args);
          }
        }
        function emitBatchProc(env, args) {
          var batch = env.proc("batch", 2);
          env.batchId = "0";
          injectExtensions(env, batch);
          var contextDynamic = false;
          var needsContext = true;
          Object.keys(args.context).forEach(function(name) {
            contextDynamic = contextDynamic || args.context[name].propDep;
          });
          if (!contextDynamic) {
            emitContext(env, batch, args.context);
            needsContext = false;
          }
          var framebuffer = args.framebuffer;
          var needsFramebuffer = false;
          if (framebuffer) {
            if (framebuffer.propDep) {
              contextDynamic = needsFramebuffer = true;
            } else if (framebuffer.contextDep && contextDynamic) {
              needsFramebuffer = true;
            }
            if (!needsFramebuffer) {
              emitPollFramebuffer(env, batch, framebuffer);
            }
          } else {
            emitPollFramebuffer(env, batch, null);
          }
          if (args.state.viewport && args.state.viewport.propDep) {
            contextDynamic = true;
          }
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          emitPollState(env, batch, args);
          emitSetOptions(env, batch, args.state, function(defn) {
            return !isInnerDefn(defn);
          });
          if (!args.profile || !isInnerDefn(args.profile)) {
            emitProfile(env, batch, args, false, "a1");
          }
          args.contextDep = contextDynamic;
          args.needsContext = needsContext;
          args.needsFramebuffer = needsFramebuffer;
          var progDefn = args.shader.progVar;
          if (progDefn.contextDep && contextDynamic || progDefn.propDep) {
            emitBatchBody(
              env,
              batch,
              args,
              null
            );
          } else {
            var PROGRAM = progDefn.append(env, batch);
            batch(env.shared.gl, ".useProgram(", PROGRAM, ".program);");
            if (args.shader.program) {
              emitBatchBody(
                env,
                batch,
                args,
                args.shader.program
              );
            } else {
              batch(env.shared.vao, ".setVAO(null);");
              var batchCache = env.global.def("{}");
              var PROG_ID = batch.def(PROGRAM, ".id");
              var CACHED_PROC = batch.def(batchCache, "[", PROG_ID, "]");
              batch(
                env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0,a1);").else(
                  CACHED_PROC,
                  "=",
                  batchCache,
                  "[",
                  PROG_ID,
                  "]=",
                  env.link(function(program) {
                    return createBody(emitBatchBody, env, args, program, 2);
                  }),
                  "(",
                  PROGRAM,
                  ");",
                  CACHED_PROC,
                  ".call(this,a0,a1);"
                )
              );
            }
          }
          if (Object.keys(args.state).length > 0) {
            batch(env.shared.current, ".dirty=true;");
          }
        }
        function emitScopeProc(env, args) {
          var scope = env.proc("scope", 3);
          env.batchId = "a2";
          var shared = env.shared;
          var CURRENT_STATE = shared.current;
          emitContext(env, scope, args.context);
          if (args.framebuffer) {
            args.framebuffer.append(env, scope);
          }
          sortState(Object.keys(args.state)).forEach(function(name) {
            var defn = args.state[name];
            var value = defn.append(env, scope);
            if (isArrayLike3(value)) {
              value.forEach(function(v2, i2) {
                scope.set(env.next[name], "[" + i2 + "]", v2);
              });
            } else {
              scope.set(shared.next, "." + name, value);
            }
          });
          emitProfile(env, scope, args, true, true);
          [S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
            function(opt) {
              var variable = args.draw[opt];
              if (!variable) {
                return;
              }
              scope.set(shared.draw, "." + opt, "" + variable.append(env, scope));
            }
          );
          Object.keys(args.uniforms).forEach(function(opt) {
            var value = args.uniforms[opt].append(env, scope);
            if (Array.isArray(value)) {
              value = "[" + value.join() + "]";
            }
            scope.set(
              shared.uniforms,
              "[" + stringStore.id(opt) + "]",
              value
            );
          });
          Object.keys(args.attributes).forEach(function(name) {
            var record = args.attributes[name].append(env, scope);
            var scopeAttrib = env.scopeAttrib(name);
            Object.keys(new AttributeRecord2()).forEach(function(prop) {
              scope.set(scopeAttrib, "." + prop, record[prop]);
            });
          });
          if (args.scopeVAO) {
            scope.set(shared.vao, ".targetVAO", args.scopeVAO.append(env, scope));
          }
          function saveShader(name) {
            var shader = args.shader[name];
            if (shader) {
              scope.set(shared.shader, "." + name, shader.append(env, scope));
            }
          }
          saveShader(S_VERT);
          saveShader(S_FRAG);
          if (Object.keys(args.state).length > 0) {
            scope(CURRENT_STATE, ".dirty=true;");
            scope.exit(CURRENT_STATE, ".dirty=true;");
          }
          scope("a1(", env.shared.context, ",a0,", env.batchId, ");");
        }
        function isDynamicObject(object) {
          if (typeof object !== "object" || isArrayLike3(object)) {
            return;
          }
          var props = Object.keys(object);
          for (var i2 = 0; i2 < props.length; ++i2) {
            if (dynamic.isDynamic(object[props[i2]])) {
              return true;
            }
          }
          return false;
        }
        function splatObject(env, options, name) {
          var object = options.static[name];
          if (!object || !isDynamicObject(object)) {
            return;
          }
          var globals = env.global;
          var keys3 = Object.keys(object);
          var thisDep = false;
          var contextDep = false;
          var propDep = false;
          var objectRef = env.global.def("{}");
          keys3.forEach(function(key) {
            var value = object[key];
            if (dynamic.isDynamic(value)) {
              if (typeof value === "function") {
                value = object[key] = dynamic.unbox(value);
              }
              var deps = createDynamicDecl(value, null);
              thisDep = thisDep || deps.thisDep;
              propDep = propDep || deps.propDep;
              contextDep = contextDep || deps.contextDep;
            } else {
              globals(objectRef, ".", key, "=");
              switch (typeof value) {
                case "number":
                  globals(value);
                  break;
                case "string":
                  globals('"', value, '"');
                  break;
                case "object":
                  if (Array.isArray(value)) {
                    globals("[", value.join(), "]");
                  }
                  break;
                default:
                  globals(env.link(value));
                  break;
              }
              globals(";");
            }
          });
          function appendBlock(env2, block) {
            keys3.forEach(function(key) {
              var value = object[key];
              if (!dynamic.isDynamic(value)) {
                return;
              }
              var ref = env2.invoke(block, value);
              block(objectRef, ".", key, "=", ref, ";");
            });
          }
          options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
            thisDep,
            contextDep,
            propDep,
            ref: objectRef,
            append: appendBlock
          });
          delete options.static[name];
        }
        function compileCommand(options, attributes, uniforms, context, stats2) {
          var env = createREGLEnvironment();
          env.stats = env.link(stats2);
          Object.keys(attributes.static).forEach(function(key) {
            splatObject(env, attributes, key);
          });
          NESTED_OPTIONS.forEach(function(name) {
            splatObject(env, options, name);
          });
          var args = parseArguments(options, attributes, uniforms, context, env);
          emitDrawProc(env, args);
          emitScopeProc(env, args);
          emitBatchProc(env, args);
          return extend4(env.compile(), {
            destroy: function() {
              args.shader.program.destroy();
            }
          });
        }
        return {
          next: nextState,
          current: currentState,
          procs: function() {
            var env = createREGLEnvironment();
            var poll = env.proc("poll");
            var refresh = env.proc("refresh");
            var common = env.block();
            poll(common);
            refresh(common);
            var shared = env.shared;
            var GL = shared.gl;
            var NEXT_STATE = shared.next;
            var CURRENT_STATE = shared.current;
            common(CURRENT_STATE, ".dirty=false;");
            emitPollFramebuffer(env, poll);
            emitPollFramebuffer(env, refresh, null, true);
            var INSTANCING;
            if (extInstancing) {
              INSTANCING = env.link(extInstancing);
            }
            if (extensions.oes_vertex_array_object) {
              refresh(env.link(extensions.oes_vertex_array_object), ".bindVertexArrayOES(null);");
            }
            for (var i2 = 0; i2 < limits.maxAttributes; ++i2) {
              var BINDING = refresh.def(shared.attributes, "[", i2, "]");
              var ifte = env.cond(BINDING, ".buffer");
              ifte.then(
                GL,
                ".enableVertexAttribArray(",
                i2,
                ");",
                GL,
                ".bindBuffer(",
                GL_ARRAY_BUFFER$2,
                ",",
                BINDING,
                ".buffer.buffer);",
                GL,
                ".vertexAttribPointer(",
                i2,
                ",",
                BINDING,
                ".size,",
                BINDING,
                ".type,",
                BINDING,
                ".normalized,",
                BINDING,
                ".stride,",
                BINDING,
                ".offset);"
              ).else(
                GL,
                ".disableVertexAttribArray(",
                i2,
                ");",
                GL,
                ".vertexAttrib4f(",
                i2,
                ",",
                BINDING,
                ".x,",
                BINDING,
                ".y,",
                BINDING,
                ".z,",
                BINDING,
                ".w);",
                BINDING,
                ".buffer=null;"
              );
              refresh(ifte);
              if (extInstancing) {
                refresh(
                  INSTANCING,
                  ".vertexAttribDivisorANGLE(",
                  i2,
                  ",",
                  BINDING,
                  ".divisor);"
                );
              }
            }
            refresh(
              env.shared.vao,
              ".currentVAO=null;",
              env.shared.vao,
              ".setVAO(",
              env.shared.vao,
              ".targetVAO);"
            );
            Object.keys(GL_FLAGS).forEach(function(flag) {
              var cap = GL_FLAGS[flag];
              var NEXT = common.def(NEXT_STATE, ".", flag);
              var block = env.block();
              block(
                "if(",
                NEXT,
                "){",
                GL,
                ".enable(",
                cap,
                ")}else{",
                GL,
                ".disable(",
                cap,
                ")}",
                CURRENT_STATE,
                ".",
                flag,
                "=",
                NEXT,
                ";"
              );
              refresh(block);
              poll(
                "if(",
                NEXT,
                "!==",
                CURRENT_STATE,
                ".",
                flag,
                "){",
                block,
                "}"
              );
            });
            Object.keys(GL_VARIABLES).forEach(function(name) {
              var func = GL_VARIABLES[name];
              var init = currentState[name];
              var NEXT, CURRENT;
              var block = env.block();
              block(GL, ".", func, "(");
              if (isArrayLike3(init)) {
                var n2 = init.length;
                NEXT = env.global.def(NEXT_STATE, ".", name);
                CURRENT = env.global.def(CURRENT_STATE, ".", name);
                block(
                  loop(n2, function(i3) {
                    return NEXT + "[" + i3 + "]";
                  }),
                  ");",
                  loop(n2, function(i3) {
                    return CURRENT + "[" + i3 + "]=" + NEXT + "[" + i3 + "];";
                  }).join("")
                );
                poll(
                  "if(",
                  loop(n2, function(i3) {
                    return NEXT + "[" + i3 + "]!==" + CURRENT + "[" + i3 + "]";
                  }).join("||"),
                  "){",
                  block,
                  "}"
                );
              } else {
                NEXT = common.def(NEXT_STATE, ".", name);
                CURRENT = common.def(CURRENT_STATE, ".", name);
                block(
                  NEXT,
                  ");",
                  CURRENT_STATE,
                  ".",
                  name,
                  "=",
                  NEXT,
                  ";"
                );
                poll(
                  "if(",
                  NEXT,
                  "!==",
                  CURRENT,
                  "){",
                  block,
                  "}"
                );
              }
              refresh(block);
            });
            return env.compile();
          }(),
          compile: compileCommand
        };
      }
      function stats() {
        return {
          vaoCount: 0,
          bufferCount: 0,
          elementsCount: 0,
          framebufferCount: 0,
          shaderCount: 0,
          textureCount: 0,
          cubeCount: 0,
          renderbufferCount: 0,
          maxTextureUnits: 0
        };
      }
      var GL_QUERY_RESULT_EXT = 34918;
      var GL_QUERY_RESULT_AVAILABLE_EXT = 34919;
      var GL_TIME_ELAPSED_EXT = 35007;
      var createTimer = function(gl2, extensions) {
        if (!extensions.ext_disjoint_timer_query) {
          return null;
        }
        var queryPool = [];
        function allocQuery() {
          return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT();
        }
        function freeQuery(query) {
          queryPool.push(query);
        }
        var pendingQueries = [];
        function beginQuery(stats2) {
          var query = allocQuery();
          extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
          pendingQueries.push(query);
          pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats2);
        }
        function endQuery() {
          extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);
        }
        function PendingStats() {
          this.startQueryIndex = -1;
          this.endQueryIndex = -1;
          this.sum = 0;
          this.stats = null;
        }
        var pendingStatsPool = [];
        function allocPendingStats() {
          return pendingStatsPool.pop() || new PendingStats();
        }
        function freePendingStats(pendingStats2) {
          pendingStatsPool.push(pendingStats2);
        }
        var pendingStats = [];
        function pushScopeStats(start, end2, stats2) {
          var ps = allocPendingStats();
          ps.startQueryIndex = start;
          ps.endQueryIndex = end2;
          ps.sum = 0;
          ps.stats = stats2;
          pendingStats.push(ps);
        }
        var timeSum = [];
        var queryPtr = [];
        function update15() {
          var ptr, i2;
          var n2 = pendingQueries.length;
          if (n2 === 0) {
            return;
          }
          queryPtr.length = Math.max(queryPtr.length, n2 + 1);
          timeSum.length = Math.max(timeSum.length, n2 + 1);
          timeSum[0] = 0;
          queryPtr[0] = 0;
          var queryTime = 0;
          ptr = 0;
          for (i2 = 0; i2 < pendingQueries.length; ++i2) {
            var query = pendingQueries[i2];
            if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
              queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
              freeQuery(query);
            } else {
              pendingQueries[ptr++] = query;
            }
            timeSum[i2 + 1] = queryTime;
            queryPtr[i2 + 1] = ptr;
          }
          pendingQueries.length = ptr;
          ptr = 0;
          for (i2 = 0; i2 < pendingStats.length; ++i2) {
            var stats2 = pendingStats[i2];
            var start = stats2.startQueryIndex;
            var end2 = stats2.endQueryIndex;
            stats2.sum += timeSum[end2] - timeSum[start];
            var startPtr = queryPtr[start];
            var endPtr = queryPtr[end2];
            if (endPtr === startPtr) {
              stats2.stats.gpuTime += stats2.sum / 1e6;
              freePendingStats(stats2);
            } else {
              stats2.startQueryIndex = startPtr;
              stats2.endQueryIndex = endPtr;
              pendingStats[ptr++] = stats2;
            }
          }
          pendingStats.length = ptr;
        }
        return {
          beginQuery,
          endQuery,
          pushScopeStats,
          update: update15,
          getNumPendingQueries: function() {
            return pendingQueries.length;
          },
          clear: function() {
            queryPool.push.apply(queryPool, pendingQueries);
            for (var i2 = 0; i2 < queryPool.length; i2++) {
              extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i2]);
            }
            pendingQueries.length = 0;
            queryPool.length = 0;
          },
          restore: function() {
            pendingQueries.length = 0;
            queryPool.length = 0;
          }
        };
      };
      var GL_COLOR_BUFFER_BIT = 16384;
      var GL_DEPTH_BUFFER_BIT = 256;
      var GL_STENCIL_BUFFER_BIT = 1024;
      var GL_ARRAY_BUFFER = 34962;
      var CONTEXT_LOST_EVENT = "webglcontextlost";
      var CONTEXT_RESTORED_EVENT = "webglcontextrestored";
      var DYN_PROP = 1;
      var DYN_CONTEXT = 2;
      var DYN_STATE = 3;
      function find4(haystack, needle) {
        for (var i2 = 0; i2 < haystack.length; ++i2) {
          if (haystack[i2] === needle) {
            return i2;
          }
        }
        return -1;
      }
      function wrapREGL(args) {
        var config = parseArgs(args);
        if (!config) {
          return null;
        }
        var gl2 = config.gl;
        var glAttributes = gl2.getContextAttributes();
        var contextLost = gl2.isContextLost();
        var extensionState = createExtensionCache(gl2, config);
        if (!extensionState) {
          return null;
        }
        var stringStore = createStringStore();
        var stats$$1 = stats();
        var extensions = extensionState.extensions;
        var timer2 = createTimer(gl2, extensions);
        var START_TIME = clock2();
        var WIDTH = gl2.drawingBufferWidth;
        var HEIGHT = gl2.drawingBufferHeight;
        var contextState = {
          tick: 0,
          time: 0,
          viewportWidth: WIDTH,
          viewportHeight: HEIGHT,
          framebufferWidth: WIDTH,
          framebufferHeight: HEIGHT,
          drawingBufferWidth: WIDTH,
          drawingBufferHeight: HEIGHT,
          pixelRatio: config.pixelRatio
        };
        var uniformState = {};
        var drawState = {
          elements: null,
          primitive: 4,
          // GL_TRIANGLES
          count: -1,
          offset: 0,
          instances: -1
        };
        var limits = wrapLimits(gl2, extensions);
        var bufferState = wrapBufferState(
          gl2,
          stats$$1,
          config,
          destroyBuffer
        );
        var attributeState = wrapAttributeState(
          gl2,
          extensions,
          limits,
          stats$$1,
          bufferState
        );
        function destroyBuffer(buffer) {
          return attributeState.destroyBuffer(buffer);
        }
        var elementState = wrapElementsState(gl2, extensions, bufferState, stats$$1);
        var shaderState = wrapShaderState(gl2, stringStore, stats$$1, config);
        var textureState = createTextureSet(
          gl2,
          extensions,
          limits,
          function() {
            core.procs.poll();
          },
          contextState,
          stats$$1,
          config
        );
        var renderbufferState = wrapRenderbuffers(gl2, extensions, limits, stats$$1, config);
        var framebufferState = wrapFBOState(
          gl2,
          extensions,
          limits,
          textureState,
          renderbufferState,
          stats$$1
        );
        var core = reglCore(
          gl2,
          stringStore,
          extensions,
          limits,
          bufferState,
          elementState,
          textureState,
          framebufferState,
          uniformState,
          attributeState,
          shaderState,
          drawState,
          contextState,
          timer2,
          config
        );
        var readPixels = wrapReadPixels(
          gl2,
          framebufferState,
          core.procs.poll,
          contextState,
          glAttributes,
          extensions,
          limits
        );
        var nextState = core.next;
        var canvas = gl2.canvas;
        var rafCallbacks = [];
        var lossCallbacks = [];
        var restoreCallbacks = [];
        var destroyCallbacks = [config.onDestroy];
        var activeRAF = null;
        function handleRAF() {
          if (rafCallbacks.length === 0) {
            if (timer2) {
              timer2.update();
            }
            activeRAF = null;
            return;
          }
          activeRAF = raf.next(handleRAF);
          poll();
          for (var i2 = rafCallbacks.length - 1; i2 >= 0; --i2) {
            var cb = rafCallbacks[i2];
            if (cb) {
              cb(contextState, null, 0);
            }
          }
          gl2.flush();
          if (timer2) {
            timer2.update();
          }
        }
        function startRAF() {
          if (!activeRAF && rafCallbacks.length > 0) {
            activeRAF = raf.next(handleRAF);
          }
        }
        function stopRAF() {
          if (activeRAF) {
            raf.cancel(handleRAF);
            activeRAF = null;
          }
        }
        function handleContextLoss(event) {
          event.preventDefault();
          contextLost = true;
          stopRAF();
          lossCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function handleContextRestored(event) {
          gl2.getError();
          contextLost = false;
          extensionState.restore();
          shaderState.restore();
          bufferState.restore();
          textureState.restore();
          renderbufferState.restore();
          framebufferState.restore();
          attributeState.restore();
          if (timer2) {
            timer2.restore();
          }
          core.procs.refresh();
          startRAF();
          restoreCallbacks.forEach(function(cb) {
            cb();
          });
        }
        if (canvas) {
          canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
          canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
        }
        function destroy() {
          rafCallbacks.length = 0;
          stopRAF();
          if (canvas) {
            canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
            canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
          }
          shaderState.clear();
          framebufferState.clear();
          renderbufferState.clear();
          textureState.clear();
          elementState.clear();
          bufferState.clear();
          attributeState.clear();
          if (timer2) {
            timer2.clear();
          }
          destroyCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function compileProcedure(options) {
          check$1(!!options, "invalid args to regl({...})");
          check$1.type(options, "object", "invalid args to regl({...})");
          function flattenNestedOptions(options2) {
            var result = extend4({}, options2);
            delete result.uniforms;
            delete result.attributes;
            delete result.context;
            delete result.vao;
            if ("stencil" in result && result.stencil.op) {
              result.stencil.opBack = result.stencil.opFront = result.stencil.op;
              delete result.stencil.op;
            }
            function merge(name) {
              if (name in result) {
                var child = result[name];
                delete result[name];
                Object.keys(child).forEach(function(prop) {
                  result[name + "." + prop] = child[prop];
                });
              }
            }
            merge("blend");
            merge("depth");
            merge("cull");
            merge("stencil");
            merge("polygonOffset");
            merge("scissor");
            merge("sample");
            if ("vao" in options2) {
              result.vao = options2.vao;
            }
            return result;
          }
          function separateDynamic(object, useArrays) {
            var staticItems = {};
            var dynamicItems = {};
            Object.keys(object).forEach(function(option) {
              var value = object[option];
              if (dynamic.isDynamic(value)) {
                dynamicItems[option] = dynamic.unbox(value, option);
                return;
              } else if (useArrays && Array.isArray(value)) {
                for (var i2 = 0; i2 < value.length; ++i2) {
                  if (dynamic.isDynamic(value[i2])) {
                    dynamicItems[option] = dynamic.unbox(value, option);
                    return;
                  }
                }
              }
              staticItems[option] = value;
            });
            return {
              dynamic: dynamicItems,
              static: staticItems
            };
          }
          var context = separateDynamic(options.context || {}, true);
          var uniforms = separateDynamic(options.uniforms || {}, true);
          var attributes = separateDynamic(options.attributes || {}, false);
          var opts = separateDynamic(flattenNestedOptions(options), false);
          var stats$$12 = {
            gpuTime: 0,
            cpuTime: 0,
            count: 0
          };
          var compiled = core.compile(opts, attributes, uniforms, context, stats$$12);
          var draw4 = compiled.draw;
          var batch = compiled.batch;
          var scope = compiled.scope;
          var EMPTY_ARRAY = [];
          function reserve(count) {
            while (EMPTY_ARRAY.length < count) {
              EMPTY_ARRAY.push(null);
            }
            return EMPTY_ARRAY;
          }
          function REGLCommand(args2, body) {
            var i2;
            if (contextLost) {
              check$1.raise("context lost");
            }
            if (typeof args2 === "function") {
              return scope.call(this, null, args2, 0);
            } else if (typeof body === "function") {
              if (typeof args2 === "number") {
                for (i2 = 0; i2 < args2; ++i2) {
                  scope.call(this, null, body, i2);
                }
              } else if (Array.isArray(args2)) {
                for (i2 = 0; i2 < args2.length; ++i2) {
                  scope.call(this, args2[i2], body, i2);
                }
              } else {
                return scope.call(this, args2, body, 0);
              }
            } else if (typeof args2 === "number") {
              if (args2 > 0) {
                return batch.call(this, reserve(args2 | 0), args2 | 0);
              }
            } else if (Array.isArray(args2)) {
              if (args2.length) {
                return batch.call(this, args2, args2.length);
              }
            } else {
              return draw4.call(this, args2);
            }
          }
          return extend4(REGLCommand, {
            stats: stats$$12,
            destroy: function() {
              compiled.destroy();
            }
          });
        }
        var setFBO = framebufferState.setFBO = compileProcedure({
          framebuffer: dynamic.define.call(null, DYN_PROP, "framebuffer")
        });
        function clearImpl(_2, options) {
          var clearFlags = 0;
          core.procs.poll();
          var c3 = options.color;
          if (c3) {
            gl2.clearColor(+c3[0] || 0, +c3[1] || 0, +c3[2] || 0, +c3[3] || 0);
            clearFlags |= GL_COLOR_BUFFER_BIT;
          }
          if ("depth" in options) {
            gl2.clearDepth(+options.depth);
            clearFlags |= GL_DEPTH_BUFFER_BIT;
          }
          if ("stencil" in options) {
            gl2.clearStencil(options.stencil | 0);
            clearFlags |= GL_STENCIL_BUFFER_BIT;
          }
          check$1(!!clearFlags, "called regl.clear with no buffer specified");
          gl2.clear(clearFlags);
        }
        function clear(options) {
          check$1(
            typeof options === "object" && options,
            "regl.clear() takes an object as input"
          );
          if ("framebuffer" in options) {
            if (options.framebuffer && options.framebuffer_reglType === "framebufferCube") {
              for (var i2 = 0; i2 < 6; ++i2) {
                setFBO(extend4({
                  framebuffer: options.framebuffer.faces[i2]
                }, options), clearImpl);
              }
            } else {
              setFBO(options, clearImpl);
            }
          } else {
            clearImpl(null, options);
          }
        }
        function frame2(cb) {
          check$1.type(cb, "function", "regl.frame() callback must be a function");
          rafCallbacks.push(cb);
          function cancel() {
            var i2 = find4(rafCallbacks, cb);
            check$1(i2 >= 0, "cannot cancel a frame twice");
            function pendingCancel() {
              var index2 = find4(rafCallbacks, pendingCancel);
              rafCallbacks[index2] = rafCallbacks[rafCallbacks.length - 1];
              rafCallbacks.length -= 1;
              if (rafCallbacks.length <= 0) {
                stopRAF();
              }
            }
            rafCallbacks[i2] = pendingCancel;
          }
          startRAF();
          return {
            cancel
          };
        }
        function pollViewport() {
          var viewport = nextState.viewport;
          var scissorBox = nextState.scissor_box;
          viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
          contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl2.drawingBufferWidth;
          contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl2.drawingBufferHeight;
        }
        function poll() {
          contextState.tick += 1;
          contextState.time = now2();
          pollViewport();
          core.procs.poll();
        }
        function refresh() {
          textureState.refresh();
          pollViewport();
          core.procs.refresh();
          if (timer2) {
            timer2.update();
          }
        }
        function now2() {
          return (clock2() - START_TIME) / 1e3;
        }
        refresh();
        function addListener(event, callback) {
          check$1.type(callback, "function", "listener callback must be a function");
          var callbacks;
          switch (event) {
            case "frame":
              return frame2(callback);
            case "lost":
              callbacks = lossCallbacks;
              break;
            case "restore":
              callbacks = restoreCallbacks;
              break;
            case "destroy":
              callbacks = destroyCallbacks;
              break;
            default:
              check$1.raise("invalid event, must be one of frame,lost,restore,destroy");
          }
          callbacks.push(callback);
          return {
            cancel: function() {
              for (var i2 = 0; i2 < callbacks.length; ++i2) {
                if (callbacks[i2] === callback) {
                  callbacks[i2] = callbacks[callbacks.length - 1];
                  callbacks.pop();
                  return;
                }
              }
            }
          };
        }
        var regl2 = extend4(compileProcedure, {
          // Clear current FBO
          clear,
          // Short cuts for dynamic variables
          prop: dynamic.define.bind(null, DYN_PROP),
          context: dynamic.define.bind(null, DYN_CONTEXT),
          this: dynamic.define.bind(null, DYN_STATE),
          // executes an empty draw command
          draw: compileProcedure({}),
          // Resources
          buffer: function(options) {
            return bufferState.create(options, GL_ARRAY_BUFFER, false, false);
          },
          elements: function(options) {
            return elementState.create(options, false);
          },
          texture: textureState.create2D,
          cube: textureState.createCube,
          renderbuffer: renderbufferState.create,
          framebuffer: framebufferState.create,
          framebufferCube: framebufferState.createCube,
          vao: attributeState.createVAO,
          // Expose context attributes
          attributes: glAttributes,
          // Frame rendering
          frame: frame2,
          on: addListener,
          // System limits
          limits,
          hasExtension: function(name) {
            return limits.extensions.indexOf(name.toLowerCase()) >= 0;
          },
          // Read pixels
          read: readPixels,
          // Destroy regl and all associated resources
          destroy,
          // Direct GL state manipulation
          _gl: gl2,
          _refresh: refresh,
          poll: function() {
            poll();
            if (timer2) {
              timer2.update();
            }
          },
          // Current time
          now: now2,
          // regl Statistics Information
          stats: stats$$1
        });
        config.onDone(null, regl2);
        return regl2;
      }
      return wrapREGL;
    });
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js
var ReglAttribute;
var init_ReglAttribute = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js"() {
    init_classCallCheck();
    init_createClass();
    ReglAttribute = function() {
      function ReglAttribute2(gl2, options) {
        _classCallCheck5(this, ReglAttribute2);
        this.attribute = void 0;
        this.buffer = void 0;
        var buffer = options.buffer, offset = options.offset, stride = options.stride, normalized = options.normalized, size3 = options.size, divisor = options.divisor;
        this.buffer = buffer;
        this.attribute = {
          buffer: buffer.get(),
          offset: offset || 0,
          stride: stride || 0,
          normalized: normalized || false,
          divisor: divisor || 0
        };
        if (size3) {
          this.attribute.size = size3;
        }
      }
      _createClass5(ReglAttribute2, [{
        key: "get",
        value: function get3() {
          return this.attribute;
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(options) {
          this.buffer.subData(options);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.buffer.destroy();
        }
      }]);
      return ReglAttribute2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/constants.js
var _primitiveMap, _usageMap, _dataTypeMap, _formatMap, _mipmapMap, _filterMap, _wrapModeMap, _colorSpaceMap, _depthFuncMap, _blendEquationMap, _blendFuncMap, _stencilFuncMap, _stencilOpMap, _cullFaceMap, primitiveMap, usageMap, dataTypeMap, formatMap, mipmapMap, filterMap, wrapModeMap, colorSpaceMap, depthFuncMap, blendEquationMap, blendFuncMap, stencilFuncMap, stencilOpMap, cullFaceMap;
var init_constants = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/constants.js"() {
    init_defineProperty();
    init_es2();
    primitiveMap = (_primitiveMap = {}, _defineProperty2(_primitiveMap, gl.POINTS, "points"), _defineProperty2(_primitiveMap, gl.LINES, "lines"), _defineProperty2(_primitiveMap, gl.LINE_LOOP, "line loop"), _defineProperty2(_primitiveMap, gl.LINE_STRIP, "line strip"), _defineProperty2(_primitiveMap, gl.TRIANGLES, "triangles"), _defineProperty2(_primitiveMap, gl.TRIANGLE_FAN, "triangle fan"), _defineProperty2(_primitiveMap, gl.TRIANGLE_STRIP, "triangle strip"), _primitiveMap);
    usageMap = (_usageMap = {}, _defineProperty2(_usageMap, gl.STATIC_DRAW, "static"), _defineProperty2(_usageMap, gl.DYNAMIC_DRAW, "dynamic"), _defineProperty2(_usageMap, gl.STREAM_DRAW, "stream"), _usageMap);
    dataTypeMap = (_dataTypeMap = {}, _defineProperty2(_dataTypeMap, gl.BYTE, "int8"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_INT, "int16"), _defineProperty2(_dataTypeMap, gl.INT, "int32"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_BYTE, "uint8"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_SHORT, "uint16"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_INT, "uint32"), _defineProperty2(_dataTypeMap, gl.FLOAT, "float"), _dataTypeMap);
    formatMap = (_formatMap = {}, _defineProperty2(_formatMap, gl.ALPHA, "alpha"), _defineProperty2(_formatMap, gl.LUMINANCE, "luminance"), _defineProperty2(_formatMap, gl.LUMINANCE_ALPHA, "luminance alpha"), _defineProperty2(_formatMap, gl.RGB, "rgb"), _defineProperty2(_formatMap, gl.RGBA, "rgba"), _defineProperty2(_formatMap, gl.RGBA4, "rgba4"), _defineProperty2(_formatMap, gl.RGB5_A1, "rgb5 a1"), _defineProperty2(_formatMap, gl.RGB565, "rgb565"), _defineProperty2(_formatMap, gl.DEPTH_COMPONENT, "depth"), _defineProperty2(_formatMap, gl.DEPTH_STENCIL, "depth stencil"), _formatMap);
    mipmapMap = (_mipmapMap = {}, _defineProperty2(_mipmapMap, gl.DONT_CARE, "dont care"), _defineProperty2(_mipmapMap, gl.NICEST, "nice"), _defineProperty2(_mipmapMap, gl.FASTEST, "fast"), _mipmapMap);
    filterMap = (_filterMap = {}, _defineProperty2(_filterMap, gl.NEAREST, "nearest"), _defineProperty2(_filterMap, gl.LINEAR, "linear"), _defineProperty2(_filterMap, gl.LINEAR_MIPMAP_LINEAR, "mipmap"), _defineProperty2(_filterMap, gl.NEAREST_MIPMAP_LINEAR, "nearest mipmap linear"), _defineProperty2(_filterMap, gl.LINEAR_MIPMAP_NEAREST, "linear mipmap nearest"), _defineProperty2(_filterMap, gl.NEAREST_MIPMAP_NEAREST, "nearest mipmap nearest"), _filterMap);
    wrapModeMap = (_wrapModeMap = {}, _defineProperty2(_wrapModeMap, gl.REPEAT, "repeat"), _defineProperty2(_wrapModeMap, gl.CLAMP_TO_EDGE, "clamp"), _defineProperty2(_wrapModeMap, gl.MIRRORED_REPEAT, "mirror"), _wrapModeMap);
    colorSpaceMap = (_colorSpaceMap = {}, _defineProperty2(_colorSpaceMap, gl.NONE, "none"), _defineProperty2(_colorSpaceMap, gl.BROWSER_DEFAULT_WEBGL, "browser"), _colorSpaceMap);
    depthFuncMap = (_depthFuncMap = {}, _defineProperty2(_depthFuncMap, gl.NEVER, "never"), _defineProperty2(_depthFuncMap, gl.ALWAYS, "always"), _defineProperty2(_depthFuncMap, gl.LESS, "less"), _defineProperty2(_depthFuncMap, gl.LEQUAL, "lequal"), _defineProperty2(_depthFuncMap, gl.GREATER, "greater"), _defineProperty2(_depthFuncMap, gl.GEQUAL, "gequal"), _defineProperty2(_depthFuncMap, gl.EQUAL, "equal"), _defineProperty2(_depthFuncMap, gl.NOTEQUAL, "notequal"), _depthFuncMap);
    blendEquationMap = (_blendEquationMap = {}, _defineProperty2(_blendEquationMap, gl.FUNC_ADD, "add"), _defineProperty2(_blendEquationMap, gl.MIN_EXT, "min"), _defineProperty2(_blendEquationMap, gl.MAX_EXT, "max"), _defineProperty2(_blendEquationMap, gl.FUNC_SUBTRACT, "subtract"), _defineProperty2(_blendEquationMap, gl.FUNC_REVERSE_SUBTRACT, "reverse subtract"), _blendEquationMap);
    blendFuncMap = (_blendFuncMap = {}, _defineProperty2(_blendFuncMap, gl.ZERO, "zero"), _defineProperty2(_blendFuncMap, gl.ONE, "one"), _defineProperty2(_blendFuncMap, gl.SRC_COLOR, "src color"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_SRC_COLOR, "one minus src color"), _defineProperty2(_blendFuncMap, gl.SRC_ALPHA, "src alpha"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_SRC_ALPHA, "one minus src alpha"), _defineProperty2(_blendFuncMap, gl.DST_COLOR, "dst color"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_DST_COLOR, "one minus dst color"), _defineProperty2(_blendFuncMap, gl.DST_ALPHA, "dst alpha"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_DST_ALPHA, "one minus dst alpha"), _defineProperty2(_blendFuncMap, gl.CONSTANT_COLOR, "constant color"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_CONSTANT_COLOR, "one minus constant color"), _defineProperty2(_blendFuncMap, gl.CONSTANT_ALPHA, "constant alpha"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_CONSTANT_ALPHA, "one minus constant alpha"), _defineProperty2(_blendFuncMap, gl.SRC_ALPHA_SATURATE, "src alpha saturate"), _blendFuncMap);
    stencilFuncMap = (_stencilFuncMap = {}, _defineProperty2(_stencilFuncMap, gl.NEVER, "never"), _defineProperty2(_stencilFuncMap, gl.ALWAYS, "always"), _defineProperty2(_stencilFuncMap, gl.LESS, "less"), _defineProperty2(_stencilFuncMap, gl.LEQUAL, "lequal"), _defineProperty2(_stencilFuncMap, gl.GREATER, "greater"), _defineProperty2(_stencilFuncMap, gl.GEQUAL, "gequal"), _defineProperty2(_stencilFuncMap, gl.EQUAL, "equal"), _defineProperty2(_stencilFuncMap, gl.NOTEQUAL, "notequal"), _stencilFuncMap);
    stencilOpMap = (_stencilOpMap = {}, _defineProperty2(_stencilOpMap, gl.ZERO, "zero"), _defineProperty2(_stencilOpMap, gl.KEEP, "keep"), _defineProperty2(_stencilOpMap, gl.REPLACE, "replace"), _defineProperty2(_stencilOpMap, gl.INVERT, "invert"), _defineProperty2(_stencilOpMap, gl.INCR, "increment"), _defineProperty2(_stencilOpMap, gl.DECR, "decrement"), _defineProperty2(_stencilOpMap, gl.INCR_WRAP, "increment wrap"), _defineProperty2(_stencilOpMap, gl.DECR_WRAP, "decrement wrap"), _stencilOpMap);
    cullFaceMap = (_cullFaceMap = {}, _defineProperty2(_cullFaceMap, gl.FRONT, "front"), _defineProperty2(_cullFaceMap, gl.BACK, "back"), _cullFaceMap);
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js
var ReglBuffer;
var init_ReglBuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_constants();
    ReglBuffer = function() {
      function ReglBuffer2(reGl, options) {
        _classCallCheck5(this, ReglBuffer2);
        this.buffer = void 0;
        var data = options.data, usage = options.usage, type = options.type;
        this.buffer = reGl.buffer({
          data,
          usage: usageMap[usage || gl.STATIC_DRAW],
          type: dataTypeMap[type || gl.UNSIGNED_BYTE]
          // length: 0,
        });
      }
      _createClass5(ReglBuffer2, [{
        key: "get",
        value: function get3() {
          return this.buffer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }, {
        key: "subData",
        value: function subData(_ref) {
          var data = _ref.data, offset = _ref.offset;
          this.buffer.subdata(data, offset);
        }
      }]);
      return ReglBuffer2;
    }();
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray3(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e8 = 0, n2 = Array(a3); e8 < a3; e8++) n2[e8] = r2[e8];
  return n2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray3(r2);
}
var init_arrayWithoutHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
var init_iterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray3(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray3(r2, a3);
    var t4 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t4 && r2.constructor && (t4 = r2.constructor.name), "Map" === t4 || "Set" === t4 ? Array.from(r2) : "Arguments" === t4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t4) ? _arrayLikeToArray3(r2, a3) : void 0;
  }
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableSpread = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray3(r2) || _nonIterableSpread();
}
var init_toConsumableArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"() {
    init_arrayWithoutHoles();
    init_iterableToArray();
    init_unsupportedIterableToArray();
    init_nonIterableSpread();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js
function ownKeys3(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_isTypedArray2, import_regenerator3, quadVert, textureId, debug, ReglComputeModel;
var init_ReglComputeModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js"() {
    init_toConsumableArray();
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_isTypedArray2 = __toESM(require_isTypedArray());
    import_regenerator3 = __toESM(require_regenerator2());
    init_es2();
    quadVert = "attribute vec3 a_Position;\nattribute vec2 a_TexCoord;\n\nvarying vec2 v_TexCoord;\n\nvoid main() {\n  gl_Position = vec4(a_Position, 1.0);\n  v_TexCoord = a_TexCoord;\n}";
    textureId = 0;
    debug = false;
    ReglComputeModel = function() {
      function ReglComputeModel2(reGl, context) {
        var _this = this;
        _classCallCheck5(this, ReglComputeModel2);
        this.reGl = reGl;
        this.context = context;
        this.entity = createEntity();
        this.texFBO = void 0;
        this.computeCommand = void 0;
        this.textureCache = {};
        this.outputTextureName = void 0;
        this.swapOutputTextureName = void 0;
        this.compiledPingpong = void 0;
        this.dynamicPingpong = void 0;
        var uniforms = {};
        this.context.uniforms.forEach(function(uniform) {
          var name = uniform.name, type = uniform.type, data = uniform.data, isReferer = uniform.isReferer, storageClass = uniform.storageClass;
          if (storageClass === STORAGE_CLASS.StorageBuffer) {
            if (!isReferer) {
              _this.textureCache[name] = _this.calcDataTexture(name, type, data);
              var _this$textureCache$na = _this.textureCache[name], width = _this$textureCache$na.textureWidth, isOutput = _this$textureCache$na.isOutput;
              uniforms["".concat(name, "Size")] = [width, width];
              if (isOutput) {
                _this.outputTextureName = name;
                if (_this.context.needPingpong) {
                  _this.outputTextureName = "".concat(name, "Output");
                  _this.textureCache[_this.outputTextureName] = _this.calcDataTexture(name, type, data);
                }
              }
            } else {
              _this.textureCache[name] = {
                data: void 0
              };
              uniforms["".concat(name, "Size")] = function() {
                return (
                  // @ts-ignore
                  data.compiledBundle.context.output.textureSize
                );
              };
            }
            uniforms[name] = function() {
              if (debug) {
                console.log("[".concat(_this.entity, "]: ").concat(name, " ").concat(_this.textureCache[name].id));
              }
              return _this.textureCache[name].texture;
            };
          } else if (storageClass === STORAGE_CLASS.Uniform) {
            if (data && (Array.isArray(data) || (0, import_isTypedArray2.default)(data)) && data.length > 16) {
              throw new Error("invalid data type ".concat(type));
            }
            uniforms[name] = function() {
              return uniform.data;
            };
          }
        });
        var _this$getOuputDataTex = this.getOuputDataTexture(), textureWidth = _this$getOuputDataTex.textureWidth, texelCount = _this$getOuputDataTex.texelCount;
        uniforms.u_OutputTextureSize = [textureWidth, textureWidth];
        uniforms.u_OutputTexelCount = texelCount;
        this.context.output.textureSize = [textureWidth, textureWidth];
        var drawParams = {
          attributes: {
            a_Position: [[-1, 1, 0], [-1, -1, 0], [1, 1, 0], [1, -1, 0]],
            a_TexCoord: [[0, 1], [0, 0], [1, 1], [1, 0]]
          },
          frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(this.context.shader),
          uniforms,
          vert: quadVert,
          // TODO: use a fullscreen triangle instead.
          primitive: "triangle strip",
          count: 4
        };
        this.computeCommand = this.reGl(drawParams);
      }
      _createClass5(ReglComputeModel2, [{
        key: "run",
        value: function run() {
          var _this2 = this;
          if (this.context.maxIteration > 1 && this.context.needPingpong) {
            this.compiledPingpong = true;
          }
          if (this.compiledPingpong || this.dynamicPingpong) {
            this.swap();
          }
          this.texFBO = this.reGl.framebuffer({
            color: this.getOuputDataTexture().texture
          });
          this.texFBO.use(function() {
            _this2.computeCommand();
          });
          if (debug) {
            console.log("[".concat(this.entity, "]: output ").concat(this.getOuputDataTexture().id));
          }
        }
      }, {
        key: "readData",
        value: function() {
          var _readData = _asyncToGenerator(import_regenerator3.default.mark(function _callee() {
            var _this3 = this;
            var pixels, _this$getOuputDataTex2, originalDataLength, elementsPerTexel, _this$getOuputDataTex3, typedArrayConstructor, formattedPixels, i2;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.reGl({
                      framebuffer: this.texFBO
                    })(function() {
                      pixels = _this3.reGl.read();
                    });
                    if (!pixels) {
                      _context.next = 6;
                      break;
                    }
                    _this$getOuputDataTex2 = this.getOuputDataTexture(), originalDataLength = _this$getOuputDataTex2.originalDataLength, elementsPerTexel = _this$getOuputDataTex2.elementsPerTexel, _this$getOuputDataTex3 = _this$getOuputDataTex2.typedArrayConstructor, typedArrayConstructor = _this$getOuputDataTex3 === void 0 ? Float32Array : _this$getOuputDataTex3;
                    formattedPixels = [];
                    if (elementsPerTexel !== 4) {
                      for (i2 = 0; i2 < pixels.length; i2 += 4) {
                        if (elementsPerTexel === 1) {
                          formattedPixels.push(pixels[i2]);
                        } else if (elementsPerTexel === 2) {
                          formattedPixels.push(pixels[i2], pixels[i2 + 1]);
                        } else {
                          formattedPixels.push(pixels[i2], pixels[i2 + 1], pixels[i2 + 2]);
                        }
                      }
                    } else {
                      formattedPixels = pixels;
                    }
                    return _context.abrupt("return", new typedArrayConstructor(formattedPixels.slice(0, originalDataLength)));
                  case 6:
                    return _context.abrupt("return", new Float32Array());
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function readData() {
            return _readData.apply(this, arguments);
          }
          return readData;
        }()
      }, {
        key: "confirmInput",
        value: function confirmInput(model, inputName) {
          var inputModel;
          if (this.entity === model.entity) {
            this.dynamicPingpong = true;
            inputModel = this;
          } else {
            inputModel = model;
          }
          this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;
          this.textureCache[inputName].texture = inputModel.getOuputDataTexture().texture;
          if (debug) {
            console.log("[".concat(this.entity, "]: confirm input ").concat(inputName, " from model ").concat(inputModel.entity, ", ").concat(inputModel.getOuputDataTexture().id));
          }
        }
      }, {
        key: "updateUniform",
        value: function updateUniform() {
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(bufferName, data) {
          var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var buffer = this.context.uniforms.find(function(_ref) {
            var name = _ref.name;
            return name === bufferName;
          });
          if (buffer) {
            var _this$calcDataTexture = this.calcDataTexture(bufferName, buffer.type, data), texture = _this$calcDataTexture.texture, paddingData = _this$calcDataTexture.data;
            this.textureCache[bufferName].data = paddingData;
            this.textureCache[bufferName].texture = texture;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }, {
        key: "swap",
        value: function swap() {
          if (!this.swapOutputTextureName) {
            this.createSwapOutputDataTexture();
          }
          if (this.compiledPingpong) {
            var outputTextureUniformName = this.context.output.name;
            this.textureCache[outputTextureUniformName].id = this.getOuputDataTexture().id;
            this.textureCache[outputTextureUniformName].texture = this.getOuputDataTexture().texture;
          }
          var tmp = this.outputTextureName;
          this.outputTextureName = this.swapOutputTextureName;
          this.swapOutputTextureName = tmp;
          if (debug) {
            console.log("[".concat(this.entity, "]: after swap, output ").concat(this.getOuputDataTexture().id));
          }
        }
      }, {
        key: "getOuputDataTexture",
        value: function getOuputDataTexture() {
          return this.textureCache[this.outputTextureName];
        }
      }, {
        key: "createSwapOutputDataTexture",
        value: function createSwapOutputDataTexture() {
          var texture = this.cloneDataTexture(this.getOuputDataTexture());
          this.swapOutputTextureName = "".concat(this.entity, "-swap");
          this.textureCache[this.swapOutputTextureName] = texture;
        }
      }, {
        key: "cloneDataTexture",
        value: function cloneDataTexture(texture) {
          var data = texture.data, textureWidth = texture.textureWidth;
          return _objectSpread3(_objectSpread3({}, texture), {}, {
            id: textureId++,
            // @ts-ignore
            texture: this.reGl.texture({
              width: textureWidth,
              height: textureWidth,
              data,
              type: "float"
            })
          });
        }
      }, {
        key: "calcDataTexture",
        value: function calcDataTexture(name, type, data) {
          var elementsPerTexel = 1;
          if (type === AST_TOKEN_TYPES.Vector4FloatArray) {
            elementsPerTexel = 4;
          }
          var paddingData = [];
          for (var i2 = 0; i2 < data.length; i2 += elementsPerTexel) {
            if (elementsPerTexel === 1) {
              paddingData.push(data[i2], 0, 0, 0);
            } else if (elementsPerTexel === 2) {
              paddingData.push(data[i2], data[i2 + 1], 0, 0);
            } else if (elementsPerTexel === 3) {
              paddingData.push(data[i2], data[i2 + 1], data[i2 + 2], 0);
            } else if (elementsPerTexel === 4) {
              paddingData.push(data[i2], data[i2 + 1], data[i2 + 2], data[i2 + 3]);
            }
          }
          var originalDataLength = data.length;
          var texelCount = Math.ceil(originalDataLength / elementsPerTexel);
          var width = Math.ceil(Math.sqrt(texelCount));
          var paddingTexelCount = width * width;
          if (texelCount < paddingTexelCount) {
            paddingData.push.apply(paddingData, _toConsumableArray(new Array((paddingTexelCount - texelCount) * 4).fill(0)));
          }
          var texture = this.reGl.texture({
            width,
            height: width,
            data: paddingData,
            type: "float"
          });
          return {
            id: textureId++,
            data: paddingData,
            originalDataLength,
            typedArrayConstructor: (0, import_isTypedArray2.default)(data) ? data.constructor : void 0,
            textureWidth: width,
            texture,
            texelCount,
            elementsPerTexel,
            isOutput: name === this.context.output.name
          };
        }
      }]);
      return ReglComputeModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js
var ReglElements;
var init_ReglElements = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_constants();
    ReglElements = function() {
      function ReglElements2(reGl, options) {
        _classCallCheck5(this, ReglElements2);
        this.elements = void 0;
        var data = options.data, usage = options.usage, type = options.type, count = options.count;
        this.elements = reGl.elements({
          data,
          usage: usageMap[usage || gl.STATIC_DRAW],
          type: dataTypeMap[type || gl.UNSIGNED_BYTE],
          count
        });
      }
      _createClass5(ReglElements2, [{
        key: "get",
        value: function get3() {
          return this.elements;
        }
      }, {
        key: "subData",
        value: function subData(_ref) {
          var data = _ref.data;
          this.elements.subdata(data);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.elements.destroy();
        }
      }]);
      return ReglElements2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js
var ReglFramebuffer;
var init_ReglFramebuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js"() {
    init_classCallCheck();
    init_createClass();
    ReglFramebuffer = function() {
      function ReglFramebuffer2(reGl, options) {
        _classCallCheck5(this, ReglFramebuffer2);
        this.framebuffer = void 0;
        var width = options.width, height = options.height, color3 = options.color, colors = options.colors, depth = options.depth, stencil = options.stencil;
        var framebufferOptions = {
          width,
          height
        };
        if (Array.isArray(colors)) {
          framebufferOptions.colors = colors.map(function(c3) {
            return c3.get();
          });
        }
        if (color3 && typeof color3 !== "boolean") {
          framebufferOptions.color = color3.get();
        }
        this.framebuffer = reGl.framebuffer(framebufferOptions);
      }
      _createClass5(ReglFramebuffer2, [{
        key: "get",
        value: function get3() {
          return this.framebuffer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.framebuffer.destroy();
        }
      }, {
        key: "resize",
        value: function resize(_ref) {
          var width = _ref.width, height = _ref.height;
          this.framebuffer.resize(width, height);
        }
      }]);
      return ReglFramebuffer2;
    }();
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform16) {
      return function(arg) {
        return func(transform16(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike3 = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto3 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty7 = objectProto3.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject3(value) {
      if (!isObjectLike3(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty7.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject3;
  }
});

// node_modules/@antv/g-webgpu-engine/es/utils/uniform.js
function extractUniforms(uniforms) {
  var extractedUniforms = {};
  Object.keys(uniforms).forEach(function(uniformName) {
    extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
  });
  return extractedUniforms;
}
function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
  if (uniformValue === null || typeof uniformValue === "number" || // u_A: 1
  typeof uniformValue === "boolean" || // u_A: false
  Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || // u_A: [1, 2, 3]
  (0, import_isTypedArray3.default)(uniformValue) || // u_A: Float32Array
  // @ts-ignore
  uniformValue === "" || // @ts-ignore
  uniformValue.resize !== void 0) {
    uniforms["".concat(prefix && prefix + ".").concat(uniformName)] = uniformValue;
    return;
  }
  if ((0, import_isPlainObject.default)(uniformValue)) {
    Object.keys(uniformValue).forEach(function(childName) {
      extractUniformsRecursively(
        childName,
        // @ts-ignore
        uniformValue[childName],
        uniforms,
        "".concat(prefix && prefix + ".").concat(uniformName)
      );
    });
  }
  if (Array.isArray(uniformValue)) {
    uniformValue.forEach(function(child, idx) {
      Object.keys(child).forEach(function(childName) {
        extractUniformsRecursively(
          childName,
          // @ts-ignore
          child[childName],
          uniforms,
          "".concat(prefix && prefix + ".").concat(uniformName, "[").concat(idx, "]")
        );
      });
    });
  }
}
var import_isTypedArray3, import_isPlainObject;
var init_uniform = __esm({
  "node_modules/@antv/g-webgpu-engine/es/utils/uniform.js"() {
    import_isTypedArray3 = __toESM(require_isTypedArray());
    import_isPlainObject = __toESM(require_isPlainObject());
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js
function ownKeys4(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ReglModel;
var init_ReglModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js"() {
    init_typeof();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_uniform();
    init_constants();
    ReglModel = function() {
      function ReglModel2(reGl, options) {
        _classCallCheck5(this, ReglModel2);
        this.reGl = void 0;
        this.drawCommand = void 0;
        this.uniforms = {};
        this.reGl = reGl;
        var vs = options.vs, fs = options.fs, defines = options.defines, attributes = options.attributes, uniforms = options.uniforms, primitive = options.primitive, count = options.count, elements = options.elements, depth = options.depth, blend = options.blend, stencil = options.stencil, cull = options.cull, instances = options.instances, scissor = options.scissor, viewport = options.viewport;
        var reglUniforms = {};
        if (uniforms) {
          this.uniforms = extractUniforms(uniforms);
          Object.keys(uniforms).forEach(function(uniformName) {
            reglUniforms[uniformName] = reGl.prop(uniformName);
          });
        }
        var reglAttributes = {};
        Object.keys(attributes).forEach(function(name) {
          reglAttributes[name] = attributes[name].get();
        });
        var defineStmts = defines && this.generateDefines(defines) || "";
        var drawParams = {
          attributes: reglAttributes,
          frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(defineStmts, "\n").concat(fs),
          uniforms: reglUniforms,
          vert: "\n".concat(defineStmts, "\n").concat(vs),
          primitive: primitiveMap[primitive === void 0 ? gl.TRIANGLES : primitive]
        };
        if (instances) {
          drawParams.instances = instances;
        }
        if (count) {
          drawParams.count = count;
        }
        if (elements) {
          drawParams.elements = elements.get();
        }
        if (scissor) {
          drawParams.scissor = scissor;
        }
        if (viewport) {
          drawParams.viewport = viewport;
        }
        this.initDepthDrawParams({
          depth
        }, drawParams);
        this.initBlendDrawParams({
          blend
        }, drawParams);
        this.initStencilDrawParams({
          stencil
        }, drawParams);
        this.initCullDrawParams({
          cull
        }, drawParams);
        this.drawCommand = reGl(drawParams);
      }
      _createClass5(ReglModel2, [{
        key: "addUniforms",
        value: function addUniforms(uniforms) {
          this.uniforms = _objectSpread4(_objectSpread4({}, this.uniforms), extractUniforms(uniforms));
        }
      }, {
        key: "draw",
        value: function draw4(options) {
          var uniforms = _objectSpread4(_objectSpread4({}, this.uniforms), extractUniforms(options.uniforms || {}));
          var reglDrawProps = {};
          Object.keys(uniforms).forEach(function(uniformName) {
            var type = _typeof6(uniforms[uniformName]);
            if (type === "boolean" || type === "number" || Array.isArray(uniforms[uniformName]) || // @ts-ignore
            uniforms[uniformName].BYTES_PER_ELEMENT) {
              reglDrawProps[uniformName] = uniforms[uniformName];
            } else if (type === "string") {
            } else {
              reglDrawProps[uniformName] = uniforms[uniformName].get();
            }
          });
          this.drawCommand(reglDrawProps);
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer
         */
      }, {
        key: "initDepthDrawParams",
        value: function initDepthDrawParams(_ref, drawParams) {
          var depth = _ref.depth;
          if (depth) {
            drawParams.depth = {
              enable: depth.enable === void 0 ? true : !!depth.enable,
              mask: depth.mask === void 0 ? true : !!depth.mask,
              func: depthFuncMap[depth.func || gl.LESS],
              range: depth.range || [0, 1]
            };
          }
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#blending
         */
      }, {
        key: "initBlendDrawParams",
        value: function initBlendDrawParams(_ref2, drawParams) {
          var blend = _ref2.blend;
          if (blend) {
            var enable = blend.enable, func = blend.func, equation = blend.equation, _blend$color = blend.color, color3 = _blend$color === void 0 ? [0, 0, 0, 0] : _blend$color;
            drawParams.blend = {
              enable: !!enable,
              func: {
                srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
                srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
                dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
                dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
              },
              equation: {
                rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
                alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
              },
              color: color3
            };
          }
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
         */
      }, {
        key: "initStencilDrawParams",
        value: function initStencilDrawParams(_ref3, drawParams) {
          var stencil = _ref3.stencil;
          if (stencil) {
            var enable = stencil.enable, _stencil$mask = stencil.mask, mask = _stencil$mask === void 0 ? -1 : _stencil$mask, _stencil$func = stencil.func, func = _stencil$func === void 0 ? {
              cmp: gl.ALWAYS,
              ref: 0,
              mask: -1
            } : _stencil$func, _stencil$opFront = stencil.opFront, opFront = _stencil$opFront === void 0 ? {
              fail: gl.KEEP,
              zfail: gl.KEEP,
              zpass: gl.KEEP
            } : _stencil$opFront, _stencil$opBack = stencil.opBack, opBack = _stencil$opBack === void 0 ? {
              fail: gl.KEEP,
              zfail: gl.KEEP,
              zpass: gl.KEEP
            } : _stencil$opBack;
            drawParams.stencil = {
              enable: !!enable,
              mask,
              func: _objectSpread4(_objectSpread4({}, func), {}, {
                cmp: stencilFuncMap[func.cmp]
              }),
              opFront: {
                fail: stencilOpMap[opFront.fail],
                zfail: stencilOpMap[opFront.zfail],
                zpass: stencilOpMap[opFront.zpass]
              },
              opBack: {
                fail: stencilOpMap[opBack.fail],
                zfail: stencilOpMap[opBack.zfail],
                zpass: stencilOpMap[opBack.zpass]
              }
            };
          }
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
         */
      }, {
        key: "initCullDrawParams",
        value: function initCullDrawParams(_ref4, drawParams) {
          var cull = _ref4.cull;
          if (cull) {
            var enable = cull.enable, _cull$face = cull.face, face = _cull$face === void 0 ? gl.BACK : _cull$face;
            drawParams.cull = {
              enable: !!enable,
              face: cullFaceMap[face]
            };
          }
        }
      }, {
        key: "generateDefines",
        value: function generateDefines(defines) {
          return Object.keys(defines).map(function(name) {
            return "#define ".concat(name, " ").concat(Number(defines[name]));
          }).join("\n");
        }
      }]);
      return ReglModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js
var ReglTexture2D;
var init_ReglTexture2D = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_constants();
    ReglTexture2D = function() {
      function ReglTexture2D2(reGl, options) {
        _classCallCheck5(this, ReglTexture2D2);
        this.texture = void 0;
        this.width = void 0;
        this.height = void 0;
        var data = options.data, _options$type = options.type, type = _options$type === void 0 ? gl.UNSIGNED_BYTE : _options$type, width = options.width, height = options.height, _options$flipY = options.flipY, flipY = _options$flipY === void 0 ? false : _options$flipY, _options$format = options.format, format2 = _options$format === void 0 ? gl.RGBA : _options$format, _options$mipmap = options.mipmap, mipmap = _options$mipmap === void 0 ? false : _options$mipmap, _options$wrapS = options.wrapS, wrapS = _options$wrapS === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapS, _options$wrapT = options.wrapT, wrapT = _options$wrapT === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapT, _options$aniso = options.aniso, aniso = _options$aniso === void 0 ? 0 : _options$aniso, _options$alignment = options.alignment, alignment = _options$alignment === void 0 ? 1 : _options$alignment, _options$premultiplyA = options.premultiplyAlpha, premultiplyAlpha = _options$premultiplyA === void 0 ? false : _options$premultiplyA, _options$mag = options.mag, mag = _options$mag === void 0 ? gl.NEAREST : _options$mag, _options$min = options.min, min6 = _options$min === void 0 ? gl.NEAREST : _options$min, _options$colorSpace = options.colorSpace, colorSpace = _options$colorSpace === void 0 ? gl.BROWSER_DEFAULT_WEBGL : _options$colorSpace;
        this.width = width;
        this.height = height;
        var textureOptions = {
          width,
          height,
          // @ts-ignore
          type: dataTypeMap[type],
          format: formatMap[format2],
          wrapS: wrapModeMap[wrapS],
          wrapT: wrapModeMap[wrapT],
          // @ts-ignore
          mag: filterMap[mag],
          min: filterMap[min6],
          alignment,
          flipY,
          colorSpace: colorSpaceMap[colorSpace],
          premultiplyAlpha,
          aniso
        };
        if (data) {
          textureOptions.data = data;
        }
        if (typeof mipmap === "number") {
          textureOptions.mipmap = mipmapMap[mipmap];
        } else if (typeof mipmap === "boolean") {
          textureOptions.mipmap = mipmap;
        }
        this.texture = reGl.texture(textureOptions);
      }
      _createClass5(ReglTexture2D2, [{
        key: "get",
        value: function get3() {
          return this.texture;
        }
      }, {
        key: "update",
        value: function update15() {
          this.texture._texture.bind();
        }
      }, {
        key: "resize",
        value: function resize(_ref) {
          var width = _ref.width, height = _ref.height;
          this.texture.resize(width, height);
          this.width = width;
          this.height = height;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.texture.destroy();
        }
      }]);
      return ReglTexture2D2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/index.js
var import_regenerator4, import_regl, WebGLEngine;
var init_webgl = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/index.js"() {
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_regenerator4 = __toESM(require_regenerator2());
    init_es2();
    import_regl = __toESM(require_regl());
    init_ReglAttribute();
    init_ReglBuffer();
    init_ReglComputeModel();
    init_ReglElements();
    init_ReglFramebuffer();
    init_ReglModel();
    init_ReglTexture2D();
    WebGLEngine = function() {
      function WebGLEngine2() {
        var _this = this;
        _classCallCheck5(this, WebGLEngine2);
        this.supportWebGPU = false;
        this.useWGSL = false;
        this.$canvas = void 0;
        this.gl = void 0;
        this.inited = void 0;
        this.createModel = function() {
          var _ref = _asyncToGenerator(import_regenerator4.default.mark(function _callee2(options) {
            return import_regenerator4.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!options.uniforms) {
                      _context2.next = 3;
                      break;
                    }
                    _context2.next = 3;
                    return Promise.all(Object.keys(options.uniforms).map(function() {
                      var _ref2 = _asyncToGenerator(import_regenerator4.default.mark(function _callee(name) {
                        var texture;
                        return import_regenerator4.default.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                if (!(options.uniforms[name] && // @ts-ignore
                                options.uniforms[name].load !== void 0)) {
                                  _context.next = 5;
                                  break;
                                }
                                _context.next = 3;
                                return options.uniforms[name].load();
                              case 3:
                                texture = _context.sent;
                                options.uniforms[name] = texture;
                              case 5:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));
                      return function(_x2) {
                        return _ref2.apply(this, arguments);
                      };
                    }()));
                  case 3:
                    return _context2.abrupt("return", new ReglModel(_this.gl, options));
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function(_x) {
            return _ref.apply(this, arguments);
          };
        }();
        this.createAttribute = function(options) {
          return new ReglAttribute(_this.gl, options);
        };
        this.createBuffer = function(options) {
          return new ReglBuffer(_this.gl, options);
        };
        this.createElements = function(options) {
          return new ReglElements(_this.gl, options);
        };
        this.createTexture2D = function(options) {
          return new ReglTexture2D(_this.gl, options);
        };
        this.createFramebuffer = function(options) {
          return new ReglFramebuffer(_this.gl, options);
        };
        this.useFramebuffer = function(framebuffer, drawCommands) {
          _this.gl({
            framebuffer: framebuffer ? framebuffer.get() : null
          })(drawCommands);
        };
        this.createComputeModel = function() {
          var _ref3 = _asyncToGenerator(import_regenerator4.default.mark(function _callee3(context) {
            return import_regenerator4.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", new ReglComputeModel(_this.gl, context));
                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));
          return function(_x3) {
            return _ref3.apply(this, arguments);
          };
        }();
        this.clear = function(options) {
          var color3 = options.color, depth = options.depth, stencil = options.stencil, _options$framebuffer = options.framebuffer, framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
          var reglClearOptions = {
            color: color3,
            depth,
            stencil
          };
          reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
          _this.gl.clear(reglClearOptions);
        };
        this.setScissor = function(scissor) {
          if (_this.gl && _this.gl._gl) {
            if (scissor.enable && scissor.box) {
              _this.gl._gl.enable(gl.SCISSOR_TEST);
              _this.gl._gl.scissor(scissor.box.x, scissor.box.y, scissor.box.width, scissor.box.height);
            } else {
              _this.gl._gl.disable(gl.SCISSOR_TEST);
            }
            _this.gl._refresh();
          }
        };
        this.viewport = function(_ref4) {
          var x4 = _ref4.x, y4 = _ref4.y, width = _ref4.width, height = _ref4.height;
          if (_this.gl && _this.gl._gl) {
            _this.gl._gl.viewport(x4, y4, width, height);
            _this.gl._refresh();
          }
        };
        this.readPixels = function(options) {
          var framebuffer = options.framebuffer, x4 = options.x, y4 = options.y, width = options.width, height = options.height;
          var readPixelsOptions = {
            x: x4,
            y: y4,
            width,
            height
          };
          if (framebuffer) {
            readPixelsOptions.framebuffer = framebuffer.get();
          }
          return _this.gl.read(readPixelsOptions);
        };
        this.getCanvas = function() {
          return _this.$canvas;
        };
        this.getGLContext = function() {
          return _this.gl._gl;
        };
        this.destroy = function() {
          if (_this.gl) {
            _this.gl.destroy();
            _this.inited = false;
          }
        };
      }
      _createClass5(WebGLEngine2, [{
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator4.default.mark(function _callee4(cfg) {
            return import_regenerator4.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!this.inited) {
                      _context4.next = 2;
                      break;
                    }
                    return _context4.abrupt("return");
                  case 2:
                    this.$canvas = cfg.canvas;
                    _context4.next = 5;
                    return new Promise(function(resolve, reject) {
                      (0, import_regl.default)({
                        canvas: cfg.canvas,
                        attributes: {
                          alpha: true,
                          // use TAA instead of MSAA
                          // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1
                          antialias: cfg.antialias,
                          premultipliedAlpha: true
                          // preserveDrawingBuffer: false,
                        },
                        pixelRatio: 1,
                        // TODO: use extensions
                        extensions: [
                          "OES_element_index_uint",
                          "OES_texture_float",
                          "OES_standard_derivatives",
                          // wireframe
                          "angle_instanced_arrays"
                          // VSM shadow map
                        ],
                        optionalExtensions: ["EXT_texture_filter_anisotropic", "EXT_blend_minmax", "WEBGL_depth_texture"],
                        profile: true,
                        onDone: function onDone(err, r2) {
                          if (err || !r2) {
                            reject(err);
                          }
                          resolve(r2);
                        }
                      });
                    });
                  case 5:
                    this.gl = _context4.sent;
                    this.inited = true;
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function init(_x4) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "isFloatSupported",
        value: function isFloatSupported() {
          return this.gl.limits.readFloat;
        }
      }, {
        key: "beginFrame",
        value: function beginFrame() {
        }
      }, {
        key: "endFrame",
        value: function endFrame() {
        }
      }]);
      return WebGLEngine2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/index.js
var init_es3 = __esm({
  "node_modules/@antv/g-webgpu-engine/es/index.js"() {
    init_webgl();
  }
});

// node_modules/@antv/g-webgpu/es/World.js
var World;
var init_World = __esm({
  "node_modules/@antv/g-webgpu/es/World.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_es3();
    init_Kernel();
    World = function() {
      function World2() {
        _classCallCheck5(this, World2);
        this.engine = void 0;
        this.configService = new ConfigService();
      }
      _createClass5(World2, [{
        key: "setConfig",
        value: function setConfig(config) {
          this.configService.set(config);
        }
      }, {
        key: "setEngine",
        value: function setEngine(engine) {
          this.engine = engine;
        }
      }, {
        key: "createEntity",
        value: function createEntity2() {
          return createEntity();
        }
      }, {
        key: "createKernel",
        value: function createKernel(precompiledBundle) {
          var kernel = new Kernel(this.engine, this.configService);
          if (typeof precompiledBundle === "string") {
            kernel.setBundle(JSON.parse(precompiledBundle));
          } else {
            kernel.setBundle(precompiledBundle);
          }
          kernel.init();
          return kernel;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.engine.destroy();
        }
      }], [{
        key: "create",
        value: function create10() {
          var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var world = new World2();
          world.setConfig(config);
          world.setEngine(new WebGLEngine());
          return world;
        }
      }]);
      return World2;
    }();
  }
});

// node_modules/@antv/g-webgpu/es/index.js
var es_exports3 = {};
__export(es_exports3, {
  Kernel: () => Kernel,
  World: () => World
});
var init_es4 = __esm({
  "node_modules/@antv/g-webgpu/es/index.js"() {
    init_Kernel();
    init_World();
  }
});

// node_modules/@antv/layout/lib/util/gpu.js
var require_gpu = __commonJS({
  "node_modules/@antv/layout/lib/util/gpu.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayToTextureData = exports.attributesToTextureData = exports.buildTextureDataWithTwoEdgeAttr = exports.buildTextureData = exports.proccessToFunc = void 0;
    var _1 = require_util2();
    var math_1 = require_math();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function() {
          return defaultV || 1;
        };
      } else if ((0, _1.isNumber)(value)) {
        func = function() {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    exports.proccessToFunc = proccessToFunc3;
    var buildTextureData3 = function(nodes, edges) {
      var dataArray = [];
      var nodeDict = [];
      var mapIdPos = {};
      var i2 = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var n2 = nodes[i2];
        mapIdPos[n2.id] = i2;
        dataArray.push(n2.x);
        dataArray.push(n2.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
      }
      for (i2 = 0; i2 < edges.length; i2++) {
        var e8 = edges[i2];
        var source = (0, math_1.getEdgeTerminal)(e8, "source");
        var target = (0, math_1.getEdgeTerminal)(e8, "target");
        if (!isNaN(mapIdPos[source]) && !isNaN(mapIdPos[target])) {
          nodeDict[mapIdPos[source]].push(mapIdPos[target]);
          nodeDict[mapIdPos[target]].push(mapIdPos[source]);
        }
      }
      var maxEdgePerVetex = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var offset = dataArray.length;
        var dests = nodeDict[i2];
        var len6 = dests.length;
        dataArray[i2 * 4 + 2] = offset;
        dataArray[i2 * 4 + 3] = len6;
        maxEdgePerVetex = Math.max(maxEdgePerVetex, len6);
        for (var j2 = 0; j2 < len6; ++j2) {
          var dest = dests[j2];
          dataArray.push(+dest);
        }
      }
      while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
      }
      return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray)
      };
    };
    exports.buildTextureData = buildTextureData3;
    var buildTextureDataWithTwoEdgeAttr3 = function(nodes, edges, attrs1, attrs2) {
      var dataArray = [];
      var nodeDict = [];
      var mapIdPos = {};
      var i2 = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var n2 = nodes[i2];
        mapIdPos[n2.id] = i2;
        dataArray.push(n2.x);
        dataArray.push(n2.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
      }
      for (i2 = 0; i2 < edges.length; i2++) {
        var e8 = edges[i2];
        var source = (0, math_1.getEdgeTerminal)(e8, "source");
        var target = (0, math_1.getEdgeTerminal)(e8, "target");
        nodeDict[mapIdPos[source]].push(mapIdPos[target]);
        nodeDict[mapIdPos[source]].push(attrs1(e8));
        nodeDict[mapIdPos[source]].push(attrs2(e8));
        nodeDict[mapIdPos[source]].push(0);
        nodeDict[mapIdPos[target]].push(mapIdPos[source]);
        nodeDict[mapIdPos[target]].push(attrs1(e8));
        nodeDict[mapIdPos[target]].push(attrs2(e8));
        nodeDict[mapIdPos[target]].push(0);
      }
      var maxEdgePerVetex = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var offset = dataArray.length;
        var dests = nodeDict[i2];
        var len6 = dests.length;
        dataArray[i2 * 4 + 2] = offset + 1048576 * len6 / 4;
        dataArray[i2 * 4 + 3] = 0;
        maxEdgePerVetex = Math.max(maxEdgePerVetex, len6 / 4);
        for (var j2 = 0; j2 < len6; ++j2) {
          var dest = dests[j2];
          dataArray.push(+dest);
        }
      }
      while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
      }
      return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray)
      };
    };
    exports.buildTextureDataWithTwoEdgeAttr = buildTextureDataWithTwoEdgeAttr3;
    var attributesToTextureData3 = function(attributeNames, items) {
      var dataArray = [];
      var attributeNum = attributeNames.length;
      var attributteStringMap = {};
      items.forEach(function(item) {
        attributeNames.forEach(function(name, i2) {
          if (attributteStringMap[item[name]] === void 0) {
            attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;
          }
          dataArray.push(attributteStringMap[item[name]]);
          if (i2 === attributeNum - 1) {
            while (dataArray.length % 4 !== 0) {
              dataArray.push(0);
            }
          }
        });
      });
      return {
        array: new Float32Array(dataArray),
        count: Object.keys(attributteStringMap).length
      };
    };
    exports.attributesToTextureData = attributesToTextureData3;
    var arrayToTextureData3 = function(valueArrays) {
      var dataArray = [];
      var attributeNum = valueArrays.length;
      var itemNum = valueArrays[0].length;
      var _loop_1 = function(j3) {
        valueArrays.forEach(function(valueArray, i2) {
          dataArray.push(valueArray[j3]);
          if (i2 === attributeNum - 1) {
            while (dataArray.length % 4 !== 0) {
              dataArray.push(0);
            }
          }
        });
      };
      for (var j2 = 0; j2 < itemNum; j2++) {
        _loop_1(j2);
      }
      return new Float32Array(dataArray);
    };
    exports.arrayToTextureData = arrayToTextureData3;
  }
});

// node_modules/@antv/layout/lib/layout/gpu/fruchtermanShader.js
var require_fruchtermanShader = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/fruchtermanShader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clusterBundle = exports.clusterCode = exports.fruchtermanBundle = exports.fruchtermanCode = void 0;
    exports.fruchtermanCode = "\nimport { globalInvocationID } from 'g-webgpu';\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n  @in\n  u_K: float;\n  @in\n  u_K2: float;\n  \n  @in\n  u_Center: vec2;\n  @in\n  u_Gravity: float;\n  @in\n  u_ClusterGravity: float;\n  @in\n  u_Speed: float;\n  @in\n  u_MaxDisplace: float;\n  @in\n  u_Clustering: float;\n  @in\n  u_AttributeArray: vec4[];\n  @in\n  u_ClusterCenters: vec4[];\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = (xDist * xDist + yDist * yDist) + 0.01;\n        let param = this.u_K2 / dist;\n        \n        if (dist > 0.0) {\n          dx += param * xDist;\n          dy += param * yDist;\n          if (xDist == 0 && yDist == 0) {\n            const sign = i < j ? 1 : -1;\n            dx += param * sign;\n            dy += param * sign;\n          }\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // \n    let dx = 0, dy = 0;\n    const vx = currentNode[0] - this.u_Center[0];\n    const vy = currentNode[1] - this.u_Center[1];\n    const gf = 0.01 * this.u_K * this.u_Gravity;\n    dx = gf * vx;\n    dy = gf * vy;\n    if (this.u_Clustering == 1) {\n      const clusterIdx = int(nodeAttributes[0]);\n      const center = this.u_ClusterCenters[clusterIdx];\n      const cvx = currentNode[0] - center[0];\n      const cvy = currentNode[1] - center[1];\n      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.01;\n      const parma = this.u_K * this.u_ClusterGravity / dist;\n      dx += parma * cvx;\n      dy += parma * cvy;\n    }\n    return [dx, dy];\n  }\n  calcAttractive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      let attractiveF = dist / this.u_K;\n    \n      if (dist > 0.0) {\n        dx -= xDist * attractiveF;\n        dy -= yDist * attractiveF;\n        if (xDist == 0 && yDist == 0) {\n          const sign = i < int(float_j) ? 1 : -1;\n          dx -= sign * attractiveF;\n          dy -= sign * attractiveF;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    let dx = 0, dy = 0;\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // [gravity, fx, fy, 0]\n    const nodeAttributes = this.u_AttributeArray[i];\n\n    if (nodeAttributes[1] != 0 && nodeAttributes[2] != 0) {\n      // the node is fixed\n      this.u_Data[i] = [\n        nodeAttributes[1],\n        nodeAttributes[2],\n        currentNode[2],\n        currentNode[3]\n      ];\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n    // gravity\n    const gravity = this.calcGravity(currentNode, nodeAttributes);\n    dx -= gravity[0];\n    dy -= gravity[1];\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n";
    exports.fruchtermanBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_K;\\nuniform float u_K2;\\nuniform vec2 u_Center;\\nuniform float u_Gravity;\\nuniform float u_ClusterGravity;\\nuniform float u_Speed;\\nuniform float u_MaxDisplace;\\nuniform float u_Clustering;\\nuniform sampler2D u_AttributeArray;\\nuniform vec2 u_AttributeArraySize;\\nvec4 getDatau_AttributeArray(vec2 address2D) {\\n  return vec4(texture2D(u_AttributeArray, address2D).rgba);\\n}\\nvec4 getDatau_AttributeArray(float address1D) {\\n  return getDatau_AttributeArray(addrTranslation_1Dto2D(address1D, u_AttributeArraySize));\\n}\\nvec4 getDatau_AttributeArray(int address1D) {\\n  return getDatau_AttributeArray(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat param = u_K2 / dist;\\nif (dist > 0.0) {dx += param * xDist;\\ndy += param * yDist;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\ndx += param * sign;\\ndy += param * sign;}}}}\\nreturn vec2(dx, dy);}\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfloat vx = currentNode.x - u_Center.x;\\nfloat vy = currentNode.y - u_Center.y;\\nfloat gf = (0.01 * u_K) * u_Gravity;\\ndx = gf * vx;\\ndy = gf * vy;\\nif (u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\nvec4 center = getDatau_ClusterCenters(clusterIdx);\\nfloat cvx = currentNode.x - center.x;\\nfloat cvy = currentNode.y - center.y;\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\nfloat parma = (u_K * u_ClusterGravity) / dist;\\ndx += parma * cvx;\\ndy += parma * cvy;}\\nreturn vec2(dx, dy);}\\nvec2 calcAttractive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nint arr_offset = int(floor(currentNode.z + 0.5));\\nint length = int(floor(currentNode.w + 0.5));\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + int(p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat attractiveF = dist / u_K;\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\ndy -= yDist * attractiveF;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\ndx -= sign * attractiveF;\\ndy -= sign * attractiveF;}}}\\nreturn vec2(dx, dy);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes = getDatau_AttributeArray(i);\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w));\\nreturn ;}\\nvec2 repulsive = calcRepulsive(i, currentNode);\\ndx += repulsive.x;\\ndy += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode);\\ndx += attractive.x;\\ndy += attractive.y;\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\ndx -= gravity.x;\\ndy -= gravity.y;\\ndx *= u_Speed;\\ndy *= u_Speed;\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_K","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_K2","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Center","type":"vec2<f32>","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Gravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterGravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Speed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_MaxDisplace","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Clustering","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AttributeArray","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}';
    exports.clusterCode = "\nimport { globalInvocationID } from 'g-webgpu';\nconst VERTEX_COUNT;\nconst CLUSTER_COUNT;\n@numthreads(1, 1, 1)\nclass CalcCenter {\n  @in\n  u_Data: vec4[];\n  @in\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\n  @in @out\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const center = this.u_ClusterCenters[i];\n    let sumx = 0;\n    let sumy = 0;\n    let count = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      const attributes = this.u_NodeAttributes[j];\n      const clusterIdx = int(attributes[0]);\n      const vertex = this.u_Data[j];\n      if (clusterIdx == i) {\n        sumx += vertex.x;\n        sumy += vertex.y;\n        count += 1;\n      }\n    }\n    this.u_ClusterCenters[i] = [\n      sumx / count,\n      sumy / count,\n      count,\n      i\n    ];\n  }\n}\n";
    exports.clusterBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributes;\\nuniform vec2 u_NodeAttributesSize;\\nvec4 getDatau_NodeAttributes(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributes, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributes(float address1D) {\\n  return getDatau_NodeAttributes(addrTranslation_1Dto2D(address1D, u_NodeAttributesSize));\\n}\\nvec4 getDatau_NodeAttributes(int address1D) {\\n  return getDatau_NodeAttributes(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 center = getDatau_ClusterCenters(i);\\nfloat sumx = 0.0;\\nfloat sumy = 0.0;\\nfloat count = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = getDatau_NodeAttributes(j);\\nint clusterIdx = int(attributes.x);\\nvec4 vertex = getDatau_Data(j);\\nif (clusterIdx == i) {sumx += vertex.x;\\nsumy += vertex.y;\\ncount += 1.0;}}\\ngl_FragColor = vec4(vec4(sumx / count, sumy / count, count, i));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"CLUSTER_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributes","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_ClusterCenters","size":[1,1],"length":1},"needPingpong":true}}';
  }
});

// node_modules/@antv/layout/lib/layout/gpu/fruchterman.js
var require_fruchterman2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/fruchterman.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter4 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e8) {
            reject(e8);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e8) {
            reject(e8);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator4 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t4[0] & 1) throw t4[1];
        return t4[1];
      }, trys: [], ops: [] }, f2, y4, t4, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2) throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
          if (f2 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done) return t4;
          if (y4 = 0, t4) op = [op[0] & 2, t4.value];
          switch (op[0]) {
            case 0:
            case 1:
              t4 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y4 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t4[1]) {
                _2.label = t4[1];
                t4 = op;
                break;
              }
              if (t4 && _2.label < t4[2]) {
                _2.label = t4[2];
                _2.ops.push(op);
                break;
              }
              if (t4[2]) _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e8) {
          op = [6, e8];
          y4 = 0;
        } finally {
          f2 = t4 = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FruchtermanGPULayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var g_webgpu_1 = (init_es4(), __toCommonJS(es_exports3));
    var gpu_1 = require_gpu();
    var fruchtermanShader_1 = require_fruchtermanShader();
    var constants_1 = require_constants();
    var FruchtermanGPULayout2 = (
      /** @class */
      function(_super) {
        __extends17(FruchtermanGPULayout3, _super);
        function FruchtermanGPULayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.gravity = 10;
          _this.speed = 1;
          _this.clustering = false;
          _this.clusterField = "cluster";
          _this.clusterGravity = 10;
          _this.workerEnabled = false;
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.updateCfg(options);
          return _this;
        }
        FruchtermanGPULayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 1e3,
            gravity: 10,
            speed: 1,
            clustering: false,
            clusterGravity: 10
          };
        };
        FruchtermanGPULayout3.prototype.execute = function() {
          return __awaiter4(this, void 0, void 0, function() {
            var self2, nodes, center, nodeMap, nodeIdxMap;
            var _this = this;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  if (!nodes || nodes.length === 0) {
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!self2.width && typeof window !== "undefined") {
                    self2.width = window.innerWidth;
                  }
                  if (!self2.height && typeof window !== "undefined") {
                    self2.height = window.innerHeight;
                  }
                  if (!self2.center) {
                    self2.center = [self2.width / 2, self2.height / 2];
                  }
                  center = self2.center;
                  if (nodes.length === 1) {
                    nodes[0].x = center[0];
                    nodes[0].y = center[1];
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  nodeMap = {};
                  nodeIdxMap = {};
                  nodes.forEach(function(node, i2) {
                    if (!(0, util_1.isNumber)(node.x))
                      node.x = Math.random() * _this.width;
                    if (!(0, util_1.isNumber)(node.y))
                      node.y = Math.random() * _this.height;
                    nodeMap[node.id] = node;
                    nodeIdxMap[node.id] = i2;
                  });
                  self2.nodeMap = nodeMap;
                  self2.nodeIdxMap = nodeIdxMap;
                  return [4, self2.run()];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FruchtermanGPULayout3.prototype.executeWithWorker = function(canvas, ctx2) {
          return __awaiter4(this, void 0, void 0, function() {
            var self2, nodes, center, nodeMap, nodeIdxMap;
            var _this = this;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  center = self2.center;
                  if (!nodes || nodes.length === 0) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (nodes.length === 1) {
                    nodes[0].x = center[0];
                    nodes[0].y = center[1];
                    return [
                      2
                      /*return*/
                    ];
                  }
                  nodeMap = {};
                  nodeIdxMap = {};
                  nodes.forEach(function(node, i2) {
                    if (!(0, util_1.isNumber)(node.x))
                      node.x = Math.random() * _this.width;
                    if (!(0, util_1.isNumber)(node.y))
                      node.y = Math.random() * _this.height;
                    nodeMap[node.id] = node;
                    nodeIdxMap[node.id] = i2;
                  });
                  self2.nodeMap = nodeMap;
                  self2.nodeIdxMap = nodeIdxMap;
                  return [4, self2.run(canvas, ctx2)];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FruchtermanGPULayout3.prototype.run = function(canvas, ctx2) {
          return __awaiter4(this, void 0, void 0, function() {
            var self2, nodes, edges, maxIteration, center, area, maxDisplace, k2, k3, speed, clustering, _a2, attributeArray, clusterCount, numParticles, _b, maxEdgePerVetex, nodesEdgesArray, workerEnabled, world, onLayoutEnd, clusterCenters, i2, kernelFruchterman, kernelCluster, execute;
            var _this = this;
            return __generator4(this, function(_c) {
              switch (_c.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  edges = self2.edges;
                  maxIteration = self2.maxIteration;
                  center = self2.center;
                  area = self2.height * self2.width;
                  maxDisplace = Math.sqrt(area) / 10;
                  k2 = area / (nodes.length + 1);
                  k3 = Math.sqrt(k2);
                  speed = self2.speed;
                  clustering = self2.clustering;
                  _a2 = (0, gpu_1.attributesToTextureData)([self2.clusterField], nodes), attributeArray = _a2.array, clusterCount = _a2.count;
                  nodes.forEach(function(node, i3) {
                    var fx = 0;
                    var fy = 0;
                    if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
                      fx = node.fx || 1e-3;
                      fy = node.fy || 1e-3;
                    }
                    attributeArray[4 * i3 + 1] = fx;
                    attributeArray[4 * i3 + 2] = fy;
                  });
                  numParticles = nodes.length;
                  _b = (0, gpu_1.buildTextureData)(nodes, edges), maxEdgePerVetex = _b.maxEdgePerVetex, nodesEdgesArray = _b.array;
                  workerEnabled = self2.workerEnabled;
                  if (workerEnabled) {
                    world = g_webgpu_1.World.create({
                      canvas,
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  } else {
                    world = g_webgpu_1.World.create({
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  }
                  onLayoutEnd = self2.onLayoutEnd;
                  clusterCenters = [];
                  for (i2 = 0; i2 < clusterCount; i2++) {
                    clusterCenters.push(0, 0, 0, 0);
                  }
                  kernelFruchterman = world.createKernel(fruchtermanShader_1.fruchtermanBundle).setDispatch([numParticles, 1, 1]).setBinding({
                    u_Data: nodesEdgesArray,
                    u_K: k3,
                    u_K2: k2,
                    u_Gravity: self2.gravity,
                    u_ClusterGravity: self2.clusterGravity || self2.gravity || 1,
                    u_Speed: speed,
                    u_MaxDisplace: maxDisplace,
                    u_Clustering: clustering ? 1 : 0,
                    u_Center: center,
                    u_AttributeArray: attributeArray,
                    u_ClusterCenters: clusterCenters,
                    MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                    VERTEX_COUNT: numParticles
                  });
                  if (clustering) {
                    kernelCluster = world.createKernel(fruchtermanShader_1.clusterBundle).setDispatch([clusterCount, 1, 1]).setBinding({
                      u_Data: nodesEdgesArray,
                      u_NodeAttributes: attributeArray,
                      u_ClusterCenters: clusterCenters,
                      VERTEX_COUNT: numParticles,
                      CLUSTER_COUNT: clusterCount
                    });
                  }
                  execute = function() {
                    return __awaiter4(_this, void 0, void 0, function() {
                      var i3, finalParticleData;
                      return __generator4(this, function(_a3) {
                        switch (_a3.label) {
                          case 0:
                            i3 = 0;
                            _a3.label = 1;
                          case 1:
                            if (!(i3 < maxIteration)) return [3, 6];
                            return [4, kernelFruchterman.execute()];
                          case 2:
                            _a3.sent();
                            if (!clustering) return [3, 4];
                            kernelCluster.setBinding({
                              u_Data: kernelFruchterman
                            });
                            return [4, kernelCluster.execute()];
                          case 3:
                            _a3.sent();
                            kernelFruchterman.setBinding({
                              u_ClusterCenters: kernelCluster
                            });
                            _a3.label = 4;
                          case 4:
                            kernelFruchterman.setBinding({
                              u_MaxDisplace: maxDisplace *= 0.99
                            });
                            _a3.label = 5;
                          case 5:
                            i3++;
                            return [3, 1];
                          case 6:
                            return [4, kernelFruchterman.getOutput()];
                          case 7:
                            finalParticleData = _a3.sent();
                            if (canvas) {
                              ctx2.postMessage({
                                type: constants_1.LAYOUT_MESSAGE.GPUEND,
                                vertexEdgeData: finalParticleData
                                // edgeIndexBufferData,
                              });
                            } else {
                              nodes.forEach(function(node, i4) {
                                var x4 = finalParticleData[4 * i4];
                                var y4 = finalParticleData[4 * i4 + 1];
                                node.x = x4;
                                node.y = y4;
                              });
                            }
                            if (onLayoutEnd)
                              onLayoutEnd();
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  };
                  return [4, execute()];
                case 1:
                  _c.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FruchtermanGPULayout3.prototype.getType = function() {
          return "fruchterman-gpu";
        };
        return FruchtermanGPULayout3;
      }(base_1.Base)
    );
    exports.FruchtermanGPULayout = FruchtermanGPULayout2;
  }
});

// node_modules/@antv/layout/lib/layout/gpu/gForceShader.js
var require_gForceShader = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/gForceShader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aveMovementBundle = exports.aveMovementCode = exports.gForceBundle = exports.gForceCode = void 0;
    exports.gForceCode = "\nimport { globalInvocationID } from 'g-webgpu';\n\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\nconst SHIFT_20 = 1048576;\n\n@numthreads(1, 1, 1)\nclass GGForce {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_damping: float;\n  \n  @in\n  u_maxSpeed: float;\n\n  @in\n  u_minMovement: float;\n\n  @in\n  u_AveMovement: vec4[];\n\n  @in\n  u_coulombDisScale: float;\n\n  @in\n  u_factor: float;\n\n  @in\n  u_NodeAttributeArray1: vec4[];\n\n  @in\n  u_NodeAttributeArray2: vec4[];\n\n  @in\n  u_interval: float;\n\n  unpack_float(packedValue: float): ivec2 {\n    const packedIntValue = int(packedValue);\n    const v0 = packedIntValue / SHIFT_20;\n    return [v0, packedIntValue - v0 * SHIFT_20];\n  }\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let ax = 0, ay = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const vx = currentNode[0] - nextNode[0];\n        const vy = currentNode[1] - nextNode[1];\n        const dist = sqrt(vx * vx + vy * vy) + 0.01;\n        const n_dist = (dist + 0.1) * this.u_coulombDisScale;\n        const direx = vx / dist;\n        const direy = vy / dist;\n        const attributesi = this.u_NodeAttributeArray1[i];\n        const attributesj = this.u_NodeAttributeArray1[j];\n        const massi = attributesi[0];\n        const nodeStrengthi = attributesi[2];\n        const nodeStrengthj = attributesj[2];\n        const nodeStrength = (nodeStrengthi + nodeStrengthj) / 2;\n        // const param = nodeStrength * this.u_factor / (n_dist * n_dist * massi);\n        const param = nodeStrength * this.u_factor / (n_dist * n_dist);\n        ax += direx * param;\n        ay += direy * param;\n      }\n    }\n    return [ax, ay];\n  }\n\n  calcGravity(i: int, currentNode: vec4, attributes2: vec4): vec2 {\n    // note: attributes2 = [centerX, centerY, gravity, 0]\n\n    const vx = currentNode[0] - attributes2[0];\n    const vy = currentNode[1] - attributes2[1];\n    \n    const ax = vx * attributes2[2];\n    const ay = vy * attributes2[2];\n    \n    return [ax, ay];\n  }\n\n  calcAttractive(i: int, currentNode: vec4, attributes1: vec4): vec2 {\n    // note: attributes1 = [mass, degree, nodeSterngth, 0]\n\n    const mass = attributes1[0];\n    let ax = 0, ay = 0;\n    // const arr_offset = int(floor(currentNode[2] + 0.5));\n    // const length = int(floor(currentNode[3] + 0.5));\n\n    const compressed = this.unpack_float(currentNode[2]);\n    const length = compressed[0];\n    const arr_offset = compressed[1];\n\n    const node_buffer: vec4;\n    for (let p: int = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + 4 * p; // i 节点的第 p 条边开始的小格子位置\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)]; // 大格子，大格子位置=小个子位置 / 4，\n      }\n\n      let float_j: float = node_buffer[0];\n\n      const nextNode = this.u_Data[int(float_j)];\n      const vx = nextNode[0] - currentNode[0];\n      const vy = nextNode[1] - currentNode[1];\n      const dist = sqrt(vx * vx + vy * vy) + 0.01;\n      const direx = vx / dist;\n      const direy = vy / dist;\n      const edgeLength = node_buffer[1];\n      const edgeStrength = node_buffer[2];\n      const diff: float = edgeLength - dist;//edgeLength\n      // const param = diff * this.u_stiffness / mass; //\n      const param = diff * edgeStrength / mass; // \n      ax -= direx * param;\n      ay -= direy * param;\n    }\n    return [ax, ay];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    const movement = u_AveMovement[0];\n    let ax = 0, ay = 0;\n\n    if (i >= VERTEX_COUNT || movement.x < u_minMovement) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // 每个节点属性占两个数组中各一格\n    // [mass, degree, nodeStrength, fx]\n    const nodeAttributes1 = this.u_NodeAttributeArray1[i];\n    // [centerX, centerY, centerGravity, fy]\n    const nodeAttributes2 = this.u_NodeAttributeArray2[i];\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    ax += repulsive[0];\n    ay += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode, nodeAttributes1);\n    ax += attractive[0];\n    ay += attractive[1];\n\n    // gravity\n    const gravity = this.calcGravity(i, currentNode, nodeAttributes2);\n    ax -= gravity[0];\n    ay -= gravity[1];\n\n    // speed\n    const param = this.u_interval * this.u_damping;\n    let vx = ax * param;\n    let vy = ay * param;\n    const vlength = sqrt(vx * vx + vy * vy) + 0.0001;\n    if (vlength > this.u_maxSpeed) {\n      const param2 = this.u_maxSpeed / vlength;\n      vx = param2 * vx;\n      vy = param2 * vy;\n    }\n\n    // move\n    if (nodeAttributes1[3] != 0 && nodeAttributes2[3] != 0) {\n      this.u_Data[i] = [\n        nodeAttributes1[3],\n        nodeAttributes2[3],\n        currentNode[2],\n        0\n      ];\n    } else {\n      const distx = vx * this.u_interval;\n      const disty = vy * this.u_interval;\n      const distLength = sqrt(distx * distx + disty * disty);\n      this.u_Data[i] = [\n        currentNode[0] + distx,\n        currentNode[1] + disty,\n        currentNode[2],\n        distLength\n      ];\n    }\n    \n    // the avarage move distance\n    // need to share memory\n    \n  }\n}\n";
    exports.gForceBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define SHIFT_20 1048576.0\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_damping;\\nuniform float u_maxSpeed;\\nuniform float u_minMovement;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nuniform float u_coulombDisScale;\\nuniform float u_factor;\\nuniform sampler2D u_NodeAttributeArray1;\\nuniform vec2 u_NodeAttributeArray1Size;\\nvec4 getDatau_NodeAttributeArray1(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray1, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray1(float address1D) {\\n  return getDatau_NodeAttributeArray1(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray1Size));\\n}\\nvec4 getDatau_NodeAttributeArray1(int address1D) {\\n  return getDatau_NodeAttributeArray1(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributeArray2;\\nuniform vec2 u_NodeAttributeArray2Size;\\nvec4 getDatau_NodeAttributeArray2(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray2, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray2(float address1D) {\\n  return getDatau_NodeAttributeArray2(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray2Size));\\n}\\nvec4 getDatau_NodeAttributeArray2(int address1D) {\\n  return getDatau_NodeAttributeArray2(float(address1D));\\n}\\nuniform float u_interval;\\nivec2 unpack_float(float packedValue) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint packedIntValue = int(packedValue);\\nint v0 = packedIntValue / int(SHIFT_20);\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat vx = currentNode.x - nextNode.x;\\nfloat vy = currentNode.y - nextNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat n_dist = (dist + 0.1) * u_coulombDisScale;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nvec4 attributesi = getDatau_NodeAttributeArray1(i);\\nvec4 attributesj = getDatau_NodeAttributeArray1(j);\\nfloat massi = attributesi.x;\\nfloat nodeStrengthi = attributesi.z;\\nfloat nodeStrengthj = attributesj.z;\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\nfloat param = (nodeStrength * u_factor) / (n_dist * n_dist);\\nax += direx * param;\\nay += direy * param;}}\\nreturn vec2(ax, ay);}\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat vx = currentNode.x - attributes2.x;\\nfloat vy = currentNode.y - attributes2.y;\\nfloat ax = vx * attributes2.z;\\nfloat ay = vy * attributes2.z;\\nreturn vec2(ax, ay);}\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat mass = attributes1.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nivec2 compressed = unpack_float(currentNode.z);\\nint length = compressed.x;\\nint arr_offset = compressed.y;\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + (4 * p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = node_buffer.x;\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat vx = nextNode.x - currentNode.x;\\nfloat vy = nextNode.y - currentNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nfloat edgeLength = node_buffer.y;\\nfloat edgeStrength = node_buffer.z;\\nfloat diff = edgeLength - dist;\\nfloat param = (diff * edgeStrength) / mass;\\nax -= direx * param;\\nay -= direy * param;}\\nreturn vec2(ax, ay);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nvec4 movement = getDatau_AveMovement(0.0);\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nif ((i >= VERTEX_COUNT) || (movement.x < u_minMovement)) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes1 = getDatau_NodeAttributeArray1(i);\\nvec4 nodeAttributes2 = getDatau_NodeAttributeArray2(i);\\nvec2 repulsive = calcRepulsive(i, currentNode);\\nax += repulsive.x;\\nay += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\nax += attractive.x;\\nay += attractive.y;\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\nax -= gravity.x;\\nay -= gravity.y;\\nfloat param = u_interval * u_damping;\\nfloat vx = ax * param;\\nfloat vy = ay * param;\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\nif (vlength > u_maxSpeed) {float param2 = u_maxSpeed / vlength;\\nvx = param2 * vx;\\nvy = param2 * vy;}\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0));}else {float distx = vx * u_interval;\\nfloat disty = vy * u_interval;\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\ngl_FragColor = vec4(vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"SHIFT_20","type":"Float","value":1048576,"runtime":false}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_damping","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_maxSpeed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_minMovement","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_coulombDisScale","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_factor","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray1","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray2","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_interval","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}';
    exports.aveMovementCode = "\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass CalcAveMovement {\n  @in\n  u_Data: vec4[];\n  @in\n  u_iter: float;\n  @in @out\n  u_AveMovement: vec4[];\n  @main\n  compute() {\n    let movement = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      const vertex = this.u_Data[j];\n      movement += vertex[3];\n    }\n    movement = movement / float(VERTEX_COUNT);\n    this.u_AveMovement[0] = [movement, 0, 0, 0];\n  }\n}\n";
    exports.aveMovementBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_iter;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat movement = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = getDatau_Data(j);\\nmovement += vertex.w;}\\nmovement = movement / float(VERTEX_COUNT);\\ngl_FragColor = vec4(vec4(movement, 0.0, 0.0, 0.0));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_iter","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_AveMovement","size":[1,1],"length":1},"needPingpong":true}}';
  }
});

// node_modules/@antv/layout/lib/layout/gpu/gForce.js
var require_gForce2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/gForce.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter4 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e8) {
            reject(e8);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e8) {
            reject(e8);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator4 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t4[0] & 1) throw t4[1];
        return t4[1];
      }, trys: [], ops: [] }, f2, y4, t4, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2) throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
          if (f2 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done) return t4;
          if (y4 = 0, t4) op = [op[0] & 2, t4.value];
          switch (op[0]) {
            case 0:
            case 1:
              t4 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y4 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t4[1]) {
                _2.label = t4[1];
                t4 = op;
                break;
              }
              if (t4 && _2.label < t4[2]) {
                _2.label = t4[2];
                _2.ops.push(op);
                break;
              }
              if (t4[2]) _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e8) {
          op = [6, e8];
          y4 = 0;
        } finally {
          f2 = t4 = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GForceGPULayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var g_webgpu_1 = (init_es4(), __toCommonJS(es_exports3));
    var gpu_1 = require_gpu();
    var math_1 = require_math();
    var gForceShader_1 = require_gForceShader();
    var constants_1 = require_constants();
    var GForceGPULayout2 = (
      /** @class */
      function(_super) {
        __extends17(GForceGPULayout3, _super);
        function GForceGPULayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.edgeStrength = 200;
          _this.nodeStrength = 1e3;
          _this.coulombDisScale = 5e-3;
          _this.damping = 0.9;
          _this.maxSpeed = 1e3;
          _this.minMovement = 0.5;
          _this.interval = 0.02;
          _this.factor = 1;
          _this.linkDistance = 1;
          _this.gravity = 10;
          _this.workerEnabled = false;
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.updateCfg(options);
          return _this;
        }
        GForceGPULayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 2e3,
            gravity: 10,
            clustering: false,
            clusterGravity: 10
          };
        };
        GForceGPULayout3.prototype.execute = function() {
          return __awaiter4(this, void 0, void 0, function() {
            var self2, nodes, center, nodeMap, nodeIdxMap;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  if (!nodes || nodes.length === 0) {
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!self2.width && typeof window !== "undefined") {
                    self2.width = window.innerWidth;
                  }
                  if (!self2.height && typeof window !== "undefined") {
                    self2.height = window.innerHeight;
                  }
                  if (!self2.center) {
                    self2.center = [self2.width / 2, self2.height / 2];
                  }
                  center = self2.center;
                  if (nodes.length === 1) {
                    nodes[0].x = center[0];
                    nodes[0].y = center[1];
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  nodeMap = {};
                  nodeIdxMap = {};
                  nodes.forEach(function(node, i2) {
                    if (!(0, util_1.isNumber)(node.x))
                      node.x = Math.random() * self2.width;
                    if (!(0, util_1.isNumber)(node.y))
                      node.y = Math.random() * self2.height;
                    nodeMap[node.id] = node;
                    nodeIdxMap[node.id] = i2;
                  });
                  self2.nodeMap = nodeMap;
                  self2.nodeIdxMap = nodeIdxMap;
                  self2.nodeStrength = (0, gpu_1.proccessToFunc)(self2.nodeStrength, 1);
                  self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength, 1);
                  return [4, self2.run()];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        GForceGPULayout3.prototype.executeWithWorker = function(canvas, ctx2) {
          var self2 = this;
          var nodes = self2.nodes;
          var center = self2.center;
          if (!nodes || nodes.length === 0) {
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            return;
          }
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * self2.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * self2.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          self2.nodeStrength = (0, gpu_1.proccessToFunc)(self2.nodeStrength, 1);
          self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength, 1);
          self2.run(canvas, ctx2);
        };
        GForceGPULayout3.prototype.run = function(canvas, ctx2) {
          return __awaiter4(this, void 0, void 0, function() {
            var self2, nodes, edges, maxIteration, numParticles, _a2, maxEdgePerVetex, nodesEdgesArray, masses, nodeStrengths, centerXs, centerYs, centerGravities, fxs, fys, gravity, center, nodeAttributeArray1, nodeAttributeArray2, workerEnabled, world, onLayoutEnd, initPreviousData, i2, kernelGForce, kernelAveMovement, execute;
            var _this = this;
            return __generator4(this, function(_b) {
              switch (_b.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  edges = self2.edges;
                  maxIteration = self2.maxIteration;
                  if (!self2.width && typeof window !== "undefined") {
                    self2.width = window.innerWidth;
                  }
                  if (!self2.height && typeof window !== "undefined") {
                    self2.height = window.innerHeight;
                  }
                  numParticles = nodes.length;
                  self2.linkDistance = (0, gpu_1.proccessToFunc)(self2.linkDistance);
                  self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength);
                  _a2 = (0, gpu_1.buildTextureDataWithTwoEdgeAttr)(nodes, edges, self2.linkDistance, self2.edgeStrength), maxEdgePerVetex = _a2.maxEdgePerVetex, nodesEdgesArray = _a2.array;
                  self2.degrees = (0, math_1.getDegree)(nodes.length, self2.nodeIdxMap, edges).map(function(degree4) {
                    return degree4.all;
                  });
                  masses = [];
                  nodeStrengths = [];
                  centerXs = [];
                  centerYs = [];
                  centerGravities = [];
                  fxs = [];
                  fys = [];
                  if (!self2.getMass) {
                    self2.getMass = function(d2) {
                      return self2.degrees[self2.nodeIdxMap[d2.id]] || 1;
                    };
                  }
                  gravity = self2.gravity;
                  center = self2.center;
                  nodes.forEach(function(node, i3) {
                    masses.push(self2.getMass(node));
                    nodeStrengths.push(self2.nodeStrength(node));
                    if (!self2.degrees[i3])
                      self2.degrees[i3] = 0;
                    var nodeGravity = [center[0], center[1], gravity];
                    if (self2.getCenter) {
                      var customCenter = self2.getCenter(node, self2.degrees[i3]);
                      if (customCenter && (0, util_1.isNumber)(customCenter[0]) && (0, util_1.isNumber)(customCenter[1]) && (0, util_1.isNumber)(customCenter[2])) {
                        nodeGravity = customCenter;
                      }
                    }
                    centerXs.push(nodeGravity[0]);
                    centerYs.push(nodeGravity[1]);
                    centerGravities.push(nodeGravity[2]);
                    if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
                      fxs.push(node.fx || 1e-3);
                      fys.push(node.fy || 1e-3);
                    } else {
                      fxs.push(0);
                      fys.push(0);
                    }
                  });
                  nodeAttributeArray1 = (0, gpu_1.arrayToTextureData)([
                    masses,
                    self2.degrees,
                    nodeStrengths,
                    fxs
                  ]);
                  nodeAttributeArray2 = (0, gpu_1.arrayToTextureData)([
                    centerXs,
                    centerYs,
                    centerGravities,
                    fys
                  ]);
                  workerEnabled = self2.workerEnabled;
                  if (workerEnabled) {
                    world = g_webgpu_1.World.create({
                      canvas,
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  } else {
                    world = g_webgpu_1.World.create({
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  }
                  onLayoutEnd = self2.onLayoutEnd;
                  initPreviousData = [];
                  nodesEdgesArray.forEach(function(value) {
                    initPreviousData.push(value);
                  });
                  for (i2 = 0; i2 < 4; i2++) {
                    initPreviousData.push(0);
                  }
                  kernelGForce = world.createKernel(gForceShader_1.gForceBundle).setDispatch([numParticles, 1, 1]).setBinding({
                    u_Data: nodesEdgesArray,
                    u_damping: self2.damping,
                    u_maxSpeed: self2.maxSpeed,
                    u_minMovement: self2.minMovement,
                    u_coulombDisScale: self2.coulombDisScale,
                    u_factor: self2.factor,
                    u_NodeAttributeArray1: nodeAttributeArray1,
                    u_NodeAttributeArray2: nodeAttributeArray2,
                    MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                    VERTEX_COUNT: numParticles,
                    u_AveMovement: initPreviousData,
                    u_interval: self2.interval
                    // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新
                  });
                  kernelAveMovement = world.createKernel(gForceShader_1.aveMovementBundle).setDispatch([1, 1, 1]).setBinding({
                    u_Data: nodesEdgesArray,
                    VERTEX_COUNT: numParticles,
                    u_AveMovement: [0, 0, 0, 0]
                  });
                  execute = function() {
                    return __awaiter4(_this, void 0, void 0, function() {
                      var i3, stepInterval, finalParticleData;
                      return __generator4(this, function(_a3) {
                        switch (_a3.label) {
                          case 0:
                            i3 = 0;
                            _a3.label = 1;
                          case 1:
                            if (!(i3 < maxIteration)) return [3, 5];
                            return [4, kernelGForce.execute()];
                          case 2:
                            _a3.sent();
                            kernelAveMovement.setBinding({
                              u_Data: kernelGForce
                            });
                            return [4, kernelAveMovement.execute()];
                          case 3:
                            _a3.sent();
                            stepInterval = Math.max(0.02, self2.interval - i3 * 2e-3);
                            kernelGForce.setBinding({
                              u_interval: stepInterval,
                              u_AveMovement: kernelAveMovement
                            });
                            _a3.label = 4;
                          case 4:
                            i3++;
                            return [3, 1];
                          case 5:
                            return [4, kernelGForce.getOutput()];
                          case 6:
                            finalParticleData = _a3.sent();
                            if (canvas) {
                              ctx2.postMessage({
                                type: constants_1.LAYOUT_MESSAGE.GPUEND,
                                vertexEdgeData: finalParticleData
                                // edgeIndexBufferData,
                              });
                            } else {
                              nodes.forEach(function(node, i4) {
                                var x4 = finalParticleData[4 * i4];
                                var y4 = finalParticleData[4 * i4 + 1];
                                node.x = x4;
                                node.y = y4;
                              });
                            }
                            if (onLayoutEnd)
                              onLayoutEnd();
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  };
                  return [4, execute()];
                case 1:
                  _b.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        GForceGPULayout3.prototype.getType = function() {
          return "gForce-gpu";
        };
        return GForceGPULayout3;
      }(base_1.Base)
    );
    exports.GForceGPULayout = GForceGPULayout2;
  }
});

// node_modules/@antv/layout/lib/layout/comboForce.js
var require_comboForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/comboForce.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboForceLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var ComboForceLayout2 = (
      /** @class */
      function(_super) {
        __extends17(ComboForceLayout3, _super);
        function ComboForceLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.maxIteration = 100;
          _this.gravity = 10;
          _this.comboGravity = 10;
          _this.linkDistance = 10;
          _this.alpha = 1;
          _this.alphaMin = 1e-3;
          _this.alphaDecay = 1 - Math.pow(_this.alphaMin, 1 / 300);
          _this.alphaTarget = 0;
          _this.velocityDecay = 0.6;
          _this.edgeStrength = 0.6;
          _this.nodeStrength = 30;
          _this.preventOverlap = false;
          _this.preventNodeOverlap = false;
          _this.preventComboOverlap = false;
          _this.collideStrength = void 0;
          _this.nodeCollideStrength = 0.5;
          _this.comboCollideStrength = 0.5;
          _this.comboSpacing = 20;
          _this.comboPadding = 10;
          _this.optimizeRangeFactor = 1;
          _this.onTick = function() {
          };
          _this.onLayoutEnd = function() {
          };
          _this.depthAttractiveForceScale = 1;
          _this.depthRepulsiveForceScale = 2;
          _this.nodes = [];
          _this.edges = [];
          _this.combos = [];
          _this.comboTrees = [];
          _this.width = 300;
          _this.height = 300;
          _this.bias = [];
          _this.nodeMap = {};
          _this.oriComboMap = {};
          _this.indexMap = {};
          _this.comboMap = {};
          _this.previousLayouted = false;
          _this.updateCfg(options);
          return _this;
        }
        ComboForceLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 100,
            center: [0, 0],
            gravity: 10,
            speed: 1,
            comboGravity: 30,
            preventOverlap: false,
            preventComboOverlap: true,
            preventNodeOverlap: true,
            nodeSpacing: void 0,
            collideStrength: void 0,
            nodeCollideStrength: 0.5,
            comboCollideStrength: 0.5,
            comboSpacing: 20,
            comboPadding: 10,
            edgeStrength: 0.6,
            nodeStrength: 30,
            linkDistance: 10
          };
        };
        ComboForceLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var center = self2.center;
          self2.comboTree = {
            id: "comboTreeRoot",
            depth: -1,
            children: self2.comboTrees
          };
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          self2.initVals();
          self2.run();
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
        };
        ComboForceLayout3.prototype.run = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var maxIteration = self2.previousLayouted ? self2.maxIteration / 5 : self2.maxIteration;
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          var center = self2.center;
          var velocityDecay = self2.velocityDecay;
          var comboMap = self2.comboMap;
          if (!self2.previousLayouted)
            self2.initPos(comboMap);
          var _loop_1 = function(i3) {
            var displacements = [];
            nodes.forEach(function(_2, j2) {
              displacements[j2] = { x: 0, y: 0 };
            });
            self2.applyCalculate(displacements);
            self2.applyComboCenterForce(displacements);
            nodes.forEach(function(n2, j2) {
              if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
                return;
              n2.x += displacements[j2].x * velocityDecay;
              n2.y += displacements[j2].y * velocityDecay;
            });
            self2.alpha += (self2.alphaTarget - self2.alpha) * self2.alphaDecay;
            self2.onTick();
          };
          for (var i2 = 0; i2 < maxIteration; i2++) {
            _loop_1(i2);
          }
          var meanCenter = [0, 0];
          nodes.forEach(function(n2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            meanCenter[0] += n2.x;
            meanCenter[1] += n2.y;
          });
          meanCenter[0] /= nodes.length;
          meanCenter[1] /= nodes.length;
          var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];
          nodes.forEach(function(n2, j2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            n2.x += centerOffset[0];
            n2.y += centerOffset[1];
          });
          self2.combos.forEach(function(combo) {
            var mapped = comboMap[combo.id];
            if (mapped && mapped.empty) {
              combo.x = mapped.cx || combo.x;
              combo.y = mapped.cy || combo.y;
            }
          });
          self2.previousLayouted = true;
        };
        ComboForceLayout3.prototype.initVals = function() {
          var self2 = this;
          var edges = self2.edges;
          var nodes = self2.nodes;
          var combos = self2.combos;
          var count = {};
          var nodeMap = {};
          var indexMap = {};
          nodes.forEach(function(node, i3) {
            nodeMap[node.id] = node;
            indexMap[node.id] = i3;
          });
          self2.nodeMap = nodeMap;
          self2.indexMap = indexMap;
          var oriComboMap = {};
          combos.forEach(function(combo) {
            oriComboMap[combo.id] = combo;
          });
          self2.oriComboMap = oriComboMap;
          self2.comboMap = self2.getComboMap();
          var preventOverlap = self2.preventOverlap;
          self2.preventComboOverlap = self2.preventComboOverlap || preventOverlap;
          self2.preventNodeOverlap = self2.preventNodeOverlap || preventOverlap;
          var collideStrength = self2.collideStrength;
          if (collideStrength) {
            self2.comboCollideStrength = collideStrength;
            self2.nodeCollideStrength = collideStrength;
          }
          self2.comboCollideStrength = self2.comboCollideStrength ? self2.comboCollideStrength : 0;
          self2.nodeCollideStrength = self2.nodeCollideStrength ? self2.nodeCollideStrength : 0;
          for (var i2 = 0; i2 < edges.length; ++i2) {
            var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
            var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
            if (count[source])
              count[source]++;
            else
              count[source] = 1;
            if (count[target])
              count[target]++;
            else
              count[target] = 1;
          }
          var bias = [];
          for (var i2 = 0; i2 < edges.length; ++i2) {
            var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
            var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
            bias[i2] = count[source] / (count[source] + count[target]);
          }
          this.bias = bias;
          var nodeSize = self2.nodeSize;
          var nodeSpacing = self2.nodeSpacing;
          var nodeSizeFunc;
          var nodeSpacingFunc;
          if ((0, util_1.isNumber)(nodeSpacing)) {
            nodeSpacingFunc = function() {
              return nodeSpacing;
            };
          } else if ((0, util_1.isFunction)(nodeSpacing)) {
            nodeSpacingFunc = nodeSpacing;
          } else {
            nodeSpacingFunc = function() {
              return 0;
            };
          }
          this.nodeSpacing = nodeSpacingFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                  return res / 2;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                  return res / 2;
                }
                return d2.size / 2;
              }
              return 10;
            };
          } else if ((0, util_1.isFunction)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              return nodeSize(d2);
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            var radius_1 = larger / 2;
            nodeSizeFunc = function(d2) {
              return radius_1;
            };
          } else {
            var radius_2 = nodeSize / 2;
            nodeSizeFunc = function(d2) {
              return radius_2;
            };
          }
          this.nodeSize = nodeSizeFunc;
          var comboSpacing = self2.comboSpacing;
          var comboSpacingFunc;
          if ((0, util_1.isNumber)(comboSpacing)) {
            comboSpacingFunc = function() {
              return comboSpacing;
            };
          } else if ((0, util_1.isFunction)(comboSpacing)) {
            comboSpacingFunc = comboSpacing;
          } else {
            comboSpacingFunc = function() {
              return 0;
            };
          }
          this.comboSpacing = comboSpacingFunc;
          var comboPadding = self2.comboPadding;
          var comboPaddingFunc;
          if ((0, util_1.isNumber)(comboPadding)) {
            comboPaddingFunc = function() {
              return comboPadding;
            };
          } else if ((0, util_1.isArray)(comboPadding)) {
            comboPaddingFunc = function() {
              return Math.max.apply(null, comboPadding);
            };
          } else if ((0, util_1.isFunction)(comboPadding)) {
            comboPaddingFunc = comboPadding;
          } else {
            comboPaddingFunc = function() {
              return 0;
            };
          }
          this.comboPadding = comboPaddingFunc;
          var linkDistance = this.linkDistance;
          var linkDistanceFunc;
          if (!linkDistance) {
            linkDistance = 10;
          }
          if ((0, util_1.isNumber)(linkDistance)) {
            linkDistanceFunc = function(d2) {
              return linkDistance;
            };
          } else {
            linkDistanceFunc = linkDistance;
          }
          this.linkDistance = linkDistanceFunc;
          var edgeStrength = this.edgeStrength;
          var edgeStrengthFunc;
          if (!edgeStrength) {
            edgeStrength = 1;
          }
          if ((0, util_1.isNumber)(edgeStrength)) {
            edgeStrengthFunc = function(d2) {
              return edgeStrength;
            };
          } else {
            edgeStrengthFunc = edgeStrength;
          }
          this.edgeStrength = edgeStrengthFunc;
          var nodeStrength = this.nodeStrength;
          var nodeStrengthFunc;
          if (!nodeStrength) {
            nodeStrength = 30;
          }
          if ((0, util_1.isNumber)(nodeStrength)) {
            nodeStrengthFunc = function(d2) {
              return nodeStrength;
            };
          } else {
            nodeStrengthFunc = nodeStrength;
          }
          this.nodeStrength = nodeStrengthFunc;
        };
        ComboForceLayout3.prototype.initPos = function(comboMap) {
          var self2 = this;
          var nodes = self2.nodes;
          nodes.forEach(function(node, i2) {
            var comboId = node.comboId;
            var combo = comboMap[comboId];
            if (comboId && combo) {
              node.x = combo.cx + 100 / (i2 + 1);
              node.y = combo.cy + 100 / (i2 + 1);
            } else {
              node.x = 100 / (i2 + 1);
              node.y = 100 / (i2 + 1);
            }
          });
        };
        ComboForceLayout3.prototype.getComboMap = function() {
          var self2 = this;
          var nodeMap = self2.nodeMap;
          var comboTrees = self2.comboTrees;
          var oriComboMap = self2.oriComboMap;
          var comboMap = {};
          (comboTrees || []).forEach(function(ctree) {
            var treeChildren = [];
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              if (treeNode.itemType === "node")
                return true;
              if (!oriComboMap[treeNode.id])
                return true;
              if (comboMap[treeNode.id] === void 0) {
                var combo = {
                  id: treeNode.id,
                  name: treeNode.id,
                  cx: 0,
                  cy: 0,
                  count: 0,
                  depth: self2.oriComboMap[treeNode.id].depth || 0,
                  children: []
                };
                comboMap[treeNode.id] = combo;
              }
              var children = treeNode.children;
              if (children) {
                children.forEach(function(child) {
                  if (!comboMap[child.id] && !nodeMap[child.id])
                    return true;
                  treeChildren.push(child);
                });
              }
              var c3 = comboMap[treeNode.id];
              c3.cx = 0;
              c3.cy = 0;
              if (treeChildren.length === 0) {
                c3.empty = true;
                var oriCombo = oriComboMap[treeNode.id];
                c3.cx = oriCombo.x;
                c3.cy = oriCombo.y;
              }
              treeChildren.forEach(function(child) {
                c3.count++;
                if (child.itemType !== "node") {
                  var childCombo = comboMap[child.id];
                  if ((0, util_1.isNumber)(childCombo.cx))
                    c3.cx += childCombo.cx;
                  if ((0, util_1.isNumber)(childCombo.cy))
                    c3.cy += childCombo.cy;
                  return;
                }
                var node = nodeMap[child.id];
                if (!node)
                  return;
                if ((0, util_1.isNumber)(node.x)) {
                  c3.cx += node.x;
                }
                if ((0, util_1.isNumber)(node.y)) {
                  c3.cy += node.y;
                }
              });
              c3.cx /= c3.count || 1;
              c3.cy /= c3.count || 1;
              c3.children = treeChildren;
              return true;
            });
          });
          return comboMap;
        };
        ComboForceLayout3.prototype.applyComboCenterForce = function(displacements) {
          var self2 = this;
          var gravity = self2.gravity;
          var comboGravity = self2.comboGravity || gravity;
          var alpha = this.alpha;
          var comboTrees = self2.comboTrees;
          var indexMap = self2.indexMap;
          var nodeMap = self2.nodeMap;
          var comboMap = self2.comboMap;
          (comboTrees || []).forEach(function(ctree) {
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              if (treeNode.itemType === "node")
                return true;
              var combo = comboMap[treeNode.id];
              if (!combo)
                return true;
              var c3 = comboMap[treeNode.id];
              var gravityScale = (c3.depth + 1) / 10 * 0.5;
              var comboX = c3.cx;
              var comboY = c3.cy;
              c3.cx = 0;
              c3.cy = 0;
              c3.children.forEach(function(child) {
                if (child.itemType !== "node") {
                  var childCombo = comboMap[child.id];
                  if (childCombo && (0, util_1.isNumber)(childCombo.cx))
                    c3.cx += childCombo.cx;
                  if (childCombo && (0, util_1.isNumber)(childCombo.cy))
                    c3.cy += childCombo.cy;
                  return;
                }
                var node = nodeMap[child.id];
                var vecX = node.x - comboX || 5e-3;
                var vecY = node.y - comboY || 5e-3;
                var l2 = Math.sqrt(vecX * vecX + vecY * vecY);
                var childIdx = indexMap[node.id];
                var params = comboGravity * alpha / l2 * gravityScale;
                displacements[childIdx].x -= vecX * params;
                displacements[childIdx].y -= vecY * params;
                if ((0, util_1.isNumber)(node.x))
                  c3.cx += node.x;
                if ((0, util_1.isNumber)(node.y))
                  c3.cy += node.y;
              });
              c3.cx /= c3.count || 1;
              c3.cy /= c3.count || 1;
              return true;
            });
          });
        };
        ComboForceLayout3.prototype.applyCalculate = function(displacements) {
          var self2 = this;
          var comboMap = self2.comboMap;
          var nodes = self2.nodes;
          var vecMap = {};
          nodes.forEach(function(v2, i2) {
            nodes.forEach(function(u2, j2) {
              if (i2 < j2)
                return;
              var vx = v2.x - u2.x || 5e-3;
              var vy = v2.y - u2.y || 5e-3;
              var vl2 = vx * vx + vy * vy;
              var vl = Math.sqrt(vl2);
              if (vl2 < 1)
                vl2 = vl;
              vecMap["".concat(v2.id, "-").concat(u2.id)] = { vx, vy, vl2, vl };
              vecMap["".concat(u2.id, "-").concat(v2.id)] = { vl2, vl, vx: -vx, vy: -vy };
            });
          });
          self2.updateComboSizes(comboMap);
          self2.calRepulsive(displacements, vecMap);
          self2.calAttractive(displacements, vecMap);
          var preventComboOverlap = self2.preventComboOverlap;
          if (preventComboOverlap)
            self2.comboNonOverlapping(displacements, comboMap);
        };
        ComboForceLayout3.prototype.updateComboSizes = function(comboMap) {
          var self2 = this;
          var comboTrees = self2.comboTrees;
          var nodeMap = self2.nodeMap;
          var nodeSize = self2.nodeSize;
          var comboSpacing = self2.comboSpacing;
          var comboPadding = self2.comboPadding;
          (comboTrees || []).forEach(function(ctree) {
            var treeChildren = [];
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              if (treeNode.itemType === "node")
                return true;
              var c3 = comboMap[treeNode.id];
              if (!c3)
                return false;
              var children = treeNode.children;
              if (children) {
                children.forEach(function(child) {
                  if (!comboMap[child.id] && !nodeMap[child.id])
                    return;
                  treeChildren.push(child);
                });
              }
              c3.minX = Infinity;
              c3.minY = Infinity;
              c3.maxX = -Infinity;
              c3.maxY = -Infinity;
              treeChildren.forEach(function(child) {
                if (child.itemType !== "node")
                  return true;
                var node = nodeMap[child.id];
                if (!node)
                  return true;
                var r2 = nodeSize(node);
                var nodeMinX = node.x - r2;
                var nodeMinY = node.y - r2;
                var nodeMaxX = node.x + r2;
                var nodeMaxY = node.y + r2;
                if (c3.minX > nodeMinX)
                  c3.minX = nodeMinX;
                if (c3.minY > nodeMinY)
                  c3.minY = nodeMinY;
                if (c3.maxX < nodeMaxX)
                  c3.maxX = nodeMaxX;
                if (c3.maxY < nodeMaxY)
                  c3.maxY = nodeMaxY;
              });
              var minSize = self2.oriComboMap[treeNode.id].size || 10;
              if ((0, util_1.isArray)(minSize))
                minSize = minSize[0];
              var maxLength = Math.max(c3.maxX - c3.minX, c3.maxY - c3.minY, minSize);
              c3.r = maxLength / 2 + comboSpacing(c3) / 2 + comboPadding(c3);
              return true;
            });
          });
        };
        ComboForceLayout3.prototype.comboNonOverlapping = function(displacements, comboMap) {
          var self2 = this;
          var comboTree = self2.comboTree;
          var comboCollideStrength = self2.comboCollideStrength;
          var indexMap = self2.indexMap;
          var nodeMap = self2.nodeMap;
          (0, util_1.traverseTreeUp)(comboTree, function(treeNode) {
            if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== "comboTreeRoot") {
              return false;
            }
            var children = treeNode.children;
            if (children && children.length > 1) {
              children.forEach(function(v2, i2) {
                if (v2.itemType === "node")
                  return false;
                var cv = comboMap[v2.id];
                if (!cv)
                  return;
                children.forEach(function(u2, j2) {
                  if (i2 <= j2)
                    return false;
                  if (u2.itemType === "node")
                    return false;
                  var cu2 = comboMap[u2.id];
                  if (!cu2)
                    return false;
                  var vx = cv.cx - cu2.cx || 5e-3;
                  var vy = cv.cy - cu2.cy || 5e-3;
                  var l2 = vx * vx + vy * vy;
                  var rv = cv.r || 1;
                  var ru2 = cu2.r || 1;
                  var r2 = rv + ru2;
                  var ru22 = ru2 * ru2;
                  var rv2 = rv * rv;
                  if (l2 < r2 * r2) {
                    var vnodes = v2.children;
                    if (!vnodes || vnodes.length === 0)
                      return false;
                    var unodes_1 = u2.children;
                    if (!unodes_1 || unodes_1.length === 0)
                      return false;
                    var sqrtl = Math.sqrt(l2);
                    var ll = (r2 - sqrtl) / sqrtl * comboCollideStrength;
                    var xl_1 = vx * ll;
                    var yl_1 = vy * ll;
                    var rratio_1 = ru22 / (rv2 + ru22);
                    var irratio_1 = 1 - rratio_1;
                    vnodes.forEach(function(vn2) {
                      if (vn2.itemType !== "node")
                        return false;
                      if (!nodeMap[vn2.id])
                        return;
                      var vindex = indexMap[vn2.id];
                      unodes_1.forEach(function(un2) {
                        if (un2.itemType !== "node")
                          return false;
                        if (!nodeMap[un2.id])
                          return false;
                        var uindex = indexMap[un2.id];
                        displacements[vindex].x += xl_1 * rratio_1;
                        displacements[vindex].y += yl_1 * rratio_1;
                        displacements[uindex].x -= xl_1 * irratio_1;
                        displacements[uindex].y -= yl_1 * irratio_1;
                      });
                    });
                  }
                });
              });
            }
            return true;
          });
        };
        ComboForceLayout3.prototype.calRepulsive = function(displacements, vecMap) {
          var self2 = this;
          var nodes = self2.nodes;
          var max8 = self2.width * self2.optimizeRangeFactor;
          var nodeStrength = self2.nodeStrength;
          var alpha = self2.alpha;
          var nodeCollideStrength = self2.nodeCollideStrength;
          var preventNodeOverlap = self2.preventNodeOverlap;
          var nodeSizeFunc = self2.nodeSize;
          var nodeSpacingFunc = self2.nodeSpacing;
          var scale12 = self2.depthRepulsiveForceScale;
          var center = self2.center;
          nodes.forEach(function(v2, i2) {
            if (!v2.x || !v2.y)
              return;
            if (center) {
              var gravity = self2.gravity;
              var vecX = v2.x - center[0] || 5e-3;
              var vecY = v2.y - center[1] || 5e-3;
              var l2 = Math.sqrt(vecX * vecX + vecY * vecY);
              displacements[i2].x -= vecX * gravity * alpha / l2;
              displacements[i2].y -= vecY * gravity * alpha / l2;
            }
            nodes.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              if (!u2.x || !u2.y)
                return;
              var _a2 = vecMap["".concat(v2.id, "-").concat(u2.id)], vl2 = _a2.vl2, vl = _a2.vl;
              if (vl > max8)
                return;
              var _b = vecMap["".concat(v2.id, "-").concat(u2.id)], vx = _b.vx, vy = _b.vy;
              var depthDiff = Math.log(Math.abs(u2.depth - v2.depth) / 10) + 1 || 1;
              depthDiff = depthDiff < 1 ? 1 : depthDiff;
              if (u2.comboId !== v2.comboId)
                depthDiff += 1;
              var depthParam = depthDiff ? Math.pow(scale12, depthDiff) : 1;
              var params = nodeStrength(u2) * alpha / vl2 * depthParam;
              displacements[i2].x += vx * params;
              displacements[i2].y += vy * params;
              if (i2 < j2 && preventNodeOverlap) {
                var ri2 = nodeSizeFunc(v2) + nodeSpacingFunc(v2) || 1;
                var rj = nodeSizeFunc(u2) + nodeSpacingFunc(u2) || 1;
                var r2 = ri2 + rj;
                if (vl2 < r2 * r2) {
                  var ll = (r2 - vl) / vl * nodeCollideStrength;
                  var rj2 = rj * rj;
                  var rratio = rj2 / (ri2 * ri2 + rj2);
                  var xl = vx * ll;
                  var yl = vy * ll;
                  displacements[i2].x += xl * rratio;
                  displacements[i2].y += yl * rratio;
                  rratio = 1 - rratio;
                  displacements[j2].x -= xl * rratio;
                  displacements[j2].y -= yl * rratio;
                }
              }
            });
          });
        };
        ComboForceLayout3.prototype.calAttractive = function(displacements, vecMap) {
          var self2 = this;
          var edges = self2.edges;
          var linkDistance = self2.linkDistance;
          var alpha = self2.alpha;
          var edgeStrength = self2.edgeStrength;
          var bias = self2.bias;
          var scale12 = self2.depthAttractiveForceScale;
          edges.forEach(function(e8, i2) {
            var source = (0, util_1.getEdgeTerminal)(e8, "source");
            var target = (0, util_1.getEdgeTerminal)(e8, "target");
            if (!source || !target || source === target)
              return;
            var uIndex = self2.indexMap[source];
            var vIndex = self2.indexMap[target];
            var u2 = self2.nodeMap[source];
            var v2 = self2.nodeMap[target];
            if (!u2 || !v2)
              return;
            var depthDiff = u2.depth === v2.depth ? 0 : Math.log(Math.abs(u2.depth - v2.depth) / 10);
            if (u2.comboId === v2.comboId) {
              depthDiff = depthDiff / 2;
            }
            var depthParam = depthDiff ? Math.pow(scale12, depthDiff) : 1;
            if (u2.comboId !== v2.comboId && depthParam === 1) {
              depthParam = scale12 / 2;
            } else if (u2.comboId === v2.comboId) {
              depthParam = 2;
            }
            if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
              return;
            }
            var _a2 = vecMap["".concat(target, "-").concat(source)], vl = _a2.vl, vx = _a2.vx, vy = _a2.vy;
            var l2 = (vl - linkDistance(e8)) / vl * alpha * edgeStrength(e8) * depthParam;
            var vecX = vx * l2;
            var vecY = vy * l2;
            var b10 = bias[i2];
            displacements[vIndex].x -= vecX * b10;
            displacements[vIndex].y -= vecY * b10;
            displacements[uIndex].x += vecX * (1 - b10);
            displacements[uIndex].y += vecY * (1 - b10);
          });
        };
        ComboForceLayout3.prototype.getType = function() {
          return "comboForce";
        };
        return ComboForceLayout3;
      }(base_1.Base)
    );
    exports.ComboForceLayout = ComboForceLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/comboCombined.js
var require_comboCombined = __commonJS({
  "node_modules/@antv/layout/lib/layout/comboCombined.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __assign18 = exports && exports.__assign || function() {
      __assign18 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign18.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboCombinedLayout = void 0;
    var constants_1 = require_constants();
    var base_1 = require_base();
    var util_1 = require_util2();
    var _1 = require_layout3();
    var ComboCombinedLayout2 = (
      /** @class */
      function(_super) {
        __extends17(ComboCombinedLayout3, _super);
        function ComboCombinedLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.nodes = [];
          _this.edges = [];
          _this.combos = [];
          _this.comboEdges = [];
          _this.comboPadding = 10;
          _this.comboTrees = [];
          _this.updateCfg(options);
          return _this;
        }
        ComboCombinedLayout3.prototype.getDefaultCfg = function() {
          return {};
        };
        ComboCombinedLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var center = self2.center;
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          self2.initVals();
          self2.run();
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
        };
        ComboCombinedLayout3.prototype.run = function() {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, combos = self2.combos, comboEdges = self2.comboEdges, center = self2.center;
          var nodeMap = {};
          nodes.forEach(function(node) {
            nodeMap[node.id] = node;
          });
          var comboMap = {};
          combos.forEach(function(combo) {
            comboMap[combo.id] = combo;
          });
          var innerGraphs = self2.getInnerGraphs(nodeMap);
          var outerNodeIds = [];
          var outerNodes = [];
          var nodeAncestorIdMap = {};
          var allHaveNoPosition = true;
          this.comboTrees.forEach(function(cTree) {
            var innerNode = innerGraphs[cTree.id];
            if (!innerNode) {
              return;
            }
            var oNode = __assign18(__assign18({}, cTree), { x: innerNode.x || comboMap[cTree.id].x, y: innerNode.y || comboMap[cTree.id].y, fx: innerNode.fx || comboMap[cTree.id].fx, fy: innerNode.fy || comboMap[cTree.id].fy, mass: innerNode.mass || comboMap[cTree.id].mass, size: innerNode.size });
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {
              allHaveNoPosition = false;
            } else {
              oNode.x = Math.random() * 100;
              oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(cTree.id);
            (0, util_1.traverseTreeUp)(cTree, function(child) {
              if (child.id !== cTree.id)
                nodeAncestorIdMap[child.id] = cTree.id;
              return true;
            });
          });
          nodes.forEach(function(node) {
            if (node.comboId && comboMap[node.comboId])
              return;
            var oNode = __assign18({}, node);
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {
              allHaveNoPosition = false;
            } else {
              oNode.x = Math.random() * 100;
              oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(node.id);
          });
          var outerEdges = [];
          edges.concat(comboEdges).forEach(function(edge) {
            var sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;
            var targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target;
            if (sourceAncestorId !== targetAncestorId && outerNodeIds.includes(sourceAncestorId) && outerNodeIds.includes(targetAncestorId)) {
              outerEdges.push({
                source: sourceAncestorId,
                target: targetAncestorId
              });
            }
          });
          if (outerNodes === null || outerNodes === void 0 ? void 0 : outerNodes.length) {
            if (outerNodes.length === 1) {
              outerNodes[0].x = center[0];
              outerNodes[0].y = center[1];
            } else {
              var outerData = {
                nodes: outerNodes,
                edges: outerEdges
              };
              var outerLayout = this.outerLayout || new _1.GForceLayout({
                gravity: 1,
                factor: 4,
                linkDistance: function(edge, source, target) {
                  var _a3, _b;
                  var nodeSize = ((((_a3 = source.size) === null || _a3 === void 0 ? void 0 : _a3[0]) || 30) + (((_b = target.size) === null || _b === void 0 ? void 0 : _b[0]) || 30)) / 2;
                  return Math.min(nodeSize * 1.5, 700);
                }
              });
              var outerLayoutType = (_a2 = outerLayout.getType) === null || _a2 === void 0 ? void 0 : _a2.call(outerLayout);
              outerLayout.updateCfg({
                center,
                kg: 5,
                preventOverlap: true,
                animate: false
              });
              if (allHaveNoPosition && constants_1.FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {
                var outerLayoutPreset = outerNodes.length < 100 ? new _1.MDSLayout() : new _1.GridLayout();
                outerLayoutPreset.layout(outerData);
              }
              outerLayout.layout(outerData);
            }
            outerNodes.forEach(function(outerNode) {
              var innerGraph = innerGraphs[outerNode.id];
              if (!innerGraph) {
                var node = nodeMap[outerNode.id];
                if (node) {
                  node.x = outerNode.x;
                  node.y = outerNode.y;
                }
                return;
              }
              innerGraph.visited = true;
              innerGraph.x = outerNode.x;
              innerGraph.y = outerNode.y;
              innerGraph.nodes.forEach(function(node2) {
                node2.x += outerNode.x;
                node2.y += outerNode.y;
              });
            });
          }
          var innerGraphIds = Object.keys(innerGraphs);
          var _loop_1 = function(i3) {
            var id = innerGraphIds[i3];
            var innerGraph = innerGraphs[id];
            if (!innerGraph)
              return "continue";
            innerGraph.nodes.forEach(function(node) {
              if (!innerGraph.visited) {
                node.x += innerGraph.x || 0;
                node.y += innerGraph.y || 0;
              }
              if (nodeMap[node.id]) {
                nodeMap[node.id].x = node.x;
                nodeMap[node.id].y = node.y;
              }
            });
            if (comboMap[id]) {
              comboMap[id].x = innerGraph.x;
              comboMap[id].y = innerGraph.y;
            }
          };
          for (var i2 = innerGraphIds.length - 1; i2 >= 0; i2--) {
            _loop_1(i2);
          }
          return { nodes, edges, combos, comboEdges };
        };
        ComboCombinedLayout3.prototype.getInnerGraphs = function(nodeMap) {
          var self2 = this;
          var comboTrees = self2.comboTrees, nodeSize = self2.nodeSize, edges = self2.edges, comboPadding = self2.comboPadding, spacing = self2.spacing;
          var innerGraphs = {};
          var innerGraphLayout = this.innerLayout || new _1.ConcentricLayout({ type: "concentric", sortBy: "id" });
          innerGraphLayout.center = [0, 0];
          innerGraphLayout.preventOverlap = true;
          innerGraphLayout.nodeSpacing = spacing;
          (comboTrees || []).forEach(function(ctree) {
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              var _a2;
              var padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(treeNode)) || 10;
              if ((0, util_1.isArray)(padding))
                padding = Math.max.apply(Math, padding);
              if (!((_a2 = treeNode.children) === null || _a2 === void 0 ? void 0 : _a2.length)) {
                if (treeNode.itemType === "combo") {
                  var treeNodeSize = padding ? [padding * 2, padding * 2] : [30, 30];
                  innerGraphs[treeNode.id] = {
                    id: treeNode.id,
                    nodes: [],
                    size: treeNodeSize
                  };
                }
              } else {
                var innerGraphNodes = treeNode.children.map(function(child) {
                  if (child.itemType === "combo")
                    return innerGraphs[child.id];
                  var oriNode = nodeMap[child.id] || {};
                  return __assign18(__assign18({}, oriNode), child);
                });
                var innerGraphNodeIds_1 = innerGraphNodes.map(function(node) {
                  return node.id;
                });
                var innerGraphData = {
                  nodes: innerGraphNodes,
                  edges: edges.filter(function(edge) {
                    return innerGraphNodeIds_1.includes(edge.source) && innerGraphNodeIds_1.includes(edge.target);
                  })
                };
                var minNodeSize_1 = Infinity;
                innerGraphNodes.forEach(function(node) {
                  var _a3;
                  if (!node.size)
                    node.size = ((_a3 = innerGraphs[node.id]) === null || _a3 === void 0 ? void 0 : _a3.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
                  if ((0, util_1.isNumber)(node.size))
                    node.size = [node.size, node.size];
                  if (minNodeSize_1 > node.size[0])
                    minNodeSize_1 = node.size[0];
                  if (minNodeSize_1 > node.size[1])
                    minNodeSize_1 = node.size[1];
                });
                innerGraphLayout.layout(innerGraphData);
                var _b = (0, util_1.getLayoutBBox)(innerGraphNodes), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
                var center_1 = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
                innerGraphData.nodes.forEach(function(node) {
                  node.x -= center_1.x;
                  node.y -= center_1.y;
                });
                var innerGraphWidth = Math.max(maxX - minX, minNodeSize_1) + padding * 2;
                var innerGraphHeight = Math.max(maxY - minY, minNodeSize_1) + padding * 2;
                innerGraphs[treeNode.id] = {
                  id: treeNode.id,
                  nodes: innerGraphNodes,
                  size: [innerGraphWidth, innerGraphHeight]
                };
              }
              return true;
            });
          });
          return innerGraphs;
        };
        ComboCombinedLayout3.prototype.initVals = function() {
          var self2 = this;
          var nodeSize = self2.nodeSize;
          var spacing = self2.spacing;
          var nodeSizeFunc;
          var spacingFunc;
          if ((0, util_1.isNumber)(spacing)) {
            spacingFunc = function() {
              return spacing;
            };
          } else if ((0, util_1.isFunction)(spacing)) {
            spacingFunc = spacing;
          } else {
            spacingFunc = function() {
              return 0;
            };
          }
          this.spacing = spacingFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              var spacing2 = spacingFunc(d2);
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                  return (res + spacing2) / 2;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                  return (res + spacing2) / 2;
                }
                return (d2.size + spacing2) / 2;
              }
              return 10 + spacing2 / 2;
            };
          } else if ((0, util_1.isFunction)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              var size3 = nodeSize(d2);
              var spacing2 = spacingFunc(d2);
              if ((0, util_1.isArray)(d2.size)) {
                var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                return (res + spacing2) / 2;
              }
              return ((size3 || 10) + spacing2) / 2;
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            var radius_1 = larger / 2;
            nodeSizeFunc = function(d2) {
              return radius_1 + spacingFunc(d2) / 2;
            };
          } else {
            var radius_2 = nodeSize / 2;
            nodeSizeFunc = function(d2) {
              return radius_2 + spacingFunc(d2) / 2;
            };
          }
          this.nodeSize = nodeSizeFunc;
          var comboPadding = self2.comboPadding;
          var comboPaddingFunc;
          if ((0, util_1.isNumber)(comboPadding)) {
            comboPaddingFunc = function() {
              return comboPadding;
            };
          } else if ((0, util_1.isArray)(comboPadding)) {
            comboPaddingFunc = function() {
              return Math.max.apply(null, comboPadding);
            };
          } else if ((0, util_1.isFunction)(comboPadding)) {
            comboPaddingFunc = comboPadding;
          } else {
            comboPaddingFunc = function() {
              return 0;
            };
          }
          this.comboPadding = comboPaddingFunc;
        };
        ComboCombinedLayout3.prototype.getType = function() {
          return "comboCombined";
        };
        return ComboCombinedLayout3;
      }(base_1.Base)
    );
    exports.ComboCombinedLayout = ComboCombinedLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/body.js
var require_body = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/body.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Body = (
      /** @class */
      function() {
        function Body2(params) {
          this.id = params.id || 0;
          this.rx = params.rx;
          this.ry = params.ry;
          this.fx = 0;
          this.fy = 0;
          this.mass = params.mass;
          this.degree = params.degree;
          this.g = params.g || 0;
        }
        Body2.prototype.distanceTo = function(bo2) {
          var dx = this.rx - bo2.rx;
          var dy = this.ry - bo2.ry;
          return Math.hypot(dx, dy);
        };
        Body2.prototype.setPos = function(x4, y4) {
          this.rx = x4;
          this.ry = y4;
        };
        Body2.prototype.resetForce = function() {
          this.fx = 0;
          this.fy = 0;
        };
        Body2.prototype.addForce = function(b10) {
          var dx = b10.rx - this.rx;
          var dy = b10.ry - this.ry;
          var dist4 = Math.hypot(dx, dy);
          dist4 = dist4 < 1e-4 ? 1e-4 : dist4;
          var F2 = this.g * (this.degree + 1) * (b10.degree + 1) / dist4;
          this.fx += F2 * dx / dist4;
          this.fy += F2 * dy / dist4;
        };
        Body2.prototype.in = function(quad) {
          return quad.contains(this.rx, this.ry);
        };
        Body2.prototype.add = function(bo2) {
          var nenwMass = this.mass + bo2.mass;
          var x4 = (this.rx * this.mass + bo2.rx * bo2.mass) / nenwMass;
          var y4 = (this.ry * this.mass + bo2.ry * bo2.mass) / nenwMass;
          var dg = this.degree + bo2.degree;
          var params = {
            rx: x4,
            ry: y4,
            mass: nenwMass,
            degree: dg
          };
          return new Body2(params);
        };
        return Body2;
      }()
    );
    exports.default = Body;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/quad.js
var require_quad = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/quad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Quad = (
      /** @class */
      function() {
        function Quad2(params) {
          this.xmid = params.xmid;
          this.ymid = params.ymid;
          this.length = params.length;
          this.massCenter = params.massCenter || [0, 0];
          this.mass = params.mass || 1;
        }
        Quad2.prototype.getLength = function() {
          return this.length;
        };
        Quad2.prototype.contains = function(x4, y4) {
          var halfLen = this.length / 2;
          return x4 <= this.xmid + halfLen && x4 >= this.xmid - halfLen && y4 <= this.ymid + halfLen && y4 >= this.ymid - halfLen;
        };
        Quad2.prototype.NW = function() {
          var x4 = this.xmid - this.length / 4;
          var y4 = this.ymid + this.length / 4;
          var len6 = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len6
          };
          var NW = new Quad2(params);
          return NW;
        };
        Quad2.prototype.NE = function() {
          var x4 = this.xmid + this.length / 4;
          var y4 = this.ymid + this.length / 4;
          var len6 = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len6
          };
          var NE = new Quad2(params);
          return NE;
        };
        Quad2.prototype.SW = function() {
          var x4 = this.xmid - this.length / 4;
          var y4 = this.ymid - this.length / 4;
          var len6 = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len6
          };
          var SW = new Quad2(params);
          return SW;
        };
        Quad2.prototype.SE = function() {
          var x4 = this.xmid + this.length / 4;
          var y4 = this.ymid - this.length / 4;
          var len6 = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len6
          };
          var SE = new Quad2(params);
          return SE;
        };
        return Quad2;
      }()
    );
    exports.default = Quad;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/quadTree.js
var require_quadTree = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/quadTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var QuadTree = (
      /** @class */
      function() {
        function QuadTree2(param) {
          this.body = null;
          this.quad = null;
          this.NW = null;
          this.NE = null;
          this.SW = null;
          this.SE = null;
          this.theta = 0.5;
          if (param != null)
            this.quad = param;
        }
        QuadTree2.prototype.insert = function(bo2) {
          if (this.body == null) {
            this.body = bo2;
            return;
          }
          if (!this._isExternal()) {
            this.body = this.body.add(bo2);
            this._putBody(bo2);
          } else {
            if (this.quad) {
              this.NW = new QuadTree2(this.quad.NW());
              this.NE = new QuadTree2(this.quad.NE());
              this.SW = new QuadTree2(this.quad.SW());
              this.SE = new QuadTree2(this.quad.SE());
            }
            this._putBody(this.body);
            this._putBody(bo2);
            this.body = this.body.add(bo2);
          }
        };
        QuadTree2.prototype._putBody = function(bo2) {
          if (!this.quad)
            return;
          if (bo2.in(this.quad.NW()) && this.NW)
            this.NW.insert(bo2);
          else if (bo2.in(this.quad.NE()) && this.NE)
            this.NE.insert(bo2);
          else if (bo2.in(this.quad.SW()) && this.SW)
            this.SW.insert(bo2);
          else if (bo2.in(this.quad.SE()) && this.SE)
            this.SE.insert(bo2);
        };
        QuadTree2.prototype._isExternal = function() {
          return this.NW == null && this.NE == null && this.SW == null && this.SE == null;
        };
        QuadTree2.prototype.updateForce = function(bo2) {
          if (this.body == null || bo2 === this.body) {
            return;
          }
          if (this._isExternal())
            bo2.addForce(this.body);
          else {
            var s2 = this.quad ? this.quad.getLength() : 0;
            var d2 = this.body.distanceTo(bo2);
            if (s2 / d2 < this.theta)
              bo2.addForce(this.body);
            else {
              this.NW && this.NW.updateForce(bo2);
              this.NE && this.NE.updateForce(bo2);
              this.SW && this.SW.updateForce(bo2);
              this.SE && this.SE.updateForce(bo2);
            }
          }
        };
        return QuadTree2;
      }()
    );
    exports.default = QuadTree;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/index.js
var require_forceAtlas2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/index.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForceAtlas2Layout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var body_1 = __importDefault2(require_body());
    var quad_1 = __importDefault2(require_quad());
    var quadTree_1 = __importDefault2(require_quadTree());
    var ForceAtlas2Layout2 = (
      /** @class */
      function(_super) {
        __extends17(ForceAtlas2Layout3, _super);
        function ForceAtlas2Layout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.width = 300;
          _this.height = 300;
          _this.nodes = [];
          _this.edges = [];
          _this.kr = 5;
          _this.kg = 1;
          _this.mode = "normal";
          _this.preventOverlap = false;
          _this.dissuadeHubs = false;
          _this.barnesHut = void 0;
          _this.maxIteration = 0;
          _this.ks = 0.1;
          _this.ksmax = 10;
          _this.tao = 0.1;
          _this.onLayoutEnd = function() {
          };
          _this.prune = void 0;
          _this.updateCfg(options);
          return _this;
        }
        ForceAtlas2Layout3.prototype.getDefaultCfg = function() {
          return {};
        };
        ForceAtlas2Layout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, onLayoutEnd = self2.onLayoutEnd, prune = self2.prune;
          var maxIteration = self2.maxIteration;
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          var sizes = [];
          var nodeNum = nodes.length;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            var node = nodes[i2];
            var nodeWidth = 10;
            var nodeHeight = 10;
            if ((0, util_1.isNumber)(node.size)) {
              nodeWidth = node.size;
              nodeHeight = node.size;
            }
            if ((0, util_1.isArray)(node.size)) {
              if (!isNaN(node.size[0]))
                nodeWidth = node.size[0];
              if (!isNaN(node.size[1]))
                nodeHeight = node.size[1];
            } else if ((0, util_1.isObject)(node.size)) {
              nodeWidth = node.size.width;
              nodeHeight = node.size.height;
            }
            if (self2.getWidth && !isNaN(self2.getWidth(node)))
              nodeHeight = self2.getWidth(node);
            if (self2.getHeight && !isNaN(self2.getHeight(node)))
              nodeWidth = self2.getHeight(node);
            var maxSize = Math.max(nodeWidth, nodeHeight);
            sizes.push(maxSize);
          }
          if (self2.barnesHut === void 0 && nodeNum > 250)
            self2.barnesHut = true;
          if (self2.prune === void 0 && nodeNum > 100)
            self2.prune = true;
          if (this.maxIteration === 0 && !self2.prune) {
            maxIteration = 250;
            if (nodeNum <= 200 && nodeNum > 100)
              maxIteration = 1e3;
            else if (nodeNum > 200)
              maxIteration = 1200;
            this.maxIteration = maxIteration;
          } else if (this.maxIteration === 0 && prune) {
            maxIteration = 100;
            if (nodeNum <= 200 && nodeNum > 100)
              maxIteration = 500;
            else if (nodeNum > 200)
              maxIteration = 950;
            this.maxIteration = maxIteration;
          }
          if (!self2.kr) {
            self2.kr = 50;
            if (nodeNum > 100 && nodeNum <= 500)
              self2.kr = 20;
            else if (nodeNum > 500)
              self2.kr = 1;
          }
          if (!self2.kg) {
            self2.kg = 20;
            if (nodeNum > 100 && nodeNum <= 500)
              self2.kg = 10;
            else if (nodeNum > 500)
              self2.kg = 1;
          }
          this.nodes = self2.updateNodesByForces(sizes);
          onLayoutEnd();
        };
        ForceAtlas2Layout3.prototype.updateNodesByForces = function(sizes) {
          var self2 = this;
          var edges = self2.edges, maxIteration = self2.maxIteration;
          var nodes = self2.nodes;
          var nonLoopEdges = edges.filter(function(edge) {
            var source2 = (0, util_1.getEdgeTerminal)(edge, "source");
            var target2 = (0, util_1.getEdgeTerminal)(edge, "target");
            return source2 !== target2;
          });
          var size3 = nodes.length;
          var esize = nonLoopEdges.length;
          var degrees3 = [];
          var idMap = {};
          var edgeEndsIdMap = {};
          var Es = [];
          for (var i2 = 0; i2 < size3; i2 += 1) {
            idMap[nodes[i2].id] = i2;
            degrees3[i2] = 0;
            if (nodes[i2].x === void 0 || isNaN(nodes[i2].x)) {
              nodes[i2].x = Math.random() * 1e3;
            }
            if (nodes[i2].y === void 0 || isNaN(nodes[i2].y)) {
              nodes[i2].y = Math.random() * 1e3;
            }
            Es.push({ x: nodes[i2].x, y: nodes[i2].y });
          }
          for (var i2 = 0; i2 < esize; i2 += 1) {
            var node1 = void 0;
            var node2 = void 0;
            var sIdx = 0;
            var tIdx = 0;
            for (var j2 = 0; j2 < size3; j2 += 1) {
              var source = (0, util_1.getEdgeTerminal)(nonLoopEdges[i2], "source");
              var target = (0, util_1.getEdgeTerminal)(nonLoopEdges[i2], "target");
              if (nodes[j2].id === source) {
                node1 = nodes[j2];
                sIdx = j2;
              } else if (nodes[j2].id === target) {
                node2 = nodes[j2];
                tIdx = j2;
              }
              edgeEndsIdMap[i2] = { sourceIdx: sIdx, targetIdx: tIdx };
            }
            if (node1)
              degrees3[idMap[node1.id]] += 1;
            if (node2)
              degrees3[idMap[node2.id]] += 1;
          }
          var iteration = maxIteration;
          nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees3, sizes);
          if (self2.prune) {
            for (var j2 = 0; j2 < esize; j2 += 1) {
              if (degrees3[edgeEndsIdMap[j2].sourceIdx] <= 1) {
                nodes[edgeEndsIdMap[j2].sourceIdx].x = nodes[edgeEndsIdMap[j2].targetIdx].x;
                nodes[edgeEndsIdMap[j2].sourceIdx].y = nodes[edgeEndsIdMap[j2].targetIdx].y;
              } else if (degrees3[edgeEndsIdMap[j2].targetIdx] <= 1) {
                nodes[edgeEndsIdMap[j2].targetIdx].x = nodes[edgeEndsIdMap[j2].sourceIdx].x;
                nodes[edgeEndsIdMap[j2].targetIdx].y = nodes[edgeEndsIdMap[j2].sourceIdx].y;
              }
            }
            self2.prune = false;
            self2.barnesHut = false;
            iteration = 100;
            nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees3, sizes);
          }
          return nodes;
        };
        ForceAtlas2Layout3.prototype.iterate = function(iteration, idMap, edgeEndsIdMap, esize, degrees3, sizes) {
          var self2 = this;
          var nodes = self2.nodes;
          var kr2 = self2.kr, preventOverlap = self2.preventOverlap;
          var barnesHut = self2.barnesHut;
          var nodeNum = nodes.length;
          var sg = 0;
          var krPrime = 100;
          var iter = iteration;
          var prevoIter = 50;
          var forces = [];
          var preForces = [];
          var bodies = [];
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            forces[2 * i2] = 0;
            forces[2 * i2 + 1] = 0;
            if (barnesHut) {
              var params = {
                id: i2,
                rx: nodes[i2].x,
                ry: nodes[i2].y,
                mass: 1,
                g: kr2,
                degree: degrees3[i2]
              };
              bodies[i2] = new body_1.default(params);
            }
          }
          while (iter > 0) {
            for (var i2 = 0; i2 < nodeNum; i2 += 1) {
              preForces[2 * i2] = forces[2 * i2];
              preForces[2 * i2 + 1] = forces[2 * i2 + 1];
              forces[2 * i2] = 0;
              forces[2 * i2 + 1] = 0;
            }
            forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees3, sizes, forces);
            if (barnesHut && (preventOverlap && iter > prevoIter || !preventOverlap)) {
              forces = this.getOptRepGraForces(forces, bodies, degrees3);
            } else {
              forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees3);
            }
            var res = this.updatePos(forces, preForces, sg, degrees3);
            nodes = res.nodes;
            sg = res.sg;
            iter--;
            if (self2.tick)
              self2.tick();
          }
          return nodes;
        };
        ForceAtlas2Layout3.prototype.getAttrForces = function(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees3, sizes, forces) {
          var self2 = this;
          var nodes = self2.nodes, preventOverlap = self2.preventOverlap, dissuadeHubs = self2.dissuadeHubs, mode = self2.mode, prune = self2.prune;
          for (var i2 = 0; i2 < esize; i2 += 1) {
            var sourceNode = nodes[edgeEndsIdMap[i2].sourceIdx];
            var sourceIdx = edgeEndsIdMap[i2].sourceIdx;
            var targetNode = nodes[edgeEndsIdMap[i2].targetIdx];
            var targetIdx = edgeEndsIdMap[i2].targetIdx;
            if (prune && (degrees3[sourceIdx] <= 1 || degrees3[targetIdx] <= 1))
              continue;
            var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];
            var eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            if (preventOverlap && iter < prevoIter)
              eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];
            var Fa1 = eucliDis;
            var Fa2 = Fa1;
            if (mode === "linlog") {
              Fa1 = Math.log(1 + eucliDis);
              Fa2 = Fa1;
            }
            if (dissuadeHubs) {
              Fa1 = eucliDis / degrees3[sourceIdx];
              Fa2 = eucliDis / degrees3[targetIdx];
            }
            if (preventOverlap && iter < prevoIter && eucliDis <= 0) {
              Fa1 = 0;
              Fa2 = 0;
            } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {
              Fa1 = eucliDis;
              Fa2 = eucliDis;
            }
            forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];
            forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];
            forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];
            forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];
          }
          return forces;
        };
        ForceAtlas2Layout3.prototype.getRepGraForces = function(iter, prevoIter, forces, krPrime, sizes, degrees3) {
          var self2 = this;
          var nodes = self2.nodes, preventOverlap = self2.preventOverlap, kr2 = self2.kr, kg = self2.kg, center = self2.center, prune = self2.prune;
          var nodeNum = nodes.length;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            for (var j2 = i2 + 1; j2 < nodeNum; j2 += 1) {
              if (prune && (degrees3[i2] <= 1 || degrees3[j2] <= 1))
                continue;
              var dir_1 = [nodes[j2].x - nodes[i2].x, nodes[j2].y - nodes[i2].y];
              var eucliDis_1 = Math.hypot(dir_1[0], dir_1[1]);
              eucliDis_1 = eucliDis_1 < 1e-4 ? 1e-4 : eucliDis_1;
              dir_1[0] = dir_1[0] / eucliDis_1;
              dir_1[1] = dir_1[1] / eucliDis_1;
              if (preventOverlap && iter < prevoIter)
                eucliDis_1 = eucliDis_1 - sizes[i2] - sizes[j2];
              var Fr2 = kr2 * (degrees3[i2] + 1) * (degrees3[j2] + 1) / eucliDis_1;
              if (preventOverlap && iter < prevoIter && eucliDis_1 < 0) {
                Fr2 = krPrime * (degrees3[i2] + 1) * (degrees3[j2] + 1);
              } else if (preventOverlap && iter < prevoIter && eucliDis_1 === 0) {
                Fr2 = 0;
              } else if (preventOverlap && iter < prevoIter && eucliDis_1 > 0) {
                Fr2 = kr2 * (degrees3[i2] + 1) * (degrees3[j2] + 1) / eucliDis_1;
              }
              forces[2 * i2] -= Fr2 * dir_1[0];
              forces[2 * j2] += Fr2 * dir_1[0];
              forces[2 * i2 + 1] -= Fr2 * dir_1[1];
              forces[2 * j2 + 1] += Fr2 * dir_1[1];
            }
            var dir = [nodes[i2].x - center[0], nodes[i2].y - center[1]];
            var eucliDis = Math.hypot(dir[0], dir[1]);
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            var Fg = kg * (degrees3[i2] + 1);
            forces[2 * i2] -= Fg * dir[0];
            forces[2 * i2 + 1] -= Fg * dir[1];
          }
          return forces;
        };
        ForceAtlas2Layout3.prototype.getOptRepGraForces = function(forces, bodies, degrees3) {
          var self2 = this;
          var nodes = self2.nodes, kg = self2.kg, center = self2.center, prune = self2.prune;
          var nodeNum = nodes.length;
          var minx = 9e10;
          var maxx = -9e10;
          var miny = 9e10;
          var maxy = -9e10;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees3[i2] <= 1)
              continue;
            bodies[i2].setPos(nodes[i2].x, nodes[i2].y);
            if (nodes[i2].x >= maxx)
              maxx = nodes[i2].x;
            if (nodes[i2].x <= minx)
              minx = nodes[i2].x;
            if (nodes[i2].y >= maxy)
              maxy = nodes[i2].y;
            if (nodes[i2].y <= miny)
              miny = nodes[i2].y;
          }
          var width = Math.max(maxx - minx, maxy - miny);
          var quadParams = {
            xmid: (maxx + minx) / 2,
            ymid: (maxy + miny) / 2,
            length: width,
            massCenter: center,
            mass: nodeNum
          };
          var quad = new quad_1.default(quadParams);
          var quadTree = new quadTree_1.default(quad);
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees3[i2] <= 1)
              continue;
            if (bodies[i2].in(quad))
              quadTree.insert(bodies[i2]);
          }
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees3[i2] <= 1)
              continue;
            bodies[i2].resetForce();
            quadTree.updateForce(bodies[i2]);
            forces[2 * i2] -= bodies[i2].fx;
            forces[2 * i2 + 1] -= bodies[i2].fy;
            var dir = [nodes[i2].x - center[0], nodes[i2].y - center[1]];
            var eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            var Fg = kg * (degrees3[i2] + 1);
            forces[2 * i2] -= Fg * dir[0];
            forces[2 * i2 + 1] -= Fg * dir[1];
          }
          return forces;
        };
        ForceAtlas2Layout3.prototype.updatePos = function(forces, preForces, sg, degrees3) {
          var self2 = this;
          var nodes = self2.nodes, ks = self2.ks, tao = self2.tao, prune = self2.prune, ksmax = self2.ksmax;
          var nodeNum = nodes.length;
          var swgns = [];
          var trans = [];
          var swgG = 0;
          var traG = 0;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees3[i2] <= 1)
              continue;
            var minus = [
              forces[2 * i2] - preForces[2 * i2],
              forces[2 * i2 + 1] - preForces[2 * i2 + 1]
            ];
            var minusNorm = Math.hypot(minus[0], minus[1]);
            var add11 = [
              forces[2 * i2] + preForces[2 * i2],
              forces[2 * i2 + 1] + preForces[2 * i2 + 1]
            ];
            var addNorm = Math.hypot(add11[0], add11[1]);
            swgns[i2] = minusNorm;
            trans[i2] = addNorm / 2;
            swgG += (degrees3[i2] + 1) * swgns[i2];
            traG += (degrees3[i2] + 1) * trans[i2];
          }
          var preSG = sg;
          sg = tao * traG / swgG;
          if (preSG !== 0) {
            sg = sg > 1.5 * preSG ? 1.5 * preSG : sg;
          }
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees3[i2] <= 1)
              continue;
            if ((0, util_1.isNumber)(nodes[i2].fx) && (0, util_1.isNumber)(nodes[i2].fy))
              continue;
            var sn2 = ks * sg / (1 + sg * Math.sqrt(swgns[i2]));
            var absForce = Math.hypot(forces[2 * i2], forces[2 * i2 + 1]);
            absForce = absForce < 1e-4 ? 1e-4 : absForce;
            var max8 = ksmax / absForce;
            sn2 = sn2 > max8 ? max8 : sn2;
            var dnx = sn2 * forces[2 * i2];
            var dny = sn2 * forces[2 * i2 + 1];
            nodes[i2].x += dnx;
            nodes[i2].y += dny;
          }
          return { nodes, sg };
        };
        return ForceAtlas2Layout3;
      }(base_1.Base)
    );
    exports.ForceAtlas2Layout = ForceAtlas2Layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/grid.js
var require_grid2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/grid.js"(exports) {
    "use strict";
    var __assign18 = exports && exports.__assign || function() {
      __assign18 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign18.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Grid3 = (
      /** @class */
      function() {
        function Grid4() {
          this.cells = [];
          this.columnNum = 0;
          this.rowNum = 0;
          this.additionColumn = [];
          this.additionRow = [];
        }
        Grid4.prototype.init = function(width, height, gridSize) {
          this.cells = [];
          this.CELL_W = gridSize.CELL_W || Grid4.DEFAULT_CELL_W;
          this.CELL_H = gridSize.CELL_H || Grid4.DEFAULT_CELL_H;
          this.columnNum = Math.ceil(width / this.CELL_W);
          this.rowNum = Math.ceil(height / this.CELL_H);
          Grid4.MIN_DIST = Math.pow(width, 2) + Math.pow(height, 2);
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            var tmp = [];
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              var cell = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false
              };
              tmp.push(cell);
            }
            this.cells.push(tmp);
          }
        };
        Grid4.prototype.findGridByNodeId = function(nodeId) {
          var _a2, _b;
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              if (this.cells[i2][j2].node) {
                if (((_b = (_a2 = this.cells[i2][j2]) === null || _a2 === void 0 ? void 0 : _a2.node) === null || _b === void 0 ? void 0 : _b.id) === nodeId) {
                  return { column: i2, row: j2 };
                }
              }
            }
          }
          return null;
        };
        Grid4.prototype.sqdist = function(a3, b10) {
          return Math.pow(a3.x - b10.x, 2) + Math.pow(a3.y - b10.y, 2);
        };
        Grid4.prototype.occupyNearest = function(p2) {
          var minDist = Grid4.MIN_DIST;
          var d2;
          var candidate = null;
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              if (!this.cells[i2][j2].occupied && (d2 = this.sqdist(p2, this.cells[i2][j2])) < minDist) {
                minDist = d2;
                candidate = this.cells[i2][j2];
              }
            }
          }
          if (candidate) {
            candidate.occupied = true;
          }
          return candidate;
        };
        Grid4.prototype.insertColumn = function(columnIndex, length6) {
          if (length6 <= 0)
            return;
          for (var i2 = 0; i2 < length6; i2++) {
            this.cells[i2 + this.columnNum] = [];
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              this.cells[i2 + this.columnNum][j2] = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false,
                node: null
              };
            }
          }
          for (var i2 = this.columnNum - 1; i2 > columnIndex; i2--) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              this.cells[i2 + length6][j2] = __assign18(__assign18({}, this.cells[i2][j2]), { x: (i2 + length6) * this.CELL_W, y: j2 * this.CELL_H });
              this.cells[i2][j2] = {
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: true,
                node: null
              };
            }
          }
          for (var j2 = 0; j2 < this.additionColumn.length; j2++) {
            if (this.additionColumn[j2] >= columnIndex) {
              this.additionColumn[j2] += length6;
            }
          }
          for (var i2 = 0; i2 < length6; i2++) {
            this.additionColumn.push(columnIndex + i2 + 1);
          }
          this.columnNum += length6;
        };
        Grid4.prototype.insertRow = function(rowIndex, length6) {
          if (length6 <= 0)
            return;
          for (var j2 = 0; j2 < length6; j2++) {
            for (var i2 = 0; i2 < this.columnNum; i2++) {
              this.cells[i2][j2 + this.rowNum] = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false,
                node: null
              };
            }
          }
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = this.rowNum - 1; j2 > rowIndex; j2--) {
              this.cells[i2][j2 + length6] = __assign18(__assign18({}, this.cells[i2][j2]), { dx: i2, dy: j2 + length6, x: i2 * this.CELL_W, y: (j2 + length6) * this.CELL_H });
              this.cells[i2][j2] = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false,
                node: null
              };
            }
          }
          for (var j2 = 0; j2 < this.additionRow.length; j2++) {
            if (this.additionRow[j2] >= rowIndex) {
              this.additionRow[j2] += length6;
            }
          }
          for (var i2 = 0; i2 < length6; i2++) {
            this.additionRow.push(rowIndex + i2 + 1);
          }
          this.rowNum += length6;
        };
        Grid4.prototype.getNodes = function() {
          var nodes = [];
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              if (this.cells[i2][j2].node) {
                nodes.push(this.cells[i2][j2]);
              }
            }
          }
          return nodes;
        };
        Grid4.MIN_DIST = 50;
        Grid4.DEFAULT_CELL_W = 80;
        Grid4.DEFAULT_CELL_H = 80;
        return Grid4;
      }()
    );
    exports.default = Grid3;
  }
});

// node_modules/@antv/layout/lib/layout/er/forceGrid.js
var require_forceGrid = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/forceGrid.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var grid_1 = __importDefault2(require_grid2());
    function layout2(data, options) {
      if (!data.nodes || data.nodes.length === 0)
        return data;
      var width = options.width;
      var height = options.height;
      var nodeMinGap = options.nodeMinGap;
      var CELL_W = 1e4;
      var CELL_H = 1e4;
      data.nodes.forEach(function(node2) {
        var nodeWidth = node2.size[0] || 50;
        var nodeHeight = node2.size[1] || 50;
        CELL_W = Math.min(nodeWidth, CELL_W);
        CELL_H = Math.min(nodeHeight, CELL_H);
      });
      var grid = new grid_1.default();
      grid.init(width, height, {
        CELL_H,
        CELL_W
      });
      data.nodes.forEach(function(d2) {
        var gridpoint = grid.occupyNearest(d2);
        if (gridpoint) {
          gridpoint.node = {
            id: d2.id,
            size: d2.size
          };
          d2.x = gridpoint.x;
          d2.y = gridpoint.y;
          d2.dx = gridpoint.dx;
          d2.dy = gridpoint.dy;
        }
      });
      for (var i2 = 0; i2 < data.nodes.length; i2++) {
        var node = data.nodes[i2];
        var result = grid.findGridByNodeId(node.id);
        if (!result)
          throw new Error("can not find node cell");
        var column = result.column, row = result.row;
        if (node.size[0] + nodeMinGap > CELL_W) {
          var addGridSize = Math.ceil((node.size[0] + nodeMinGap) / CELL_W) - 1;
          var realAdd = addGridSize;
          for (var j2 = 0; j2 < addGridSize; j2++) {
            var hasColumn = grid.additionColumn.indexOf(column + j2 + 1) > -1;
            if (hasColumn && !grid.cells[column + j2 + 1][row].node) {
              realAdd--;
            } else {
              break;
            }
          }
          grid.insertColumn(column, realAdd);
        }
        if (node.size[1] + nodeMinGap > CELL_H) {
          var addGridSize = Math.ceil((node.size[1] + nodeMinGap) / CELL_H) - 1;
          var realAdd = addGridSize;
          for (var j2 = 0; j2 < addGridSize; j2++) {
            var hasColumn = grid.additionRow.indexOf(row + j2 + 1) > -1;
            if (hasColumn && !grid.cells[column][row + j2 + 1].node) {
              realAdd--;
            } else {
              break;
            }
          }
          grid.insertRow(row, realAdd);
        }
      }
      for (var i2 = 0; i2 < grid.columnNum; i2++) {
        var _loop_1 = function(j3) {
          var cell = grid.cells[i2][j3];
          if (cell.node) {
            var node2 = data.nodes.find(function(node3) {
              var _a2;
              return node3.id === ((_a2 = cell === null || cell === void 0 ? void 0 : cell.node) === null || _a2 === void 0 ? void 0 : _a2.id);
            });
            if (node2) {
              node2.x = cell.x + node2.size[0] / 2;
              node2.y = cell.y + node2.size[1] / 2;
            }
          }
        };
        for (var j2 = 0; j2 < grid.rowNum; j2++) {
          _loop_1(j2);
        }
      }
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/mysqlWorkbench.js
var require_mysqlWorkbench = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/mysqlWorkbench.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var graphWidth = 1200;
    var graphHeight = 800;
    var OVERLAP_QUOT = 1e7;
    var MIN_DIST = 10;
    var M_PI = 3.141592653589793;
    var M_PI_2 = 1.5707963267948966;
    var PI_38 = M_PI * 0.375;
    var PI_58 = M_PI * 0.625;
    var nodeEdgeMap = /* @__PURE__ */ new Map();
    var CELL_W = 10;
    var CELL_H = 10;
    var T2 = 0.8;
    var T_MIN = 0.1;
    var R2 = 0.5;
    function distanceToNode(node1, node2, isHoriz) {
      var x11 = node1.x - node1.size[0] / 2;
      var y11 = node1.y - node1.size[1] / 2;
      var x12 = node1.x + node1.size[0] / 2;
      var y12 = node1.y + node1.size[1] / 2;
      var x21 = node2.x - node2.size[0] / 2;
      var y21 = node2.y - node2.size[1] / 2;
      var x22 = node2.x + node2.size[0] / 2;
      var y22 = node2.y + node2.size[1] / 2;
      var cx1 = node1.x;
      var cy1 = node1.y;
      var cx2 = node2.x;
      var cy2 = node2.y;
      var dcx = cx2 - cx1;
      var qr2 = Math.atan2(dcx, cy2 - cy1);
      var dx = 0;
      var dy = 0;
      var l1 = 0;
      var l2 = 0;
      if (qr2 > M_PI_2) {
        dy = y11 - y22;
        dx = x21 - x12;
        l1 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
      } else if (0 < qr2 && qr2 <= M_PI_2) {
        dy = y21 - y12;
        dx = x21 - x12;
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      } else if (qr2 < -M_PI_2) {
        dy = y11 - y22;
        dx = -(x22 - x11);
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      } else {
        dy = y21 - y12;
        if (Math.abs(dcx) > (x12 - x11) / 2) {
          dx = x11 - x22;
        } else {
          dx = dcx;
        }
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx && qr2 !== 0 ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      }
      var aqr = parseFloat(qr2.toFixed(2));
      var newHoriz = isHoriz;
      if (isHoriz) {
        newHoriz = PI_38 < aqr && aqr < PI_58;
      }
      return {
        distance: Math.abs(l1 < l2 ? l1 : l2),
        isHoriz: newHoriz
      };
    }
    function calcNodePair(nodeA, nodeB) {
      var edges = nodeEdgeMap.get(nodeA.id) || [];
      var isLinked = edges.find(function(edge) {
        return edge.source === nodeB.id || edge.target === nodeB.id;
      });
      var areaA = nodeA.size[0] * nodeA.size[1];
      var areaB = nodeB.size[0] * nodeB.size[1];
      var node1 = areaA > areaB ? nodeB : nodeA;
      var node2 = areaA > areaB ? nodeA : nodeB;
      var x11 = node1.x - node1.size[0] / 2;
      var y11 = node1.y - node1.size[1] / 2;
      var x12 = node1.x + node1.size[0] / 2;
      var y12 = node1.y + node1.size[1] / 2;
      var x21 = node2.x - node2.size[0] / 2;
      var y21 = node2.y - node2.size[1] / 2;
      var x22 = node2.x + node2.size[0] / 2;
      var y22 = node2.y + node2.size[1] / 2;
      var cx1 = node1.x;
      var cy1 = node1.y;
      var cx2 = node2.x;
      var cy2 = node2.y;
      var isoverlap = x12 >= x21 && x22 >= x11 && y12 >= y21 && y22 >= y11;
      var e8 = 0;
      var distance11 = 0;
      if (isoverlap) {
        distance11 = Math.sqrt(Math.pow(cx2 - cx1, 2) + Math.pow(cy2 - cy1, 2));
        var sx1 = x11 > x21 ? x11 : x21;
        var sy1 = y11 > y21 ? y11 : y21;
        var sx2 = x12 < x22 ? x12 : x22;
        var sy2 = y12 < y22 ? y12 : y22;
        var dsx = sx2 - sx1;
        var dsy = sy2 - sy1;
        var sov = dsx * dsy;
        if (distance11 === 0) {
          distance11 = 1e-7;
        }
        e8 = MIN_DIST * 1 / distance11 * 100 + sov;
        e8 *= OVERLAP_QUOT;
      } else {
        var isHoriz = false;
        var res = distanceToNode(node1, node2, isHoriz);
        distance11 = res.distance;
        isHoriz = res.isHoriz;
        if (distance11 <= MIN_DIST) {
          if (distance11 !== 0) {
            if (isLinked) {
              e8 += MIN_DIST + OVERLAP_QUOT * 1 / distance11;
            } else {
              e8 += MIN_DIST + OVERLAP_QUOT * MIN_DIST / distance11;
            }
          } else {
            e8 += OVERLAP_QUOT;
          }
        } else {
          e8 += distance11;
          if (isLinked) {
            e8 += distance11 * distance11;
          }
        }
      }
      return e8;
    }
    function calcEnergy(nodes) {
      var energy = 0;
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (node.x < 0 || node.y < 0 || node.x > graphWidth || node.y > graphHeight) {
          energy += 1e12;
        }
        for (var j2 = i2 + 1; j2 < nodes.length; j2++) {
          energy += calcNodePair(node, nodes[j2]);
        }
      }
      return energy;
    }
    function isCorrectPosition(node, newPosition, nodes, edges) {
      var nodeIdxMap = /* @__PURE__ */ new Map();
      nodes.forEach(function(o2, i3) {
        nodeIdxMap.set(o2.id, o2);
      });
      var relateEdges = edges.filter(function(edge) {
        return edge.source === node.id || edge.target === node.id;
      }) || [];
      var relateNodes = [];
      relateEdges.forEach(function(edge) {
        var otherNodeId = edge.source === node.id ? edge.target : edge.source;
        var otherNode = nodeIdxMap.get(otherNodeId);
        if (otherNode) {
          relateNodes.push(otherNode);
        }
      });
      var flag = true;
      for (var i2 = 0; i2 < relateNodes.length; i2++) {
        var item = relateNodes[i2];
        var delta = Math.atan((node.y - item.y) / (item.x - node.y)) * 180;
        var newDelta = Math.atan((newPosition.y - item.y) / (item.x - newPosition.y)) * 180;
        var isHor = delta < 30 || delta > 150;
        var newIsHor = newDelta < 30 || newDelta > 150;
        var isVer = delta > 70 && delta < 110;
        var newIsVer = newDelta > 70 && newDelta < 110;
        if (isHor && !newIsHor || delta * newDelta < 0) {
          flag = false;
          break;
        } else if (isVer && !newIsVer || delta * newDelta < 0) {
          flag = false;
          break;
        } else if ((item.x - node.x) * (item.x - newPosition.x) < 0) {
          flag = false;
          break;
        } else if ((item.y - node.y) * (item.y - newPosition.y) < 0) {
          flag = false;
          break;
        }
      }
      return flag;
    }
    function shuffle(nodes, edges) {
      var foundSmallerEnergy = false;
      var step = 1;
      var wstep = CELL_W * step;
      var hstep = CELL_H * step;
      var wsteps = [wstep, -wstep, 0, 0];
      var hsteps = [0, 0, hstep, -hstep];
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        var node = nodes[i2];
        var nodeEnergy = calcNodeEnergy(node, nodes);
        for (var ns = 0; ns < wsteps.length; ns++) {
          var flag = isCorrectPosition(node, { x: node.x + wsteps[ns], y: node.y + hsteps[ns] }, nodes, edges);
          if (flag) {
            node.x += wsteps[ns];
            node.y += hsteps[ns];
            var energy = calcNodeEnergy(node, nodes);
            var rdm = Math.random();
            if (energy < nodeEnergy) {
              nodeEnergy = energy;
              foundSmallerEnergy = true;
            } else if (rdm < T2 && rdm > T_MIN) {
              nodeEnergy = energy;
              foundSmallerEnergy = true;
            } else {
              node.x -= wsteps[ns];
              node.y -= hsteps[ns];
            }
          }
        }
      }
      if (T2 > T_MIN) {
        T2 *= R2;
      }
      if (foundSmallerEnergy) {
        return calcEnergy(nodes);
      }
      return 0;
    }
    function calcNodeEnergy(node, nodes) {
      var e8 = 0;
      if (node.x < 0 || node.y < 0 || node.x + node.size[0] + 20 > graphWidth || node.y + node.size[1] + 20 > graphHeight) {
        e8 += 1e12;
      }
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        if (node.id !== nodes[i2].id) {
          e8 += calcNodePair(node, nodes[i2]);
        }
      }
      return e8;
    }
    function layout2(nodes, edges) {
      if (nodes.length === 0) {
        return { nodes, edges };
      }
      nodes.forEach(function(node) {
        var relateEdge = edges.filter(function(edge) {
          return edge.source === node.id || edge.target === node.id;
        });
        nodeEdgeMap.set(node, relateEdge);
      });
      nodes.sort(function(node1, node2) {
        var _a2, _b;
        return ((_a2 = nodeEdgeMap.get(node1.id)) === null || _a2 === void 0 ? void 0 : _a2.length) - ((_b = nodeEdgeMap.get(node2.id)) === null || _b === void 0 ? void 0 : _b.length);
      });
      var minEnergy = calcEnergy(nodes);
      var deSameCount = 20;
      var de2 = 1;
      var prevEnergy = 0;
      var MAX_COUNT = 50;
      var count = 0;
      while (deSameCount > 0) {
        count++;
        if (count >= MAX_COUNT) {
          break;
        }
        var ea2 = shuffle(nodes, edges);
        if (ea2 !== 0) {
          prevEnergy = ea2;
        }
        de2 = prevEnergy - minEnergy;
        minEnergy = prevEnergy;
        if (de2 === 0) {
          --deSameCount;
        } else {
          deSameCount = 20;
        }
      }
      nodes.forEach(function(node) {
        node.x = node.x - node.size[0] / 2;
        node.y = node.y - node.size[1] / 2;
      });
      return {
        nodes,
        edges
      };
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/core.js
var require_core = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/core.js"(exports) {
    "use strict";
    var __assign18 = exports && exports.__assign || function() {
      __assign18 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign18.apply(this, arguments);
    };
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k2 in mod4) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod4, k2)) __createBinding2(result, mod4, k2);
      }
      __setModuleDefault2(result, mod4);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3Force = __importStar2((init_src4(), __toCommonJS(src_exports4)));
    var forceGrid_1 = __importDefault2(require_forceGrid());
    var mysqlWorkbench_1 = __importDefault2(require_mysqlWorkbench());
    var dagre_1 = require_dagre2();
    function layout2(data, options) {
      var nodes = data.nodes, edges = data.edges;
      var width = options.width;
      var height = options.height;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return Promise.resolve();
      var noLeafNodes = [];
      nodes.forEach(function(node) {
        var relateEdges = edges.filter(function(edge) {
          return edge.source === node.id || edge.target === node.id;
        });
        if (relateEdges.length > 1) {
          var temp = __assign18({}, node);
          delete temp.size;
          noLeafNodes.push(temp);
        }
      });
      var noLeafEdge = [];
      edges.forEach(function(edge) {
        var sourceNode = noLeafNodes.find(function(node) {
          return node.id === edge.source;
        });
        var targetNode = noLeafNodes.find(function(node) {
          return node.id === edge.target;
        });
        if (sourceNode && targetNode) {
          noLeafEdge.push(edge);
        }
      });
      var graphLayout = new dagre_1.DagreLayout({
        type: "dagre",
        ranksep: options.nodeMinGap,
        nodesep: options.nodeMinGap
      });
      var nodesTmp = graphLayout.layout({
        nodes: noLeafNodes,
        edges: noLeafEdge
      }).nodes;
      nodes.forEach(function(n2) {
        var found = (nodesTmp || []).find(function(temp) {
          return temp.id === n2.id;
        });
        n2.x = (found === null || found === void 0 ? void 0 : found.x) || width / 2;
        n2.y = (found === null || found === void 0 ? void 0 : found.y) || height / 2;
      });
      var copyNodes = JSON.parse(JSON.stringify(nodes));
      var copyEdges = JSON.parse(JSON.stringify(edges));
      var simulation = d3Force.forceSimulation().nodes(copyNodes).force("link", d3Force.forceLink(copyEdges).id(function(d2) {
        return d2.id;
      }).distance(function(d2) {
        var edgeInfo = noLeafEdge.find(function(edge) {
          return edge.source === d2.source && edge.target === d2.target;
        });
        if (edgeInfo) {
          return 30;
        }
        return 20;
      })).force("charge", d3Force.forceManyBody()).force("center", d3Force.forceCenter(width / 2, height / 2)).force("x", d3Force.forceX(width / 2)).force("y", d3Force.forceY(height / 2)).alpha(0.3).alphaDecay(0.08).alphaMin(1e-3);
      var layoutPromise = new Promise(function(resolve) {
        simulation.on("end", function() {
          nodes.forEach(function(node) {
            var nodeInfo = copyNodes.find(function(item) {
              return item.id === node.id;
            });
            if (nodeInfo) {
              node.x = nodeInfo.x;
              node.y = nodeInfo.y;
            }
          });
          var minX = Math.min.apply(Math, nodes.map(function(node) {
            return node.x;
          }));
          var maxX = Math.max.apply(Math, nodes.map(function(node) {
            return node.x;
          }));
          var minY = Math.min.apply(Math, nodes.map(function(node) {
            return node.y;
          }));
          var maxY = Math.max.apply(Math, nodes.map(function(node) {
            return node.y;
          }));
          var scalex = width / (maxX - minX);
          var scaley = height / (maxY - minY);
          nodes.forEach(function(node) {
            if (node.x !== void 0 && scalex < 1) {
              node.x = (node.x - minX) * scalex;
            }
            if (node.y !== void 0 && scaley < 1) {
              node.y = (node.y - minY) * scaley;
            }
          });
          nodes.forEach(function(node) {
            node.sizeTemp = node.size;
            node.size = [10, 10];
          });
          (0, mysqlWorkbench_1.default)(nodes, edges);
          nodes.forEach(function(node) {
            node.size = node.sizeTemp || [];
            delete node.sizeTemp;
          });
          (0, forceGrid_1.default)({
            nodes,
            edges
          }, options);
          resolve();
        });
      });
      return layoutPromise;
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/index.js
var require_er = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/index.js"(exports) {
    "use strict";
    var __extends17 = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics4 = function(d2, b10) {
        extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
        };
        return extendStatics4(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics4(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault2 = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERLayout = void 0;
    var base_1 = require_base();
    var core_1 = __importDefault2(require_core());
    var ERLayout = (
      /** @class */
      function(_super) {
        __extends17(ERLayout2, _super);
        function ERLayout2(options) {
          var _this = _super.call(this) || this;
          _this.width = 300;
          _this.height = 300;
          _this.nodeMinGap = 50;
          _this.onLayoutEnd = function() {
          };
          if (options) {
            _this.updateCfg(options);
          }
          return _this;
        }
        ERLayout2.prototype.getDefaultCfg = function() {
          return {
            width: 300,
            height: 300,
            nodeMinGap: 50
          };
        };
        ERLayout2.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges;
          nodes === null || nodes === void 0 ? void 0 : nodes.forEach(function(node) {
            if (!node.size) {
              node.size = [50, 50];
            }
          });
          return (0, core_1.default)({
            nodes,
            edges
          }, {
            width: this.width,
            height: this.height,
            nodeMinGap: this.nodeMinGap
          }).then(function() {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
          });
        };
        ERLayout2.prototype.getType = function() {
          return "er";
        };
        return ERLayout2;
      }(base_1.Base)
    );
    exports.ERLayout = ERLayout;
  }
});

// node_modules/@antv/layout/lib/layout/layout.js
var require_layout2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Layouts = exports.Layout = void 0;
    var registy_1 = require_registy();
    var grid_1 = require_grid();
    var random_1 = require_random();
    var force2_1 = require_force2();
    var gForce_1 = require_gForce();
    var force_1 = require_force3();
    var circular_1 = require_circular();
    var dagre_1 = require_dagre2();
    var radial_1 = require_radial2();
    var concentric_1 = require_concentric();
    var mds_1 = require_mds2();
    var fruchterman_1 = require_fruchterman();
    var fruchterman_2 = require_fruchterman2();
    var gForce_2 = require_gForce2();
    var comboForce_1 = require_comboForce();
    var comboCombined_1 = require_comboCombined();
    var forceAtlas2_1 = require_forceAtlas2();
    var er_1 = require_er();
    var dagreCompound_1 = require_dagreCompound();
    var util_1 = require_util2();
    var Layout2 = (
      /** @class */
      function() {
        function Layout3(options) {
          var layoutClass = (0, registy_1.getLayoutByName)(options.type);
          this.layoutInstance = new layoutClass(options);
        }
        Layout3.prototype.layout = function(data) {
          return this.layoutInstance.layout(data);
        };
        Layout3.prototype.updateCfg = function(cfg) {
          this.layoutInstance.updateCfg(cfg);
        };
        Layout3.prototype.init = function(data) {
          this.correctLayers(data.nodes);
          this.layoutInstance.init(data);
        };
        Layout3.prototype.correctLayers = function(nodes) {
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          var minLayer = Infinity;
          var hasLayerNodes = [];
          nodes.forEach(function(node) {
            if ((0, util_1.isString)(node.layer)) {
              node.layer = parseInt(node.layer, 10);
            }
            if (node.layer === void 0 || isNaN(node.layer))
              return;
            hasLayerNodes.push(node);
            if (node.layer < minLayer)
              minLayer = node.layer;
          });
          if (minLayer <= 0) {
            var layerOffset_1 = Math.abs(minLayer) + 1;
            hasLayerNodes.forEach(function(node) {
              return node.layer += layerOffset_1;
            });
          }
        };
        Layout3.prototype.execute = function() {
          this.layoutInstance.execute();
        };
        Layout3.prototype.getDefaultCfg = function() {
          return this.layoutInstance.getDefaultCfg();
        };
        Layout3.prototype.destroy = function() {
          return this.layoutInstance.destroy();
        };
        return Layout3;
      }()
    );
    exports.Layout = Layout2;
    exports.Layouts = {
      force: force_1.ForceLayout,
      fruchterman: fruchterman_1.FruchtermanLayout,
      forceAtlas2: forceAtlas2_1.ForceAtlas2Layout,
      gForce: gForce_1.GForceLayout,
      force2: force2_1.Force2Layout,
      dagre: dagre_1.DagreLayout,
      dagreCompound: dagreCompound_1.DagreCompoundLayout,
      circular: circular_1.CircularLayout,
      radial: radial_1.RadialLayout,
      concentric: concentric_1.ConcentricLayout,
      grid: grid_1.GridLayout,
      mds: mds_1.MDSLayout,
      comboForce: comboForce_1.ComboForceLayout,
      comboCombined: comboCombined_1.ComboCombinedLayout,
      random: random_1.RandomLayout,
      "gForce-gpu": gForce_2.GForceGPULayout,
      "fruchterman-gpu": fruchterman_2.FruchtermanGPULayout,
      er: er_1.ERLayout
    };
  }
});

// node_modules/@antv/layout/lib/layout/types.js
var require_types2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@antv/layout/lib/layout/index.js
var require_layout3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding2(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERLayout = exports.ForceAtlas2Layout = exports.ComboCombinedLayout = exports.ComboForceLayout = exports.GForceGPULayout = exports.FruchtermanGPULayout = exports.FruchtermanLayout = exports.MDSLayout = exports.ConcentricLayout = exports.RadialLayout = exports.DagreCompoundLayout = exports.DagreLayout = exports.CircularLayout = exports.ForceLayout = exports.Force2Layout = exports.GForceLayout = exports.RandomLayout = exports.GridLayout = exports.Layouts = exports.Layout = void 0;
    var grid_1 = require_grid();
    Object.defineProperty(exports, "GridLayout", { enumerable: true, get: function() {
      return grid_1.GridLayout;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports, "RandomLayout", { enumerable: true, get: function() {
      return random_1.RandomLayout;
    } });
    var gForce_1 = require_gForce();
    Object.defineProperty(exports, "GForceLayout", { enumerable: true, get: function() {
      return gForce_1.GForceLayout;
    } });
    var force2_1 = require_force2();
    Object.defineProperty(exports, "Force2Layout", { enumerable: true, get: function() {
      return force2_1.Force2Layout;
    } });
    var force_1 = require_force3();
    Object.defineProperty(exports, "ForceLayout", { enumerable: true, get: function() {
      return force_1.ForceLayout;
    } });
    var circular_1 = require_circular();
    Object.defineProperty(exports, "CircularLayout", { enumerable: true, get: function() {
      return circular_1.CircularLayout;
    } });
    var dagre_1 = require_dagre2();
    Object.defineProperty(exports, "DagreLayout", { enumerable: true, get: function() {
      return dagre_1.DagreLayout;
    } });
    var dagreCompound_1 = require_dagreCompound();
    Object.defineProperty(exports, "DagreCompoundLayout", { enumerable: true, get: function() {
      return dagreCompound_1.DagreCompoundLayout;
    } });
    var radial_1 = require_radial2();
    Object.defineProperty(exports, "RadialLayout", { enumerable: true, get: function() {
      return radial_1.RadialLayout;
    } });
    var concentric_1 = require_concentric();
    Object.defineProperty(exports, "ConcentricLayout", { enumerable: true, get: function() {
      return concentric_1.ConcentricLayout;
    } });
    var mds_1 = require_mds2();
    Object.defineProperty(exports, "MDSLayout", { enumerable: true, get: function() {
      return mds_1.MDSLayout;
    } });
    var fruchterman_1 = require_fruchterman();
    Object.defineProperty(exports, "FruchtermanLayout", { enumerable: true, get: function() {
      return fruchterman_1.FruchtermanLayout;
    } });
    var fruchterman_2 = require_fruchterman2();
    Object.defineProperty(exports, "FruchtermanGPULayout", { enumerable: true, get: function() {
      return fruchterman_2.FruchtermanGPULayout;
    } });
    var gForce_2 = require_gForce2();
    Object.defineProperty(exports, "GForceGPULayout", { enumerable: true, get: function() {
      return gForce_2.GForceGPULayout;
    } });
    var comboForce_1 = require_comboForce();
    Object.defineProperty(exports, "ComboForceLayout", { enumerable: true, get: function() {
      return comboForce_1.ComboForceLayout;
    } });
    var comboCombined_1 = require_comboCombined();
    Object.defineProperty(exports, "ComboCombinedLayout", { enumerable: true, get: function() {
      return comboCombined_1.ComboCombinedLayout;
    } });
    var forceAtlas2_1 = require_forceAtlas2();
    Object.defineProperty(exports, "ForceAtlas2Layout", { enumerable: true, get: function() {
      return forceAtlas2_1.ForceAtlas2Layout;
    } });
    var er_1 = require_er();
    Object.defineProperty(exports, "ERLayout", { enumerable: true, get: function() {
      return er_1.ERLayout;
    } });
    var layout_1 = require_layout2();
    Object.defineProperty(exports, "Layout", { enumerable: true, get: function() {
      return layout_1.Layout;
    } });
    Object.defineProperty(exports, "Layouts", { enumerable: true, get: function() {
      return layout_1.Layouts;
    } });
    __exportStar2(require_types2(), exports);
  }
});

// node_modules/@antv/layout/lib/index.js
var require_lib = __commonJS({
  "node_modules/@antv/layout/lib/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding2(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;
    var registy_1 = require_registy();
    Object.defineProperty(exports, "registerLayout", { enumerable: true, get: function() {
      return registy_1.registerLayout;
    } });
    Object.defineProperty(exports, "unRegisterLayout", { enumerable: true, get: function() {
      return registy_1.unRegisterLayout;
    } });
    Object.defineProperty(exports, "getLayoutByName", { enumerable: true, get: function() {
      return registy_1.getLayoutByName;
    } });
    __exportStar2(require_layout3(), exports);
  }
});

// node_modules/@antv/hierarchy/lib/util.js
var require_util5 = __commonJS({
  "node_modules/@antv/hierarchy/lib/util.js"(exports, module) {
    function getHeight3(preNode, node, align, heightField) {
      if (heightField === void 0) {
        heightField = "height";
      }
      return align === "center" ? (preNode[heightField] + node[heightField]) / 2 : preNode.height;
    }
    module.exports = {
      assign: Object.assign,
      getHeight: getHeight3
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/hierarchy.js
var require_hierarchy = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/hierarchy.js"(exports, module) {
    var util = require_util5();
    var PEM = 18;
    var DEFAULT_HEIGHT = PEM * 2;
    var DEFAULT_GAP = PEM;
    var DEFAULT_OPTIONS = {
      getId: function getId(d2) {
        return d2.id || d2.name;
      },
      getPreH: function getPreH(d2) {
        return d2.preH || 0;
      },
      getPreV: function getPreV(d2) {
        return d2.preV || 0;
      },
      getHGap: function getHGap(d2) {
        return d2.hgap || DEFAULT_GAP;
      },
      getVGap: function getVGap(d2) {
        return d2.vgap || DEFAULT_GAP;
      },
      getChildren: function getChildren(d2) {
        return d2.children;
      },
      getHeight: function getHeight3(d2) {
        return d2.height || DEFAULT_HEIGHT;
      },
      getWidth: function getWidth(d2) {
        var label = d2.label || " ";
        return d2.width || label.split("").length * PEM;
      }
    };
    function Node3(data, options) {
      var me2 = this;
      me2.vgap = me2.hgap = 0;
      if (data instanceof Node3) return data;
      me2.data = data;
      var hgap = options.getHGap(data);
      var vgap = options.getVGap(data);
      me2.preH = options.getPreH(data);
      me2.preV = options.getPreV(data);
      me2.width = options.getWidth(data);
      me2.height = options.getHeight(data);
      me2.width += me2.preH;
      me2.height += me2.preV;
      me2.id = options.getId(data);
      me2.x = me2.y = 0;
      me2.depth = 0;
      if (!me2.children) {
        me2.children = [];
      }
      me2.addGap(hgap, vgap);
      return me2;
    }
    util.assign(Node3.prototype, {
      isRoot: function isRoot() {
        return this.depth === 0;
      },
      isLeaf: function isLeaf() {
        return this.children.length === 0;
      },
      addGap: function addGap(hgap, vgap) {
        var me2 = this;
        me2.hgap += hgap;
        me2.vgap += vgap;
        me2.width += 2 * hgap;
        me2.height += 2 * vgap;
      },
      eachNode: function eachNode(callback) {
        var me2 = this;
        var nodes = [me2];
        var current;
        while (current = nodes.shift()) {
          callback(current);
          nodes = current.children.concat(nodes);
        }
      },
      DFTraverse: function DFTraverse(callback) {
        this.eachNode(callback);
      },
      BFTraverse: function BFTraverse(callback) {
        var me2 = this;
        var nodes = [me2];
        var current;
        while (current = nodes.shift()) {
          callback(current);
          nodes = nodes.concat(current.children);
        }
      },
      getBoundingBox: function getBoundingBox() {
        var bb = {
          left: Number.MAX_VALUE,
          top: Number.MAX_VALUE,
          width: 0,
          height: 0
        };
        this.eachNode(function(node) {
          bb.left = Math.min(bb.left, node.x);
          bb.top = Math.min(bb.top, node.y);
          bb.width = Math.max(bb.width, node.x + node.width);
          bb.height = Math.max(bb.height, node.y + node.height);
        });
        return bb;
      },
      // translate
      translate: function translate7(tx, ty) {
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.eachNode(function(node) {
          node.x += tx;
          node.y += ty;
          node.x += node.preH;
          node.y += node.preV;
        });
      },
      right2left: function right2left() {
        var me2 = this;
        var bb = me2.getBoundingBox();
        me2.eachNode(function(node) {
          node.x = node.x - (node.x - bb.left) * 2 - node.width;
        });
        me2.translate(bb.width, 0);
      },
      bottom2top: function bottom2top() {
        var me2 = this;
        var bb = me2.getBoundingBox();
        me2.eachNode(function(node) {
          node.y = node.y - (node.y - bb.top) * 2 - node.height;
        });
        me2.translate(0, bb.height);
      }
    });
    function hierarchy(data, options, isolated) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      var root = new Node3(data, options);
      var nodes = [root];
      var node;
      if (!isolated && !data.collapsed) {
        while (node = nodes.shift()) {
          if (!node.data.collapsed) {
            var children = options.getChildren(node.data);
            var length6 = children ? children.length : 0;
            node.children = new Array(length6);
            if (children && length6) {
              for (var i2 = 0; i2 < length6; i2++) {
                var child = new Node3(children[i2], options);
                node.children[i2] = child;
                nodes.push(child);
                child.parent = node;
                child.depth = node.depth + 1;
              }
            }
          }
        }
      }
      return root;
    }
    module.exports = hierarchy;
  }
});

// node_modules/@antv/hierarchy/lib/layout/base.js
var require_base2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/base.js"(exports, module) {
    var hierarchy = require_hierarchy();
    var Layout2 = function() {
      function Layout3(root, options) {
        if (options === void 0) {
          options = {};
        }
        var me2 = this;
        me2.options = options;
        me2.rootNode = hierarchy(root, options);
      }
      var _proto = Layout3.prototype;
      _proto.execute = function execute() {
        throw new Error("please override this method");
      };
      return Layout3;
    }();
    module.exports = Layout2;
  }
});

// node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js
var require_non_layered_tidy = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js"(exports, module) {
    function WrappedTree(w2, h2, y4, c3) {
      if (c3 === void 0) {
        c3 = [];
      }
      var me2 = this;
      me2.w = w2 || 0;
      me2.h = h2 || 0;
      me2.y = y4 || 0;
      me2.x = 0;
      me2.c = c3 || [];
      me2.cs = c3.length;
      me2.prelim = 0;
      me2.mod = 0;
      me2.shift = 0;
      me2.change = 0;
      me2.tl = null;
      me2.tr = null;
      me2.el = null;
      me2.er = null;
      me2.msel = 0;
      me2.mser = 0;
    }
    WrappedTree.fromNode = function(root, isHorizontal) {
      if (!root) return null;
      var children = [];
      root.children.forEach(function(child) {
        children.push(WrappedTree.fromNode(child, isHorizontal));
      });
      if (isHorizontal) return new WrappedTree(root.height, root.width, root.x, children);
      return new WrappedTree(root.width, root.height, root.y, children);
    };
    function moveRight(node, move3, isHorizontal) {
      if (isHorizontal) {
        node.y += move3;
      } else {
        node.x += move3;
      }
      node.children.forEach(function(child) {
        moveRight(child, move3, isHorizontal);
      });
    }
    function getMin(node, isHorizontal) {
      var res = isHorizontal ? node.y : node.x;
      node.children.forEach(function(child) {
        res = Math.min(getMin(child, isHorizontal), res);
      });
      return res;
    }
    function normalize6(node, isHorizontal) {
      var min6 = getMin(node, isHorizontal);
      moveRight(node, -min6, isHorizontal);
    }
    function convertBack(converted, root, isHorizontal) {
      if (isHorizontal) {
        root.y = converted.x;
      } else {
        root.x = converted.x;
      }
      converted.c.forEach(function(child, i2) {
        convertBack(child, root.children[i2], isHorizontal);
      });
    }
    function layer(node, isHorizontal, d2) {
      if (d2 === void 0) {
        d2 = 0;
      }
      if (isHorizontal) {
        node.x = d2;
        d2 += node.width;
      } else {
        node.y = d2;
        d2 += node.height;
      }
      node.children.forEach(function(child) {
        layer(child, isHorizontal, d2);
      });
    }
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      var isHorizontal = options.isHorizontal;
      function firstWalk(t4) {
        if (t4.cs === 0) {
          setExtremes(t4);
          return;
        }
        firstWalk(t4.c[0]);
        var ih = updateIYL(bottom(t4.c[0].el), 0, null);
        for (var i2 = 1; i2 < t4.cs; ++i2) {
          firstWalk(t4.c[i2]);
          var min6 = bottom(t4.c[i2].er);
          separate(t4, i2, ih);
          ih = updateIYL(min6, i2, ih);
        }
        positionRoot(t4);
        setExtremes(t4);
      }
      function setExtremes(t4) {
        if (t4.cs === 0) {
          t4.el = t4;
          t4.er = t4;
          t4.msel = t4.mser = 0;
        } else {
          t4.el = t4.c[0].el;
          t4.msel = t4.c[0].msel;
          t4.er = t4.c[t4.cs - 1].er;
          t4.mser = t4.c[t4.cs - 1].mser;
        }
      }
      function separate(t4, i2, ih) {
        var sr2 = t4.c[i2 - 1];
        var mssr = sr2.mod;
        var cl = t4.c[i2];
        var mscl = cl.mod;
        while (sr2 !== null && cl !== null) {
          if (bottom(sr2) > ih.low) ih = ih.nxt;
          var dist4 = mssr + sr2.prelim + sr2.w - (mscl + cl.prelim);
          if (dist4 > 0) {
            mscl += dist4;
            moveSubtree(t4, i2, ih.index, dist4);
          }
          var sy = bottom(sr2);
          var cy = bottom(cl);
          if (sy <= cy) {
            sr2 = nextRightContour(sr2);
            if (sr2 !== null) mssr += sr2.mod;
          }
          if (sy >= cy) {
            cl = nextLeftContour(cl);
            if (cl !== null) mscl += cl.mod;
          }
        }
        if (!sr2 && !!cl) {
          setLeftThread(t4, i2, cl, mscl);
        } else if (!!sr2 && !cl) {
          setRightThread(t4, i2, sr2, mssr);
        }
      }
      function moveSubtree(t4, i2, si2, dist4) {
        t4.c[i2].mod += dist4;
        t4.c[i2].msel += dist4;
        t4.c[i2].mser += dist4;
        distributeExtra(t4, i2, si2, dist4);
      }
      function nextLeftContour(t4) {
        return t4.cs === 0 ? t4.tl : t4.c[0];
      }
      function nextRightContour(t4) {
        return t4.cs === 0 ? t4.tr : t4.c[t4.cs - 1];
      }
      function bottom(t4) {
        return t4.y + t4.h;
      }
      function setLeftThread(t4, i2, cl, modsumcl) {
        var li2 = t4.c[0].el;
        li2.tl = cl;
        var diff = modsumcl - cl.mod - t4.c[0].msel;
        li2.mod += diff;
        li2.prelim -= diff;
        t4.c[0].el = t4.c[i2].el;
        t4.c[0].msel = t4.c[i2].msel;
      }
      function setRightThread(t4, i2, sr2, modsumsr) {
        var ri2 = t4.c[i2].er;
        ri2.tr = sr2;
        var diff = modsumsr - sr2.mod - t4.c[i2].mser;
        ri2.mod += diff;
        ri2.prelim -= diff;
        t4.c[i2].er = t4.c[i2 - 1].er;
        t4.c[i2].mser = t4.c[i2 - 1].mser;
      }
      function positionRoot(t4) {
        t4.prelim = (t4.c[0].prelim + t4.c[0].mod + t4.c[t4.cs - 1].mod + t4.c[t4.cs - 1].prelim + t4.c[t4.cs - 1].w) / 2 - t4.w / 2;
      }
      function secondWalk(t4, modsum) {
        modsum += t4.mod;
        t4.x = t4.prelim + modsum;
        addChildSpacing(t4);
        for (var i2 = 0; i2 < t4.cs; i2++) {
          secondWalk(t4.c[i2], modsum);
        }
      }
      function distributeExtra(t4, i2, si2, dist4) {
        if (si2 !== i2 - 1) {
          var nr2 = i2 - si2;
          t4.c[si2 + 1].shift += dist4 / nr2;
          t4.c[i2].shift -= dist4 / nr2;
          t4.c[i2].change -= dist4 - dist4 / nr2;
        }
      }
      function addChildSpacing(t4) {
        var d2 = 0;
        var modsumdelta = 0;
        for (var i2 = 0; i2 < t4.cs; i2++) {
          d2 += t4.c[i2].shift;
          modsumdelta += d2 + t4.c[i2].change;
          t4.c[i2].mod += modsumdelta;
        }
      }
      function updateIYL(low, index2, ih) {
        while (ih !== null && low >= ih.low) {
          ih = ih.nxt;
        }
        return {
          low,
          index: index2,
          nxt: ih
        };
      }
      layer(root, isHorizontal);
      var wt2 = WrappedTree.fromNode(root, isHorizontal);
      firstWalk(wt2);
      secondWalk(wt2, 0);
      convertBack(wt2, root, isHorizontal);
      normalize6(root, isHorizontal);
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/separate-root.js
var require_separate_root = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/separate-root.js"(exports, module) {
    var hierarchy = require_hierarchy();
    module.exports = function(root, options) {
      var left = hierarchy(root.data, options, true);
      var right = hierarchy(root.data, options, true);
      var treeSize = root.children.length;
      var rightTreeSize = Math.round(treeSize / 2);
      var getSide = options.getSide || function(child2, index2) {
        if (index2 < rightTreeSize) {
          return "right";
        }
        return "left";
      };
      for (var i2 = 0; i2 < treeSize; i2++) {
        var child = root.children[i2];
        var side = getSide(child, i2);
        if (side === "right") {
          right.children.push(child);
        } else {
          left.children.push(child);
        }
      }
      left.eachNode(function(node) {
        if (!node.isRoot()) {
          node.side = "left";
        }
      });
      right.eachNode(function(node) {
        if (!node.isRoot()) {
          node.side = "right";
        }
      });
      return {
        left,
        right
      };
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/do-layout.js
var require_do_layout = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/do-layout.js"(exports, module) {
    var separateTree = require_separate_root();
    var VALID_DIRECTIONS = [
      "LR",
      // left to right
      "RL",
      // right to left
      "TB",
      // top to bottom
      "BT",
      // bottom to top
      "H",
      // horizontal
      "V"
      // vertical
    ];
    var HORIZONTAL_DIRECTIONS = ["LR", "RL", "H"];
    var isHorizontal = function isHorizontal2(direction3) {
      return HORIZONTAL_DIRECTIONS.indexOf(direction3) > -1;
    };
    var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
    module.exports = function(root, options, layoutAlgrithm) {
      var direction3 = options.direction || DEFAULT_DIRECTION;
      options.isHorizontal = isHorizontal(direction3);
      if (direction3 && VALID_DIRECTIONS.indexOf(direction3) === -1) {
        throw new TypeError("Invalid direction: " + direction3);
      }
      if (direction3 === VALID_DIRECTIONS[0]) {
        layoutAlgrithm(root, options);
      } else if (direction3 === VALID_DIRECTIONS[1]) {
        layoutAlgrithm(root, options);
        root.right2left();
      } else if (direction3 === VALID_DIRECTIONS[2]) {
        layoutAlgrithm(root, options);
      } else if (direction3 === VALID_DIRECTIONS[3]) {
        layoutAlgrithm(root, options);
        root.bottom2top();
      } else if (direction3 === VALID_DIRECTIONS[4] || direction3 === VALID_DIRECTIONS[5]) {
        var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
        layoutAlgrithm(left, options);
        layoutAlgrithm(right, options);
        options.isHorizontal ? left.right2left() : left.bottom2top();
        right.translate(left.x - right.x, left.y - right.y);
        root.x = left.x;
        root.y = right.y;
        var bb = root.getBoundingBox();
        if (options.isHorizontal) {
          if (bb.top < 0) {
            root.translate(0, -bb.top);
          }
        } else {
          if (bb.left < 0) {
            root.translate(-bb.left, 0);
          }
        }
      }
      var fixedRoot = options.fixedRoot;
      if (fixedRoot === void 0) fixedRoot = true;
      if (fixedRoot) {
        root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));
      }
      reassignXYIfRadial(root, options);
      return root;
    };
    function reassignXYIfRadial(root, options) {
      if (options.radial) {
        var _ref = options.isHorizontal ? ["x", "y"] : ["y", "x"], rScale = _ref[0], radScale = _ref[1];
        var min6 = {
          x: Infinity,
          y: Infinity
        };
        var max8 = {
          x: -Infinity,
          y: -Infinity
        };
        var count = 0;
        root.DFTraverse(function(node) {
          count++;
          var x4 = node.x, y4 = node.y;
          min6.x = Math.min(min6.x, x4);
          min6.y = Math.min(min6.y, y4);
          max8.x = Math.max(max8.x, x4);
          max8.y = Math.max(max8.y, y4);
        });
        var radDiff = max8[radScale] - min6[radScale];
        if (radDiff === 0) return;
        var avgRad = Math.PI * 2 / count;
        root.DFTraverse(function(node) {
          var rad = (node[radScale] - min6[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;
          var r2 = node[rScale] - root[rScale];
          node.x = Math.cos(rad) * r2;
          node.y = Math.sin(rad) * r2;
        });
      }
    }
  }
});

// node_modules/@antv/hierarchy/lib/compact-box.js
var require_compact_box = __commonJS({
  "node_modules/@antv/hierarchy/lib/compact-box.js"(exports, module) {
    function _inheritsLoose(t4, o2) {
      t4.prototype = Object.create(o2.prototype), t4.prototype.constructor = t4, _setPrototypeOf3(t4, o2);
    }
    function _setPrototypeOf3(t4, e8) {
      return _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e9) {
        return t5.__proto__ = e9, t5;
      }, _setPrototypeOf3(t4, e8);
    }
    var TreeLayout2 = require_base2();
    var nonLayeredTidyTree = require_non_layered_tidy();
    var doTreeLayout = require_do_layout();
    var util = require_util5();
    var CompactBoxTreeLayout = function(_TreeLayout) {
      function CompactBoxTreeLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      _inheritsLoose(CompactBoxTreeLayout2, _TreeLayout);
      var _proto = CompactBoxTreeLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        return doTreeLayout(me2.rootNode, me2.options, nonLayeredTidyTree);
      };
      return CompactBoxTreeLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function compactBoxLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new CompactBoxTreeLayout(root, options).execute();
    }
    module.exports = compactBoxLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/dendrogram.js
var require_dendrogram = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/dendrogram.js"(exports, module) {
    var util = require_util5();
    function WrappedTree(height, children) {
      if (height === void 0) {
        height = 0;
      }
      if (children === void 0) {
        children = [];
      }
      var me2 = this;
      me2.x = me2.y = 0;
      me2.leftChild = me2.rightChild = null;
      me2.height = 0;
      me2.children = children;
    }
    var DEFAULT_OPTIONS = {
      isHorizontal: true,
      nodeSep: 20,
      nodeSize: 20,
      rankSep: 200,
      subTreeSep: 10
    };
    function convertBack(converted, root, isHorizontal) {
      if (isHorizontal) {
        root.x = converted.x;
        root.y = converted.y;
      } else {
        root.x = converted.y;
        root.y = converted.x;
      }
      converted.children.forEach(function(child, i2) {
        convertBack(child, root.children[i2], isHorizontal);
      });
    }
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      var maxDepth = 0;
      function wrappedTreeFromNode(n2) {
        if (!n2) return null;
        n2.width = 0;
        if (n2.depth && n2.depth > maxDepth) {
          maxDepth = n2.depth;
        }
        var children = n2.children;
        var childrenCount = children.length;
        var t4 = new WrappedTree(n2.height, []);
        children.forEach(function(child, i2) {
          var childWT = wrappedTreeFromNode(child);
          t4.children.push(childWT);
          if (i2 === 0) {
            t4.leftChild = childWT;
          }
          if (i2 === childrenCount - 1) {
            t4.rightChild = childWT;
          }
        });
        t4.originNode = n2;
        t4.isLeaf = n2.isLeaf();
        return t4;
      }
      function getDrawingDepth(t4) {
        if (t4.isLeaf || t4.children.length === 0) {
          t4.drawingDepth = maxDepth;
        } else {
          var depths = t4.children.map(function(child) {
            return getDrawingDepth(child);
          });
          var minChildDepth = Math.min.apply(null, depths);
          t4.drawingDepth = minChildDepth - 1;
        }
        return t4.drawingDepth;
      }
      var prevLeaf;
      function position(t4) {
        t4.x = t4.drawingDepth * options.rankSep;
        if (t4.isLeaf) {
          t4.y = 0;
          if (prevLeaf) {
            t4.y = prevLeaf.y + prevLeaf.height + options.nodeSep;
            if (t4.originNode.parent !== prevLeaf.originNode.parent) {
              t4.y += options.subTreeSep;
            }
          }
          prevLeaf = t4;
        } else {
          t4.children.forEach(function(child) {
            position(child);
          });
          t4.y = (t4.leftChild.y + t4.rightChild.y) / 2;
        }
      }
      var wt2 = wrappedTreeFromNode(root);
      getDrawingDepth(wt2);
      position(wt2);
      convertBack(wt2, root, options.isHorizontal);
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/dendrogram.js
var require_dendrogram2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/dendrogram.js"(exports, module) {
    function _inheritsLoose(t4, o2) {
      t4.prototype = Object.create(o2.prototype), t4.prototype.constructor = t4, _setPrototypeOf3(t4, o2);
    }
    function _setPrototypeOf3(t4, e8) {
      return _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e9) {
        return t5.__proto__ = e9, t5;
      }, _setPrototypeOf3(t4, e8);
    }
    var TreeLayout2 = require_base2();
    var dendrogram = require_dendrogram();
    var doTreeLayout = require_do_layout();
    var util = require_util5();
    var DendrogramLayout = function(_TreeLayout) {
      function DendrogramLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      _inheritsLoose(DendrogramLayout2, _TreeLayout);
      var _proto = DendrogramLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        me2.rootNode.width = 0;
        return doTreeLayout(me2.rootNode, me2.options, dendrogram);
      };
      return DendrogramLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function dendrogramLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new DendrogramLayout(root, options).execute();
    }
    module.exports = dendrogramLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/indented.js
var require_indented = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/indented.js"(exports, module) {
    var util = require_util5();
    function positionNode(node, previousNode, indent2, dropCap, align) {
      var displacementX = (typeof indent2 === "function" ? indent2(node) : indent2) * node.depth;
      if (!dropCap) {
        try {
          if (node.id === node.parent.children[0].id) {
            node.x += displacementX;
            node.y = previousNode ? previousNode.y : 0;
            return;
          }
        } catch (e8) {
        }
      }
      node.x += displacementX;
      if (previousNode) {
        node.y = previousNode.y + util.getHeight(previousNode, node, align);
        if (previousNode.parent && node.parent.id !== previousNode.parent.id) {
          var prevParent = previousNode.parent;
          var preY = prevParent.y + util.getHeight(prevParent, node, align);
          node.y = preY > node.y ? preY : node.y;
        }
      } else {
        node.y = 0;
      }
      return;
    }
    module.exports = function(root, indent2, dropCap, align) {
      var previousNode = null;
      root.eachNode(function(node) {
        positionNode(node, previousNode, indent2, dropCap, align);
        previousNode = node;
      });
    };
  }
});

// node_modules/@antv/hierarchy/lib/indented.js
var require_indented2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/indented.js"(exports, module) {
    function _inheritsLoose(t4, o2) {
      t4.prototype = Object.create(o2.prototype), t4.prototype.constructor = t4, _setPrototypeOf3(t4, o2);
    }
    function _setPrototypeOf3(t4, e8) {
      return _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e9) {
        return t5.__proto__ = e9, t5;
      }, _setPrototypeOf3(t4, e8);
    }
    var TreeLayout2 = require_base2();
    var indentedTree = require_indented();
    var separateTree = require_separate_root();
    var util = require_util5();
    var VALID_DIRECTIONS = [
      "LR",
      // left to right
      "RL",
      // right to left
      "H"
      // horizontal
    ];
    var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
    var IndentedLayout = function(_TreeLayout) {
      function IndentedLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      _inheritsLoose(IndentedLayout2, _TreeLayout);
      var _proto = IndentedLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        var options = me2.options;
        var root = me2.rootNode;
        options.isHorizontal = true;
        var _options$indent = options.indent, indent2 = _options$indent === void 0 ? 20 : _options$indent, _options$dropCap = options.dropCap, dropCap = _options$dropCap === void 0 ? true : _options$dropCap, _options$direction = options.direction, direction3 = _options$direction === void 0 ? DEFAULT_DIRECTION : _options$direction, align = options.align;
        if (direction3 && VALID_DIRECTIONS.indexOf(direction3) === -1) {
          throw new TypeError("Invalid direction: " + direction3);
        }
        if (direction3 === VALID_DIRECTIONS[0]) {
          indentedTree(root, indent2, dropCap, align);
        } else if (direction3 === VALID_DIRECTIONS[1]) {
          indentedTree(root, indent2, dropCap, align);
          root.right2left();
        } else if (direction3 === VALID_DIRECTIONS[2]) {
          var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
          indentedTree(left, indent2, dropCap, align);
          left.right2left();
          indentedTree(right, indent2, dropCap, align);
          var bbox = left.getBoundingBox();
          right.translate(bbox.width, 0);
          root.x = right.x - root.width / 2;
        }
        return root;
      };
      return IndentedLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function indentedLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new IndentedLayout(root, options).execute();
    }
    module.exports = indentedLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/mindmap.js
var require_mindmap = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/mindmap.js"(exports, module) {
    var util = require_util5();
    function secondWalk(node, options) {
      var totalHeight = 0;
      if (!node.children.length) {
        totalHeight = node.height;
      } else {
        node.children.forEach(function(c3) {
          totalHeight += secondWalk(c3, options);
        });
      }
      node._subTreeSep = options.getSubTreeSep(node.data);
      node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;
      return node.totalHeight;
    }
    function thirdWalk(node) {
      var children = node.children;
      var len6 = children.length;
      if (len6) {
        children.forEach(function(c3) {
          thirdWalk(c3);
        });
        var first = children[0];
        var last3 = children[len6 - 1];
        var childrenHeight = last3.y - first.y + last3.height;
        var childrenTotalHeight = 0;
        children.forEach(function(child) {
          childrenTotalHeight += child.totalHeight;
        });
        if (childrenHeight > node.height) {
          node.y = first.y + childrenHeight / 2 - node.height / 2;
        } else if (children.length !== 1 || node.height > childrenTotalHeight) {
          var offset = node.y + (node.height - childrenHeight) / 2 - first.y;
          children.forEach(function(c3) {
            c3.translate(0, offset);
          });
        } else {
          node.y = (first.y + first.height / 2 + last3.y + last3.height / 2) / 2 - node.height / 2;
        }
      }
    }
    var DEFAULT_OPTIONS = {
      getSubTreeSep: function getSubTreeSep() {
        return 0;
      }
    };
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      root.parent = {
        x: 0,
        width: 0,
        height: 0,
        y: 0
      };
      root.BFTraverse(function(node) {
        node.x = node.parent.x + node.parent.width;
      });
      root.parent = null;
      secondWalk(root, options);
      root.startY = 0;
      root.y = root.totalHeight / 2 - root.height / 2;
      root.eachNode(function(node) {
        var children = node.children;
        var len6 = children.length;
        if (len6) {
          var first = children[0];
          first.startY = node.startY + node._subTreeSep;
          if (len6 === 1) {
            first.y = node.y + node.height / 2 - first.height / 2;
          } else {
            first.y = first.startY + first.totalHeight / 2 - first.height / 2;
            for (var i2 = 1; i2 < len6; i2++) {
              var c3 = children[i2];
              c3.startY = children[i2 - 1].startY + children[i2 - 1].totalHeight;
              c3.y = c3.startY + c3.totalHeight / 2 - c3.height / 2;
            }
          }
        }
      });
      thirdWalk(root);
    };
  }
});

// node_modules/@antv/hierarchy/lib/mindmap.js
var require_mindmap2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/mindmap.js"(exports, module) {
    function _inheritsLoose(t4, o2) {
      t4.prototype = Object.create(o2.prototype), t4.prototype.constructor = t4, _setPrototypeOf3(t4, o2);
    }
    function _setPrototypeOf3(t4, e8) {
      return _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e9) {
        return t5.__proto__ = e9, t5;
      }, _setPrototypeOf3(t4, e8);
    }
    var TreeLayout2 = require_base2();
    var mindmap = require_mindmap();
    var doTreeLayout = require_do_layout();
    var util = require_util5();
    var MindmapLayout = function(_TreeLayout) {
      function MindmapLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      _inheritsLoose(MindmapLayout2, _TreeLayout);
      var _proto = MindmapLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        return doTreeLayout(me2.rootNode, me2.options, mindmap);
      };
      return MindmapLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function mindmapLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new MindmapLayout(root, options).execute();
    }
    module.exports = mindmapLayout;
  }
});

// node_modules/@antv/hierarchy/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/index.js"(exports, module) {
    var hierarchy = {
      compactBox: require_compact_box(),
      dendrogram: require_dendrogram2(),
      indented: require_indented2(),
      mindmap: require_mindmap2()
    };
    module.exports = hierarchy;
  }
});

// node_modules/insert-css/index.js
var require_insert_css = __commonJS({
  "node_modules/insert-css/index.js"(exports, module) {
    var containers = [];
    var styleElements = [];
    var usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
    function insertCss5(css, options) {
      options = options || {};
      if (css === void 0) {
        throw new Error(usage);
      }
      var position = options.prepend === true ? "prepend" : "append";
      var container = options.container !== void 0 ? options.container : document.querySelector("head");
      var containerId = containers.indexOf(container);
      if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
      }
      var styleElement;
      if (styleElements[containerId] !== void 0 && styleElements[containerId][position] !== void 0) {
        styleElement = styleElements[containerId][position];
      } else {
        styleElement = styleElements[containerId][position] = createStyleElement();
        if (position === "prepend") {
          container.insertBefore(styleElement, container.childNodes[0]);
        } else {
          container.appendChild(styleElement);
        }
      }
      if (css.charCodeAt(0) === 65279) {
        css = css.substr(1, css.length);
      }
      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css;
      } else {
        styleElement.textContent += css;
      }
      return styleElement;
    }
    function createStyleElement() {
      var styleElement = document.createElement("style");
      styleElement.setAttribute("type", "text/css");
      return styleElement;
    }
    module.exports = insertCss5;
    module.exports.insertCss = insertCss5;
  }
});

// node_modules/@antv/g6-pc/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b10) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
  };
  return extendStatics(d2, b10);
};
function __extends(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign18(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e8) {
  var t4 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
    t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t4[0] & 1) throw t4[1];
    return t4[1];
  }, trys: [], ops: [] }, f2, y4, t4, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done) return t4;
      if (y4 = 0, t4) op = [op[0] & 2, t4.value];
      switch (op[0]) {
        case 0:
        case 1:
          t4 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t4[1]) {
            _2.label = t4[1];
            t4 = op;
            break;
          }
          if (t4 && _2.label < t4[2]) {
            _2.label = t4[2];
            _2.ops.push(op);
            break;
          }
          if (t4[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e8) {
      op = [6, e8];
      y4 = 0;
    } finally {
      f2 = t4 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}

// node_modules/@antv/g6-core/es/behavior/behavior.js
init_esm();

// node_modules/@antv/g6-core/es/behavior/behaviorOption.js
init_esm();
var behaviorOption_default = {
  getDefaultCfg: function getDefaultCfg() {
    return {};
  },
  /**
   * register event handler, behavior will auto bind events
   * for example:
   * return {
   *  click: 'onClick'
   * }
   */
  getEvents: function getEvents() {
    return {};
  },
  updateCfg: function updateCfg(cfg) {
    Object.assign(this, cfg);
    return true;
  },
  shouldBegin: function shouldBegin() {
    return true;
  },
  shouldUpdate: function shouldUpdate() {
    return true;
  },
  shouldEnd: function shouldEnd() {
    return true;
  },
  /**
   * auto bind events when register behavior
   * @param graph Graph instance
   */
  bind: function bind(graph) {
    var _this = this;
    var events = this.events;
    this.graph = graph;
    if (this.type === "drag-canvas" || this.type === "brush-select" || this.type === "lasso-select") {
      graph.get("canvas").set("draggable", true);
    }
    each_default(events, function(handler, event) {
      graph.on(event, handler);
    });
    document.addEventListener("visibilitychange", function() {
      _this.keydown = false;
    });
  },
  unbind: function unbind(graph) {
    var events = this.events;
    var draggable = graph.get("canvas").get("draggable");
    if (this.type === "drag-canvas" || this.type === "brush-select" || this.type === "lasso-select") {
      graph.get("canvas").set("draggable", false);
    }
    each_default(events, function(handler, event) {
      graph.off(event, handler);
    });
    graph.get("canvas").set("draggable", draggable);
  },
  get: function get(val) {
    return this[val];
  },
  set: function set(key, val) {
    this[key] = val;
    return this;
  }
};

// node_modules/@antv/g6-core/es/behavior/behavior.js
var Behavior = (
  /** @class */
  function() {
    function Behavior2() {
    }
    Behavior2.registerBehavior = function(type, behavior) {
      if (!behavior) {
        throw new Error("please specify handler for this behavior: ".concat(type));
      }
      var prototype = clone_default(behaviorOption_default);
      Object.assign(prototype, behavior);
      var base = function base2(cfg) {
        var _this = this;
        Object.assign(this, this.getDefaultCfg(), cfg);
        var events = this.getEvents();
        this.events = null;
        var eventsToBind = {};
        if (events) {
          each_default(events, function(handle, event) {
            eventsToBind[event] = wrap_behavior_default(_this, handle);
          });
          this.events = eventsToBind;
        }
      };
      base.prototype = prototype;
      Behavior2.types[type] = base;
    };
    Behavior2.hasBehavior = function(type) {
      return !!Behavior2.types[type];
    };
    Behavior2.getBehavior = function(type) {
      return Behavior2.types[type];
    };
    Behavior2.types = {};
    return Behavior2;
  }()
);
var behavior_default = Behavior;

// node_modules/@antv/g6-core/es/behavior/index.js
var behavior_default2 = behavior_default;

// node_modules/@antv/g6-core/node_modules/tslib/tslib.es6.mjs
var extendStatics3 = function(d2, b10) {
  extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
  };
  return extendStatics3(d2, b10);
};
function __extends3(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics3(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign3 = function() {
  __assign3 = Object.assign || function __assign18(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign3.apply(this, arguments);
};
function __rest3(s2, e8) {
  var t4 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
    t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
}
function __awaiter3(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator3(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t4[0] & 1) throw t4[1];
    return t4[1];
  }, trys: [], ops: [] }, f2, y4, t4, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done) return t4;
      if (y4 = 0, t4) op = [op[0] & 2, t4.value];
      switch (op[0]) {
        case 0:
        case 1:
          t4 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t4[1]) {
            _2.label = t4[1];
            t4 = op;
            break;
          }
          if (t4 && _2.label < t4[2]) {
            _2.label = t4[2];
            _2.ops.push(op);
            break;
          }
          if (t4[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e8) {
      op = [6, e8];
      y4 = 0;
    } finally {
      f2 = t4 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray2(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
    if (ar2 || !(i2 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
      ar2[i2] = from[i2];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter2.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        args[_i2 - 1] = arguments[_i2];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length6 = es.length;
        for (var i2 = 0; i2 < length6; i2++) {
          if (!es[i2]) {
            continue;
          }
          var _a2 = es[i2], callback = _a2.callback, once = _a2.once;
          if (once) {
            es.splice(i2, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length6--;
            i2--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter2.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i2 = 0; i2 < length_1; i2++) {
            if (events[i2].callback === callback) {
              events.splice(i2, 1);
              length_1--;
              i2--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter2;
  }()
);
var esm_default = EventEmitter;

// node_modules/@antv/matrix-util/esm/index.js
init_esm2();

// node_modules/@antv/matrix-util/esm/ext.js
var ext_exports = {};
__export(ext_exports, {
  angleTo: () => angleTo,
  direction: () => direction,
  leftRotate: () => leftRotate,
  leftScale: () => leftScale,
  leftTranslate: () => leftTranslate,
  transform: () => transform,
  vertical: () => vertical
});
init_esm2();
function leftTranslate(out, a3, v2) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v2);
  return mat3_exports.multiply(out, transMat, a3);
}
function leftRotate(out, a3, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a3);
}
function leftScale(out, a3, v2) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v2);
  return mat3_exports.multiply(out, scaleMat, a3);
}
function leftMultiply(out, a3, a1) {
  return mat3_exports.multiply(out, a1, a3);
}
function transform(m3, actions) {
  var matrix = m3 ? [].concat(m3) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0, len6 = actions.length; i2 < len6; i2++) {
    var action = actions[i2];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function vertical(out, v2, flag) {
  if (flag) {
    out[0] = v2[1];
    out[1] = -1 * v2[0];
  } else {
    out[0] = -1 * v2[1];
    out[1] = v2[0];
  }
  return out;
}

// node_modules/@antv/g6-core/es/graph/graph.js
init_esm();

// node_modules/@antv/algorithm/es/index.js
var es_exports = {};
__export(es_exports, {
  GADDI: () => gaddi_default,
  Stack: () => stack_default,
  breadthFirstSearch: () => bfs_default,
  connectedComponent: () => getConnectedComponents,
  cosineSimilarity: () => cosine_similarity_default,
  default: () => es_default,
  depthFirstSearch: () => depthFirstSearch,
  detectAllCycles: () => detectAllCycles,
  detectAllDirectedCycle: () => detectAllDirectedCycle,
  detectAllUndirectedCycle: () => detectAllUndirectedCycle,
  detectCycle: () => detect_cycle_default,
  detectDirectedCycle: () => detectDirectedCycle3,
  dijkstra: () => dijkstra_default,
  findAllPath: () => findAllPath,
  findShortestPath: () => findShortestPath,
  floydWarshall: () => floydWarshall_default,
  getAdjMatrix: () => adjacent_matrix_default,
  getDegree: () => degree_default,
  getInDegree: () => getInDegree,
  getNeighbors: () => getNeighbors,
  getOutDegree: () => getOutDegree,
  iLouvain: () => i_louvain_default,
  kCore: () => k_core_default,
  kMeans: () => k_means_default,
  labelPropagation: () => label_propagation_default,
  louvain: () => louvain_default,
  minimumSpanningTree: () => mts_default,
  nodesCosineSimilarity: () => nodes_cosine_similarity_default,
  pageRank: () => pageRank_default
});

// node_modules/@antv/algorithm/es/adjacent-matrix.js
var adjMatrix = function adjMatrix2(graphData, directed) {
  var nodes = graphData.nodes, edges = graphData.edges;
  var matrix = [];
  var nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach(function(node, i2) {
      nodeMap[node.id] = i2;
      var row = [];
      matrix.push(row);
    });
  }
  if (edges) {
    edges.forEach(function(edge) {
      var source = edge.source, target = edge.target;
      var sIndex = nodeMap[source];
      var tIndex = nodeMap[target];
      if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0) return;
      matrix[sIndex][tIndex] = 1;
      if (!directed) {
        matrix[tIndex][sIndex] = 1;
      }
    });
  }
  return matrix;
};
var adjacent_matrix_default = adjMatrix;

// node_modules/@antv/algorithm/es/structs/linked-list.js
var defaultComparator = function defaultComparator2(a3, b10) {
  if (a3 === b10) {
    return true;
  }
  return false;
};
var LinkedListNode = (
  /** @class */
  function() {
    function LinkedListNode2(value, next) {
      if (next === void 0) {
        next = null;
      }
      this.value = value;
      this.next = next;
    }
    LinkedListNode2.prototype.toString = function(callback) {
      return callback ? callback(this.value) : "".concat(this.value);
    };
    return LinkedListNode2;
  }()
);
var LinkedList = (
  /** @class */
  function() {
    function LinkedList2(comparator) {
      if (comparator === void 0) {
        comparator = defaultComparator;
      }
      this.head = null;
      this.tail = null;
      this.compare = comparator;
    }
    LinkedList2.prototype.prepend = function(value) {
      var newNode = new LinkedListNode(value, this.head);
      this.head = newNode;
      if (!this.tail) {
        this.tail = newNode;
      }
      return this;
    };
    LinkedList2.prototype.append = function(value) {
      var newNode = new LinkedListNode(value);
      if (!this.head) {
        this.head = newNode;
        this.tail = newNode;
        return this;
      }
      this.tail.next = newNode;
      this.tail = newNode;
      return this;
    };
    LinkedList2.prototype.delete = function(value) {
      if (!this.head) {
        return null;
      }
      var deleteNode = null;
      while (this.head && this.compare(this.head.value, value)) {
        deleteNode = this.head;
        this.head = this.head.next;
      }
      var currentNode = this.head;
      if (currentNode !== null) {
        while (currentNode.next) {
          if (this.compare(currentNode.next.value, value)) {
            deleteNode = currentNode.next;
            currentNode.next = currentNode.next.next;
          } else {
            currentNode = currentNode.next;
          }
        }
      }
      if (this.compare(this.tail.value, value)) {
        this.tail = currentNode;
      }
      return deleteNode;
    };
    LinkedList2.prototype.find = function(_a2) {
      var _b = _a2.value, value = _b === void 0 ? void 0 : _b, _c = _a2.callback, callback = _c === void 0 ? void 0 : _c;
      if (!this.head) {
        return null;
      }
      var currentNode = this.head;
      while (currentNode) {
        if (callback && callback(currentNode.value)) {
          return currentNode;
        }
        if (value !== void 0 && this.compare(currentNode.value, value)) {
          return currentNode;
        }
        currentNode = currentNode.next;
      }
      return null;
    };
    LinkedList2.prototype.deleteTail = function() {
      var deletedTail = this.tail;
      if (this.head === this.tail) {
        this.head = null;
        this.tail = null;
        return deletedTail;
      }
      var currentNode = this.head;
      while (currentNode.next) {
        if (!currentNode.next.next) {
          currentNode.next = null;
        } else {
          currentNode = currentNode.next;
        }
      }
      this.tail = currentNode;
      return deletedTail;
    };
    LinkedList2.prototype.deleteHead = function() {
      if (!this.head) {
        return null;
      }
      var deletedHead = this.head;
      if (this.head.next) {
        this.head = this.head.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      return deletedHead;
    };
    LinkedList2.prototype.fromArray = function(values3) {
      var _this = this;
      values3.forEach(function(value) {
        return _this.append(value);
      });
      return this;
    };
    LinkedList2.prototype.toArray = function() {
      var nodes = [];
      var currentNode = this.head;
      while (currentNode) {
        nodes.push(currentNode);
        currentNode = currentNode.next;
      }
      return nodes;
    };
    LinkedList2.prototype.reverse = function() {
      var currentNode = this.head;
      var prevNode = null;
      var nextNode = null;
      while (currentNode) {
        nextNode = currentNode.next;
        currentNode.next = prevNode;
        prevNode = currentNode;
        currentNode = nextNode;
      }
      this.tail = this.head;
      this.head = prevNode;
    };
    LinkedList2.prototype.toString = function(callback) {
      if (callback === void 0) {
        callback = void 0;
      }
      return this.toArray().map(function(node) {
        return node.toString(callback);
      }).toString();
    };
    return LinkedList2;
  }()
);
var linked_list_default = LinkedList;

// node_modules/@antv/algorithm/es/structs/queue.js
var Queue = (
  /** @class */
  function() {
    function Queue2() {
      this.linkedList = new linked_list_default();
    }
    Queue2.prototype.isEmpty = function() {
      return !this.linkedList.head;
    };
    Queue2.prototype.peek = function() {
      if (!this.linkedList.head) {
        return null;
      }
      return this.linkedList.head.value;
    };
    Queue2.prototype.enqueue = function(value) {
      this.linkedList.append(value);
    };
    Queue2.prototype.dequeue = function() {
      var removeHead = this.linkedList.deleteHead();
      return removeHead ? removeHead.value : null;
    };
    Queue2.prototype.toString = function(callback) {
      return this.linkedList.toString(callback);
    };
    return Queue2;
  }()
);
var queue_default = Queue;

// node_modules/@antv/algorithm/es/util.js
var getNeighbors = function getNeighbors2(nodeId, edges, type) {
  if (edges === void 0) {
    edges = [];
  }
  var currentEdges = edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
  if (type === "target") {
    var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
      return edge.source === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
      return edge.target;
    });
  }
  if (type === "source") {
    var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
      return edge.target === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
      return edge.source;
    });
  }
  var neighhborsConverter = function neighhborsConverter2(edge) {
    return edge.source === nodeId ? edge.target : edge.source;
  };
  return currentEdges.map(neighhborsConverter);
};
var getOutEdgesNodeId = function getOutEdgesNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId;
  });
};
var getEdgesByNodeId = function getEdgesByNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
};
var uniqueId = function uniqueId2(index2) {
  if (index2 === void 0) {
    index2 = 0;
  }
  var random1 = "".concat(Math.random()).split(".")[1].substr(0, 5);
  var random22 = "".concat(Math.random()).split(".")[1].substr(0, 5);
  return "".concat(index2, "-").concat(random1).concat(random22);
};

// node_modules/@antv/algorithm/es/bfs.js
function initCallbacks(callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var initiatedCallback = callbacks;
  var stubCallback = function stubCallback2() {
  };
  var allowTraversalCallback = /* @__PURE__ */ function() {
    var seen = {};
    return function(_a2) {
      var next = _a2.next;
      var id = next;
      if (!seen[id]) {
        seen[id] = true;
        return true;
      }
      return false;
    };
  }();
  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
  initiatedCallback.enter = callbacks.enter || stubCallback;
  initiatedCallback.leave = callbacks.leave || stubCallback;
  return initiatedCallback;
}
var breadthFirstSearch = function breadthFirstSearch2(graphData, startNodeId, originalCallbacks, directed) {
  if (directed === void 0) {
    directed = true;
  }
  var callbacks = initCallbacks(originalCallbacks);
  var nodeQueue = new queue_default();
  var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
  nodeQueue.enqueue(startNodeId);
  var previousNode = "";
  var _loop_1 = function _loop_12() {
    var currentNode = nodeQueue.dequeue();
    callbacks.enter({
      current: currentNode,
      previous: previousNode
    });
    getNeighbors(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
      if (callbacks.allowTraversal({
        previous: previousNode,
        current: currentNode,
        next: nextNode
      })) {
        nodeQueue.enqueue(nextNode);
      }
    });
    callbacks.leave({
      current: currentNode,
      previous: previousNode
    });
    previousNode = currentNode;
  };
  while (!nodeQueue.isEmpty()) {
    _loop_1();
  }
};
var bfs_default = breadthFirstSearch;

// node_modules/@antv/algorithm/es/connected-component.js
var detectConnectedComponents = function detectConnectedComponents2(graphData) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var allComponents = [];
  var visited = {};
  var nodeStack = [];
  var getComponent = function getComponent2(node2) {
    nodeStack.push(node2);
    visited[node2.id] = true;
    var neighbors = getNeighbors(node2.id, edges);
    var _loop_1 = function _loop_12(i4) {
      var neighbor = neighbors[i4];
      if (!visited[neighbor]) {
        var targetNode = nodes.filter(function(node3) {
          return node3.id === neighbor;
        });
        if (targetNode.length > 0) {
          getComponent2(targetNode[0]);
        }
      }
    };
    for (var i3 = 0; i3 < neighbors.length; ++i3) {
      _loop_1(i3);
    }
  };
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node = nodes[i2];
    if (!visited[node.id]) {
      getComponent(node);
      var component = [];
      while (nodeStack.length > 0) {
        component.push(nodeStack.pop());
      }
      allComponents.push(component);
    }
  }
  return allComponents;
};
var detectStrongConnectComponents = function detectStrongConnectComponents2(graphData) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodeStack = [];
  var inStack = {};
  var indices = {};
  var lowLink = {};
  var allComponents = [];
  var index2 = 0;
  var getComponent = function getComponent2(node2) {
    indices[node2.id] = index2;
    lowLink[node2.id] = index2;
    index2 += 1;
    nodeStack.push(node2);
    inStack[node2.id] = true;
    var neighbors = getNeighbors(node2.id, edges, "target").filter(function(n2) {
      return nodes.map(function(node3) {
        return node3.id;
      }).indexOf(n2) > -1;
    });
    var _loop_2 = function _loop_22(i3) {
      var targetNodeID = neighbors[i3];
      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {
        var targetNode = nodes.filter(function(node3) {
          return node3.id === targetNodeID;
        });
        if (targetNode.length > 0) {
          getComponent2(targetNode[0]);
        }
        lowLink[node2.id] = Math.min(lowLink[node2.id], lowLink[targetNodeID]);
      } else if (inStack[targetNodeID]) {
        lowLink[node2.id] = Math.min(lowLink[node2.id], indices[targetNodeID]);
      }
    };
    for (var i2 = 0; i2 < neighbors.length; i2++) {
      _loop_2(i2);
    }
    if (lowLink[node2.id] === indices[node2.id]) {
      var component = [];
      while (nodeStack.length > 0) {
        var tmpNode = nodeStack.pop();
        inStack[tmpNode.id] = false;
        component.push(tmpNode);
        if (tmpNode === node2) break;
      }
      if (component.length > 0) {
        allComponents.push(component);
      }
    }
  };
  for (var _i2 = 0, nodes_1 = nodes; _i2 < nodes_1.length; _i2++) {
    var node = nodes_1[_i2];
    if (!indices[node.id] && indices[node.id] !== 0) {
      getComponent(node);
    }
  }
  return allComponents;
};
function getConnectedComponents(graphData, directed) {
  if (directed) return detectStrongConnectComponents(graphData);
  return detectConnectedComponents(graphData);
}

// node_modules/@antv/algorithm/es/degree.js
var degree2 = function degree3(graphData) {
  var degrees3 = {};
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  nodes.forEach(function(node) {
    degrees3[node.id] = {
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
  });
  edges.forEach(function(edge) {
    degrees3[edge.source].degree++;
    degrees3[edge.source].outDegree++;
    degrees3[edge.target].degree++;
    degrees3[edge.target].inDegree++;
  });
  return degrees3;
};
var degree_default = degree2;
var getInDegree = function getInDegree2(graphData, nodeId) {
  var nodeDegree = degree2(graphData);
  if (nodeDegree[nodeId]) {
    return degree2(graphData)[nodeId].inDegree;
  }
  return 0;
};
var getOutDegree = function getOutDegree2(graphData, nodeId) {
  var nodeDegree = degree2(graphData);
  if (nodeDegree[nodeId]) {
    return degree2(graphData)[nodeId].outDegree;
  }
  return 0;
};

// node_modules/@antv/algorithm/es/dfs.js
function initCallbacks2(callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var initiatedCallback = callbacks;
  var stubCallback = function stubCallback2() {
  };
  var allowTraversalCallback = /* @__PURE__ */ function() {
    var seen = {};
    return function(_a2) {
      var next = _a2.next;
      if (!seen[next]) {
        seen[next] = true;
        return true;
      }
      return false;
    };
  }();
  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
  initiatedCallback.enter = callbacks.enter || stubCallback;
  initiatedCallback.leave = callbacks.leave || stubCallback;
  return initiatedCallback;
}
function depthFirstSearchRecursive(graphData, currentNode, previousNode, callbacks, directed) {
  if (directed === void 0) {
    directed = true;
  }
  callbacks.enter({
    current: currentNode,
    previous: previousNode
  });
  var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
  getNeighbors(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
    if (callbacks.allowTraversal({
      previous: previousNode,
      current: currentNode,
      next: nextNode
    })) {
      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks, directed);
    }
  });
  callbacks.leave({
    current: currentNode,
    previous: previousNode
  });
}
function depthFirstSearch(graphData, startNodeId, callbacks, directed) {
  if (directed === void 0) {
    directed = true;
  }
  depthFirstSearchRecursive(graphData, startNodeId, "", initCallbacks2(callbacks), directed);
}

// node_modules/@antv/algorithm/es/detect-cycle.js
var detectDirectedCycle = function detectDirectedCycle2(graphData) {
  var cycle = null;
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
  var dfsParentMap = {};
  var unvisitedSet = {};
  var visitingSet = {};
  var visitedSet = {};
  nodes.forEach(function(node) {
    unvisitedSet[node.id] = node;
  });
  var callbacks = {
    enter: function enter(_a3) {
      var currentNode = _a3.current, previousNode = _a3.previous;
      if (visitingSet[currentNode]) {
        cycle = {};
        var currentCycleNode = currentNode;
        var previousCycleNode = previousNode;
        while (previousCycleNode !== currentNode) {
          cycle[currentCycleNode] = previousCycleNode;
          currentCycleNode = previousCycleNode;
          previousCycleNode = dfsParentMap[previousCycleNode];
        }
        cycle[currentCycleNode] = previousCycleNode;
      } else {
        visitingSet[currentNode] = currentNode;
        delete unvisitedSet[currentNode];
        dfsParentMap[currentNode] = previousNode;
      }
    },
    leave: function leave(_a3) {
      var currentNode = _a3.current;
      visitedSet[currentNode] = currentNode;
      delete visitingSet[currentNode];
    },
    allowTraversal: function allowTraversal(_a3) {
      var nextNode = _a3.next;
      if (cycle) {
        return false;
      }
      return !visitedSet[nextNode];
    }
  };
  while (Object.keys(unvisitedSet).length) {
    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];
    depthFirstSearch(graphData, firsetUnVisitedKey, callbacks);
  }
  return cycle;
};
var detectAllUndirectedCycle = function detectAllUndirectedCycle2(graphData, nodeIds, include) {
  var _a2, _b;
  if (include === void 0) {
    include = true;
  }
  var allCycles = [];
  var components3 = getConnectedComponents(graphData, false);
  for (var _i2 = 0, components_1 = components3; _i2 < components_1.length; _i2++) {
    var component = components_1[_i2];
    if (!component.length) continue;
    var root = component[0];
    var rootId = root.id;
    var stack = [root];
    var parent_1 = (_a2 = {}, _a2[rootId] = root, _a2);
    var used = (_b = {}, _b[rootId] = /* @__PURE__ */ new Set(), _b);
    while (stack.length > 0) {
      var curNode = stack.pop();
      var curNodeId = curNode.id;
      var neighbors = getNeighbors(curNodeId, graphData.edges);
      var _loop_1 = function _loop_12(i3) {
        var _c;
        var neighborId = neighbors[i3];
        var neighbor = graphData.nodes.find(function(node) {
          return node.id === neighborId;
        });
        if (neighborId === curNodeId) {
          allCycles.push((_c = {}, _c[neighborId] = curNode, _c));
        } else if (!(neighborId in used)) {
          parent_1[neighborId] = curNode;
          stack.push(neighbor);
          used[neighborId] = /* @__PURE__ */ new Set([curNode]);
        } else if (!used[curNodeId].has(neighbor)) {
          var cycleValid = true;
          var cyclePath = [neighbor, curNode];
          var p2 = parent_1[curNodeId];
          while (used[neighborId].size && !used[neighborId].has(p2)) {
            cyclePath.push(p2);
            if (p2 === parent_1[p2.id]) break;
            else p2 = parent_1[p2.id];
          }
          cyclePath.push(p2);
          if (nodeIds && include) {
            cycleValid = false;
            if (cyclePath.findIndex(function(node) {
              return nodeIds.indexOf(node.id) > -1;
            }) > -1) {
              cycleValid = true;
            }
          } else if (nodeIds && !include) {
            if (cyclePath.findIndex(function(node) {
              return nodeIds.indexOf(node.id) > -1;
            }) > -1) {
              cycleValid = false;
            }
          }
          if (cycleValid) {
            var cycle = {};
            for (var index2 = 1; index2 < cyclePath.length; index2 += 1) {
              cycle[cyclePath[index2 - 1].id] = cyclePath[index2];
            }
            if (cyclePath.length) {
              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];
            }
            allCycles.push(cycle);
          }
          used[neighborId].add(curNode);
        }
      };
      for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
        _loop_1(i2);
      }
    }
  }
  return allCycles;
};
var detectAllDirectedCycle = function detectAllDirectedCycle2(graphData, nodeIds, include) {
  if (include === void 0) {
    include = true;
  }
  var path = [];
  var blocked = /* @__PURE__ */ new Set();
  var B3 = [];
  var allCycles = [];
  var idx2Node = {};
  var node2Idx = {};
  var unblock = function unblock2(thisNode) {
    var stack = [thisNode];
    while (stack.length > 0) {
      var node2 = stack.pop();
      if (blocked.has(node2)) {
        blocked.delete(node2);
        B3[node2.id].forEach(function(n2) {
          stack.push(n2);
        });
        B3[node2.id].clear();
      }
    }
  };
  var circuit = function circuit2(node2, start, adjList2) {
    var closed = false;
    if (nodeIds && include === false && nodeIds.indexOf(node2.id) > -1) return closed;
    path.push(node2);
    blocked.add(node2);
    var neighbors = adjList2[node2.id];
    for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
      var neighbor = idx2Node[neighbors[i3]];
      if (neighbor === start) {
        var cycle = {};
        for (var index2 = 1; index2 < path.length; index2 += 1) {
          cycle[path[index2 - 1].id] = path[index2];
        }
        if (path.length) {
          cycle[path[path.length - 1].id] = path[0];
        }
        allCycles.push(cycle);
        closed = true;
      } else if (!blocked.has(neighbor)) {
        if (circuit2(neighbor, start, adjList2)) {
          closed = true;
        }
      }
    }
    if (closed) {
      unblock(node2);
    } else {
      for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
        var neighbor = idx2Node[neighbors[i3]];
        if (!B3[neighbor.id].has(node2)) {
          B3[neighbor.id].add(node2);
        }
      }
    }
    path.pop();
    return closed;
  };
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
  for (var i2 = 0; i2 < nodes.length; i2 += 1) {
    var node = nodes[i2];
    var nodeId = node.id;
    node2Idx[nodeId] = i2;
    idx2Node[i2] = node;
  }
  if (nodeIds && include) {
    var _loop_2 = function _loop_22(i3) {
      var nodeId2 = nodeIds[i3];
      node2Idx[nodes[i3].id] = node2Idx[nodeId2];
      node2Idx[nodeId2] = 0;
      idx2Node[0] = nodes.find(function(node2) {
        return node2.id === nodeId2;
      });
      idx2Node[node2Idx[nodes[i3].id]] = nodes[i3];
    };
    for (var i2 = 0; i2 < nodeIds.length; i2++) {
      _loop_2(i2);
    }
  }
  var getMinComponentAdj = function getMinComponentAdj2(components3) {
    var _a3;
    var minCompIdx;
    var minIdx2 = Infinity;
    for (var i3 = 0; i3 < components3.length; i3 += 1) {
      var comp = components3[i3];
      for (var j2 = 0; j2 < comp.length; j2++) {
        var nodeIdx_1 = node2Idx[comp[j2].id];
        if (nodeIdx_1 < minIdx2) {
          minIdx2 = nodeIdx_1;
          minCompIdx = i3;
        }
      }
    }
    var component2 = components3[minCompIdx];
    var adjList2 = [];
    for (var i3 = 0; i3 < component2.length; i3 += 1) {
      var node2 = component2[i3];
      adjList2[node2.id] = [];
      for (var _i2 = 0, _b = getNeighbors(node2.id, graphData.edges, "target").filter(function(n2) {
        return component2.map(function(c3) {
          return c3.id;
        }).indexOf(n2) > -1;
      }); _i2 < _b.length; _i2++) {
        var neighbor = _b[_i2];
        if (neighbor === node2.id && !(include === false && nodeIds.indexOf(node2.id) > -1)) {
          allCycles.push((_a3 = {}, _a3[node2.id] = node2, _a3));
        } else {
          adjList2[node2.id].push(node2Idx[neighbor]);
        }
      }
    }
    return {
      component: component2,
      adjList: adjList2,
      minIdx: minIdx2
    };
  };
  var nodeIdx = 0;
  while (nodeIdx < nodes.length) {
    var subgraphNodes = nodes.filter(function(n2) {
      return node2Idx[n2.id] >= nodeIdx;
    });
    var sccs = detectStrongConnectComponents({
      nodes: subgraphNodes,
      edges: graphData.edges
    }).filter(function(component2) {
      return component2.length > 1;
    });
    if (sccs.length === 0) break;
    var scc = getMinComponentAdj(sccs);
    var minIdx = scc.minIdx, adjList = scc.adjList, component = scc.component;
    if (component.length > 1) {
      component.forEach(function(node2) {
        B3[node2.id] = /* @__PURE__ */ new Set();
      });
      var startNode = idx2Node[minIdx];
      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;
      circuit(startNode, startNode, adjList);
      nodeIdx = minIdx + 1;
    } else {
      break;
    }
  }
  return allCycles;
};
var detectAllCycles = function detectAllCycles2(graphData, directed, nodeIds, include) {
  if (include === void 0) {
    include = true;
  }
  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);
  return detectAllUndirectedCycle(graphData, nodeIds, include);
};
var detect_cycle_default = detectDirectedCycle;

// node_modules/@antv/algorithm/es/dijkstra.js
init_tslib_es6();
init_esm();
var minVertex = function minVertex2(D3, nodes, marks) {
  var minDis = Infinity;
  var minNode;
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var nodeId = nodes[i2].id;
    if (!marks[nodeId] && D3[nodeId] <= minDis) {
      minDis = D3[nodeId];
      minNode = nodes[i2];
    }
  }
  return minNode;
};
var dijkstra = function dijkstra2(graphData, source, directed, weightPropertyName) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodeIds = [];
  var marks = {};
  var D3 = {};
  var prevs = {};
  nodes.forEach(function(node, i3) {
    var id = node.id;
    nodeIds.push(id);
    D3[id] = Infinity;
    if (id === source) D3[id] = 0;
  });
  var nodeNum = nodes.length;
  var _loop_1 = function _loop_12(i3) {
    var minNode = minVertex(D3, nodes, marks);
    var minNodeId = minNode.id;
    marks[minNodeId] = true;
    if (D3[minNodeId] === Infinity) return "continue";
    var relatedEdges = [];
    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);
    else relatedEdges = getEdgesByNodeId(minNodeId, edges);
    relatedEdges.forEach(function(edge) {
      var edgeTarget = edge.target;
      var edgeSource = edge.source;
      var w2 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
      if (D3[w2] > D3[minNode.id] + weight) {
        D3[w2] = D3[minNode.id] + weight;
        prevs[w2] = [minNode.id];
      } else if (D3[w2] === D3[minNode.id] + weight) {
        prevs[w2].push(minNode.id);
      }
    });
  };
  for (var i2 = 0; i2 < nodeNum; i2++) {
    _loop_1(i2);
  }
  prevs[source] = [source];
  var paths = {};
  for (var target in D3) {
    if (D3[target] !== Infinity) {
      findAllPaths(source, target, prevs, paths);
    }
  }
  var path = {};
  for (var target in paths) {
    path[target] = paths[target][0];
  }
  return {
    length: D3,
    path,
    allPath: paths
  };
};
var dijkstra_default = dijkstra;
function findAllPaths(source, target, prevs, foundPaths) {
  if (source === target) {
    return [source];
  }
  if (foundPaths[target]) {
    return foundPaths[target];
  }
  var paths = [];
  for (var _i2 = 0, _a2 = prevs[target]; _i2 < _a2.length; _i2++) {
    var prev = _a2[_i2];
    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);
    if (!prevPaths) return;
    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
      var prePath = prevPaths_1[_b];
      if (is_array_default(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));
      else paths.push([prePath, target]);
    }
  }
  foundPaths[target] = paths;
  return foundPaths[target];
}

// node_modules/@antv/algorithm/es/find-path.js
var findShortestPath = function findShortestPath2(graphData, start, end2, directed, weightPropertyName) {
  var _a2 = dijkstra_default(graphData, start, directed, weightPropertyName), length6 = _a2.length, path = _a2.path, allPath = _a2.allPath;
  return {
    length: length6[end2],
    path: path[end2],
    allPath: allPath[end2]
  };
};
var findAllPath = function findAllPath2(graphData, start, end2, directed) {
  var _a2;
  if (start === end2) return [[start]];
  var _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var visited = [start];
  var isVisited = (_a2 = {}, _a2[start] = true, _a2);
  var stack = [];
  var allPath = [];
  var neighbors = directed ? getNeighbors(start, edges, "target") : getNeighbors(start, edges);
  stack.push(neighbors);
  while (visited.length > 0 && stack.length > 0) {
    var children = stack[stack.length - 1];
    if (children.length) {
      var child = children.shift();
      if (child) {
        visited.push(child);
        isVisited[child] = true;
        neighbors = directed ? getNeighbors(child, edges, "target") : getNeighbors(child, edges);
        stack.push(neighbors.filter(function(neighbor) {
          return !isVisited[neighbor];
        }));
      }
    } else {
      var node = visited.pop();
      isVisited[node] = false;
      stack.pop();
      continue;
    }
    if (visited[visited.length - 1] === end2) {
      var path = visited.map(function(node2) {
        return node2;
      });
      allPath.push(path);
      var node = visited.pop();
      isVisited[node] = false;
      stack.pop();
    }
  }
  return allPath;
};

// node_modules/@antv/algorithm/es/floydWarshall.js
var floydWarshall = function floydWarshall2(graphData, directed) {
  var adjacentMatrix = adjacent_matrix_default(graphData, directed);
  var dist4 = [];
  var size3 = adjacentMatrix.length;
  for (var i2 = 0; i2 < size3; i2 += 1) {
    dist4[i2] = [];
    for (var j2 = 0; j2 < size3; j2 += 1) {
      if (i2 === j2) {
        dist4[i2][j2] = 0;
      } else if (adjacentMatrix[i2][j2] === 0 || !adjacentMatrix[i2][j2]) {
        dist4[i2][j2] = Infinity;
      } else {
        dist4[i2][j2] = adjacentMatrix[i2][j2];
      }
    }
  }
  for (var k2 = 0; k2 < size3; k2 += 1) {
    for (var i2 = 0; i2 < size3; i2 += 1) {
      for (var j2 = 0; j2 < size3; j2 += 1) {
        if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
          dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
        }
      }
    }
  }
  return dist4;
};
var floydWarshall_default = floydWarshall;

// node_modules/@antv/algorithm/es/label-propagation.js
var labelPropagation = function labelPropagation2(graphData, directed, weightPropertyName, maxIteration) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (maxIteration === void 0) {
    maxIteration = 1e3;
  }
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var clusters = {};
  var nodeMap = {};
  nodes.forEach(function(node, i2) {
    var cid = uniqueId();
    node.clusterId = cid;
    clusters[cid] = {
      id: cid,
      nodes: [node]
    };
    nodeMap[node.id] = {
      node,
      idx: i2
    };
  });
  var adjMatrix3 = adjacent_matrix_default(graphData, directed);
  var ks = [];
  var neighbors = {};
  adjMatrix3.forEach(function(row, i2) {
    var k2 = 0;
    var iid = nodes[i2].id;
    neighbors[iid] = {};
    row.forEach(function(entry, j2) {
      if (!entry) return;
      k2 += entry;
      var jid = nodes[j2].id;
      neighbors[iid][jid] = entry;
    });
    ks.push(k2);
  });
  var iter = 0;
  var _loop_1 = function _loop_12() {
    var changed = false;
    nodes.forEach(function(node) {
      var neighborClusters = {};
      Object.keys(neighbors[node.id]).forEach(function(neighborId) {
        var neighborWeight = neighbors[node.id][neighborId];
        var neighborNode = nodeMap[neighborId].node;
        var neighborClusterId = neighborNode.clusterId;
        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;
        neighborClusters[neighborClusterId] += neighborWeight;
      });
      var maxWeight = -Infinity;
      var bestClusterIds = [];
      Object.keys(neighborClusters).forEach(function(clusterId) {
        if (maxWeight < neighborClusters[clusterId]) {
          maxWeight = neighborClusters[clusterId];
          bestClusterIds = [clusterId];
        } else if (maxWeight === neighborClusters[clusterId]) {
          bestClusterIds.push(clusterId);
        }
      });
      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;
      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);
      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);
      if (bestClusterIds && bestClusterIds.length) {
        changed = true;
        var selfCluster = clusters[node.clusterId];
        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);
        var bestCluster = clusters[bestClusterIds[randomIdx]];
        bestCluster.nodes.push(node);
        node.clusterId = bestCluster.id;
      }
    });
    if (!changed) return "break";
    iter++;
  };
  while (iter < maxIteration) {
    var state_1 = _loop_1();
    if (state_1 === "break") break;
  }
  Object.keys(clusters).forEach(function(clusterId) {
    var cluster = clusters[clusterId];
    if (!cluster.nodes || !cluster.nodes.length) {
      delete clusters[clusterId];
    }
  });
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var source = edge.source, target = edge.target;
    var weight = edge[weightPropertyName] || 1;
    var sourceClusterId = nodeMap[source].node.clusterId;
    var targetClusterId = nodeMap[target].node.clusterId;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].weight += weight;
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        weight,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  var clustersArray = [];
  Object.keys(clusters).forEach(function(clusterId) {
    clustersArray.push(clusters[clusterId]);
  });
  return {
    clusters: clustersArray,
    clusterEdges
  };
};
var label_propagation_default = labelPropagation;

// node_modules/@antv/algorithm/es/louvain.js
init_esm();

// node_modules/@antv/algorithm/es/utils/vector.js
init_esm();
var Vector = (
  /** @class */
  function() {
    function Vector2(arr) {
      this.arr = arr;
    }
    Vector2.prototype.getArr = function() {
      return this.arr || [];
    };
    Vector2.prototype.add = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        return new Vector2(otherArr);
      }
      if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return new Vector2(this.arr);
      }
      if (this.arr.length === otherArr.length) {
        var res = [];
        for (var index2 in this.arr) {
          res[index2] = this.arr[index2] + otherArr[index2];
        }
        return new Vector2(res);
      }
    };
    Vector2.prototype.subtract = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        return new Vector2(otherArr);
      }
      if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return new Vector2(this.arr);
      }
      if (this.arr.length === otherArr.length) {
        var res = [];
        for (var index2 in this.arr) {
          res[index2] = this.arr[index2] - otherArr[index2];
        }
        return new Vector2(res);
      }
    };
    Vector2.prototype.avg = function(length6) {
      var res = [];
      if (length6 !== 0) {
        for (var index2 in this.arr) {
          res[index2] = this.arr[index2] / length6;
        }
      }
      return new Vector2(res);
    };
    Vector2.prototype.negate = function() {
      var res = [];
      for (var index2 in this.arr) {
        res[index2] = -this.arr[index2];
      }
      return new Vector2(res);
    };
    Vector2.prototype.squareEuclideanDistance = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index2 in this.arr) {
          res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
        }
        return res;
      }
    };
    Vector2.prototype.euclideanDistance = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index2 in this.arr) {
          res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
        }
        return Math.sqrt(res);
      } else {
        console.error("The two vectors are unequal in length.");
      }
    };
    Vector2.prototype.normalize = function() {
      var res = [];
      var cloneArr = clone_default(this.arr);
      cloneArr.sort(function(a3, b10) {
        return a3 - b10;
      });
      var max8 = cloneArr[cloneArr.length - 1];
      var min6 = cloneArr[0];
      for (var index2 in this.arr) {
        res[index2] = (this.arr[index2] - min6) / (max8 - min6);
      }
      return new Vector2(res);
    };
    Vector2.prototype.norm2 = function() {
      var _a2;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        return 0;
      }
      var res = 0;
      for (var index2 in this.arr) {
        res += Math.pow(this.arr[index2], 2);
      }
      return Math.sqrt(res);
    };
    Vector2.prototype.dot = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index2 in this.arr) {
          res += this.arr[index2] * otherVector.arr[index2];
        }
        return res;
      } else {
        console.error("The two vectors are unequal in length.");
      }
    };
    Vector2.prototype.equal = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return false;
      }
      for (var index2 in this.arr) {
        if (this.arr[index2] !== otherArr[index2]) {
          return false;
        }
      }
      return true;
    };
    return Vector2;
  }()
);
var vector_default = Vector;

// node_modules/@antv/algorithm/es/utils/node-properties.js
var getAllProperties = function getAllProperties2(nodes, key) {
  if (key === void 0) {
    key = void 0;
  }
  var allProperties = [];
  nodes.forEach(function(node) {
    if (key === void 0) {
      allProperties.push(node);
    }
    if (node[key] !== void 0) {
      allProperties.push(node[key]);
    }
  });
  return allProperties;
};

// node_modules/@antv/algorithm/es/utils/data-preprocessing.js
init_esm();

// node_modules/@antv/algorithm/es/types.js
var DistanceType;
(function(DistanceType2) {
  DistanceType2["EuclideanDistance"] = "euclideanDistance";
})(DistanceType || (DistanceType = {}));

// node_modules/@antv/algorithm/es/utils/data-preprocessing.js
var getAllKeyValueMap = function getAllKeyValueMap2(dataList, involvedKeys, uninvolvedKeys) {
  var keys3 = [];
  if (involvedKeys === null || involvedKeys === void 0 ? void 0 : involvedKeys.length) {
    keys3 = involvedKeys;
  } else {
    dataList.forEach(function(data) {
      keys3 = keys3.concat(Object.keys(data));
    });
    keys3 = uniq(keys3);
  }
  var allKeyValueMap = {};
  keys3.forEach(function(key) {
    var value = [];
    dataList.forEach(function(data) {
      if (data[key] !== void 0 && data[key] !== "") {
        value.push(data[key]);
      }
    });
    if (value.length && !(uninvolvedKeys === null || uninvolvedKeys === void 0 ? void 0 : uninvolvedKeys.includes(key))) {
      allKeyValueMap[key] = uniq(value);
    }
  });
  return allKeyValueMap;
};
var oneHot = function oneHot2(dataList, involvedKeys, uninvolvedKeys) {
  var allKeyValueMap = getAllKeyValueMap(dataList, involvedKeys, uninvolvedKeys);
  var oneHotCode = [];
  if (!Object.keys(allKeyValueMap).length) {
    return oneHotCode;
  }
  var allValue = Object.values(allKeyValueMap);
  var isAllNumber = allValue.every(function(value) {
    return value.every(function(item) {
      return typeof item === "number";
    });
  });
  dataList.forEach(function(data, index2) {
    var code = [];
    Object.keys(allKeyValueMap).forEach(function(key) {
      var keyValue = data[key];
      var allKeyValue = allKeyValueMap[key];
      var valueIndex = allKeyValue.findIndex(function(value) {
        return keyValue === value;
      });
      var subCode = [];
      if (isAllNumber) {
        subCode.push(keyValue);
      } else {
        for (var i2 = 0; i2 < allKeyValue.length; i2++) {
          if (i2 === valueIndex) {
            subCode.push(1);
          } else {
            subCode.push(0);
          }
        }
      }
      code = code.concat(subCode);
    });
    oneHotCode[index2] = code;
  });
  return oneHotCode;
};
var getDistance = function getDistance2(item, otherItem, distanceType, graphData) {
  if (distanceType === void 0) {
    distanceType = DistanceType.EuclideanDistance;
  }
  var distance11 = 0;
  switch (distanceType) {
    case DistanceType.EuclideanDistance:
      distance11 = new vector_default(item).euclideanDistance(new vector_default(otherItem));
      break;
    default:
      break;
  }
  return distance11;
};

// node_modules/@antv/algorithm/es/louvain.js
var getModularity = function getModularity2(nodes, adjMatrix3, ks, m3) {
  var length6 = adjMatrix3.length;
  var param = 2 * m3;
  var modularity = 0;
  for (var i2 = 0; i2 < length6; i2++) {
    var clusteri = nodes[i2].clusterId;
    for (var j2 = 0; j2 < length6; j2++) {
      var clusterj = nodes[j2].clusterId;
      if (clusteri !== clusterj) continue;
      var entry = adjMatrix3[i2][j2] || 0;
      var ki2 = ks[i2] || 0;
      var kj = ks[j2] || 0;
      modularity += entry - ki2 * kj / param;
    }
  }
  modularity *= 1 / param;
  return modularity;
};
var getInertialModularity = function getInertialModularity2(nodes, allPropertiesWeight) {
  if (nodes === void 0) {
    nodes = [];
  }
  var length6 = nodes.length;
  var totalProperties = new vector_default([]);
  for (var i2 = 0; i2 < length6; i2++) {
    totalProperties = totalProperties.add(new vector_default(allPropertiesWeight[i2]));
  }
  var avgProperties = totalProperties.avg(length6);
  avgProperties.normalize();
  var variance = 0;
  for (var i2 = 0; i2 < length6; i2++) {
    var propertiesi = new vector_default(allPropertiesWeight[i2]);
    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);
    variance += squareEuclideanDistance;
  }
  var squareEuclideanDistanceInfo = [];
  nodes.forEach(function() {
    squareEuclideanDistanceInfo.push([]);
  });
  for (var i2 = 0; i2 < length6; i2++) {
    var propertiesi = new vector_default(allPropertiesWeight[i2]);
    nodes[i2]["clusterInertial"] = 0;
    for (var j2 = 0; j2 < length6; j2++) {
      if (i2 === j2) {
        squareEuclideanDistanceInfo[i2][j2] = 0;
        continue;
      }
      var propertiesj = new vector_default(allPropertiesWeight[j2]);
      squareEuclideanDistanceInfo[i2][j2] = propertiesi.squareEuclideanDistance(propertiesj);
      nodes[i2]["clusterInertial"] += squareEuclideanDistanceInfo[i2][j2];
    }
  }
  var inertialModularity = 0;
  var param = 2 * length6 * variance;
  for (var i2 = 0; i2 < length6; i2++) {
    var clusteri = nodes[i2].clusterId;
    for (var j2 = 0; j2 < length6; j2++) {
      var clusterj = nodes[j2].clusterId;
      if (i2 === j2 || clusteri !== clusterj) continue;
      var inertial = nodes[i2].clusterInertial * nodes[j2].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i2][j2] / param;
      inertialModularity += inertial;
    }
  }
  return Number(inertialModularity.toFixed(4));
};
var louvain = function louvain2(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (threshold === void 0) {
    threshold = 1e-4;
  }
  if (inertialModularity === void 0) {
    inertialModularity = false;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (inertialWeight === void 0) {
    inertialWeight = 1;
  }
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var allPropertiesWeight = [];
  if (inertialModularity) {
    nodes.forEach(function(node, index2) {
      node.properties = node.properties || {};
      node.originIndex = index2;
    });
    var nodeTypeInfo_1 = [];
    if (nodes.every(function(node) {
      return node.hasOwnProperty("nodeType");
    })) {
      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function(node) {
        return node.nodeType;
      })));
      nodes.forEach(function(node) {
        node.properties.nodeType = nodeTypeInfo_1.findIndex(function(nodeType) {
          return nodeType === node.nodeType;
        });
      });
    }
    var properties = getAllProperties(nodes, propertyKey);
    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  }
  var uniqueId5 = 1;
  var clusters = {};
  var nodeMap = {};
  nodes.forEach(function(node, i2) {
    var cid = String(uniqueId5++);
    node.clusterId = cid;
    clusters[cid] = {
      id: cid,
      nodes: [node]
    };
    nodeMap[node.id] = {
      node,
      idx: i2
    };
  });
  var adjMatrix3 = adjacent_matrix_default(graphData, directed);
  var ks = [];
  var neighbors = {};
  var m3 = 0;
  adjMatrix3.forEach(function(row, i2) {
    var k2 = 0;
    var iid = nodes[i2].id;
    neighbors[iid] = {};
    row.forEach(function(entry, j2) {
      if (!entry) return;
      k2 += entry;
      var jid = nodes[j2].id;
      neighbors[iid][jid] = entry;
      m3 += entry;
    });
    ks.push(k2);
  });
  m3 /= 2;
  var totalModularity = Infinity;
  var previousModularity = Infinity;
  var iter = 0;
  var finalNodes = [];
  var finalClusters = {};
  while (true) {
    if (inertialModularity && nodes.every(function(node) {
      return node.hasOwnProperty("properties");
    })) {
      totalModularity = getModularity(nodes, adjMatrix3, ks, m3) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;
    } else {
      totalModularity = getModularity(nodes, adjMatrix3, ks, m3);
    }
    if (iter === 0) {
      previousModularity = totalModularity;
      finalNodes = nodes;
      finalClusters = clusters;
    }
    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;
    if (totalModularity > previousModularity) {
      finalNodes = nodes.map(function(node) {
        return {
          node,
          clusterId: node.clusterId
        };
      });
      finalClusters = clone_default(clusters);
      previousModularity = totalModularity;
    }
    if (increaseWithinThreshold || iter > 100) {
      break;
    }
    ;
    iter++;
    Object.keys(clusters).forEach(function(clusterId) {
      var sumTot = 0;
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {
          sumTot = sumTot + (edge[weightPropertyName] || 1);
        }
      });
      clusters[clusterId].sumTot = sumTot;
    });
    nodes.forEach(function(node, i2) {
      var selfCluster = clusters[node.clusterId];
      var bestIncrease = 0;
      var bestCluster;
      var commonParam = ks[i2] / (2 * m3);
      var kiin = 0;
      var selfClusterNodes = selfCluster.nodes;
      selfClusterNodes.forEach(function(scNode) {
        var scNodeIdx = nodeMap[scNode.id].idx;
        kiin += adjMatrix3[i2][scNodeIdx] || 0;
      });
      var removeModurarity = kiin - selfCluster.sumTot * commonParam;
      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function(scNode) {
        return scNode.id !== node.id;
      });
      var propertiesWeightRemove = [];
      selfClusterNodesAfterRemove.forEach(function(nodeRemove, index2) {
        propertiesWeightRemove[index2] = allPropertiesWeight[nodeRemove.originIndex];
      });
      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;
      var nodeNeighborIds = neighbors[node.id];
      Object.keys(nodeNeighborIds).forEach(function(neighborNodeId) {
        var neighborNode = nodeMap[neighborNodeId].node;
        var neighborClusterId = neighborNode.clusterId;
        if (neighborClusterId === node.clusterId) return;
        var neighborCluster = clusters[neighborClusterId];
        var clusterNodes = neighborCluster.nodes;
        if (!clusterNodes || !clusterNodes.length) return;
        var neighborClusterKiin = 0;
        clusterNodes.forEach(function(cNode) {
          var cNodeIdx = nodeMap[cNode.id].idx;
          neighborClusterKiin += adjMatrix3[i2][cNodeIdx] || 0;
        });
        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;
        var clusterNodesAfterAdd = clusterNodes.concat([node]);
        var propertiesWeightAdd = [];
        clusterNodesAfterAdd.forEach(function(nodeAdd, index2) {
          propertiesWeightAdd[index2] = allPropertiesWeight[nodeAdd.originIndex];
        });
        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;
        var increase = addModurarity - removeModurarity;
        if (inertialModularity) {
          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);
        }
        if (increase > bestIncrease) {
          bestIncrease = increase;
          bestCluster = neighborCluster;
        }
      });
      if (bestIncrease > 0) {
        bestCluster.nodes.push(node);
        var previousClusterId_1 = node.clusterId;
        node.clusterId = bestCluster.id;
        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
        var neighborClusterSumTot_1 = 0;
        var selfClusterSumTot_1 = 0;
        edges.forEach(function(edge) {
          var source = edge.source, target = edge.target;
          var sourceClusterId = nodeMap[source].node.clusterId;
          var targetClusterId = nodeMap[target].node.clusterId;
          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {
            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);
          }
          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {
            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);
          }
        });
        bestCluster.sumTot = neighborClusterSumTot_1;
        selfCluster.sumTot = selfClusterSumTot_1;
      }
    });
  }
  var newClusterIdMap = {};
  var clusterIdx = 0;
  Object.keys(finalClusters).forEach(function(clusterId) {
    var cluster = finalClusters[clusterId];
    if (!cluster.nodes || !cluster.nodes.length) {
      delete finalClusters[clusterId];
      return;
    }
    var newId = String(clusterIdx + 1);
    if (newId === clusterId) {
      return;
    }
    cluster.id = newId;
    cluster.nodes = cluster.nodes.map(function(item) {
      return {
        id: item.id,
        clusterId: newId
      };
    });
    finalClusters[newId] = cluster;
    newClusterIdMap[clusterId] = newId;
    delete finalClusters[clusterId];
    clusterIdx++;
  });
  finalNodes.forEach(function(nodeInfo) {
    var node = nodeInfo.node, clusterId = nodeInfo.clusterId;
    if (!node) return;
    node.clusterId = clusterId;
    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];
  });
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var source = edge.source, target = edge.target;
    var weight = edge[weightPropertyName] || 1;
    var sourceClusterId = nodeMap[source].node.clusterId;
    var targetClusterId = nodeMap[target].node.clusterId;
    if (!sourceClusterId || !targetClusterId) return;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].weight += weight;
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        weight,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  var clustersArray = [];
  Object.keys(finalClusters).forEach(function(clusterId) {
    clustersArray.push(finalClusters[clusterId]);
  });
  return {
    clusters: clustersArray,
    clusterEdges
  };
};
var louvain_default = louvain;

// node_modules/@antv/algorithm/es/i-louvain.js
var iLouvain = function iLouvain2(graphData, directed, weightPropertyName, threshold, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (threshold === void 0) {
    threshold = 1e-4;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (inertialWeight === void 0) {
    inertialWeight = 1;
  }
  return louvain_default(graphData, directed, weightPropertyName, threshold, true, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight);
};
var i_louvain_default = iLouvain;

// node_modules/@antv/algorithm/es/k-core.js
init_esm();
var kCore = function kCore2(graphData, k2) {
  var _a2;
  if (k2 === void 0) {
    k2 = 1;
  }
  var data = clone_default(graphData);
  var _b = data.nodes, nodes = _b === void 0 ? [] : _b;
  var _c = data.edges, edges = _c === void 0 ? [] : _c;
  var _loop_1 = function _loop_12() {
    var degrees3 = degree_default({
      nodes,
      edges
    });
    var nodeIds = Object.keys(degrees3);
    nodeIds.sort(function(a3, b10) {
      var _a3, _b2;
      return ((_a3 = degrees3[a3]) === null || _a3 === void 0 ? void 0 : _a3.degree) - ((_b2 = degrees3[b10]) === null || _b2 === void 0 ? void 0 : _b2.degree);
    });
    var minIndexId = nodeIds[0];
    if (!nodes.length || ((_a2 = degrees3[minIndexId]) === null || _a2 === void 0 ? void 0 : _a2.degree) >= k2) {
      return "break";
    }
    var originIndex = nodes.findIndex(function(node) {
      return node.id === minIndexId;
    });
    nodes.splice(originIndex, 1);
    edges = edges.filter(function(edge) {
      return !(edge.source === minIndexId || edge.target === minIndexId);
    });
  };
  while (true) {
    var state_1 = _loop_1();
    if (state_1 === "break") break;
  }
  return {
    nodes,
    edges
  };
};
var k_core_default = kCore;

// node_modules/@antv/algorithm/es/k-means.js
init_esm();
var getCentroid = function getCentroid2(distanceType, allPropertiesWeight, index2) {
  var centroid = [];
  switch (distanceType) {
    case DistanceType.EuclideanDistance:
      centroid = allPropertiesWeight[index2];
      break;
    default:
      centroid = [];
      break;
  }
  return centroid;
};
var kMeans = function kMeans2(data, k2, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {
  if (k2 === void 0) {
    k2 = 3;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (distanceType === void 0) {
    distanceType = DistanceType.EuclideanDistance;
  }
  var _a2 = data.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = data.edges, edges = _b === void 0 ? [] : _b;
  var defaultClusterInfo = {
    clusters: [{
      id: "0",
      nodes
    }],
    clusterEdges: []
  };
  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function(node) {
    return node.hasOwnProperty(propertyKey);
  })) {
    return defaultClusterInfo;
  }
  var properties = [];
  var allPropertiesWeight = [];
  if (distanceType === DistanceType.EuclideanDistance) {
    properties = getAllProperties(nodes, propertyKey);
    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  }
  if (!allPropertiesWeight.length) {
    return defaultClusterInfo;
  }
  var allPropertiesWeightUniq = uniq(allPropertiesWeight.map(function(item) {
    return item.join("");
  }));
  var finalK = Math.min(k2, nodes.length, allPropertiesWeightUniq.length);
  for (var i2 = 0; i2 < nodes.length; i2++) {
    nodes[i2].originIndex = i2;
  }
  var centroids = [];
  var centroidIndexList = [];
  var clusters = [];
  for (var i2 = 0; i2 < finalK; i2++) {
    if (i2 === 0) {
      var randomIndex = Math.floor(Math.random() * nodes.length);
      switch (distanceType) {
        case DistanceType.EuclideanDistance:
          centroids[i2] = allPropertiesWeight[randomIndex];
          break;
        default:
          centroids[i2] = [];
          break;
      }
      centroidIndexList.push(randomIndex);
      clusters[i2] = [nodes[randomIndex]];
      nodes[randomIndex].clusterId = String(i2);
    } else {
      var maxDistance = -Infinity;
      var maxDistanceNodeIndex = 0;
      var _loop_1 = function _loop_12(m4) {
        if (!centroidIndexList.includes(m4)) {
          var totalDistance = 0;
          for (var j3 = 0; j3 < centroids.length; j3++) {
            var distance12 = 0;
            switch (distanceType) {
              case DistanceType.EuclideanDistance:
                distance12 = getDistance(allPropertiesWeight[nodes[m4].originIndex], centroids[j3], distanceType);
                break;
              default:
                break;
            }
            totalDistance += distance12;
          }
          var avgDistance = totalDistance / centroids.length;
          if (avgDistance > maxDistance && !centroids.find(function(centroid) {
            return is_equal_default(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m4].originIndex));
          })) {
            maxDistance = avgDistance;
            maxDistanceNodeIndex = m4;
          }
        }
      };
      for (var m3 = 0; m3 < nodes.length; m3++) {
        _loop_1(m3);
      }
      centroids[i2] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);
      centroidIndexList.push(maxDistanceNodeIndex);
      clusters[i2] = [nodes[maxDistanceNodeIndex]];
      nodes[maxDistanceNodeIndex].clusterId = String(i2);
    }
  }
  var iterations = 0;
  while (true) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var minDistanceIndex = 0;
      var minDistance = Infinity;
      if (!(iterations === 0 && centroidIndexList.includes(i2))) {
        for (var j2 = 0; j2 < centroids.length; j2++) {
          var distance11 = 0;
          switch (distanceType) {
            case DistanceType.EuclideanDistance:
              distance11 = getDistance(allPropertiesWeight[i2], centroids[j2], distanceType);
              break;
            default:
              break;
          }
          if (distance11 < minDistance) {
            minDistance = distance11;
            minDistanceIndex = j2;
          }
        }
        if (nodes[i2].clusterId !== void 0) {
          for (var n2 = clusters[Number(nodes[i2].clusterId)].length - 1; n2 >= 0; n2--) {
            if (clusters[Number(nodes[i2].clusterId)][n2].id === nodes[i2].id) {
              clusters[Number(nodes[i2].clusterId)].splice(n2, 1);
            }
          }
        }
        nodes[i2].clusterId = String(minDistanceIndex);
        clusters[minDistanceIndex].push(nodes[i2]);
      }
    }
    var centroidsEqualAvg = false;
    for (var i2 = 0; i2 < clusters.length; i2++) {
      var clusterNodes = clusters[i2];
      var totalVector = new vector_default([]);
      for (var j2 = 0; j2 < clusterNodes.length; j2++) {
        totalVector = totalVector.add(new vector_default(allPropertiesWeight[clusterNodes[j2].originIndex]));
      }
      var avgVector = totalVector.avg(clusterNodes.length);
      if (!avgVector.equal(new vector_default(centroids[i2]))) {
        centroidsEqualAvg = true;
        centroids[i2] = avgVector.getArr();
      }
    }
    iterations++;
    if (nodes.every(function(node) {
      return node.clusterId !== void 0;
    }) && centroidsEqualAvg || iterations >= 1e3) {
      break;
    }
  }
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var _a3, _b2;
    var source = edge.source, target = edge.target;
    var sourceClusterId = (_a3 = nodes.find(function(node) {
      return node.id === source;
    })) === null || _a3 === void 0 ? void 0 : _a3.clusterId;
    var targetClusterId = (_b2 = nodes.find(function(node) {
      return node.id === target;
    })) === null || _b2 === void 0 ? void 0 : _b2.clusterId;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  return {
    clusters,
    clusterEdges
  };
};
var k_means_default = kMeans;

// node_modules/@antv/algorithm/es/cosine-similarity.js
var cosineSimilarity = function cosineSimilarity2(item, targetItem) {
  var targetItemVector = new vector_default(targetItem);
  var targetNodeNorm2 = targetItemVector.norm2();
  var itemVector = new vector_default(item);
  var itemNorm2 = itemVector.norm2();
  var dot6 = targetItemVector.dot(itemVector);
  var norm2Product = targetNodeNorm2 * itemNorm2;
  var cosineSimilarity3 = norm2Product ? dot6 / norm2Product : 0;
  return cosineSimilarity3;
};
var cosine_similarity_default = cosineSimilarity;

// node_modules/@antv/algorithm/es/nodes-cosine-similarity.js
init_esm();
var nodesCosineSimilarity = function nodesCosineSimilarity2(nodes, seedNode, propertyKey, involvedKeys, uninvolvedKeys) {
  if (nodes === void 0) {
    nodes = [];
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = [];
  }
  var similarNodes = clone_default(nodes.filter(function(node) {
    return node.id !== seedNode.id;
  }));
  var seedNodeIndex = nodes.findIndex(function(node) {
    return node.id === seedNode.id;
  });
  var properties = getAllProperties(nodes, propertyKey);
  var allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  var seedNodeProperties = allPropertiesWeight[seedNodeIndex];
  var allCosineSimilarity = [];
  similarNodes.forEach(function(node, index2) {
    if (node.id !== seedNode.id) {
      var nodeProperties = allPropertiesWeight[index2];
      var cosineSimilarityValue = cosine_similarity_default(nodeProperties, seedNodeProperties);
      allCosineSimilarity.push(cosineSimilarityValue);
      node.cosineSimilarity = cosineSimilarityValue;
    }
  });
  similarNodes.sort(function(a3, b10) {
    return b10.cosineSimilarity - a3.cosineSimilarity;
  });
  return {
    allCosineSimilarity,
    similarNodes
  };
};
var nodes_cosine_similarity_default = nodesCosineSimilarity;

// node_modules/@antv/algorithm/es/structs/union-find.js
var UnionFind = (
  /** @class */
  function() {
    function UnionFind2(items) {
      this.count = items.length;
      this.parent = {};
      for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
        var i2 = items_1[_i2];
        this.parent[i2] = i2;
      }
    }
    UnionFind2.prototype.find = function(item) {
      while (this.parent[item] !== item) {
        item = this.parent[item];
      }
      return item;
    };
    UnionFind2.prototype.union = function(a3, b10) {
      var rootA = this.find(a3);
      var rootB = this.find(b10);
      if (rootA === rootB) return;
      if (rootA < rootB) {
        if (this.parent[b10] !== b10) this.union(this.parent[b10], a3);
        this.parent[b10] = this.parent[a3];
      } else {
        if (this.parent[a3] !== a3) this.union(this.parent[a3], b10);
        this.parent[a3] = this.parent[b10];
      }
    };
    UnionFind2.prototype.connected = function(a3, b10) {
      return this.find(a3) === this.find(b10);
    };
    return UnionFind2;
  }()
);
var union_find_default = UnionFind;

// node_modules/@antv/algorithm/es/structs/binary-heap.js
var defaultCompare = function defaultCompare2(a3, b10) {
  return a3 - b10;
};
var MinBinaryHeap = (
  /** @class */
  function() {
    function MinBinaryHeap2(compareFn) {
      if (compareFn === void 0) {
        compareFn = defaultCompare;
      }
      this.compareFn = compareFn;
      this.list = [];
    }
    MinBinaryHeap2.prototype.getLeft = function(index2) {
      return 2 * index2 + 1;
    };
    MinBinaryHeap2.prototype.getRight = function(index2) {
      return 2 * index2 + 2;
    };
    MinBinaryHeap2.prototype.getParent = function(index2) {
      if (index2 === 0) {
        return null;
      }
      return Math.floor((index2 - 1) / 2);
    };
    MinBinaryHeap2.prototype.isEmpty = function() {
      return this.list.length <= 0;
    };
    MinBinaryHeap2.prototype.top = function() {
      return this.isEmpty() ? void 0 : this.list[0];
    };
    MinBinaryHeap2.prototype.delMin = function() {
      var top = this.top();
      var bottom = this.list.pop();
      if (this.list.length > 0) {
        this.list[0] = bottom;
        this.moveDown(0);
      }
      return top;
    };
    MinBinaryHeap2.prototype.insert = function(value) {
      if (value !== null) {
        this.list.push(value);
        var index2 = this.list.length - 1;
        this.moveUp(index2);
        return true;
      }
      return false;
    };
    MinBinaryHeap2.prototype.moveUp = function(index2) {
      var parent = this.getParent(index2);
      while (index2 && index2 > 0 && this.compareFn(this.list[parent], this.list[index2]) > 0) {
        var tmp = this.list[parent];
        this.list[parent] = this.list[index2];
        this.list[index2] = tmp;
        index2 = parent;
        parent = this.getParent(index2);
      }
    };
    MinBinaryHeap2.prototype.moveDown = function(index2) {
      var _a2;
      var element = index2;
      var left = this.getLeft(index2);
      var right = this.getRight(index2);
      var size3 = this.list.length;
      if (left !== null && left < size3 && this.compareFn(this.list[element], this.list[left]) > 0) {
        element = left;
      } else if (right !== null && right < size3 && this.compareFn(this.list[element], this.list[right]) > 0) {
        element = right;
      }
      if (index2 !== element) {
        _a2 = [this.list[element], this.list[index2]], this.list[index2] = _a2[0], this.list[element] = _a2[1];
        this.moveDown(element);
      }
    };
    return MinBinaryHeap2;
  }()
);
var binary_heap_default = MinBinaryHeap;

// node_modules/@antv/algorithm/es/mts.js
var primMST = function primMST2(graphData, weight) {
  var selectedEdges = [];
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  if (nodes.length === 0) {
    return selectedEdges;
  }
  var currNode = nodes[0];
  var visited = /* @__PURE__ */ new Set();
  visited.add(currNode);
  var compareWeight = function compareWeight2(a3, b10) {
    if (weight) {
      return a3.weight - b10.weight;
    }
    return 0;
  };
  var edgeQueue = new binary_heap_default(compareWeight);
  getEdgesByNodeId(currNode.id, edges).forEach(function(edge) {
    edgeQueue.insert(edge);
  });
  while (!edgeQueue.isEmpty()) {
    var currEdge = edgeQueue.delMin();
    var source = currEdge.source;
    var target = currEdge.target;
    if (visited.has(source) && visited.has(target)) continue;
    selectedEdges.push(currEdge);
    if (!visited.has(source)) {
      visited.add(source);
      getEdgesByNodeId(source, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
    }
    if (!visited.has(target)) {
      visited.add(target);
      getEdgesByNodeId(target, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
    }
  }
  return selectedEdges;
};
var kruskalMST = function kruskalMST2(graphData, weight) {
  var selectedEdges = [];
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  if (nodes.length === 0) {
    return selectedEdges;
  }
  var weightEdges = edges.map(function(edge) {
    return edge;
  });
  if (weight) {
    weightEdges.sort(function(a3, b10) {
      return a3.weight - b10.weight;
    });
  }
  var disjointSet = new union_find_default(nodes.map(function(n2) {
    return n2.id;
  }));
  while (weightEdges.length > 0) {
    var curEdge = weightEdges.shift();
    var source = curEdge.source;
    var target = curEdge.target;
    if (!disjointSet.connected(source, target)) {
      selectedEdges.push(curEdge);
      disjointSet.union(source, target);
    }
  }
  return selectedEdges;
};
var minimumSpanningTree = function minimumSpanningTree2(graphData, weight, algo) {
  var algos = {
    prim: primMST,
    kruskal: kruskalMST
  };
  if (!algo) return kruskalMST(graphData, weight);
  return algos[algo](graphData, weight);
};
var mts_default = minimumSpanningTree;

// node_modules/@antv/algorithm/es/pageRank.js
var pageRank = function pageRank2(graphData, epsilon, linkProb) {
  if (typeof epsilon !== "number") epsilon = 1e-6;
  if (typeof linkProb !== "number") linkProb = 0.85;
  var distance11 = 1;
  var leakedRank = 0;
  var maxIterations = 1e3;
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodesCount = nodes.length;
  var currentRank;
  var curRanks = {};
  var prevRanks = {};
  for (var j2 = 0; j2 < nodesCount; ++j2) {
    var node = nodes[j2];
    var nodeId = node.id;
    curRanks[nodeId] = 1 / nodesCount;
    prevRanks[nodeId] = 1 / nodesCount;
  }
  var nodeDegree = degree_default(graphData);
  while (maxIterations > 0 && distance11 > epsilon) {
    leakedRank = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = 0;
      if (nodeDegree[node.id].inDegree === 0) {
        curRanks[nodeId] = 0;
      } else {
        var neighbors = getNeighbors(nodeId, edges, "source");
        for (var i2 = 0; i2 < neighbors.length; ++i2) {
          var neighbor = neighbors[i2];
          var outDegree = nodeDegree[neighbor].outDegree;
          if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;
        }
        curRanks[nodeId] = linkProb * currentRank;
        leakedRank += curRanks[nodeId];
      }
    }
    leakedRank = (1 - leakedRank) / nodesCount;
    distance11 = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = curRanks[nodeId] + leakedRank;
      distance11 += Math.abs(currentRank - prevRanks[nodeId]);
      prevRanks[nodeId] = currentRank;
    }
    maxIterations -= 1;
  }
  return prevRanks;
};
var pageRank_default = pageRank;

// node_modules/@antv/algorithm/es/gaddi.js
init_tslib_es6();

// node_modules/@antv/algorithm/es/gSpan/gSpan.js
init_esm();

// node_modules/@antv/algorithm/es/gSpan/struct.js
var VACANT_EDGE_ID = -1;
var VACANT_NODE_ID = -1;
var VACANT_EDGE_LABEL = "-1";
var VACANT_NODE_LABEL = "-1";
var VACANT_GRAPH_ID = -1;
var Edge = (
  /** @class */
  /* @__PURE__ */ function() {
    function Edge3(id, from, to2, label) {
      if (id === void 0) {
        id = VACANT_EDGE_ID;
      }
      if (from === void 0) {
        from = VACANT_NODE_ID;
      }
      if (to2 === void 0) {
        to2 = VACANT_NODE_ID;
      }
      if (label === void 0) {
        label = VACANT_EDGE_LABEL;
      }
      this.id = id;
      this.from = from;
      this.to = to2;
      this.label = label;
    }
    return Edge3;
  }()
);
var Node = (
  /** @class */
  function() {
    function Node3(id, label) {
      if (id === void 0) {
        id = VACANT_NODE_ID;
      }
      if (label === void 0) {
        label = VACANT_NODE_LABEL;
      }
      this.id = id;
      this.label = label;
      this.edges = [];
      this.edgeMap = {};
    }
    Node3.prototype.addEdge = function(edge) {
      this.edges.push(edge);
      this.edgeMap[edge.id] = edge;
    };
    return Node3;
  }()
);
var Graph = (
  /** @class */
  function() {
    function Graph4(id, edgeIdAutoIncrease, directed) {
      if (id === void 0) {
        id = VACANT_NODE_ID;
      }
      if (edgeIdAutoIncrease === void 0) {
        edgeIdAutoIncrease = true;
      }
      if (directed === void 0) {
        directed = false;
      }
      this.id = id;
      this.edgeIdAutoIncrease = edgeIdAutoIncrease;
      this.edges = [];
      this.nodes = [];
      this.nodeMap = {};
      this.edgeMap = {};
      this.nodeLabelMap = {};
      this.edgeLabelMap = {};
      this.counter = 0;
      this.directed = directed;
    }
    Graph4.prototype.getNodeNum = function() {
      return this.nodes.length;
    };
    Graph4.prototype.addNode = function(id, label) {
      if (this.nodeMap[id]) return;
      var node = new Node(id, label);
      this.nodes.push(node);
      this.nodeMap[id] = node;
      if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];
      this.nodeLabelMap[label].push(id);
    };
    Graph4.prototype.addEdge = function(id, from, to2, label) {
      if (this.edgeIdAutoIncrease || id === void 0) id = this.counter++;
      if (this.nodeMap[from] && this.nodeMap[to2] && this.nodeMap[to2].edgeMap[id]) return;
      var edge = new Edge(id, from, to2, label);
      this.edges.push(edge);
      this.edgeMap[id] = edge;
      this.nodeMap[from].addEdge(edge);
      if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];
      this.edgeLabelMap[label].push(edge);
      if (!this.directed) {
        var rEdge = new Edge(id, to2, from, label);
        this.nodeMap[to2].addEdge(rEdge);
        this.edgeLabelMap[label].push(rEdge);
      }
    };
    return Graph4;
  }()
);

// node_modules/@antv/algorithm/es/gSpan/gSpan.js
var DFSedge = (
  /** @class */
  function() {
    function DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
      this.fromNode = fromNode;
      this.toNode = toNode;
      this.nodeEdgeNodeLabel = {
        nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,
        edgeLabel: edgeLabel || VACANT_EDGE_LABEL,
        nodeLabel2: toNodeLabel || VACANT_NODE_LABEL
      };
    }
    DFSedge2.prototype.equalTo = function(other) {
      return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
    };
    DFSedge2.prototype.notEqualTo = function(other) {
      return !this.equalTo(other);
    };
    return DFSedge2;
  }()
);
var DFScode = (
  /** @class */
  function() {
    function DFScode2() {
      this.rmpath = [];
      this.dfsEdgeList = [];
    }
    DFScode2.prototype.equalTo = function(other) {
      var aLength = this.dfsEdgeList.length;
      var bLength = other.length;
      if (aLength !== bLength) return false;
      for (var i2 = 0; i2 < aLength; i2++) {
        if (this.dfsEdgeList[i2] !== other[i2]) return false;
      }
      return true;
    };
    DFScode2.prototype.notEqualTo = function(other) {
      return !this.equalTo(other);
    };
    DFScode2.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
      this.dfsEdgeList.push(new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
      return this.dfsEdgeList;
    };
    DFScode2.prototype.toGraph = function(graphId, directed) {
      if (graphId === void 0) {
        graphId = VACANT_GRAPH_ID;
      }
      if (directed === void 0) {
        directed = false;
      }
      var graph = new Graph(graphId, true, directed);
      this.dfsEdgeList.forEach(function(dfsEdge) {
        var fromNodeId = dfsEdge.fromNode;
        var toNodeId = dfsEdge.toNode;
        var _a2 = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        if (nodeLabel1 !== VACANT_NODE_LABEL) graph.addNode(fromNodeId, nodeLabel1);
        if (nodeLabel2 !== VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);
        if (nodeLabel1 !== VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1) graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
      });
      return graph;
    };
    DFScode2.prototype.buildRmpath = function() {
      this.rmpath = [];
      var oldFrom = void 0;
      var selfLength = this.dfsEdgeList.length;
      for (var i2 = selfLength - 1; i2 >= 0; i2--) {
        var dfsEdge = this.dfsEdgeList[i2];
        var fromNodeIdx = dfsEdge.fromNode;
        var toNodeIdx = dfsEdge.toNode;
        if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
          this.rmpath.push(i2);
          oldFrom = fromNodeIdx;
        }
      }
      return this.rmpath;
    };
    DFScode2.prototype.getNodeNum = function() {
      var nodeMap = {};
      this.dfsEdgeList.forEach(function(dfsEdge) {
        if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;
        if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;
      });
      return Object.keys(nodeMap).length;
    };
    return DFScode2;
  }()
);
var History = (
  /** @class */
  function() {
    function History2(pdfs) {
      this.his = {};
      this.nodesUsed = {};
      this.edgesUsed = {};
      this.edges = [];
      if (!pdfs) return;
      while (pdfs) {
        var e8 = pdfs.edge;
        this.edges.push(e8);
        this.nodesUsed[e8.from] = 1;
        this.nodesUsed[e8.to] = 1;
        this.edgesUsed[e8.id] = 1;
        pdfs = pdfs.preNode;
      }
      this.edges = this.edges.reverse();
    }
    History2.prototype.hasNode = function(node) {
      return this.nodesUsed[node.id] === 1;
    };
    History2.prototype.hasEdge = function(edge) {
      return this.edgesUsed[edge.id] === 1;
    };
    return History2;
  }()
);
var GSpan = (
  /** @class */
  function() {
    function GSpan2(_a2) {
      var graphs = _a2.graphs, _b = _a2.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a2.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a2.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e2 = _a2.top, top = _e2 === void 0 ? 10 : _e2, _f = _a2.directed, directed = _f === void 0 ? false : _f, _g = _a2.verbose, verbose = _g === void 0 ? false : _g;
      this.graphs = graphs;
      this.dfsCode = new DFScode();
      this.support = 0;
      this.frequentSize1Subgraphs = [];
      this.frequentSubgraphs = [];
      this.minSupport = minSupport;
      this.top = top;
      this.directed = directed;
      this.counter = 0;
      this.maxNodeNum = maxNodeNum;
      this.minNodeNum = minNodeNum;
      this.verbose = verbose;
      if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;
      this.reportDF = [];
    }
    GSpan2.prototype.findForwardRootEdges = function(graph, fromNode) {
      var _this = this;
      var result = [];
      var nodeMap = graph.nodeMap;
      fromNode.edges.forEach(function(edge) {
        if (_this.directed || fromNode.label <= nodeMap[edge.to].label) result.push(edge);
      });
      return result;
    };
    GSpan2.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
      if (!this.directed && edge1 === edge2) return null;
      var nodeMap = graph.nodeMap;
      var edge2To = nodeMap[edge2.to];
      var edge2ToEdges = edge2To.edges;
      var edgeLength = edge2ToEdges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edge2ToEdges[i2];
        if (history.hasEdge(edge) || edge.to !== edge1.from) continue;
        if (!this.directed) {
          if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
            return edge;
          }
        } else {
          if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
            return edge;
          }
        }
      }
      return null;
    };
    GSpan2.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
      var result = [];
      var rightmostEdgeToId = rightmostEdge.to;
      var edges = graph.nodeMap[rightmostEdgeToId].edges;
      var edgeLength = edges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edges[i2];
        var toNode = graph.nodeMap[edge.to];
        if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
          result.push(edge);
        }
      }
      return result;
    };
    GSpan2.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
      var result = [];
      var nodeMap = graph.nodeMap;
      var toNodeLabel = nodeMap[rightmostEdge.to].label;
      var fromNode = nodeMap[rightmostEdge.from];
      var edges = fromNode.edges;
      var edgeLength = edges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edges[i2];
        var newToNodeLabel = nodeMap[edge.to].label;
        if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
          continue;
        }
        if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
          result.push(edge);
        }
      }
      return result;
    };
    GSpan2.prototype.getSupport = function(projected) {
      var graphMap = {};
      projected.forEach(function(pro) {
        if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;
      });
      return Object.keys(graphMap).length;
    };
    GSpan2.prototype.findMinLabel = function(obj) {
      var minLabel = void 0;
      Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
        var _a2 = obj[nodeEdgeNodeLabel], nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        if (!minLabel) {
          minLabel = {
            nodeLabel1,
            edgeLabel,
            nodeLabel2
          };
          return;
        }
        if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
          minLabel = {
            nodeLabel1,
            edgeLabel,
            nodeLabel2
          };
        }
      });
      return minLabel;
    };
    GSpan2.prototype.isMin = function() {
      var _this = this;
      var dfsCode = this.dfsCode;
      if (this.verbose) console.log("isMin checking", dfsCode);
      if (dfsCode.dfsEdgeList.length === 1) return true;
      var directed = this.directed;
      var graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);
      var nodeMap = graph.nodeMap;
      var dfsCodeMin = new DFScode();
      var root = {};
      graph.nodes.forEach(function(node) {
        var forwardEdges = _this.findForwardRootEdges(graph, node);
        forwardEdges.forEach(function(edge) {
          var otherNode = nodeMap[edge.to];
          var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
          if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {
            projected: [],
            nodeLabel1: node.label,
            edgeLabel: edge.label,
            nodeLabel2: otherNode.label
          };
          var pdfs = {
            graphId: graph.id,
            edge,
            preNode: null
          };
          root[nodeEdgeNodeLabel].projected.push(pdfs);
        });
      });
      var minLabel = this.findMinLabel(root);
      if (!minLabel) return;
      dfsCodeMin.dfsEdgeList.push(new DFSedge(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
      var projectIsMin = function projectIsMin2(projected) {
        var rmpath = dfsCodeMin.buildRmpath();
        var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
        var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
        var backwardRoot = {};
        var flag = false, newTo = 0;
        var end2 = directed ? -1 : 0;
        var _loop_1 = function _loop_12(i3) {
          if (flag) return "break";
          projected.forEach(function(p2) {
            var history = new History(p2);
            var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i3]], history.edges[rmpath[0]], history);
            if (backwardEdge) {
              if (!backwardRoot[backwardEdge.label]) {
                backwardRoot[backwardEdge.label] = {
                  projected: [],
                  edgeLabel: backwardEdge.label
                };
              }
              backwardRoot[backwardEdge.label].projected.push({
                graphId: graph.id,
                edge: backwardRoot,
                preNode: p2
              });
              newTo = dfsCodeMin.dfsEdgeList[rmpath[i3]].fromNode;
              flag = true;
            }
          });
        };
        for (var i2 = rmpath.length - 1; i2 > end2; i2--) {
          var state_1 = _loop_1(i2);
          if (state_1 === "break") break;
        }
        if (flag) {
          var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);
          dfsCodeMin.dfsEdgeList.push(new DFSedge(maxToC, newTo, VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, VACANT_NODE_LABEL));
          var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
          if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1]) return false;
          return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
        }
        var forwardRoot = {};
        flag = false;
        var newFrom = 0;
        projected.forEach(function(p2) {
          var history = new History(p2);
          var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
          if (forwardPureEdges.length > 0) {
            flag = true;
            newFrom = maxToC;
            forwardPureEdges.forEach(function(edge) {
              var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2]) forwardRoot[key2] = {
                projected: [],
                edgeLabel: edge.label,
                nodeLabel2: nodeMap[edge.to].label
              };
              forwardRoot[key2].projected.push({
                graphId: graph.id,
                edge,
                preNode: p2
              });
            });
          }
        });
        var pathLength = rmpath.length;
        var _loop_2 = function _loop_22(i3) {
          if (flag) return "break";
          var value = rmpath[i3];
          projected.forEach(function(p2) {
            var history = new History(p2);
            var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
            if (forwardRmpathEdges.length > 0) {
              flag = true;
              newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
              forwardRmpathEdges.forEach(function(edge) {
                var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                if (!forwardRoot[key2]) forwardRoot[key2] = {
                  projected: [],
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
                forwardRoot[key2].projected.push({
                  graphId: graph.id,
                  edge,
                  preNode: p2
                });
              });
            }
          });
        };
        for (var i2 = 0; i2 < pathLength; i2++) {
          var state_2 = _loop_2(i2);
          if (state_2 === "break") break;
        }
        if (!flag) return true;
        var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);
        dfsCodeMin.dfsEdgeList.push(new DFSedge(newFrom, maxToC + 1, VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
        var idx = dfsCodeMin.dfsEdgeList.length - 1;
        if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx]) return false;
        return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
      };
      var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
      return projectIsMin(root[key].projected);
    };
    GSpan2.prototype.report = function() {
      if (this.dfsCode.getNodeNum() < this.minNodeNum) return;
      this.counter++;
      var graph = this.dfsCode.toGraph(this.counter, this.directed);
      this.frequentSubgraphs.push(clone_default(graph));
    };
    GSpan2.prototype.subGraphMining = function(projected) {
      var _this = this;
      var support = this.getSupport(projected);
      if (support < this.minSupport) return;
      if (!this.isMin()) return;
      this.report();
      var nodeNum = this.dfsCode.getNodeNum();
      var rmpath = this.dfsCode.buildRmpath();
      var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
      var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
      var forwardRoot = {};
      var backwardRoot = {};
      projected.forEach(function(p2) {
        var graph = _this.graphs[p2.graphId];
        var nodeMap = graph.nodeMap;
        var history = new History(p2);
        for (var i2 = rmpath.length - 1; i2 >= 0; i2--) {
          var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
          if (backwardEdge) {
            var key = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(backwardEdge.label);
            if (!backwardRoot[key]) backwardRoot[key] = {
              projected: [],
              toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
              edgeLabel: backwardEdge.label
            };
            backwardRoot[key].projected.push({
              graphId: p2.graphId,
              edge: backwardEdge,
              preNode: p2
            });
          }
        }
        if (nodeNum >= _this.maxNodeNum) return;
        var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
        forwardPureEdges.forEach(function(edge) {
          var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
          if (!forwardRoot[key2]) forwardRoot[key2] = {
            projected: [],
            fromNodeId: maxToC,
            edgeLabel: edge.label,
            nodeLabel2: nodeMap[edge.to].label
          };
          forwardRoot[key2].projected.push({
            graphId: p2.graphId,
            edge,
            preNode: p2
          });
        });
        var _loop_3 = function _loop_32(i3) {
          var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i3]], minNodeLabel, history);
          forwardRmpathEdges.forEach(function(edge) {
            var key2 = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
            if (!forwardRoot[key2]) forwardRoot[key2] = {
              projected: [],
              fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode,
              edgeLabel: edge.label,
              nodeLabel2: nodeMap[edge.to].label
            };
            forwardRoot[key2].projected.push({
              graphId: p2.graphId,
              edge,
              preNode: p2
            });
          });
        };
        for (var i2 = 0; i2 < rmpath.length; i2++) {
          _loop_3(i2);
        }
      });
      Object.keys(backwardRoot).forEach(function(key) {
        var _a2 = backwardRoot[key], toNodeId = _a2.toNodeId, edgeLabel = _a2.edgeLabel;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(maxToC, toNodeId, "-1", edgeLabel, "-1"));
        _this.subGraphMining(backwardRoot[key].projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
      Object.keys(forwardRoot).forEach(function(key) {
        var _a2 = forwardRoot[key], fromNodeId = _a2.fromNodeId, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(fromNodeId, maxToC + 1, VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
        _this.subGraphMining(forwardRoot[key].projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
    };
    GSpan2.prototype.generate1EdgeFrequentSubGraphs = function() {
      var graphs = this.graphs;
      var directed = this.directed;
      var minSupport = this.minSupport;
      var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
      var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
      var nodeLableCounted = {};
      var nodeEdgeNodeLabelCounted = {};
      Object.keys(graphs).forEach(function(key) {
        var graph = graphs[key];
        var nodeMap = graph.nodeMap;
        graph.nodes.forEach(function(node, i2) {
          var nodeLabel = node.label;
          var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
          if (!nodeLableCounted[graphNodeKey]) {
            var counter = nodeLabelCounter[nodeLabel] || 0;
            counter++;
            nodeLabelCounter[nodeLabel] = counter;
          }
          nodeLableCounted[graphNodeKey] = {
            graphKey: key,
            label: nodeLabel
          };
          node.edges.forEach(function(edge) {
            var nodeLabel1 = nodeLabel;
            var nodeLabel2 = nodeMap[edge.to].label;
            if (!directed && nodeLabel1 > nodeLabel2) {
              var tmp = nodeLabel2;
              nodeLabel2 = nodeLabel1;
              nodeLabel1 = tmp;
            }
            var edgeLabel = edge.label;
            var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
            var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
            if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
              var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
              counter2++;
              nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
            }
            nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
              graphId: key,
              nodeLabel1,
              edgeLabel,
              nodeLabel2
            };
          });
        });
      });
      Object.keys(nodeLabelCounter).forEach(function(label) {
        var count = nodeLabelCounter[label];
        if (count < minSupport) return;
        var g2 = {
          nodes: [],
          edges: []
        };
        g2.nodes.push({
          id: "0",
          label
        });
        frequentSize1Subgraphs.push(g2);
      });
      return frequentSize1Subgraphs;
    };
    GSpan2.prototype.run = function() {
      var _this = this;
      this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
      if (this.maxNodeNum < 2) return;
      var graphs = this.graphs;
      var directed = this.directed;
      var root = {};
      Object.keys(graphs).forEach(function(graphId) {
        var graph = graphs[graphId];
        var nodeMap = graph.nodeMap;
        graph.nodes.forEach(function(node) {
          var forwardRootEdges = _this.findForwardRootEdges(graph, node);
          forwardRootEdges.forEach(function(edge) {
            var toNode = nodeMap[edge.to];
            var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
            if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {
              projected: [],
              nodeLabel1: node.label,
              edgeLabel: edge.label,
              nodeLabel2: toNode.label
            };
            var pdfs = {
              graphId,
              edge,
              preNode: null
            };
            root[nodeEdgeNodeLabel].projected.push(pdfs);
          });
        });
      });
      Object.keys(root).forEach(function(nodeEdgeNodeLabel) {
        var _a2 = root[nodeEdgeNodeLabel], projected = _a2.projected, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
        _this.subGraphMining(projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
    };
    return GSpan2;
  }()
);
var formatGraphs = function formatGraphs2(graphs, directed, nodeLabelProp, edgeLabelProp) {
  var result = {};
  Object.keys(graphs).forEach(function(key, i2) {
    var graph = graphs[key];
    var fGraph = new Graph(i2, true, directed);
    var nodeIdxMap = {};
    graph.nodes.forEach(function(node, j2) {
      fGraph.addNode(j2, node[nodeLabelProp]);
      nodeIdxMap[node.id] = j2;
    });
    graph.edges.forEach(function(edge, k2) {
      var sourceIdx = nodeIdxMap[edge.source];
      var targetIdx = nodeIdxMap[edge.target];
      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);
    });
    if (fGraph && fGraph.getNodeNum()) result[fGraph.id] = fGraph;
  });
  return result;
};
var toGraphDatas = function toGraphDatas2(graphs, nodeLabelProp, edgeLabelProp) {
  var result = [];
  graphs.forEach(function(graph) {
    var graphData = {
      nodes: [],
      edges: []
    };
    graph.nodes.forEach(function(node) {
      var _a2;
      graphData.nodes.push((_a2 = {
        id: "".concat(node.id)
      }, _a2[nodeLabelProp] = node.label, _a2));
    });
    graph.edges.forEach(function(edge) {
      var _a2;
      graphData.edges.push((_a2 = {
        source: "".concat(edge.from),
        target: "".concat(edge.to)
      }, _a2[edgeLabelProp] = edge.label, _a2));
    });
    result.push(graphData);
  });
  return result;
};
var DEFAULT_LABEL_NAME = "cluster";
var gSpan = function gSpan2(params) {
  var graphs = params.graphs, _a2 = params.directed, directed = _a2 === void 0 ? false : _a2, _b = params.nodeLabelProp, nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME : _b, _c = params.edgeLabelProp, edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME : _c;
  var formattedGraphs = formatGraphs(graphs, directed, nodeLabelProp, edgeLabelProp);
  var minSupport = params.minSupport, maxNodeNum = params.maxNodeNum, minNodeNum = params.minNodeNum, verbose = params.verbose, top = params.top;
  var algoParams = {
    graphs: formattedGraphs,
    minSupport,
    maxNodeNum,
    minNodeNum,
    top,
    verbose,
    directed
  };
  var calculator = new GSpan(algoParams);
  calculator.run();
  var result = toGraphDatas(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);
  return result;
};
var gSpan_default = gSpan;

// node_modules/@antv/algorithm/es/gaddi.js
var findKNeighborUnits = function findKNeighborUnits2(graphData, spm, nodeLabelProp, k2) {
  if (nodeLabelProp === void 0) {
    nodeLabelProp = "cluster";
  }
  if (k2 === void 0) {
    k2 = 2;
  }
  var units = [];
  var nodes = graphData.nodes;
  spm.forEach(function(row, i2) {
    units.push(findKNeighborUnit(nodes, row, i2, nodeLabelProp, k2));
  });
  return units;
};
var findKNeighborUnit = function findKNeighborUnit2(nodes, row, i2, nodeLabelProp, k2) {
  var unitNodeIdxs = [i2];
  var neighbors = [];
  var labelCountMap = {};
  row.forEach(function(v2, j2) {
    if (v2 <= k2 && i2 !== j2) {
      unitNodeIdxs.push(j2);
      neighbors.push(nodes[j2]);
      var label = nodes[j2][nodeLabelProp];
      if (!labelCountMap[label]) labelCountMap[label] = {
        count: 1,
        dists: [v2]
      };
      else {
        labelCountMap[label].count++;
        labelCountMap[label].dists.push(v2);
      }
    }
  });
  Object.keys(labelCountMap).forEach(function(label) {
    labelCountMap[label].dists = labelCountMap[label].dists.sort(function(a3, b10) {
      return a3 - b10;
    });
  });
  return {
    nodeIdx: i2,
    nodeId: nodes[i2].id,
    nodeIdxs: unitNodeIdxs,
    neighbors,
    neighborNum: unitNodeIdxs.length - 1,
    nodeLabelCountMap: labelCountMap
  };
};
var findNodePairsRandomly = function findNodePairsRandomly2(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm) {
  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);
  var nodePairMap = {};
  var foundNodePairCount = 0;
  kNeighborUnits.forEach(function(unit, i2) {
    var nodePairForICount = 0;
    var outerLoopCount = 0;
    var neighbors = unit.nodeIdxs;
    var neighborNum = unit.neighborNum - 1;
    while (nodePairForICount < nodePairNumEachNode) {
      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];
      var innerLoopCount = 0;
      while (nodePairMap["".concat(i2, "-").concat(oidx)] || nodePairMap["".concat(oidx, "-").concat(i2)]) {
        oidx = Math.floor(Math.random() * nodeNum);
        innerLoopCount++;
        if (innerLoopCount > 2 * nodeNum) break;
      }
      if (innerLoopCount < 2 * nodeNum) {
        nodePairMap["".concat(i2, "-").concat(oidx)] = {
          start: i2,
          end: oidx,
          distance: spm[i2][oidx]
        };
        nodePairForICount++;
        foundNodePairCount++;
        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;
      }
      outerLoopCount++;
      if (outerLoopCount > 2 * nodeNum) break;
    }
    if (nodePairForICount < nodePairNumEachNode) {
      var gap = nodePairNumEachNode - nodePairForICount;
      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i2 - 1);
    }
  });
  return nodePairMap;
};
var getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph2(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {
  var nodes = graphData.nodes;
  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};
  Object.keys(nodePairMap).forEach(function(key) {
    var _a2, _b;
    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;
    cachedInducedGraphMap[key] = {
      nodes: [],
      edges: []
    };
    var pair = nodePairMap[key];
    var startUnitNodeIds = (_a2 = neighborUnits[pair.start]) === null || _a2 === void 0 ? void 0 : _a2.nodeIdxs;
    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;
    if (!startUnitNodeIds || !endUnitNodeIds) return;
    var endSet = new Set(endUnitNodeIds);
    var intersect2 = startUnitNodeIds.filter(function(x4) {
      return endSet.has(x4);
    });
    if (!intersect2 || !intersect2.length) return;
    var intersectIdMap = {};
    var intersectLength = intersect2.length;
    for (var i2 = 0; i2 < intersectLength; i2++) {
      var node = nodes[intersect2[i2]];
      cachedInducedGraphMap[key].nodes.push(node);
      intersectIdMap[node.id] = true;
    }
    graphData.edges.forEach(function(edge) {
      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);
    });
  });
  return cachedInducedGraphMap;
};
var getMatchedCount = function getMatchedCount2(graph, structure, nodeLabelProp, edgeLabelProp) {
  var _a2, _b;
  var nodeMap = {};
  graph.nodes.forEach(function(node) {
    nodeMap[node.id] = node;
  });
  var count = 0;
  if (!((_a2 = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2) return 0;
  graph.edges.forEach(function(e8) {
    var sourceLabel = nodeMap[e8.source][nodeLabelProp];
    var targetLabel = nodeMap[e8.target][nodeLabelProp];
    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];
    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];
    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];
    if (e8[edgeLabelProp] !== strEdgeLabel) return;
    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {
      count++;
    }
  });
  return count;
};
var findRepresentStructure = function findRepresentStructure2(matchedCountMap, structureNum, structures) {
  var maxOffset = Infinity, representClusterType = 0;
  var _loop_1 = function _loop_12(i3) {
    var countMapI = matchedCountMap[i3];
    var sortedGraphKeys = Object.keys(countMapI).sort(function(a3, b10) {
      return countMapI[a3] - countMapI[b10];
    });
    var groupNum = 10;
    var clusters = [];
    sortedGraphKeys.forEach(function(key, j2) {
      if (!clusters[j2 % groupNum]) clusters[j2 % groupNum] = {
        graphs: [],
        totalCount: 0,
        aveCount: 0
      };
      clusters[j2 % groupNum].graphs.push(key);
      clusters[j2 % groupNum].totalCount += countMapI[key];
    });
    var aveIntraDist = 0;
    var aveCounts = [];
    clusters.forEach(function(graphsInCluster) {
      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;
      graphsInCluster.aveCount = aveCount;
      aveCounts.push(aveCount);
      var aveIntraPerCluster = 0;
      var graphsNum = graphsInCluster.length;
      graphsInCluster.graphs.forEach(function(graphKey1, j2) {
        var graph1Count = countMapI[graphKey1];
        graphsInCluster.graphs.forEach(function(graphKey2, k2) {
          if (j2 === k2) return;
          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);
        });
      });
      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;
      aveIntraDist += aveIntraPerCluster;
    });
    aveIntraDist /= clusters.length;
    var aveInterDist = 0;
    aveCounts.forEach(function(aveCount1, j2) {
      aveCounts.forEach(function(aveCount2, k2) {
        if (j2 === k2) return;
        aveInterDist += Math.abs(aveCount1 - aveCount2);
      });
      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;
    });
    var offset = aveInterDist - aveIntraDist;
    if (maxOffset < offset) {
      maxOffset = offset;
      representClusterType = i3;
    }
  };
  for (var i2 = 0; i2 < structureNum; i2++) {
    _loop_1(i2);
  }
  return {
    structure: structures[representClusterType],
    structureCountMap: matchedCountMap[representClusterType]
  };
};
var getNodeMaps = function getNodeMaps2(nodes, nodeLabelProp) {
  var nodeMap = {}, nodeLabelMap = {};
  nodes.forEach(function(node, i2) {
    nodeMap[node.id] = {
      idx: i2,
      node,
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
    var label = node[nodeLabelProp];
    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];
    nodeLabelMap[label].push(node);
  });
  return {
    nodeMap,
    nodeLabelMap
  };
};
var getEdgeMaps = function getEdgeMaps2(edges, edgeLabelProp, nodeMap) {
  var edgeMap = {}, edgeLabelMap = {};
  edges.forEach(function(edge, i2) {
    edgeMap["".concat(uniqueId)] = {
      idx: i2,
      edge
    };
    var label = edge[edgeLabelProp];
    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];
    edgeLabelMap[label].push(edge);
    var sourceNode = nodeMap[edge.source];
    if (sourceNode) {
      sourceNode.degree++;
      sourceNode.outDegree++;
    }
    var targetNode = nodeMap[edge.target];
    if (targetNode) {
      targetNode.degree++;
      targetNode.inDegree++;
    }
  });
  return {
    edgeMap,
    edgeLabelMap
  };
};
var getSpmMap = function getSpmMap2(nodes, spm, directed) {
  var length6 = spm.length;
  var map6 = {};
  spm.forEach(function(row, i2) {
    var start = directed ? 0 : i2 + 1;
    var iId = nodes[i2].id;
    for (var j2 = start; j2 < length6; j2++) {
      if (i2 === j2) continue;
      var jId = nodes[j2].id;
      var dist4 = row[j2];
      map6["".concat(iId, "-").concat(jId)] = dist4;
      if (!directed) map6["".concat(jId, "-").concat(iId)] = dist4;
    }
  });
  return map6;
};
var getNDSDist = function getNDSDist2(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {
  var _a2;
  var key = "".concat(node1.id, "-").concat(node2.id);
  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];
  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : void 0;
  if (!interInducedGraph) {
    var pairMap = (_a2 = {}, _a2[key] = {
      start: nodeMap[node1.id].idx,
      end: nodeMap[node2.id].idx,
      distance: spDist
    }, _a2);
    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);
    interInducedGraph = cachedInterInducedGraph[key];
  }
  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);
};
var stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap2(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {
  var _a2, _b, _c;
  var minPatternNodeLabelDegree = (_a2 = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a2 === void 0 ? void 0 : _a2.degree;
  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;
  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;
  if (minPatternNodeLabelDegreeMap[neighborLabel] === void 0) {
    minPatternNodeLabelDegree = Infinity;
    minPatternNodeLabelInDegree = Infinity;
    minPatternNodeLabelOutDegree = Infinity;
    patternNodeLabelMap[neighborLabel].forEach(function(patternNodeWithLabel) {
      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;
      if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;
      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;
      if (minPatternNodeLabelInDegree > patternNodeInDegree) minPatternNodeLabelInDegree = patternNodeInDegree;
      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;
      if (minPatternNodeLabelOutDegree > patternNodeOutDegree) minPatternNodeLabelOutDegree = patternNodeOutDegree;
    });
    minPatternNodeLabelDegreeMap[neighborLabel] = {
      degree: minPatternNodeLabelDegree,
      inDegree: minPatternNodeLabelInDegree,
      outDegree: minPatternNodeLabelOutDegree
    };
  }
  return {
    minPatternNodeLabelDegree,
    minPatternNodeLabelInDegree,
    minPatternNodeLabelOutDegree
  };
};
var GADDI = function GADDI2(graphData, pattern, directed, k2, length6, nodeLabelProp, edgeLabelProp) {
  var _a2;
  if (directed === void 0) {
    directed = false;
  }
  if (nodeLabelProp === void 0) {
    nodeLabelProp = "cluster";
  }
  if (edgeLabelProp === void 0) {
    edgeLabelProp = "cluster";
  }
  if (!graphData || !graphData.nodes) return;
  var nodeNum = graphData.nodes.length;
  if (!nodeNum) return;
  var spm = floydWarshall_default(graphData, directed);
  var patternSpm = floydWarshall_default(pattern, directed);
  var spmMap = getSpmMap(graphData.nodes, spm, directed);
  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);
  var _b = getNodeMaps(graphData.nodes, nodeLabelProp), nodeMap = _b.nodeMap, nodeLabelMap = _b.nodeLabelMap;
  var _c = getNodeMaps(pattern.nodes, nodeLabelProp), patternNodeMap = _c.nodeMap, patternNodeLabelMap = _c.nodeLabelMap;
  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);
  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;
  var patternSpmSpread = [];
  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function(row) {
    patternSpmSpread = patternSpmSpread.concat(row);
  });
  if (!length6) length6 = Math.max.apply(Math, __spreadArray(__spreadArray([], patternSpmSpread, false), [2], false));
  if (!k2) k2 = length6;
  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k2);
  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k2);
  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);
  var nodePairsMap = findNodePairsRandomly(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm);
  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);
  var top = 10, minSupport = 1, minNodeNum = 1, maxNodeNum = 4;
  var params = {
    graphs: intGMap,
    nodeLabelProp,
    edgeLabelProp,
    minSupport,
    minNodeNum,
    maxNodeNum,
    directed
  };
  var freStructures = gSpan_default(params).slice(0, top);
  var structureNum = freStructures.length;
  var matchedCountMap = [];
  freStructures.forEach(function(structure, i3) {
    matchedCountMap[i3] = {};
    Object.keys(intGMap).forEach(function(key) {
      var graph = intGMap[key];
      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);
      matchedCountMap[i3][key] = subStructureCount;
    });
  });
  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures), dsG = _d.structure, ndsDist = _d.structureCountMap;
  var beginPNode = pattern.nodes[0], candidates = [], label = (_a2 = pattern.nodes[0]) === null || _a2 === void 0 ? void 0 : _a2[nodeLabelProp], maxNodeNumWithSameLabel = -Infinity;
  pattern.nodes.forEach(function(node) {
    var pLabel = node[nodeLabelProp];
    var nodesWithSameLabel = nodeLabelMap[pLabel];
    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {
      maxNodeNumWithSameLabel = nodesWithSameLabel.length;
      candidates = nodesWithSameLabel;
      label = pLabel;
      beginPNode = node;
    }
  });
  var minPatternNodeLabelDegreeMap = {};
  var patternIntGraphMap = {}, patternNDSDist = {}, patternNDSDistMap = {};
  var patternSpDist = {};
  var patternSpDistBack = {};
  Object.keys(patternNodeLabelMap).forEach(function(label2, j2) {
    patternSpDist[label2] = [];
    if (directed) {
      patternSpDistBack[label2] = [];
    }
    var maxDist = -Infinity;
    var patternNodesWithLabel2 = patternNodeLabelMap[label2];
    var patternNodePairMap = {};
    patternNodesWithLabel2.forEach(function(nodeWithLabel2) {
      var dist4 = patternSpmMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)];
      dist4 && patternSpDist[label2].push(dist4);
      if (maxDist < dist4) maxDist = dist4;
      patternNodePairMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)] = {
        start: 0,
        end: patternNodeMap[nodeWithLabel2.id].idx,
        distance: dist4
      };
      if (directed) {
        var distBack = patternSpmMap["".concat(nodeWithLabel2.id, "-").concat(beginPNode.id)];
        distBack && patternSpDistBack[label2].push(distBack);
      }
    });
    patternSpDist[label2] = patternSpDist[label2].sort(function(a3, b10) {
      return a3 - b10;
    });
    if (directed) patternSpDistBack[label2] = patternSpDistBack[label2].sort(function(a3, b10) {
      return a3 - b10;
    });
    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);
    var currentPatternNDSDistArray = [];
    Object.keys(patternNodePairMap).forEach(function(key) {
      if (patternNDSDist[key]) {
        currentPatternNDSDistArray.push(patternNDSDist[key]);
        return;
      }
      var patternIntGraph = patternIntGraphMap[key];
      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);
      currentPatternNDSDistArray.push(patternNDSDist[key]);
    });
    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function(a3, b10) {
      return b10 - a3;
    });
    patternNDSDistMap["".concat(beginPNode.id, "-").concat(label2)] = currentPatternNDSDistArray;
    if (label2 === label) return;
    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;
    var _loop_4 = function _loop_42(m4) {
      var cNode = candidates[m4];
      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];
      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];
      var patternLabel2Num = patternNodeLabelMap[label2].length;
      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {
        candidates.splice(m4, 1);
        return "continue";
      }
      var prune2Invalid = false;
      for (var n2 = 0; n2 < patternLabel2Num; n2++) {
        if (graphNeighborUnitCountMap.dists[n2] > patternSpDist[label2][n2]) {
          prune2Invalid = true;
          break;
        }
      }
      if (prune2Invalid) {
        candidates.splice(m4, 1);
        return "continue";
      }
      var cNodePairMap = {};
      graphNeighborUnit.neighbors.forEach(function(neighborNode) {
        var dist4 = spmMap["".concat(cNode.id, "-").concat(neighborNode.id)];
        cNodePairMap["".concat(cNode.id, "-").concat(neighborNode.id)] = {
          start: nodeMap[cNode.id].idx,
          end: nodeMap[neighborNode.id].idx,
          distance: dist4
        };
      });
      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);
      var currentNDSDistArray = [];
      Object.keys(cNodePairMap).forEach(function(key) {
        if (ndsDist[key]) {
          currentNDSDistArray.push(ndsDist[key]);
          return;
        }
        var intGraph = intGMap[key];
        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);
        currentNDSDistArray.push(ndsDist[key]);
      });
      currentNDSDistArray = currentNDSDistArray.sort(function(a3, b10) {
        return b10 - a3;
      });
      var prune3Invalid = false;
      for (var n2 = 0; n2 < patternLabel2Num; n2++) {
        if (currentNDSDistArray[n2] < currentPatternNDSDistArray[n2]) {
          prune3Invalid = true;
          break;
        }
      }
      if (prune3Invalid) {
        candidates.splice(m4, 1);
        return "continue";
      }
    };
    for (var m3 = candidatesNum - 1; m3 >= 0; m3--) {
      _loop_4(m3);
    }
  });
  var candidateGraphs = [];
  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function(candidate) {
    var nodeIdx = nodeMap[candidate.id].idx;
    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length6);
    var neighborNodes = lengthNeighborUnit.neighbors;
    var neighborNum = neighborNodes.length;
    var unmatched = false;
    for (var i3 = neighborNum - 1; i3 >= 0; i3--) {
      if (neighborNodes.length + 1 < pattern.nodes.length) {
        unmatched = true;
        return;
      }
      var neighborNode = neighborNodes[i3];
      var neighborLabel = neighborNode[nodeLabelProp];
      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      var key = "".concat(candidate.id, "-").concat(neighborNode.id);
      var distToCandidate = spmMap[key];
      var idx = patternSpDist[neighborLabel].length - 1;
      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx];
      if (distToCandidate > maxDistWithLabelInPattern) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      if (directed) {
        var keyBack = "".concat(neighborNode.id, "-").concat(candidate.id);
        var distFromCandidate = spmMap[keyBack];
        idx = patternSpDistBack[neighborLabel].length - 1;
        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];
        if (distFromCandidate > maxBackDistWithLabelInPattern) {
          neighborNodes.splice(i3, 1);
          continue;
        }
      }
      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);
      var patternKey = "".concat(beginPNode.id, "-").concat(neighborLabel);
      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1];
      if (ndsToCandidate < minNdsWithLabelInPattern) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      var _a3 = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _a3.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _a3.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _a3.minPatternNodeLabelOutDegree;
      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {
        neighborNodes.splice(i3, 1);
        continue;
      }
    }
    if (!unmatched) {
      candidateGraphs.push({
        nodes: [candidate].concat(neighborNodes)
      });
    }
  });
  var undirectedLengthsToBeginPNode = dijkstra_default(pattern, beginPNode.id, false).length;
  var undirectedLengthsToBeginPNodeLabelMap = {};
  if (directed) {
    Object.keys(undirectedLengthsToBeginPNode).forEach(function(nodeId) {
      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];
      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];
      else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);
    });
    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function(pLabel) {
      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function(a3, b10) {
        return a3 - b10;
      });
    });
  } else {
    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;
  }
  var candidateGraphNum = candidateGraphs.length;
  var _loop_2 = function _loop_22(i3) {
    var candidateGraph = candidateGraphs[i3];
    var candidate = candidateGraph.nodes[0];
    var candidateNodeLabelCountMap = {};
    var candidateNodeMap = {};
    candidateGraph.nodes.forEach(function(node, q2) {
      candidateNodeMap[node.id] = {
        idx: q2,
        node,
        degree: 0,
        inDegree: 0,
        outDegree: 0
      };
      var cNodeLabel2 = node[nodeLabelProp];
      if (!candidateNodeLabelCountMap[cNodeLabel2]) candidateNodeLabelCountMap[cNodeLabel2] = 1;
      else candidateNodeLabelCountMap[cNodeLabel2]++;
    });
    var candidateEdges = [];
    var edgeLabelCountMap = {};
    graphData.edges.forEach(function(edge) {
      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {
        candidateEdges.push(edge);
        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;
        else edgeLabelCountMap[edge[edgeLabelProp]]++;
        candidateNodeMap[edge.source].degree++;
        candidateNodeMap[edge.target].degree++;
        candidateNodeMap[edge.source].outDegree++;
        candidateNodeMap[edge.target].inDegree++;
      }
    });
    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;
    var prunedByEdgeLabel = false;
    for (var e8 = 0; e8 < pattenrEdgeLabelNum; e8++) {
      var label_1 = Object.keys(patternEdgeLabelMap)[e8];
      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {
        prunedByEdgeLabel = true;
        break;
      }
    }
    if (prunedByEdgeLabel) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    var candidateEdgeNum = candidateEdges.length;
    if (candidateEdgeNum < pattern.edges.length) {
      candidateGraphs.splice(i3, 1);
      return "break";
    }
    var candidateGraphInvalid = false;
    var _loop_5 = function _loop_52(e9) {
      var edge = candidateEdges[e9];
      var edgeLabel2 = edge[edgeLabelProp];
      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel2];
      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {
        edgeLabelCountMap[edgeLabel2]--;
        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
          candidateGraphInvalid = true;
          return "break";
        }
        candidateEdges.splice(e9, 1);
        candidateNodeMap[edge.source].degree--;
        candidateNodeMap[edge.target].degree--;
        candidateNodeMap[edge.source].outDegree--;
        candidateNodeMap[edge.target].inDegree--;
        return "continue";
      }
      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];
      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];
      var edgeMatched = false;
      patternEdgesWithLabel.forEach(function(patternEdge) {
        var patternSource = patternNodeMap[patternEdge.source].node;
        var patternTarget = patternNodeMap[patternEdge.target].node;
        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;
        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;
      });
      if (!edgeMatched) {
        edgeLabelCountMap[edgeLabel2]--;
        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
          candidateGraphInvalid = true;
          return "break";
        }
        candidateEdges.splice(e9, 1);
        candidateNodeMap[edge.source].degree--;
        candidateNodeMap[edge.target].degree--;
        candidateNodeMap[edge.source].outDegree--;
        candidateNodeMap[edge.target].inDegree--;
        return "continue";
      }
    };
    for (var e8 = candidateEdgeNum - 1; e8 >= 0; e8--) {
      var state_2 = _loop_5(e8);
      if (state_2 === "break") break;
    }
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    candidateGraph.edges = candidateEdges;
    var lengthsToCandidate = dijkstra_default(candidateGraph, candidateGraph.nodes[0].id, false).length;
    Object.keys(lengthsToCandidate).reverse().forEach(function(targetId) {
      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return;
      if (lengthsToCandidate[targetId] === Infinity) {
        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
        candidateNodeLabelCountMap[targetNodeLabel]--;
        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
          candidateGraphInvalid = true;
          return;
        }
        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
        candidateGraph.nodes.splice(idx, 1);
        candidateNodeMap[targetId] = void 0;
        return;
      }
      var nLabel = nodeMap[targetId].node[nodeLabelProp];
      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {
        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
        candidateNodeLabelCountMap[targetNodeLabel]--;
        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
          candidateGraphInvalid = true;
          return;
        }
        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
        candidateGraph.nodes.splice(idx, 1);
        candidateNodeMap[targetId] = void 0;
      }
    });
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    var degreeChanged = true;
    var loopCount = 0;
    while (degreeChanged && !candidateGraphInvalid) {
      degreeChanged = false;
      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;
      if (condition) {
        candidateGraphInvalid = true;
        break;
      }
      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {
        candidateGraphInvalid = true;
        break;
      }
      var currentCandidateNodeNum = candidateGraph.nodes.length;
      for (var o2 = currentCandidateNodeNum - 1; o2 >= 0; o2--) {
        var cgNode = candidateGraph.nodes[o2];
        var nodeDegree = candidateNodeMap[cgNode.id].degree;
        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;
        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;
        var cNodeLabel = cgNode[nodeLabelProp];
        var _e2 = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _e2.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _e2.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _e2.minPatternNodeLabelOutDegree;
        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;
        if (deleteCondition) {
          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;
          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {
            candidateGraphInvalid = true;
            break;
          }
          candidateGraph.nodes.splice(o2, 1);
          candidateNodeMap[cgNode.id] = void 0;
          degreeChanged = true;
        }
      }
      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break;
      candidateEdgeNum = candidateEdges.length;
      for (var y4 = candidateEdgeNum - 1; y4 >= 0; y4--) {
        var cedge = candidateEdges[y4];
        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {
          candidateEdges.splice(y4, 1);
          var edgeLabel = cedge[edgeLabelProp];
          edgeLabelCountMap[edgeLabel]--;
          if (candidateNodeMap[cedge.source]) {
            candidateNodeMap[cedge.source].degree--;
            candidateNodeMap[cedge.source].outDegree--;
          }
          if (candidateNodeMap[cedge.target]) {
            candidateNodeMap[cedge.target].degree--;
            candidateNodeMap[cedge.target].inDegree--;
          }
          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {
            candidateGraphInvalid = true;
            break;
          }
          degreeChanged = true;
        }
      }
      loopCount++;
    }
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
  };
  for (var i2 = candidateGraphNum - 1; i2 >= 0; i2--) {
    var state_1 = _loop_2(i2);
    if (state_1 === "break") break;
  }
  var currentLength = candidateGraphs.length;
  var _loop_3 = function _loop_32(i3) {
    var cg1 = candidateGraphs[i3];
    var cg1EdgeMap = {};
    cg1.edges.forEach(function(edge) {
      var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;
      else cg1EdgeMap[key]++;
    });
    var _loop_6 = function _loop_62(j3) {
      var cg2 = candidateGraphs[j3];
      var cg2EdgeMap = {};
      cg2.edges.forEach(function(edge) {
        var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;
        else cg2EdgeMap[key]++;
      });
      var same = true;
      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {
        same = false;
      } else {
        Object.keys(cg1EdgeMap).forEach(function(key) {
          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;
        });
      }
      if (same) {
        candidateGraphs.splice(j3, 1);
      }
    };
    for (var j2 = currentLength - 1; j2 > i3; j2--) {
      _loop_6(j2);
    }
    currentLength = candidateGraphs.length;
  };
  for (var i2 = 0; i2 <= currentLength - 1; i2++) {
    _loop_3(i2);
  }
  return candidateGraphs;
};
var gaddi_default = GADDI;

// node_modules/@antv/algorithm/es/structs/stack.js
var Stack = (
  /** @class */
  function() {
    function Stack2(maxStep) {
      if (maxStep === void 0) {
        maxStep = 10;
      }
      this.linkedList = new linked_list_default();
      this.maxStep = maxStep;
    }
    Object.defineProperty(Stack2.prototype, "length", {
      get: function get3() {
        return this.linkedList.toArray().length;
      },
      enumerable: false,
      configurable: true
    });
    Stack2.prototype.isEmpty = function() {
      return !this.linkedList.head;
    };
    Stack2.prototype.isMaxStack = function() {
      return this.toArray().length >= this.maxStep;
    };
    Stack2.prototype.peek = function() {
      if (this.isEmpty()) {
        return null;
      }
      return this.linkedList.head.value;
    };
    Stack2.prototype.push = function(value) {
      this.linkedList.prepend(value);
      if (this.length > this.maxStep) {
        this.linkedList.deleteTail();
      }
    };
    Stack2.prototype.pop = function() {
      var removeHead = this.linkedList.deleteHead();
      return removeHead ? removeHead.value : null;
    };
    Stack2.prototype.toArray = function() {
      return this.linkedList.toArray().map(function(node) {
        return node.value;
      });
    };
    Stack2.prototype.clear = function() {
      while (!this.isEmpty()) {
        this.pop();
      }
    };
    return Stack2;
  }()
);
var stack_default = Stack;

// node_modules/@antv/algorithm/es/index.js
var detectDirectedCycle3 = detect_cycle_default;
var es_default = {
  getAdjMatrix: adjacent_matrix_default,
  breadthFirstSearch: bfs_default,
  connectedComponent: getConnectedComponents,
  getDegree: degree_default,
  getInDegree,
  getOutDegree,
  detectCycle: detect_cycle_default,
  detectDirectedCycle: detectDirectedCycle3,
  detectAllCycles,
  detectAllDirectedCycle,
  detectAllUndirectedCycle,
  depthFirstSearch,
  dijkstra: dijkstra_default,
  findAllPath,
  findShortestPath,
  floydWarshall: floydWarshall_default,
  labelPropagation: label_propagation_default,
  louvain: louvain_default,
  iLouvain: i_louvain_default,
  kCore: k_core_default,
  kMeans: k_means_default,
  cosineSimilarity: cosine_similarity_default,
  nodesCosineSimilarity: nodes_cosine_similarity_default,
  minimumSpanningTree: mts_default,
  pageRank: pageRank_default,
  getNeighbors,
  Stack: stack_default,
  GADDI: gaddi_default
};

// node_modules/@antv/g6-core/es/util/math.js
var math_exports = {};
__export(math_exports, {
  Line: () => Line,
  applyMatrix: () => applyMatrix,
  compare: () => compare,
  distance: () => distance4,
  floydWarshall: () => floydWarshall3,
  fractionToLine: () => fractionToLine,
  getAdjMatrix: () => getAdjMatrix,
  getBBoxBoundLine: () => getBBoxBoundLine,
  getCircleCenterByPoints: () => getCircleCenterByPoints,
  getCircleIntersectByPoint: () => getCircleIntersectByPoint,
  getDegree: () => getDegree,
  getEllipseIntersectByPoint: () => getEllipseIntersectByPoint,
  getLineIntersect: () => getLineIntersect,
  getPointsCenter: () => getPointsCenter,
  getRectIntersectByPoint: () => getRectIntersectByPoint,
  intersectBBox: () => intersectBBox,
  invertMatrix: () => invertMatrix,
  isPointInPolygon: () => isPointInPolygon,
  isPointsOverlap: () => isPointsOverlap,
  isPolygonsIntersect: () => isPolygonsIntersect,
  itemIntersectByLine: () => itemIntersectByLine,
  lerp: () => lerp6,
  lerpArray: () => lerpArray,
  move: () => move,
  pointLineDistance: () => pointLineDistance,
  pointLineSquareDist: () => pointLineSquareDist,
  pointRectSquareDist: () => pointRectSquareDist,
  rotate: () => rotate6,
  scale: () => scale10,
  scaleMatrix: () => scaleMatrix,
  squareDist: () => squareDist,
  translate: () => translate5
});
init_esm();
var transform2 = ext_exports.transform;
var compare = function compare2(attributeName) {
  return function(m3, n2) {
    return m3[attributeName] - n2[attributeName];
  };
};
var isBetween = function isBetween2(value, min6, max8) {
  return value >= min6 && value <= max8;
};
var getLineIntersect = function getLineIntersect2(p0, p1, p2, p3) {
  var tolerance3 = 1e-4;
  var E3 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var invertKross = 1 / kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  if (sqrKross > tolerance3 * sqrLen0 * sqrLen1) {
    var s2 = (E3.x * D1.y - E3.y * D1.x) * invertKross;
    var t4 = (E3.x * D0.y - E3.y * D0.x) * invertKross;
    if (!isBetween(s2, 0, 1) || !isBetween(t4, 0, 1)) return null;
    return {
      x: p0.x + s2 * D0.x,
      y: p0.y + s2 * D0.y
    };
  }
  return null;
};
var getRectIntersectByPoint = function getRectIntersectByPoint2(rect2, point) {
  var x4 = rect2.x, y4 = rect2.y, width = rect2.width, height = rect2.height;
  var cx = x4 + width / 2;
  var cy = y4 + height / 2;
  var points = [];
  var center = {
    x: cx,
    y: cy
  };
  points.push({
    x: x4,
    y: y4
  });
  points.push({
    x: x4 + width,
    y: y4
  });
  points.push({
    x: x4 + width,
    y: y4 + height
  });
  points.push({
    x: x4,
    y: y4 + height
  });
  points.push({
    x: x4,
    y: y4
  });
  var rst = null;
  for (var i2 = 1; i2 < points.length; i2++) {
    rst = getLineIntersect(points[i2 - 1], points[i2], center, point);
    if (rst) {
      break;
    }
  }
  return rst;
};
var getCircleIntersectByPoint = function getCircleIntersectByPoint2(circle2, point) {
  var cx = circle2.x, cy = circle2.y, r2 = circle2.r;
  var x4 = point.x, y4 = point.y;
  var dx = x4 - cx;
  var dy = y4 - cy;
  if (dx * dx + dy * dy < r2 * r2) {
    return null;
  }
  var angle3 = Math.atan(dy / dx);
  return {
    x: cx + Math.abs(r2 * Math.cos(angle3)) * Math.sign(dx),
    y: cy + Math.abs(r2 * Math.sin(angle3)) * Math.sign(dy)
  };
};
var getEllipseIntersectByPoint = function getEllipseIntersectByPoint2(ellipse, point) {
  var a3 = ellipse.rx;
  var b10 = ellipse.ry;
  var cx = ellipse.x;
  var cy = ellipse.y;
  var dx = point.x - cx;
  var dy = point.y - cy;
  var angle3 = Math.atan2(dy / b10, dx / a3);
  if (angle3 < 0) {
    angle3 += 2 * Math.PI;
  }
  return {
    x: cx + a3 * Math.cos(angle3),
    y: cy + b10 * Math.sin(angle3)
  };
};
var applyMatrix = function applyMatrix2(point, matrix, tag) {
  if (tag === void 0) {
    tag = 1;
  }
  var vector = [point.x, point.y, tag];
  if (!matrix || isNaN(matrix[0])) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  vec3_exports.transformMat3(vector, vector, matrix);
  return {
    x: vector[0],
    y: vector[1]
  };
};
var invertMatrix = function invertMatrix2(point, matrix, tag) {
  if (tag === void 0) {
    tag = 1;
  }
  if (!matrix || isNaN(matrix[0])) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var inversedMatrix = mat3_exports.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);
  if (!inversedMatrix) {
    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var vector = [point.x, point.y, tag];
  vec3_exports.transformMat3(vector, vector, inversedMatrix);
  return {
    x: vector[0],
    y: vector[1]
  };
};
var getCircleCenterByPoints = function getCircleCenterByPoints2(p1, p2, p3) {
  var a3 = p1.x - p2.x;
  var b10 = p1.y - p2.y;
  var c3 = p1.x - p3.x;
  var d2 = p1.y - p3.y;
  var e8 = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;
  var f2 = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;
  var denominator = b10 * c3 - a3 * d2;
  return {
    x: -(d2 * e8 - b10 * f2) / denominator,
    y: -(a3 * f2 - c3 * e8) / denominator
  };
};
var distance4 = function distance5(p1, p2) {
  var vx = p1.x - p2.x;
  var vy = p1.y - p2.y;
  return Math.sqrt(vx * vx + vy * vy);
};
var scaleMatrix = function scaleMatrix2(matrix, ratio) {
  var result = [];
  matrix.forEach(function(row) {
    var newRow = [];
    row.forEach(function(v2) {
      newRow.push(v2 * ratio);
    });
    result.push(newRow);
  });
  return result;
};
var floydWarshall3 = function floydWarshall4(adjMatrix3) {
  var dist4 = [];
  var size3 = adjMatrix3.length;
  for (var i2 = 0; i2 < size3; i2 += 1) {
    dist4[i2] = [];
    for (var j2 = 0; j2 < size3; j2 += 1) {
      if (i2 === j2) {
        dist4[i2][j2] = 0;
      } else if (adjMatrix3[i2][j2] === 0 || !adjMatrix3[i2][j2]) {
        dist4[i2][j2] = Infinity;
      } else {
        dist4[i2][j2] = adjMatrix3[i2][j2];
      }
    }
  }
  for (var k2 = 0; k2 < size3; k2 += 1) {
    for (var i2 = 0; i2 < size3; i2 += 1) {
      for (var j2 = 0; j2 < size3; j2 += 1) {
        if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
          dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
        }
      }
    }
  }
  return dist4;
};
var getAdjMatrix = function getAdjMatrix2(data, directed) {
  var nodes = data.nodes, edges = data.edges;
  var matrix = [];
  var nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach(function(node, i2) {
      nodeMap[node.id] = i2;
      var row = [];
      matrix.push(row);
    });
  }
  if (edges) {
    edges.forEach(function(e8) {
      var source = e8.source, target = e8.target;
      var sIndex = nodeMap[source];
      var tIndex = nodeMap[target];
      matrix[sIndex][tIndex] = 1;
      if (!directed) {
        matrix[tIndex][sIndex] = 1;
      }
    });
  }
  return matrix;
};
var translate5 = function translate6(group, vec) {
  group.translate(vec.x, vec.y);
};
var move = function move2(group, point, animate, animateCfg) {
  if (animateCfg === void 0) {
    animateCfg = {
      duration: 500
    };
  }
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var bbox = group.getCanvasBBox();
  var vx = point.x - bbox.minX;
  var vy = point.y - bbox.minY;
  if (animate) {
    var dx_1 = vx * matrix[0];
    var dy_1 = vy * matrix[4];
    var lastX_1 = 0;
    var lastY_1 = 0;
    var newX_1 = 0;
    var newY_1 = 0;
    group.animate(function(ratio) {
      newX_1 = dx_1 * ratio;
      newY_1 = dy_1 * ratio;
      matrix = transform2(matrix, [["t", newX_1 - lastX_1, newY_1 - lastY_1]]);
      lastX_1 = newX_1;
      lastY_1 = newY_1;
      return {
        matrix
      };
    }, animateCfg);
  } else {
    var movedMatrix = transform2(matrix, [["t", vx, vy]]);
    group.setMatrix(movedMatrix);
  }
};
var scale10 = function scale11(group, ratio) {
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var scaleXY = ratio;
  if (!is_array_default(ratio)) {
    scaleXY = [ratio, ratio];
  }
  if (is_array_default(ratio) && ratio.length === 1) {
    scaleXY = [ratio[0], ratio[0]];
  }
  matrix = transform2(matrix, [["s", scaleXY[0], scaleXY[1]]]);
  group.setMatrix(matrix);
};
var rotate6 = function rotate7(group, angle3) {
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  matrix = transform2(matrix, [["r", angle3]]);
  group.setMatrix(matrix);
};
var getDegree = function getDegree2(n2, nodeIdxMap, edges) {
  var degrees3 = [];
  for (var i2 = 0; i2 < n2; i2++) {
    degrees3[i2] = 0;
  }
  edges.forEach(function(e8) {
    if (e8.source) {
      degrees3[nodeIdxMap[e8.source]] += 1;
    }
    if (e8.target) {
      degrees3[nodeIdxMap[e8.target]] += 1;
    }
  });
  return degrees3;
};
function onSegment(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
var isPointInPolygon = function isPointInPolygon2(points, x4, y4) {
  var isHit = false;
  var n2 = points.length;
  var tolerance3 = 1e-6;
  function dcmp3(xValue) {
    if (Math.abs(xValue) < tolerance3) {
      return 0;
    }
    return xValue < 0 ? -1 : 1;
  }
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment(p1, p2, [x4, y4])) {
      return true;
    }
    if (dcmp3(p1[1] - y4) > 0 !== dcmp3(p2[1] - y4) > 0 && dcmp3(x4 - (y4 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
};
var intersectBBox = function intersectBBox2(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
};
var lineIntersectPolygon = function lineIntersectPolygon2(lines, line) {
  var isIntersect = false;
  each_default(lines, function(l2) {
    if (getLineIntersect(l2.from, l2.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
};
var isPolygonsIntersect = function isPolygonsIntersect2(points1, points2) {
  var getBBox5 = function getBBox6(points) {
    var xArr = points.map(function(p2) {
      return p2[0];
    });
    var yArr = points.map(function(p2) {
      return p2[1];
    });
    return {
      minX: Math.min.apply(null, xArr),
      maxX: Math.max.apply(null, xArr),
      minY: Math.min.apply(null, yArr),
      maxY: Math.max.apply(null, yArr)
    };
  };
  var parseToLines2 = function parseToLines3(points) {
    var lines = [];
    var count = points.length;
    for (var i2 = 0; i2 < count - 1; i2++) {
      var point = points[i2];
      var next = points[i2 + 1];
      lines.push({
        from: {
          x: point[0],
          y: point[1]
        },
        to: {
          x: next[0],
          y: next[1]
        }
      });
    }
    if (lines.length > 1) {
      var first = points[0];
      var last3 = points[count - 1];
      lines.push({
        from: {
          x: last3[0],
          y: last3[1]
        },
        to: {
          x: first[0],
          y: first[1]
        }
      });
    }
    return lines;
  };
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox5(points1);
  var bbox2 = getBBox5(points2);
  if (!intersectBBox(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each_default(points2, function(point) {
    if (isPointInPolygon(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each_default(points1, function(point) {
    if (isPointInPolygon(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines2(points1);
  var lines2 = parseToLines2(points2);
  var isIntersect = false;
  each_default(lines2, function(line) {
    if (lineIntersectPolygon(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
};
var Line = (
  /** @class */
  function() {
    function Line4(x1, y1, x22, y22) {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x22;
      this.y2 = y22;
    }
    Line4.prototype.getBBox = function() {
      var minX = Math.min(this.x1, this.x2);
      var minY = Math.min(this.y1, this.y2);
      var maxX = Math.max(this.x1, this.x2);
      var maxY = Math.max(this.y1, this.y2);
      var res = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return res;
    };
    return Line4;
  }()
);
var getBBoxBoundLine = function getBBoxBoundLine2(bbox, direction3) {
  var bounds = {
    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],
    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],
    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],
    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]
  };
  return bounds[direction3];
};
var fractionAlongLineA = function fractionAlongLineA2(la2, lb) {
  var uaT = (lb.x2 - lb.x1) * (la2.y1 - lb.y1) - (lb.y2 - lb.y1) * (la2.x1 - lb.x1);
  var ubT = (la2.x2 - la2.x1) * (la2.y1 - lb.y1) - (la2.y2 - la2.y1) * (la2.x1 - lb.x1);
  var uB = (lb.y2 - lb.y1) * (la2.x2 - la2.x1) - (lb.x2 - lb.x1) * (la2.y2 - la2.y1);
  if (uB) {
    var ua2 = uaT / uB;
    var ub = ubT / uB;
    if (ua2 >= 0 && ua2 <= 1 && ub >= 0 && ub <= 1) {
      return ua2;
    }
  }
  return Number.POSITIVE_INFINITY;
};
var itemIntersectByLine = function itemIntersectByLine2(item, line) {
  var directions = ["top", "left", "bottom", "right"];
  var bbox = item.getBBox();
  var countIntersections = 0;
  var intersections = [];
  for (var i2 = 0; i2 < 4; i2++) {
    var _a2 = getBBoxBoundLine(bbox, directions[i2]), x1 = _a2[0], y1 = _a2[1], x22 = _a2[2], y22 = _a2[3];
    intersections[i2] = getLineIntersect({
      x: line.x1,
      y: line.y1
    }, {
      x: line.x2,
      y: line.y2
    }, {
      x: x1,
      y: y1
    }, {
      x: x22,
      y: y22
    });
    if (intersections[i2]) {
      countIntersections += 1;
    }
  }
  return [intersections, countIntersections];
};
var fractionToLine = function fractionToLine2(item, line) {
  var directions = ["top", "left", "bottom", "right"];
  var bbox = item.getBBox();
  var minDistance = Number.POSITIVE_INFINITY;
  var countIntersections = 0;
  for (var i2 = 0; i2 < 4; i2++) {
    var _a2 = getBBoxBoundLine(bbox, directions[i2]), x1 = _a2[0], y1 = _a2[1], x22 = _a2[2], y22 = _a2[3];
    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x22, y22));
    testDistance = Math.abs(testDistance - 0.5);
    if (testDistance >= 0 && testDistance <= 1) {
      countIntersections += 1;
      minDistance = testDistance < minDistance ? testDistance : minDistance;
    }
  }
  if (countIntersections === 0) return -1;
  return minDistance;
};
var getPointsCenter = function getPointsCenter2(points) {
  var centerX = 0;
  var centerY = 0;
  if (points.length > 0) {
    for (var _i2 = 0, points_1 = points; _i2 < points_1.length; _i2++) {
      var point = points_1[_i2];
      centerX += point.x;
      centerY += point.y;
    }
    centerX /= points.length;
    centerY /= points.length;
  }
  return {
    x: centerX,
    y: centerY
  };
};
var squareDist = function squareDist2(a3, b10) {
  return Math.pow(a3.x - b10.x, 2) + Math.pow(a3.y - b10.y, 2);
};
var pointLineSquareDist = function pointLineSquareDist2(point, line) {
  var x1 = line.x1;
  var y1 = line.y1;
  var x22 = line.x2 - x1;
  var y22 = line.y2 - y1;
  var px = point.x - x1;
  var py = point.y - y1;
  var dotprod = px * x22 + py * y22;
  var projlenSq;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px = x22 - px;
    py = y22 - py;
    dotprod = px * x22 + py * y22;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x22 * x22 + y22 * y22);
    }
  }
  var lenSq = px * px + py * py - projlenSq;
  if (lenSq < 0) {
    lenSq = 0;
  }
  return lenSq;
};
var isPointsOverlap = function isPointsOverlap2(p1, p2, e8) {
  if (e8 === void 0) {
    e8 = 1e-3;
  }
  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e8, 2);
};
var pointRectSquareDist = function pointRectSquareDist2(point, rect2) {
  var isLeft = point.x < rect2.x;
  var isRight = point.x > rect2.x + rect2.width;
  var isTop = point.y > rect2.y + rect2.height;
  var isBottom = point.y < rect2.y;
  var isPointOutside = isLeft || isRight || isTop || isBottom;
  if (!isPointOutside) {
    return 0;
  }
  if (isTop && !isLeft && !isRight) {
    return Math.pow(rect2.y + rect2.height - point.y, 2);
  }
  if (isBottom && !isLeft && !isRight) {
    return Math.pow(point.y - rect2.y, 2);
  }
  if (isLeft && !isTop && !isBottom) {
    return Math.pow(rect2.x - point.x, 2);
  }
  if (isRight && !isTop && !isBottom) {
    return Math.pow(rect2.x + rect2.width - point.x, 2);
  }
  var dx = Math.min(Math.abs(rect2.x - point.x), Math.abs(rect2.x + rect2.width - point.x));
  var dy = Math.min(Math.abs(rect2.y - point.y), Math.abs(rect2.y + rect2.height - point.y));
  return dx * dx + dy * dy;
};
var pointLineDistance = function pointLineDistance2(line, point) {
  var x1 = line[0], y1 = line[1], x22 = line[2], y22 = line[3];
  var x4 = point.x, y4 = point.y;
  var d2 = [x22 - x1, y22 - y1];
  if (vec2_exports.exactEquals(d2, [0, 0])) {
    return NaN;
  }
  var u2 = [-d2[1], d2[0]];
  vec2_exports.normalize(u2, u2);
  var a3 = [x4 - x1, y4 - y1];
  return Math.abs(vec2_exports.dot(a3, u2));
};
var lerp6 = function lerp7(start, end2, alpha) {
  return start + (end2 - start) * alpha;
};
var lerpArray = function lerpArray2(start, end2, alpha) {
  var len6 = Math.min(start.length, end2.length);
  var out = new Array(len6);
  for (var i2 = 0; i2 < len6; i2++) {
    out[i2] = lerp6(start[i2], end2[i2], alpha);
  }
  return out;
};

// node_modules/@antv/g6-core/es/util/validation.js
init_esm();

// node_modules/@antv/g6-core/es/util/graphic.js
var graphic_exports = {};
__export(graphic_exports, {
  cloneBesidesImg: () => cloneBesidesImg,
  getAnimateCfgWithCallback: () => getAnimateCfgWithCallback,
  getBBox: () => getBBox,
  getComboBBox: () => getComboBBox,
  getLabelPosition: () => getLabelPosition,
  getLetterWidth: () => getLetterWidth,
  getLoopCfgs: () => getLoopCfgs,
  getTextSize: () => getTextSize,
  plainCombosToTrees: () => plainCombosToTrees,
  reconstructTree: () => reconstructTree,
  shouldRefreshEdge: () => shouldRefreshEdge,
  traverseTree: () => traverseTree,
  traverseTreeUp: () => traverseTreeUp,
  truncateLabelByLength: () => truncateLabelByLength
});
init_esm();

// node_modules/@antv/g6-core/es/global.js
var subjectColor = "rgb(95, 149, 255)";
var backColor = "rgb(255, 255, 255)";
var textColor = "rgb(0, 0, 0)";
var activeFill = "rgb(247, 250, 255)";
var nodeMainFill = "rgb(239, 244, 255)";
var comboFill = "rgb(253, 253, 253)";
var disabledFill = "rgb(250, 250, 250)";
var edgeMainStroke = "rgb(224, 224, 224)";
var edgeInactiveStroke = "rgb(234, 234, 234)";
var edgeDisablesStroke = "rgb(245, 245, 245)";
var inactiveStroke = "rgb(191, 213, 255)";
var highlightStroke = "#4572d9";
var highlightFill = "rgb(223, 234, 255)";
var colorSet = {
  // for nodes
  mainStroke: subjectColor,
  mainFill: nodeMainFill,
  activeStroke: subjectColor,
  activeFill,
  inactiveStroke,
  inactiveFill: activeFill,
  selectedStroke: subjectColor,
  selectedFill: backColor,
  highlightStroke,
  highlightFill,
  disableStroke: edgeMainStroke,
  disableFill: disabledFill,
  // for edges
  edgeMainStroke,
  edgeActiveStroke: subjectColor,
  edgeInactiveStroke,
  edgeSelectedStroke: subjectColor,
  edgeHighlightStroke: subjectColor,
  edgeDisableStroke: edgeDisablesStroke,
  // for combos
  comboMainStroke: edgeMainStroke,
  comboMainFill: comboFill,
  comboActiveStroke: subjectColor,
  comboActiveFill: activeFill,
  comboInactiveStroke: edgeMainStroke,
  comboInactiveFill: comboFill,
  comboSelectedStroke: subjectColor,
  comboSelectedFill: comboFill,
  comboHighlightStroke: highlightStroke,
  comboHighlightFill: comboFill,
  comboDisableStroke: edgeInactiveStroke,
  comboDisableFill: disabledFill
};
var global_default = {
  version: "0.8.23",
  rootContainerClassName: "root-container",
  nodeContainerClassName: "node-container",
  edgeContainerClassName: "edge-container",
  comboContainerClassName: "combo-container",
  delegateContainerClassName: "delegate-container",
  defaultLoopPosition: "top",
  nodeLabel: {
    style: {
      fill: "#000",
      fontSize: 12,
      textAlign: "center",
      textBaseline: "middle"
    },
    offset: 4
    // 节点的默认文本不居中时的偏移量
  },
  defaultNode: {
    type: "circle",
    style: {
      lineWidth: 1,
      stroke: colorSet.mainStroke,
      fill: nodeMainFill
    },
    size: 20,
    color: colorSet.mainStroke,
    linkPoints: {
      size: 8,
      lineWidth: 1,
      fill: colorSet.activeFill,
      stroke: colorSet.activeStroke
    }
  },
  // 节点应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  nodeStateStyles: {
    active: {
      fill: colorSet.activeFill,
      stroke: colorSet.activeStroke,
      lineWidth: 2,
      shadowColor: colorSet.mainStroke,
      shadowBlur: 10
    },
    selected: {
      fill: colorSet.selectedFill,
      stroke: colorSet.selectedStroke,
      lineWidth: 4,
      shadowColor: colorSet.selectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      fill: colorSet.highlightFill,
      stroke: colorSet.highlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      fill: colorSet.inactiveFill,
      stroke: colorSet.inactiveStroke,
      lineWidth: 1
    },
    disable: {
      fill: colorSet.disableFill,
      stroke: colorSet.disableStroke,
      lineWidth: 1
    }
  },
  edgeLabel: {
    style: {
      fill: textColor,
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 12
    }
  },
  defaultEdge: {
    type: "line",
    size: 1,
    style: {
      stroke: colorSet.edgeMainStroke,
      lineAppendWidth: 2
    },
    color: colorSet.edgeMainStroke
  },
  // 边应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  edgeStateStyles: {
    active: {
      stroke: colorSet.edgeActiveStroke,
      lineWidth: 1
    },
    selected: {
      stroke: colorSet.edgeSelectedStroke,
      lineWidth: 2,
      shadowColor: colorSet.edgeSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet.edgeHighlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet.edgeInactiveStroke,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet.edgeDisableStroke,
      lineWidth: 1
    }
  },
  comboLabel: {
    style: {
      fill: textColor,
      // textAlign: 'center',
      textBaseline: "middle",
      fontSize: 12
    },
    refY: 10,
    refX: 10
    // Combo 的默认文本不居中时的偏移量
  },
  defaultCombo: {
    type: "circle",
    style: {
      fill: colorSet.comboMainFill,
      lineWidth: 1,
      stroke: colorSet.comboMainStroke,
      r: 5,
      width: 20,
      height: 10
    },
    size: [20, 5],
    color: colorSet.comboMainStroke,
    padding: [25, 20, 15, 20]
  },
  // combo 应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  comboStateStyles: {
    active: {
      stroke: colorSet.comboActiveStroke,
      lineWidth: 1,
      fill: colorSet.comboActiveFill
    },
    selected: {
      stroke: colorSet.comboSelectedStroke,
      lineWidth: 2,
      fill: colorSet.comboSelectedFill,
      shadowColor: colorSet.comboSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet.comboHighlightStroke,
      lineWidth: 2,
      fill: colorSet.comboHighlightFill,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet.comboInactiveStroke,
      fill: colorSet.comboInactiveFill,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet.comboDisableStroke,
      fill: colorSet.comboDisableFill,
      lineWidth: 1
    }
  },
  delegateStyle: {
    fill: "#F3F9FF",
    fillOpacity: 0.5,
    stroke: "#1890FF",
    strokeOpacity: 0.9,
    lineDash: [5, 5]
  },
  windowFontFamily: typeof window !== "undefined" && window.getComputedStyle && document.body ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif"
};

// node_modules/@antv/g6-core/es/util/letterAspectRatio.js
var letterAspectRatio_default = {
  " ": 0.3329986572265625,
  a: 0.5589996337890625,
  A: 0.6569992065429687,
  b: 0.58599853515625,
  B: 0.6769989013671875,
  c: 0.5469985961914062,
  C: 0.7279998779296875,
  d: 0.58599853515625,
  D: 0.705999755859375,
  e: 0.554998779296875,
  E: 0.63699951171875,
  f: 0.37299957275390627,
  F: 0.5769989013671875,
  g: 0.5909988403320312,
  G: 0.7479995727539063,
  h: 0.555999755859375,
  H: 0.7199996948242188,
  i: 0.255999755859375,
  I: 0.23699951171875,
  j: 0.26699981689453123,
  J: 0.5169998168945312,
  k: 0.5289993286132812,
  K: 0.6899993896484375,
  l: 0.23499908447265624,
  L: 0.5879989624023437,
  m: 0.854998779296875,
  M: 0.8819992065429687,
  n: 0.5589996337890625,
  N: 0.7189987182617188,
  o: 0.58599853515625,
  O: 0.7669998168945312,
  p: 0.58599853515625,
  P: 0.6419998168945312,
  q: 0.58599853515625,
  Q: 0.7669998168945312,
  r: 0.3649993896484375,
  R: 0.6759994506835938,
  s: 0.504998779296875,
  S: 0.6319992065429687,
  t: 0.354998779296875,
  T: 0.6189987182617187,
  u: 0.5599990844726562,
  U: 0.7139999389648437,
  v: 0.48199920654296874,
  V: 0.6389999389648438,
  w: 0.754998779296875,
  W: 0.929998779296875,
  x: 0.5089996337890625,
  X: 0.63699951171875,
  y: 0.4959991455078125,
  Y: 0.66199951171875,
  z: 0.48699951171875,
  Z: 0.6239990234375,
  "0": 0.6,
  "1": 0.40099945068359377,
  "2": 0.6,
  "3": 0.6,
  "4": 0.6,
  "5": 0.6,
  "6": 0.6,
  "7": 0.5469985961914062,
  "8": 0.6,
  "9": 0.6,
  "[": 0.3329986572265625,
  "]": 0.3329986572265625,
  ",": 0.26399993896484375,
  ".": 0.26399993896484375,
  ";": 0.26399993896484375,
  ":": 0.26399993896484375,
  "{": 0.3329986572265625,
  "}": 0.3329986572265625,
  "\\": 0.5,
  "|": 0.19499969482421875,
  "=": 0.604998779296875,
  "+": 0.604998779296875,
  "-": 0.604998779296875,
  _: 0.5,
  "`": 0.3329986572265625,
  " ~": 0.8329986572265625,
  "!": 0.3329986572265625,
  "@": 0.8579986572265625,
  "#": 0.6,
  $: 0.6,
  "%": 0.9699996948242188,
  "^": 0.517999267578125,
  "&": 0.7259994506835937,
  "*": 0.505999755859375,
  "(": 0.3329986572265625,
  ")": 0.3329986572265625,
  "<": 0.604998779296875,
  ">": 0.604998779296875,
  "/": 0.5,
  "?": 0.53699951171875
};

// node_modules/@antv/g6-core/es/util/graphic.js
var PI = Math.PI;
var sin = Math.sin;
var cos = Math.cos;
var SELF_LINK_SIN = sin(PI / 8);
var SELF_LINK_COS = cos(PI / 8);
var getBBox = function getBBox2(element, group) {
  var bbox = element.getBBox();
  var leftTop = {
    x: bbox.minX,
    y: bbox.minY
  };
  var rightBottom = {
    x: bbox.maxX,
    y: bbox.maxY
  };
  if (group) {
    var matrix = group.getMatrix();
    if (!matrix) {
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    leftTop = applyMatrix(leftTop, matrix);
    rightBottom = applyMatrix(rightBottom, matrix);
  }
  var lx = leftTop.x, ly = leftTop.y;
  var rx = rightBottom.x, ry = rightBottom.y;
  return {
    x: lx,
    y: ly,
    minX: lx,
    minY: ly,
    maxX: rx,
    maxY: ry,
    width: rx - lx,
    height: ry - ly
  };
};
var getLoopCfgs = function getLoopCfgs2(cfg) {
  var item = cfg.sourceNode || cfg.targetNode;
  var container = item.get("group");
  var containerMatrix = container.getMatrix();
  if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  var keyShape = item.getKeyShape();
  var bbox = keyShape.getBBox();
  var loopCfg = cfg.loopCfg || {};
  var dist4 = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2;
  var position = loopCfg.position || global_default.defaultLoopPosition;
  var center = [(bbox.minX + bbox.maxX) / 2 + containerMatrix[6], (bbox.minY + bbox.maxY) / 2 + containerMatrix[7]];
  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];
  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];
  var halfOfHeight = bbox.height / 2;
  var halfOfWidth = bbox.width / 2;
  var rstart = halfOfHeight;
  var rend = halfOfHeight;
  var sinDeltaStart = rstart * SELF_LINK_SIN;
  var cosDeltaStart = rstart * SELF_LINK_COS;
  var sinDeltaEnd = rend * SELF_LINK_SIN;
  var cosDeltaEnd = rend * SELF_LINK_COS;
  var shapeType = keyShape.get("type");
  var defaultPointPadding = Math.min(halfOfHeight / 2, halfOfWidth / 2);
  var maxPointPadding = Math.min(halfOfHeight, halfOfWidth);
  var pointPadding = (loopCfg === null || loopCfg === void 0 ? void 0 : loopCfg.pointPadding) ? Math.min(maxPointPadding, loopCfg === null || loopCfg === void 0 ? void 0 : loopCfg.pointPadding) : defaultPointPadding;
  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {
    switch (position) {
      case "top":
        if (shapeType === "circle") {
          startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];
          endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];
        } else {
          startPoint = [center[0] - pointPadding, center[1] - halfOfHeight];
          endPoint = [center[0] + pointPadding, center[1] - halfOfHeight];
        }
        break;
      case "top-right":
        rstart = halfOfHeight;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];
          endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];
        } else {
          startPoint = [center[0] + halfOfWidth - pointPadding, center[1] - halfOfHeight];
          endPoint = [center[0] + halfOfWidth, center[1] - halfOfHeight + pointPadding];
        }
        break;
      case "right":
        rstart = halfOfWidth;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];
          endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];
        } else {
          startPoint = [center[0] + halfOfWidth, center[1] - pointPadding];
          endPoint = [center[0] + halfOfWidth, center[1] + pointPadding];
        }
        break;
      case "bottom-right":
        rstart = halfOfWidth;
        rend = halfOfHeight;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];
          endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];
        } else {
          startPoint = [center[0] + halfOfWidth, center[1] + halfOfHeight - pointPadding];
          endPoint = [center[0] + halfOfWidth - pointPadding, center[1] + halfOfHeight];
        }
        break;
      case "bottom":
        rstart = halfOfHeight;
        rend = halfOfHeight;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];
          endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];
        } else {
          startPoint = [center[0] - pointPadding, center[1] + halfOfHeight];
          endPoint = [center[0] + pointPadding, center[1] + halfOfHeight];
        }
        break;
      case "bottom-left":
        rstart = halfOfHeight;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];
          endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];
        } else {
          startPoint = [center[0] - halfOfWidth, center[1] + halfOfHeight - pointPadding];
          endPoint = [center[0] - halfOfWidth + pointPadding, center[1] + halfOfHeight];
        }
        break;
      case "left":
        rstart = halfOfWidth;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];
          endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];
        } else {
          startPoint = [center[0] - halfOfWidth, center[1] - pointPadding];
          endPoint = [center[0] - halfOfWidth, center[1] + pointPadding];
        }
        break;
      case "top-left":
        rstart = halfOfWidth;
        rend = halfOfHeight;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];
          endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];
        } else {
          startPoint = [center[0] - halfOfWidth + pointPadding, center[1] - halfOfHeight];
          endPoint = [center[0] - halfOfWidth, center[1] - halfOfHeight + pointPadding];
        }
        break;
      default:
        rstart = halfOfWidth;
        rend = halfOfWidth;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];
        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];
    }
    if (loopCfg.clockwise === false) {
      var swap = [startPoint[0], startPoint[1]];
      startPoint = [endPoint[0], endPoint[1]];
      endPoint = [swap[0], swap[1]];
    }
  }
  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];
  var scaleRateStart = (rstart + dist4) / rstart;
  var scaleRateEnd = (rend + dist4) / rend;
  if (loopCfg.clockwise === false) {
    scaleRateStart = (rend + dist4) / rend;
    scaleRateEnd = (rstart + dist4) / rstart;
  }
  var startExtendVec = vec2_exports.scale([0, 0], startVec, scaleRateStart);
  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];
  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];
  var endExtendVec = vec2_exports.scale([0, 0], endVec, scaleRateEnd);
  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];
  cfg.startPoint = {
    x: startPoint[0],
    y: startPoint[1]
  };
  cfg.endPoint = {
    x: endPoint[0],
    y: endPoint[1]
  };
  cfg.controlPoints = [{
    x: controlPoint1[0],
    y: controlPoint1[1]
  }, {
    x: controlPoint2[0],
    y: controlPoint2[1]
  }];
  return cfg;
};
var getLabelPosition = function getLabelPosition2(pathShape, percent, refX, refY, rotate9) {
  var TAN_OFFSET = 1e-4;
  var vector = [];
  var point = pathShape === null || pathShape === void 0 ? void 0 : pathShape.getPoint(percent);
  if (!point) {
    return {
      x: 0,
      y: 0,
      angle: 0
    };
  }
  if (percent < TAN_OFFSET) {
    vector = pathShape.getStartTangent().reverse();
  } else if (percent > 1 - TAN_OFFSET) {
    vector = pathShape.getEndTangent();
  } else {
    var offsetPoint = pathShape === null || pathShape === void 0 ? void 0 : pathShape.getPoint(percent + TAN_OFFSET);
    vector.push([point.x, point.y]);
    vector.push([offsetPoint.x, offsetPoint.y]);
  }
  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);
  if (rad < 0) {
    rad += PI * 2;
  }
  if (refX) {
    point.x += cos(rad) * refX;
    point.y += sin(rad) * refX;
  }
  if (refY) {
    var normal = rad - PI / 2;
    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {
      normal -= PI;
    }
    point.x += cos(normal) * refY;
    point.y += sin(normal) * refY;
  }
  var result = {
    x: point.x,
    y: point.y,
    angle: rad
  };
  if (rotate9) {
    if (rad > 0.5 * PI && rad < 1.5 * PI) {
      rad -= PI;
    }
    return __assign3({
      rotate: rad
    }, result);
  }
  return result;
};
var traverse = function traverse2(data, parent, index2, fn2) {
  if (fn2(data, parent, index2) === false) {
    return false;
  }
  if (data && data.children) {
    for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
      if (!traverse2(data.children[i2], data, i2, fn2)) return false;
    }
  }
  return true;
};
var traverseUp = function traverseUp2(data, parent, index2, fn2) {
  if (data && data.children) {
    for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
      if (!traverseUp2(data.children[i2], data, i2, fn2)) return;
    }
  }
  if (fn2(data, parent, index2) === false) {
    return false;
  }
  return true;
};
var traverseTree = function traverseTree2(data, fn2) {
  if (typeof fn2 !== "function") {
    return;
  }
  traverse(data, null, -1, fn2);
};
var traverseTreeUp = function traverseTreeUp2(data, fn2) {
  if (typeof fn2 !== "function") {
    return;
  }
  traverseUp(data, null, -1, fn2);
};
var getLetterWidth = function getLetterWidth2(letter, fontSize) {
  return fontSize * (letterAspectRatio_default[letter] || 1);
};
var getTextSize = function getTextSize2(text, fontSize) {
  var width = 0;
  var pattern = new RegExp("[一-龥]+");
  text.split("").forEach(function(letter) {
    if (pattern.test(letter)) {
      width += fontSize;
    } else {
      width += getLetterWidth(letter, fontSize);
    }
  });
  return [width, fontSize];
};
var truncateLabelByLength = function truncateLabelByLength2(text, length6) {
  if (typeof length6 !== "number" || length6 <= 0 || length6 >= text.length) {
    return text;
  }
  return text.substring(0, length6) + "...";
};
var plainCombosToTrees = function plainCombosToTrees2(array, nodes) {
  var result = [];
  var addedMap = {};
  var modelMap = {};
  array.forEach(function(d2) {
    modelMap[d2.id] = d2;
  });
  array.forEach(function(d2, i2) {
    var cd = clone_default(d2);
    cd.itemType = "combo";
    cd.children = void 0;
    if (cd.parentId === cd.id) {
      console.warn("The parentId for combo ".concat(cd.id, " can not be the same as the combo's id"));
      delete cd.parentId;
    } else if (cd.parentId && !modelMap[cd.parentId]) {
      console.warn("The parent combo for combo ".concat(cd.id, " does not exist!"));
      delete cd.parentId;
    }
    var mappedObj = addedMap[cd.id];
    if (mappedObj) {
      cd.children = mappedObj.children;
      addedMap[cd.id] = cd;
      mappedObj = cd;
      if (!mappedObj.parentId) {
        result.push(mappedObj);
        return;
      }
      var mappedParent = addedMap[mappedObj.parentId];
      if (mappedParent) {
        if (mappedParent.children) mappedParent.children.push(cd);
        else mappedParent.children = [cd];
      } else {
        var parent_1 = {
          id: mappedObj.parentId,
          children: [mappedObj]
        };
        addedMap[mappedObj.parentId] = parent_1;
        addedMap[cd.id] = cd;
      }
      return;
    }
    if (is_string_default(d2.parentId)) {
      var parent_2 = addedMap[d2.parentId];
      if (parent_2) {
        if (parent_2.children) parent_2.children.push(cd);
        else parent_2.children = [cd];
        addedMap[cd.id] = cd;
      } else {
        var pa2 = {
          id: d2.parentId,
          children: [cd]
        };
        addedMap[pa2.id] = pa2;
        addedMap[cd.id] = cd;
      }
    } else {
      result.push(cd);
      addedMap[cd.id] = cd;
    }
  });
  var nodeMap = {};
  (nodes || []).forEach(function(node) {
    nodeMap[node.id] = node;
    var combo = addedMap[node.comboId];
    if (combo) {
      var cnode = {
        id: node.id,
        comboId: node.comboId
      };
      if (combo.children) combo.children.push(cnode);
      else combo.children = [cnode];
      cnode.itemType = "node";
      addedMap[node.id] = cnode;
    }
  });
  var maxDepth = 0;
  result.forEach(function(tree) {
    tree.depth = maxDepth + 10;
    traverseTree(tree, function(child) {
      var parent;
      var itemType = addedMap[child.id].itemType;
      if (itemType === "node") {
        parent = addedMap[child.comboId];
      } else {
        parent = addedMap[child.parentId];
      }
      if (parent) {
        if (itemType === "node") child.depth = maxDepth + 1;
        else child.depth = maxDepth + 10;
      } else {
        child.depth = maxDepth + 10;
      }
      if (maxDepth < child.depth) maxDepth = child.depth;
      var oriNodeModel = nodeMap[child.id];
      if (oriNodeModel) {
        oriNodeModel.depth = child.depth;
      }
      return true;
    });
  });
  return result;
};
var reconstructTree = function reconstructTree2(trees, subtreeId, newParentId) {
  var _a2;
  var brothers = trees;
  var subtree;
  var comboChildsMap = {
    root: {
      children: trees
    }
  };
  var foundSubTree = false;
  var oldParentId = "root";
  (trees || []).forEach(function(tree) {
    if (foundSubTree) return;
    if (tree.id === subtreeId) {
      subtree = tree;
      if (tree.itemType === "combo") {
        subtree.parentId = newParentId;
      } else {
        subtree.comboId = newParentId;
      }
      foundSubTree = true;
      return;
    }
    traverseTree(tree, function(child) {
      var _a3;
      comboChildsMap[child.id] = {
        children: (child === null || child === void 0 ? void 0 : child.children) || []
      };
      brothers = (_a3 = comboChildsMap[child.parentId || child.comboId || "root"]) === null || _a3 === void 0 ? void 0 : _a3.children;
      if (child && (child.removed || subtreeId === child.id) && brothers) {
        oldParentId = child.parentId || child.comboId || "root";
        subtree = child;
        if (child.itemType === "combo") {
          subtree.parentId = newParentId;
        } else {
          subtree.comboId = newParentId;
        }
        foundSubTree = true;
        return false;
      }
      return true;
    });
  });
  brothers = (_a2 = comboChildsMap[oldParentId]) === null || _a2 === void 0 ? void 0 : _a2.children;
  var index2 = brothers ? brothers.indexOf(subtree) : -1;
  if (index2 > -1) brothers.splice(index2, 1);
  if (!foundSubTree) {
    subtree = {
      id: subtreeId,
      itemType: "node",
      comboId: newParentId
    };
    comboChildsMap[subtreeId] = {
      children: void 0
    };
  }
  if (subtreeId) {
    var found_1 = false;
    if (newParentId) {
      var newParentDepth_1 = 0;
      (trees || []).forEach(function(tree) {
        if (found_1) return;
        traverseTree(tree, function(child) {
          if (newParentId === child.id) {
            found_1 = true;
            if (child.children) child.children.push(subtree);
            else child.children = [subtree];
            newParentDepth_1 = child.depth;
            if (subtree.itemType === "node") subtree.depth = newParentDepth_1 + 2;
            else subtree.depth = newParentDepth_1 + 1;
            return false;
          }
          return true;
        });
      });
    } else if ((!newParentId || !found_1) && subtree.itemType !== "node") {
      trees.push(subtree);
    }
    var currentDepth_1 = subtree.depth;
    traverseTree(subtree, function(child) {
      if (child.itemType === "node") currentDepth_1 += 2;
      else currentDepth_1 += 1;
      child.depth = currentDepth_1;
      return true;
    });
  }
  return trees;
};
var getComboBBox = function getComboBBox2(children, graph, combo) {
  var comboBBox = {
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity,
    x: void 0,
    y: void 0,
    width: void 0,
    height: void 0,
    centerX: void 0,
    centerY: void 0
  };
  if (!children || children.length === 0) {
    var comboModel = combo === null || combo === void 0 ? void 0 : combo.getModel();
    var _a2 = comboModel || {}, x4 = _a2.x, y4 = _a2.y, fixSize = _a2.fixSize, collapsed = _a2.collapsed, fixCollapseSize = _a2.fixCollapseSize;
    var useFixSize = collapsed ? fixCollapseSize : fixSize;
    var _b = is_array_default(useFixSize) ? useFixSize : [useFixSize, useFixSize], width = _b[0], height = _b[1];
    var halfSize = [width / 2, height / 2];
    return {
      minX: x4 - halfSize[0],
      minY: y4 - halfSize[1],
      maxX: x4 + halfSize[0],
      maxY: y4 + halfSize[1],
      x: x4,
      y: y4,
      width,
      height
    };
  }
  children.forEach(function(child) {
    var childItem = graph.findById(child.id);
    if (!childItem || !childItem.isVisible()) return;
    childItem.set("bboxCanvasCache", void 0);
    var childBBox = childItem.getCanvasBBox();
    if (childBBox.x && comboBBox.minX > childBBox.minX) comboBBox.minX = childBBox.minX;
    if (childBBox.y && comboBBox.minY > childBBox.minY) comboBBox.minY = childBBox.minY;
    if (childBBox.x && comboBBox.maxX < childBBox.maxX) comboBBox.maxX = childBBox.maxX;
    if (childBBox.y && comboBBox.maxY < childBBox.maxY) comboBBox.maxY = childBBox.maxY;
  });
  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;
  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;
  comboBBox.width = comboBBox.maxX - comboBBox.minX;
  comboBBox.height = comboBBox.maxY - comboBBox.minY;
  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;
  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;
  if ((combo === null || combo === void 0 ? void 0 : combo.getKeyShape().get("type")) === "circle") {
    comboBBox.width = Math.hypot(comboBBox.height, comboBBox.width);
    comboBBox.height = comboBBox.width;
  }
  Object.keys(comboBBox).forEach(function(key) {
    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {
      comboBBox[key] = void 0;
    }
  });
  return comboBBox;
};
var shouldRefreshEdge = function shouldRefreshEdge2(cfg) {
  var refreshEdge = is_number_default(cfg.x) || is_number_default(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size;
  if (cfg.style) refreshEdge = refreshEdge || is_number_default(cfg.style.r) || is_number_default(cfg.style.width) || is_number_default(cfg.style.height) || is_number_default(cfg.style.rx) || is_number_default(cfg.style.ry);
  return refreshEdge;
};
var cloneBesidesImg = function cloneBesidesImg2(obj) {
  var clonedObj = {};
  Object.keys(obj).forEach(function(key1) {
    var obj2 = obj[key1];
    if (key1 === "img" && !is_string_default(obj2)) return;
    if (is_object_default(obj2) && !is_array_default(obj2)) {
      var clonedObj2_1 = {};
      Object.keys(obj2).forEach(function(key2) {
        var v2 = obj2[key2];
        if (key2 === "img" && !is_string_default(v2)) return;
        clonedObj2_1[key2] = clone_default(v2);
      });
      clonedObj[key1] = clonedObj2_1;
    } else {
      clonedObj[key1] = clone_default(obj2);
    }
  });
  return clonedObj;
};
var getAnimateCfgWithCallback = function getAnimateCfgWithCallback2(_a2) {
  var animateCfg = _a2.animateCfg, callback = _a2.callback;
  var animateConfig;
  if (!animateCfg) {
    animateConfig = {
      duration: 500,
      callback
    };
  } else {
    animateConfig = clone_default(animateCfg);
    if (animateCfg.callback) {
      var animateCfgCallback_1 = animateCfg.callback;
      animateConfig.callback = function() {
        callback();
        animateCfgCallback_1();
      };
    } else {
      animateConfig.callback = callback;
    }
  }
  return animateConfig;
};

// node_modules/@antv/g6-core/es/util/validation.js
var dataValidation = function dataValidation2(data) {
  if (!data) {
    console.error("G6 Error Tips: the data must be defined");
    return false;
  }
  var nodes = data.nodes, edges = data.edges, _a2 = data.combos, combos = _a2 === void 0 ? [] : _a2;
  if (!nodes && !edges) {
    var validated_1 = true;
    traverseTree(data, function(param) {
      if (!is_string_default(param.id)) {
        validated_1 = false;
        return false;
      }
      return true;
    });
    return validated_1;
  }
  var nonNode = (nodes || []).find(function(node) {
    return !is_string_default(node.id);
  });
  if (nonNode) {
    console.warn("G6 Warning Tips: missing 'id' property, or %c".concat(nonNode.id, "%c is not a string."), "font-size: 20px; color: red;", "");
    return false;
  }
  var nodeIds = (nodes || []).map(function(node) {
    return node.id;
  });
  var comboIds = combos === null || combos === void 0 ? void 0 : combos.map(function(combo) {
    return combo.id;
  });
  var ids = __spreadArray2(__spreadArray2([], nodeIds, true), comboIds, true);
  var nonEdges = (edges || []).find(function(edge) {
    return !ids.includes(edge.source) || !ids.includes(edge.target);
  });
  if (nonEdges) {
    console.warn("G6 Warning Tips: The source %c".concat(nonEdges.source, "%c or the target %c").concat(nonEdges.target, "%c of the edge do not exist in the nodes or combos."), "font-size: 20px; color: red;", "", "font-size: 20px; color: red;", "");
    return false;
  }
  return true;
};
var singleDataValidation = function singleDataValidation2(type, data) {
  if (type === "node" || type === "combo") {
    if (data.id && !is_string_default(data.id)) {
      console.warn("G6 Warning Tips: missing 'id' property, or the 'id' %c".concat(data.id, "%c is not a string."), "font-size: 20px; color: red;", "");
      return false;
    }
  } else if (type === "edge") {
    if (!data.source || !data.target) {
      console.warn("G6 Warning Tips: missing 'source' or 'target' for the edge.");
      return false;
    }
  }
  return true;
};

// node_modules/@antv/g6-core/es/graph/controller/mode.js
init_esm();
var ModeController = (
  /** @class */
  function() {
    function ModeController2(graph) {
      this.graph = graph;
      this.destroyed = false;
      this.modes = graph.get("modes") || {
        default: []
      };
      this.formatModes();
      this.mode = graph.get("defaultMode") || "default";
      this.currentBehaves = [];
      this.setMode(this.mode);
    }
    ModeController2.prototype.formatModes = function() {
      var modes = this.modes;
      each_default(modes, function(mode) {
        each_default(mode, function(behavior, i2) {
          if (is_string_default(behavior)) {
            mode[i2] = {
              type: behavior
            };
          }
        });
      });
    };
    ModeController2.prototype.setBehaviors = function(mode) {
      var graph = this.graph;
      var behaviors2 = this.modes[mode];
      var behaves = [];
      var behave;
      each_default(behaviors2 || [], function(behavior) {
        var BehaviorInstance = behavior_default.getBehavior(behavior.type || behavior);
        if (!BehaviorInstance) {
          return;
        }
        behave = new BehaviorInstance(behavior);
        if (behave) {
          behave.bind(graph);
          behaves.push(behave);
        }
      });
      this.currentBehaves = behaves;
    };
    ModeController2.mergeBehaviors = function(modeBehaviors, behaviors2) {
      each_default(behaviors2, function(behavior) {
        if (modeBehaviors.indexOf(behavior) < 0) {
          if (is_string_default(behavior)) {
            behavior = {
              type: behavior
            };
          }
          modeBehaviors.push(behavior);
        }
      });
      return modeBehaviors;
    };
    ModeController2.filterBehaviors = function(modeBehaviors, behaviors2) {
      var result = [];
      modeBehaviors.forEach(function(behavior) {
        var type = "";
        if (is_string_default(behavior)) {
          type = behavior;
        } else {
          type = behavior.type;
        }
        if (behaviors2.indexOf(type) < 0) {
          result.push(behavior);
        }
      });
      return result;
    };
    ModeController2.prototype.setMode = function(mode) {
      var _a2 = this, modes = _a2.modes, graph = _a2.graph;
      var current = mode;
      var behaviors2 = modes[current];
      if (!behaviors2) {
        return;
      }
      graph.emit("beforemodechange", {
        mode
      });
      each_default(this.currentBehaves, function(behave) {
        if (behave.delegate) behave.delegate.remove();
        behave.unbind(graph);
      });
      this.setBehaviors(current);
      graph.emit("aftermodechange", {
        mode
      });
      this.mode = mode;
    };
    ModeController2.prototype.getMode = function() {
      return this.mode;
    };
    ModeController2.prototype.manipulateBehaviors = function(behaviors2, modes, isAdd) {
      var _this = this;
      var behaves;
      if (!is_array_default(behaviors2)) {
        behaves = [behaviors2];
      } else {
        behaves = behaviors2;
      }
      if (is_array_default(modes)) {
        each_default(modes, function(mode) {
          if (!_this.modes[mode]) {
            if (isAdd) {
              _this.modes[mode] = behaves;
            }
          } else if (isAdd) {
            _this.modes[mode] = ModeController2.mergeBehaviors(_this.modes[mode] || [], behaves);
          } else {
            _this.modes[mode] = ModeController2.filterBehaviors(_this.modes[mode] || [], behaves);
          }
        });
        return this;
      }
      var currentMode = modes;
      if (!modes) {
        currentMode = this.mode;
      }
      if (!this.modes[currentMode]) {
        if (isAdd) {
          this.modes[currentMode] = behaves;
        }
      }
      if (isAdd) {
        this.modes[currentMode] = ModeController2.mergeBehaviors(this.modes[currentMode] || [], behaves);
      } else {
        this.modes[currentMode] = ModeController2.filterBehaviors(this.modes[currentMode] || [], behaves);
      }
      this.formatModes();
      this.setMode(this.mode);
      return this;
    };
    ModeController2.prototype.updateBehavior = function(behavior, newCfg, mode) {
      if (is_string_default(behavior)) {
        behavior = {
          type: behavior
        };
      }
      var behaviorSet = [];
      if (!mode || mode === this.mode || mode === "default") {
        behaviorSet = this.currentBehaves;
        if (!behaviorSet || !behaviorSet.length) {
          console.warn("Update behavior failed! There is no behaviors in this mode on the graph.");
          return this;
        }
        var length_1 = behaviorSet.length;
        for (var i2 = 0; i2 < length_1; i2++) {
          var behave = behaviorSet[i2];
          if (behave.type === behavior.type) {
            behave.updateCfg(newCfg);
            return this;
          }
          if (i2 === length_1 - 1) console.warn("Update behavior failed! There is no such behavior in the mode");
        }
      } else {
        behaviorSet = this.modes[mode];
        if (!behaviorSet || !behaviorSet.length) {
          console.warn("Update behavior failed! There is no behaviors in this mode on the graph.");
          return this;
        }
        var length_2 = behaviorSet.length;
        for (var i2 = 0; i2 < length_2; i2++) {
          var behave = behaviorSet[i2];
          if (behave.type === behavior.type || behave === behavior.type) {
            if (behave === behavior.type) behave = {
              type: behave
            };
            Object.assign(behave, newCfg);
            behaviorSet[i2] = behave;
            return this;
          }
          if (i2 === length_2 - 1) console.warn("Update behavior failed! There is no such behavior in the mode");
        }
      }
      return this;
    };
    ModeController2.prototype.destroy = function() {
      this.graph = null;
      this.modes = null;
      this.currentBehaves = null;
      this.destroyed = true;
    };
    return ModeController2;
  }()
);
var mode_default = ModeController;

// node_modules/@antv/g6-core/es/graph/controller/view.js
init_esm();

// node_modules/@antv/g6-core/es/util/base.js
var base_exports = {};
__export(base_exports, {
  calculationItemsBBox: () => calculationItemsBBox,
  cloneEvent: () => cloneEvent,
  formatPadding: () => formatPadding,
  isNaN: () => isNaN2,
  isViewportChanged: () => isViewportChanged,
  processParallelEdges: () => processParallelEdges,
  uniqueId: () => uniqueId3
});
init_esm();

// node_modules/@antv/g-base/esm/util/path.js
var path_exports = {};
__export(path_exports, {
  catmullRomToBezier: () => catmullRomToBezier,
  fillPath: () => fillPath,
  fillPathByDiff: () => fillPathByDiff,
  formatPath: () => formatPath,
  intersection: () => intersection,
  parsePathArray: () => parsePathArray,
  parsePathString: () => parsePathString,
  pathToAbsolute: () => pathToAbsolute,
  pathToCurve: () => pathToCurve,
  rectPath: () => rectPath
});
init_esm();
var SPACES = "	\n\v\f\r   ᠎             　\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
var parsePathString = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function(a3, b10, c3) {
    var params = [];
    var name = b10.toLowerCase();
    c3.replace(PATH_VALUES, function(a4, b11) {
      b11 && params.push(+b11);
    });
    if (name === "m" && params.length > 2) {
      data.push([b10].concat(params.splice(0, 2)));
      name = "l";
      b10 = b10 === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b10, params[0]]);
    }
    if (name === "r") {
      data.push([b10].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b10].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data;
};
var catmullRomToBezier = function(crp, z2) {
  var d2 = [];
  for (var i2 = 0, iLen = crp.length; iLen - 2 * !z2 > i2; i2 += 2) {
    var p2 = [
      {
        x: +crp[i2 - 2],
        y: +crp[i2 - 1]
      },
      {
        x: +crp[i2],
        y: +crp[i2 + 1]
      },
      {
        x: +crp[i2 + 2],
        y: +crp[i2 + 3]
      },
      {
        x: +crp[i2 + 4],
        y: +crp[i2 + 5]
      }
    ];
    if (z2) {
      if (!i2) {
        p2[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i2) {
        p2[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i2) {
        p2[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p2[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i2) {
        p2[3] = p2[2];
      } else if (!i2) {
        p2[0] = {
          x: +crp[i2],
          y: +crp[i2 + 1]
        };
      }
    }
    d2.push([
      "C",
      (-p2[0].x + 6 * p2[1].x + p2[2].x) / 6,
      (-p2[0].y + 6 * p2[1].y + p2[2].y) / 6,
      (p2[1].x + 6 * p2[2].x - p2[3].x) / 6,
      (p2[1].y + 6 * p2[2].y - p2[3].y) / 6,
      p2[2].x,
      p2[2].y
    ]);
  }
  return d2;
};
var ellipsePath = function(x4, y4, rx, ry, a3) {
  var res = [];
  if (a3 === null && ry === null) {
    ry = rx;
  }
  x4 = +x4;
  y4 = +y4;
  rx = +rx;
  ry = +ry;
  if (a3 !== null) {
    var rad = Math.PI / 180;
    var x1 = x4 + rx * Math.cos(-ry * rad);
    var x22 = x4 + rx * Math.cos(-a3 * rad);
    var y1 = y4 + rx * Math.sin(-ry * rad);
    var y22 = y4 + rx * Math.sin(-a3 * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a3 - ry > 180), 0, x22, y22]
    ];
  } else {
    res = [["M", x4, y4], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute = function(pathArray) {
  pathArray = parsePathString(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x4 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x4 = +pathArray[0][1];
    y4 = +pathArray[0][2];
    mx = x4;
    my = y4;
    start++;
    res[0] = ["M", x4, y4];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r2 = void 0, pa2 = void 0, i2 = start, ii2 = pathArray.length; i2 < ii2; i2++) {
    res.push(r2 = []);
    pa2 = pathArray[i2];
    pa0 = pa2[0];
    if (pa0 !== pa0.toUpperCase()) {
      r2[0] = pa0.toUpperCase();
      switch (r2[0]) {
        case "A":
          r2[1] = pa2[1];
          r2[2] = pa2[2];
          r2[3] = pa2[3];
          r2[4] = pa2[4];
          r2[5] = pa2[5];
          r2[6] = +pa2[6] + x4;
          r2[7] = +pa2[7] + y4;
          break;
        case "V":
          r2[1] = +pa2[1] + y4;
          break;
        case "H":
          r2[1] = +pa2[1] + x4;
          break;
        case "R":
          dots = [x4, y4].concat(pa2.slice(1));
          for (var j2 = 2, jj = dots.length; j2 < jj; j2++) {
            dots[j2] = +dots[j2] + x4;
            dots[++j2] = +dots[j2] + y4;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x4, y4, pa2[1], pa2[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x4, y4, pa2[1], pa2[2], pa2[3]));
          r2 = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa2[1] + x4;
          my = +pa2[2] + y4;
          break;
        default:
          for (var j2 = 1, jj = pa2.length; j2 < jj; j2++) {
            r2[j2] = +pa2[j2] + (j2 % 2 ? x4 : y4);
          }
      }
    } else if (pa0 === "R") {
      dots = [x4, y4].concat(pa2.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r2 = ["R"].concat(pa2.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x4, y4, pa2[1], pa2[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x4, y4, pa2[1], pa2[2], pa2[3]));
      r2 = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k2 = 0, kk = pa2.length; k2 < kk; k2++) {
        r2[k2] = pa2[k2];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r2[0]) {
        case "Z":
          x4 = +mx;
          y4 = +my;
          break;
        case "H":
          x4 = r2[1];
          break;
        case "V":
          y4 = r2[1];
          break;
        case "M":
          mx = r2[r2.length - 2];
          my = r2[r2.length - 1];
          break;
        default:
          x4 = r2[r2.length - 2];
          y4 = r2[r2.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x22, y22) {
  return [x1, y1, x22, y22, x22, y22];
};
var q2c = function(x1, y1, ax, ay, x22, y22) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x22 + _23 * ax, _13 * y22 + _23 * ay, x22, y22];
};
var a2c = function(x1, y1, rx, ry, angle3, large_arc_flag, sweep_flag, x22, y22, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle3 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate9 = function(x5, y5, rad2) {
    var X2 = x5 * Math.cos(rad2) - y5 * Math.sin(rad2);
    var Y2 = x5 * Math.sin(rad2) + y5 * Math.cos(rad2);
    return {
      x: X2,
      y: Y2
    };
  };
  if (!recursive) {
    xy = rotate9(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate9(x22, y22, -rad);
    x22 = xy.x;
    y22 = xy.y;
    if (x1 === x22 && y1 === y22) {
      x22 += 1;
      y22 += 1;
    }
    var x4 = (x1 - x22) / 2;
    var y4 = (y1 - y22) / 2;
    var h2 = x4 * x4 / (rx * rx) + y4 * y4 / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx = h2 * rx;
      ry = h2 * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y4 * y4 - ry2 * x4 * x4) / (rx2 * y4 * y4 + ry2 * x4 * x4)));
    cx = k2 * rx * y4 / ry + (x1 + x22) / 2;
    cy = k2 * -ry * x4 / rx + (y1 + y22) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y22 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x22 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x22;
    var y2old = y22;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x22 = cx + rx * Math.cos(f2);
    y22 = cy + ry * Math.sin(f2);
    res = a2c(x22, y22, rx, ry, angle3, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c22 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t4 = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t4;
  var hy = 4 / 3 * ry * t4;
  var m1 = [x1, y1];
  var m22 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x22 + hx * s2, y22 - hy * c22];
  var m4 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return [m22, m3, m4].concat(res);
  }
  res = [m22, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i2 = 0, ii2 = res.length; i2 < ii2; i2++) {
    newres[i2] = i2 % 2 ? rotate9(res[i2 - 1], res[i2], rad).y : rotate9(res[i2], res[i2 + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function(path, path2) {
  var p2 = pathToAbsolute(path);
  var p22 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii2;
  var processPath = function(path3, d2, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d2.x, d2.y, d2.x, d2.y, d2.x, d2.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d2.qx = d2.qy = null);
    switch (path3[0]) {
      case "M":
        d2.X = path3[1];
        d2.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d2.x, d2.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d2.x * 2 - d2.bx;
          ny = d2.y * 2 - d2.by;
        } else {
          nx = d2.x;
          ny = d2.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d2.qx = d2.x * 2 - d2.qx;
          d2.qy = d2.y * 2 - d2.qy;
        } else {
          d2.qx = d2.x;
          d2.qy = d2.y;
        }
        path3 = ["C"].concat(q2c(d2.x, d2.y, d2.qx, d2.qy, path3[1], path3[2]));
        break;
      case "Q":
        d2.qx = path3[1];
        d2.qy = path3[2];
        path3 = ["C"].concat(q2c(d2.x, d2.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d2.x, d2.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d2.x, d2.y, path3[1], d2.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d2.x, d2.y, d2.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d2.x, d2.y, d2.X, d2.Y));
        break;
      default:
        break;
    }
    return path3;
  };
  var fixArc2 = function(pp, i3) {
    if (pp[i3].length > 7) {
      pp[i3].shift();
      var pi3 = pp[i3];
      while (pi3.length) {
        pcoms1[i3] = "A";
        p22 && (pcoms2[i3] = "A");
        pp.splice(i3++, 0, ["C"].concat(pi3.splice(0, 6)));
      }
      pp.splice(i3, 1);
      ii2 = Math.max(p2.length, p22 && p22.length || 0);
    }
  };
  var fixM = function(path1, path22, a1, a22, i3) {
    if (path1 && path22 && path1[i3][0] === "M" && path22[i3][0] !== "M") {
      path22.splice(i3, 0, ["M", a22.x, a22.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i3][1];
      a1.y = path1[i3][2];
      ii2 = Math.max(p2.length, p22 && p22.length || 0);
    }
  };
  ii2 = Math.max(p2.length, p22 && p22.length || 0);
  for (var i2 = 0; i2 < ii2; i2++) {
    p2[i2] && (pfirst = p2[i2][0]);
    if (pfirst !== "C") {
      pcoms1[i2] = pfirst;
      i2 && (pcom = pcoms1[i2 - 1]);
    }
    p2[i2] = processPath(p2[i2], attrs, pcom);
    if (pcoms1[i2] !== "A" && pfirst === "C")
      pcoms1[i2] = "C";
    fixArc2(p2, i2);
    if (p22) {
      p22[i2] && (pfirst = p22[i2][0]);
      if (pfirst !== "C") {
        pcoms2[i2] = pfirst;
        i2 && (pcom = pcoms2[i2 - 1]);
      }
      p22[i2] = processPath(p22[i2], attrs2, pcom);
      if (pcoms2[i2] !== "A" && pfirst === "C") {
        pcoms2[i2] = "C";
      }
      fixArc2(p22, i2);
    }
    fixM(p2, p22, attrs, attrs2, i2);
    fixM(p22, p2, attrs2, attrs, i2);
    var seg = p2[i2];
    var seg2 = p22 && p22[i2];
    var seglen = seg.length;
    var seg2len = p22 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p22 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p22 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p22 && seg2[seg2len - 2];
    attrs2.y = p22 && seg2[seg2len - 1];
  }
  return p22 ? [p2, p22] : p2;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path) {
  return path.join(",").replace(p2s, "$1");
};
var base3 = function(t4, p1, p2, p3, p4) {
  var t12 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t22 = t4 * t12 + 6 * p1 - 12 * p2 + 6 * p3;
  return t4 * t22 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x22, y22, x32, y32, x4, y4, z2) {
  if (z2 === null) {
    z2 = 1;
  }
  z2 = z2 > 1 ? 1 : z2 < 0 ? 0 : z2;
  var z22 = z2 / 2;
  var n2 = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i2 = 0; i2 < n2; i2++) {
    var ct2 = z22 * Tvalues[i2] + z22;
    var xbase = base3(ct2, x1, x22, x32, x4);
    var ybase = base3(ct2, y1, y22, y32, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i2] * Math.sqrt(comb);
  }
  return z22 * sum;
};
var curveDim = function(x0, y0, x1, y1, x22, y22, x32, y32) {
  var tvalues = [];
  var bounds = [[], []];
  var a3;
  var b10;
  var c3;
  var t4;
  for (var i2 = 0; i2 < 2; ++i2) {
    if (i2 === 0) {
      b10 = 6 * x0 - 12 * x1 + 6 * x22;
      a3 = -3 * x0 + 9 * x1 - 9 * x22 + 3 * x32;
      c3 = 3 * x1 - 3 * x0;
    } else {
      b10 = 6 * y0 - 12 * y1 + 6 * y22;
      a3 = -3 * y0 + 9 * y1 - 9 * y22 + 3 * y32;
      c3 = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a3) < 1e-12) {
      if (Math.abs(b10) < 1e-12) {
        continue;
      }
      t4 = -c3 / b10;
      if (t4 > 0 && t4 < 1) {
        tvalues.push(t4);
      }
      continue;
    }
    var b2ac = b10 * b10 - 4 * c3 * a3;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t12 = (-b10 + sqrtb2ac) / (2 * a3);
    if (t12 > 0 && t12 < 1) {
      tvalues.push(t12);
    }
    var t22 = (-b10 - sqrtb2ac) / (2 * a3);
    if (t22 > 0 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j2 = tvalues.length;
  var jlen = j2;
  var mt2;
  while (j2--) {
    t4 = tvalues[j2];
    mt2 = 1 - t4;
    bounds[0][j2] = mt2 * mt2 * mt2 * x0 + 3 * mt2 * mt2 * t4 * x1 + 3 * mt2 * t4 * t4 * x22 + t4 * t4 * t4 * x32;
    bounds[1][j2] = mt2 * mt2 * mt2 * y0 + 3 * mt2 * mt2 * t4 * y1 + 3 * mt2 * t4 * t4 * y22 + t4 * t4 * t4 * y32;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x32;
  bounds[1][jlen + 1] = y32;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect = function(x1, y1, x22, y22, x32, y32, x4, y4) {
  if (Math.max(x1, x22) < Math.min(x32, x4) || Math.min(x1, x22) > Math.max(x32, x4) || Math.max(y1, y22) < Math.min(y32, y4) || Math.min(y1, y22) > Math.max(y32, y4)) {
    return;
  }
  var nx = (x1 * y22 - y1 * x22) * (x32 - x4) - (x1 - x22) * (x32 * y4 - y32 * x4);
  var ny = (x1 * y22 - y1 * x22) * (y32 - y4) - (y1 - y22) * (x32 * y4 - y32 * x4);
  var denominator = (x1 - x22) * (y32 - y4) - (y1 - y22) * (x32 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x22).toFixed(2) || px2 > +Math.max(x1, x22).toFixed(2) || px2 < +Math.min(x32, x4).toFixed(2) || px2 > +Math.max(x32, x4).toFixed(2) || py2 < +Math.min(y1, y22).toFixed(2) || py2 > +Math.max(y1, y22).toFixed(2) || py2 < +Math.min(y32, y4).toFixed(2) || py2 > +Math.max(y32, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x4, y4) {
  return x4 >= bbox.x && x4 <= bbox.x + bbox.width && y4 >= bbox.y && y4 <= bbox.y + bbox.height;
};
var rectPath = function(x4, y4, w2, h2, r2) {
  if (r2) {
    return [
      ["M", +x4 + +r2, y4],
      ["l", w2 - r2 * 2, 0],
      ["a", r2, r2, 0, 0, 1, r2, r2],
      ["l", 0, h2 - r2 * 2],
      ["a", r2, r2, 0, 0, 1, -r2, r2],
      ["l", r2 * 2 - w2, 0],
      ["a", r2, r2, 0, 0, 1, -r2, -r2],
      ["l", 0, r2 * 2 - h2],
      ["a", r2, r2, 0, 0, 1, r2, -r2],
      ["z"]
    ];
  }
  var res = [["M", x4, y4], ["l", w2, 0], ["l", 0, h2], ["l", -w2, 0], ["z"]];
  res.parsePathArray = parsePathArray;
  return res;
};
var box = function(x4, y4, width, height) {
  if (x4 === null) {
    x4 = y4 = width = height = 0;
  }
  if (y4 === null) {
    y4 = x4.y;
    width = x4.width;
    height = x4.height;
    x4 = x4.x;
  }
  return {
    x: x4,
    y: y4,
    width,
    w: width,
    height,
    h: height,
    x2: x4 + width,
    y2: y4 + height,
    cx: x4 + width / 2,
    cy: y4 + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x4, y4, width, height),
    vb: [x4, y4, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!is_array_default(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t4) {
  var t12 = 1 - t4;
  var t13 = Math.pow(t12, 3);
  var t122 = Math.pow(t12, 2);
  var t22 = t4 * t4;
  var t32 = t22 * t4;
  var x4 = t13 * p1x + t122 * 3 * t4 * c1x + t12 * 3 * t4 * t4 * c2x + t32 * p2x;
  var y4 = t13 * p1y + t122 * 3 * t4 * c1y + t12 * 3 * t4 * t4 * c2y + t32 * p2y;
  var mx = p1x + 2 * t4 * (c1x - p1x) + t22 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t4 * (c1y - p1y) + t22 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t4 * (c2x - c1x) + t22 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t4 * (c2y - c1y) + t22 * (p2y - 2 * c2y + c1y);
  var ax = t12 * p1x + t4 * c1x;
  var ay = t12 * p1y + t4 * c1y;
  var cx = t12 * c2x + t4 * p2x;
  var cy = t12 * c2y + t4 * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x: x4,
    y: y4,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i2 = 0; i2 < n1 + 1; i2++) {
    var d2 = findDotsAtSegment.apply(0, bez1.concat(i2 / n1));
    dots1.push({
      x: d2.x,
      y: d2.y,
      t: i2 / n1
    });
  }
  for (var i2 = 0; i2 < n2 + 1; i2++) {
    var d2 = findDotsAtSegment.apply(0, bez2.concat(i2 / n2));
    dots2.push({
      x: d2.x,
      y: d2.y,
      t: i2 / n2
    });
  }
  for (var i2 = 0; i2 < n1; i2++) {
    for (var j2 = 0; j2 < n2; j2++) {
      var di2 = dots1[i2];
      var di1 = dots1[i2 + 1];
      var dj = dots2[j2];
      var dj1 = dots2[j2 + 1];
      var ci2 = Math.abs(di1.x - di2.x) < 1e-3 ? "y" : "x";
      var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
      var is = intersect(di2.x, di2.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t12 = di2.t + Math.abs((is[ci2] - di2[ci2]) / (di1[ci2] - di2[ci2])) * (di1.t - di2.t);
        var t22 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t12,
              t2: t22
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x22;
  var y22;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i2 = 0, ii2 = path1.length; i2 < ii2; i2++) {
    var pi3 = path1[i2];
    if (pi3[0] === "M") {
      x1 = x1m = pi3[1];
      y1 = y1m = pi3[2];
    } else {
      if (pi3[0] === "C") {
        bez1 = [x1, y1].concat(pi3.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j2 = 0, jj = path2.length; j2 < jj; j2++) {
        var pj = path2[j2];
        if (pj[0] === "M") {
          x22 = x2m = pj[1];
          y22 = y2m = pj[2];
        } else {
          if (pj[0] === "C") {
            bez2 = [x22, y22].concat(pj.slice(1));
            x22 = bez2[6];
            y22 = bez2[7];
          } else {
            bez2 = [x22, y22, x22, y22, x2m, y2m, x2m, y2m];
            x22 = x2m;
            y22 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k2 = 0, kk = intr.length; k2 < kk; k2++) {
              intr[k2].segment1 = i2;
              intr[k2].segment2 = j2;
              intr[k2].bez1 = bez1;
              intr[k2].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points, t4) {
  var left = [];
  var right = [];
  function recurse(points2, t5) {
    if (points2.length === 1) {
      left.push(points2[0]);
      right.push(points2[0]);
    } else {
      var middlePoints = [];
      for (var i2 = 0; i2 < points2.length - 1; i2++) {
        if (i2 === 0) {
          left.push(points2[0]);
        }
        if (i2 === points2.length - 2) {
          right.push(points2[i2 + 1]);
        }
        middlePoints[i2] = [
          (1 - t5) * points2[i2][0] + t5 * points2[i2 + 1][0],
          (1 - t5) * points2[i2][1] + t5 * points2[i2 + 1][1]
        ];
      }
      recurse(middlePoints, t5);
    }
  }
  if (points.length) {
    recurse(points, t4);
  }
  return { left, right: right.reverse() };
}
function splitCurve(start, end2, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];
  if (end2[0] === "A") {
    points.push(end2[6]);
    points.push(end2[7]);
  } else if (end2[0] === "C") {
    points.push([end2[1], end2[2]]);
    points.push([end2[3], end2[4]]);
    points.push([end2[5], end2[6]]);
  } else if (end2[0] === "S" || end2[0] === "Q") {
    points.push([end2[1], end2[2]]);
    points.push([end2[3], end2[4]]);
  } else {
    points.push([end2[1], end2[2]]);
  }
  var leftSegments = points;
  var t4 = 1 / count;
  for (var i2 = 0; i2 < count - 1; i2++) {
    var rt2 = t4 / (1 - t4 * i2);
    var split = decasteljau(leftSegments, rt2);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function(start, end2, count) {
  if (count === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end2[0] === "L" || end2[0] === "C" || end2[0] === "Q") {
    segments = segments.concat(splitCurve(start, end2, count));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i2 = 0; i2 <= count - 1; i2++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i2 = 0; i2 < targetLen - sourceLen; i2++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i2 = 0; i2 < targetLen; i2++) {
    var index2 = Math.floor(ratio * i2);
    segmentsToFill[index2] = (segmentsToFill[index2] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count, i3) {
    if (i3 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i3], source[i3 + 1], count));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === "Z" || target[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual2 = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each_default(obj1, function(item, i2) {
    if (item !== obj2[i2]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add11, modify) {
  var type = null;
  var min6 = modify;
  if (add11 < min6) {
    min6 = add11;
    type = "add";
  }
  if (del < min6) {
    min6 = del;
    type = "del";
  }
  return {
    type,
    min: min6
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist4 = [];
  for (var i2 = 0; i2 <= sourceLen; i2++) {
    dist4[i2] = [];
    dist4[i2][0] = { min: i2 };
  }
  for (var j2 = 0; j2 <= targetLen; j2++) {
    dist4[0][j2] = { min: j2 };
  }
  for (var i2 = 1; i2 <= sourceLen; i2++) {
    sourceSegment = source[i2 - 1];
    for (var j2 = 1; j2 <= targetLen; j2++) {
      targetSegment = target[j2 - 1];
      if (isEqual2(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist4[i2 - 1][j2].min + 1;
      var add11 = dist4[i2][j2 - 1].min + 1;
      var modify = dist4[i2 - 1][j2 - 1].min + temp;
      dist4[i2][j2] = getMinDiff(del, add11, modify);
    }
  }
  return dist4;
};
var fillPathByDiff = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index2 = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i2 = 1; i2 <= sourceLen; i2++) {
      var min6 = diffMatrix[i2][i2].min;
      minPos = i2;
      for (var j2 = index2; j2 <= targetLen; j2++) {
        if (diffMatrix[i2][j2].min < min6) {
          min6 = diffMatrix[i2][j2].min;
          minPos = j2;
        }
      }
      index2 = minPos;
      if (diffMatrix[i2][index2].type) {
        changes.push({ index: i2 - 1, type: diffMatrix[i2][index2].type });
      }
    }
    for (var i2 = changes.length - 1; i2 >= 0; i2--) {
      index2 = changes[i2].index;
      if (changes[i2].type === "add") {
        source.splice(index2, 0, [].concat(source[index2]));
      } else {
        source.splice(index2, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i2 = 0; i2 < diff; i2++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index2;
  var t4 = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i2 = 1; i2 <= count; i2++) {
    t4 *= i2;
    index2 = Math.floor(points.length * t4);
    if (index2 === 0) {
      result.unshift([formerEnd[0] * t4 + points[index2][0] * (1 - t4), formerEnd[1] * t4 + points[index2][1] * (1 - t4)]);
    } else {
      result.splice(index2, 0, [
        formerEnd[0] * t4 + points[index2][0] * (1 - t4),
        formerEnd[1] * t4 + points[index2][1] * (1 - t4)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case "M":
      points.push([segment[1], segment[2]]);
      break;
    case "L":
      points.push([segment[1], segment[2]]);
      break;
    case "A":
      points.push([segment[6], segment[7]]);
      break;
    case "Q":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "T":
      points.push([segment[1], segment[2]]);
      break;
    case "C":
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case "S":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "H":
      points.push([segment[1], segment[1]]);
      break;
    case "V":
      points.push([segment[1], segment[1]]);
      break;
    default:
  }
  return points;
}
var formatPath = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i2 = 0; i2 < toPath.length; i2++) {
    if (fromPath[i2][0] !== toPath[i2][0]) {
      points = _getSegmentPoints(fromPath[i2]);
      switch (toPath[i2][0]) {
        case "M":
          fromPath[i2] = ["M"].concat(points[0]);
          break;
        case "L":
          fromPath[i2] = ["L"].concat(points[0]);
          break;
        case "A":
          fromPath[i2] = [].concat(toPath[i2]);
          fromPath[i2][6] = points[0][0];
          fromPath[i2][7] = points[0][1];
          break;
        case "Q":
          if (points.length < 2) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["Q"].concat(points.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        case "T":
          fromPath[i2] = ["T"].concat(points[0]);
          break;
        case "C":
          if (points.length < 3) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 2);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["C"].concat(points.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        case "S":
          if (points.length < 2) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["S"].concat(points.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        default:
          fromPath[i2] = toPath[i2];
      }
    }
  }
  return fromPath;
};

// node_modules/@antv/g-base/esm/event/graph-event.js
var GraphEvent = (
  /** @class */
  function() {
    function GraphEvent2(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent2.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent2.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent2.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent2.prototype.save = function() {
    };
    GraphEvent2.prototype.restore = function() {
    };
    return GraphEvent2;
  }()
);
var graph_event_default = GraphEvent;

// node_modules/@antv/g-base/esm/abstract/base.js
init_tslib_es6();

// node_modules/@antv/g-base/esm/util/util.js
init_esm();
function removeFromArray(arr, obj) {
  var index2 = arr.indexOf(obj);
  if (index2 !== -1) {
    arr.splice(index2, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}

// node_modules/@antv/g-base/esm/abstract/base.js
var Base = (
  /** @class */
  function(_super) {
    __extends2(Base2, _super);
    function Base2(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg2 = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg2, cfg);
      return _this;
    }
    Base2.prototype.getDefaultCfg = function() {
      return {};
    };
    Base2.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base2.prototype.set = function(name, value) {
      this.cfg[name] = value;
    };
    Base2.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base2;
  }(esm_default)
);
var base_default = Base;

// node_modules/@antv/g-base/esm/abstract/canvas.js
init_tslib_es6();

// node_modules/detect-browser/es/index.js
var __spreadArray3 = function(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
    if (ar2 || !(i2 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
      ar2[i2] = from[i2];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name, version2, os) {
      this.name = name;
      this.version = version2;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name, version2, os, bot) {
      this.name = name;
      this.version = version2;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray3(__spreadArray3([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a2 = operatingSystemRules[ii2], os = _a2[0], regex = _a2[1];
    var match = regex.exec(ua2);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output.push("0");
  }
  return output;
}

// node_modules/@antv/g-base/esm/abstract/container.js
init_tslib_es6();

// node_modules/@antv/g-base/esm/abstract/element.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g-base/esm/util/matrix.js
function multiplyMatrix(a3, b10) {
  var out = [];
  var a00 = a3[0];
  var a01 = a3[1];
  var a02 = a3[2];
  var a10 = a3[3];
  var a11 = a3[4];
  var a12 = a3[5];
  var a20 = a3[6];
  var a21 = a3[7];
  var a22 = a3[8];
  var b00 = b10[0];
  var b01 = b10[1];
  var b02 = b10[2];
  var b102 = b10[3];
  var b11 = b10[4];
  var b12 = b10[5];
  var b20 = b10[6];
  var b21 = b10[7];
  var b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2(m3, v2) {
  var out = [];
  var x4 = v2[0];
  var y4 = v2[1];
  out[0] = m3[0] * x4 + m3[3] * y4 + m3[6];
  out[1] = m3[1] * x4 + m3[4] * y4 + m3[7];
  return out;
}
function invert7(a3) {
  var out = [];
  var a00 = a3[0];
  var a01 = a3[1];
  var a02 = a3[2];
  var a10 = a3[3];
  var a11 = a3[4];
  var a12 = a3[5];
  var a20 = a3[6];
  var a21 = a3[7];
  var a22 = a3[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

// node_modules/@antv/g-base/esm/abstract/element.js
var transform3 = ext_exports.transform;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD2 = "*";
function _cloneArrayAttr(arr) {
  var result = [];
  for (var i2 = 0; i2 < arr.length; i2++) {
    if (is_array_default(arr[i2])) {
      result.push([].concat(arr[i2]));
    } else {
      result.push(arr[i2]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k2 in toAttrs) {
    fromAttrs[k2] = attrs[k2];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each_default(props, function(v2, k2) {
    if (RESERVED_PORPS.indexOf(k2) === -1 && !is_equal_default(attrs[k2], v2)) {
      toAttrs[k2] = v2;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation) {
  if (animation.onFrame) {
    return animations;
  }
  var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
  var hasOwnProperty7 = Object.prototype.hasOwnProperty;
  each_default(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each_default(animation.toAttrs, function(v2, k2) {
        if (hasOwnProperty7.call(item.toAttrs, k2)) {
          delete item.toAttrs[k2];
          delete item.fromAttrs[k2];
        }
      });
    }
  });
  return animations;
}
var Element2 = (
  /** @class */
  function(_super) {
    __extends2(Element3, _super);
    function Element3(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element3.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element3.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element3.prototype.onCanvasChange = function(changeType) {
    };
    Element3.prototype.initAttrs = function(attrs) {
    };
    Element3.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element3.prototype.isGroup = function() {
      return false;
    };
    Element3.prototype.getParent = function() {
      return this.get("parent");
    };
    Element3.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element3.prototype.attr = function() {
      var _a2;
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var name = args[0], value = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k2 in name) {
          this.setAttr(k2, name[k2]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value);
        this.afterAttrsChange((_a2 = {}, _a2[name] = value, _a2));
        return this;
      }
      return this.attrs[name];
    };
    Element3.prototype.isClipped = function(refX, refY) {
      var clip = this.getClip();
      return clip && !clip.isHit(refX, refY);
    };
    Element3.prototype.setAttr = function(name, value) {
      var originValue = this.attrs[name];
      if (originValue !== value) {
        this.attrs[name] = value;
        this.onAttrChange(name, value, originValue);
      }
    };
    Element3.prototype.onAttrChange = function(name, value, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element3.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element3.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element3.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element3.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element3.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index2 = children.indexOf(this);
      children.splice(index2, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element3.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index2 = children.indexOf(this);
      children.splice(index2, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element3.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element3.prototype.resetMatrix = function() {
      this.attr(MATRIX, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element3.prototype.getMatrix = function() {
      return this.attr(MATRIX);
    };
    Element3.prototype.setMatrix = function(m3) {
      this.attr(MATRIX, m3);
      this.onCanvasChange("matrix");
    };
    Element3.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element3.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element3.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element3.prototype.applyToMatrix = function(v2) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec2(matrix, v2);
      }
      return v2;
    };
    Element3.prototype.invertFromMatrix = function(v2) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix3 = invert7(matrix);
        if (invertMatrix3) {
          return multiplyVec2(invertMatrix3, v2);
        }
      }
      return v2;
    };
    Element3.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase3 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase3[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element3.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element3.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i2, k2) {
        if (is_array_default(originAttrs[k2])) {
          attrs[k2] = _cloneArrayAttr(originAttrs[k2]);
        } else {
          attrs[k2] = originAttrs[k2];
        }
      });
      var cons = this.constructor;
      var clone13 = new cons({ attrs });
      each_default(CLONE_CFGS, function(cfgName) {
        clone13.set(cfgName, _this.get(cfgName));
      });
      return clone13;
    };
    Element3.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element3.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element3.prototype.animate = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a2 = args[2], easing = _a2 === void 0 ? "easeLinear" : _a2, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat = animateCfg.repeat || repeat || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs(toAttrs, this);
      var animation = {
        fromAttrs: getFormatFromAttrs(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs(animations, animation);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element3.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation) {
        if (toEnd) {
          if (animation.onFrame) {
            _this.attr(animation.onFrame(1));
          } else {
            _this.attr(animation.toAttrs);
          }
        }
        if (animation.callback) {
          animation.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element3.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation) {
        animation._paused = true;
        animation._pauseTime = pauseTime;
        if (animation.pauseCallback) {
          animation.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element3.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation) {
        animation.startTime = animation.startTime + (current - pauseTime);
        animation._paused = false;
        animation._pauseTime = null;
        if (animation.resumeCallback) {
          animation.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element3.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i3) {
        var element = paths[i3];
        var name_1 = element.get("name");
        if (name_1) {
          if (
            // 只有 element 是 Group 或者 Canvas 的时候，才需要判断 isParent
            (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)
          ) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i2 = 0; i2 < paths.length; i2++) {
        var state_1 = _loop_1(i2);
        if (state_1 === "break")
          break;
      }
    };
    Element3.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT + eventObj.type;
      if (events[eventName] || events[WILDCARD2]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element3.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.move = function(targetX, targetY) {
      var x4 = this.attr("x") || 0;
      var y4 = this.attr("y") || 0;
      this.translate(targetX - x4, targetY - y4);
      return this;
    };
    Element3.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element3.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.rotate = function(radian2) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["r", radian2]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.rotateAtStart = function(rotate9) {
      var _a2 = this.attr(), x4 = _a2.x, y4 = _a2.y;
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [
        ["t", -x4, -y4],
        ["r", rotate9],
        ["t", x4, y4]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.rotateAtPoint = function(x4, y4, rotate9) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [
        ["t", -x4, -y4],
        ["r", rotate9],
        ["t", x4, y4]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element3;
  }(base_default)
);
var element_default = Element2;

// node_modules/@antv/g-base/esm/abstract/container.js
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare3) {
  return function(left, right) {
    var result = compare3(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}
var Container = (
  /** @class */
  function(_super) {
    __extends2(Container2, _super);
    function Container2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container2.prototype.isCanvas = function() {
      return false;
    };
    Container2.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var _a2 = child.getBBox(), childMinX = _a2.minX, childMaxX = _a2.maxX, childMinY = _a2.minY, childMaxY = _a2.maxY;
          if (childMinX < minX) {
            minX = childMinX;
          }
          if (childMaxX > maxX) {
            maxX = childMaxX;
          }
          if (childMinY < minY) {
            minY = childMinY;
          }
          if (childMaxY > maxY) {
            maxY = childMaxY;
          }
        });
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container2.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var _a2 = child.getCanvasBBox(), childMinX = _a2.minX, childMaxX = _a2.maxX, childMinY = _a2.minY, childMaxY = _a2.maxY;
          if (childMinX < minX) {
            minX = childMinX;
          }
          if (childMaxX > maxX) {
            maxX = childMaxX;
          }
          if (childMinY < minY) {
            minY = childMinY;
          }
          if (childMaxY > maxY) {
            maxY = childMaxY;
          }
        });
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container2.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container2.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container2.prototype.addShape = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP[cfg.type] = shapeType;
      }
      var ShapeBase3 = this.getShapeBase();
      var shape = new ShapeBase3[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container2.prototype.addGroup = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var groupClass = args[0], cfg = args[1];
      var group;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group = new groupClass(cfg);
        } else {
          group = new groupClass({
            // canvas,
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group = new TmpGroupClass(tmpCfg);
      }
      this.add(group);
      return group;
    };
    Container2.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container2.prototype.getShape = function(x4, y4, ev) {
      if (!isAllowCapture(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v2 = [x4, y4, 1];
        v2 = this.invertFromMatrix(v2);
        if (!this.isClipped(v2[0], v2[1])) {
          shape = this._findShape(children, v2[0], v2[1], ev);
        }
      } else {
        shape = this._findShape(children, x4, y4, ev);
      }
      return shape;
    };
    Container2.prototype._findShape = function(children, x4, y4, ev) {
      var shape = null;
      for (var i2 = children.length - 1; i2 >= 0; i2--) {
        var child = children[i2];
        if (isAllowCapture(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x4, y4, ev);
          } else if (child.isHit(x4, y4)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container2.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas(element, canvas);
      }
      if (timeline) {
        setTimeline(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container2.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container2.prototype.getChildren = function() {
      return this.get("children") || [];
    };
    Container2.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index2) {
        child[INDEX] = index2;
        return child;
      });
      children.sort(getComparer(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container2.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i2 = children.length - 1; i2 >= 0; i2--) {
        children[i2].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container2.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container2.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container2.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container2.prototype.getChildByIndex = function(index2) {
      var children = this.getChildren();
      return children[index2];
    };
    Container2.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container2.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container2.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container2.prototype.findAll = function(fn2) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn2(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn2));
        }
      });
      return rst;
    };
    Container2.prototype.find = function(fn2) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn2(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn2);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container2.prototype.findById = function(id) {
      return this.find(function(element) {
        return element.get("id") === id;
      });
    };
    Container2.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container2.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container2;
  }(element_default)
);
var container_default = Container;

// node_modules/@antv/g-base/esm/animate/timeline.js
init_esm();
init_src();

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend2(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m3, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format2)) ? (l2 = m3[1].length, m3 = parseInt(m3[1], 16), l2 === 6 ? rgbn(m3) : l2 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l2 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l2 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format2)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format2)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format2)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format2)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format2)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format2)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b10, a3) {
  if (a3 <= 0) r2 = g2 = b10 = NaN;
  return new Rgb(r2, g2, b10, a3);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g2, b10, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b10, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b10, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b10;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend2(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a3 = clampa(this.opacity);
  return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a3) {
  if (a3 <= 0) h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s2 = NaN;
  else if (s2 <= 0) h2 = NaN;
  return new Hsl(h2, s2, l2, a3);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b10 = o2.b / 255, min6 = Math.min(r2, g2, b10), max8 = Math.max(r2, g2, b10), h2 = NaN, s2 = max8 - min6, l2 = (max8 + min6) / 2;
  if (s2) {
    if (r2 === max8) h2 = (g2 - b10) / s2 + (g2 < b10) * 6;
    else if (g2 === max8) h2 = (b10 - r2) / s2 + 2;
    else h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max8 + min6 : 2 - max8 - min6;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend2(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m22;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22),
      hsl2rgb(h2, m1, m22),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m22) {
  return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o2) {
  if (o2 instanceof Lab) return new Lab(o2.l, o2.a, o2.b, o2.opacity);
  if (o2 instanceof Hcl) return hcl2lab(o2);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r2 = rgb2lrgb(o2.r), g2 = rgb2lrgb(o2.g), b10 = rgb2lrgb(o2.b), y4 = xyz2lab((0.2225045 * r2 + 0.7168786 * g2 + 0.0606169 * b10) / Yn), x4, z2;
  if (r2 === g2 && g2 === b10) x4 = z2 = y4;
  else {
    x4 = xyz2lab((0.4360747 * r2 + 0.3850649 * g2 + 0.1430804 * b10) / Xn);
    z2 = xyz2lab((0.0139322 * r2 + 0.0971045 * g2 + 0.7141733 * b10) / Zn);
  }
  return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z2), o2.opacity);
}
function lab(l2, a3, b10, opacity) {
  return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a3, b10, opacity == null ? 1 : opacity);
}
function Lab(l2, a3, b10, opacity) {
  this.l = +l2;
  this.a = +a3;
  this.b = +b10;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend2(Color, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y4 = (this.l + 16) / 116, x4 = isNaN(this.a) ? y4 : y4 + this.a / 500, z2 = isNaN(this.b) ? y4 : y4 - this.b / 200;
    x4 = Xn * lab2xyz(x4);
    y4 = Yn * lab2xyz(y4);
    z2 = Zn * lab2xyz(z2);
    return new Rgb(
      lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z2),
      lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z2),
      lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z2),
      this.opacity
    );
  }
}));
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0;
}
function lab2xyz(t4) {
  return t4 > t1 ? t4 * t4 * t4 : t2 * (t4 - t0);
}
function lrgb2rgb(x4) {
  return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x4) {
  return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);
}
function hclConvert(o2) {
  if (o2 instanceof Hcl) return new Hcl(o2.h, o2.c, o2.l, o2.opacity);
  if (!(o2 instanceof Lab)) o2 = labConvert(o2);
  if (o2.a === 0 && o2.b === 0) return new Hcl(NaN, 0 < o2.l && o2.l < 100 ? 0 : NaN, o2.l, o2.opacity);
  var h2 = Math.atan2(o2.b, o2.a) * degrees;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o2.a * o2.a + o2.b * o2.b), o2.l, o2.opacity);
}
function hcl(h2, c3, l2, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c3, l2, opacity == null ? 1 : opacity);
}
function Hcl(h2, c3, l2, opacity) {
  this.h = +h2;
  this.c = +c3;
  this.l = +l2;
  this.opacity = +opacity;
}
function hcl2lab(o2) {
  if (isNaN(o2.h)) return new Lab(o2.l, 0, 0, o2.opacity);
  var h2 = o2.h * radians;
  return new Lab(o2.l, Math.cos(h2) * o2.c, Math.sin(h2) * o2.c, o2.opacity);
}
define_default(Hcl, hcl, extend2(Color, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o2) {
  if (o2 instanceof Cubehelix) return new Cubehelix(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r2 = o2.r / 255, g2 = o2.g / 255, b10 = o2.b / 255, l2 = (BC_DA * b10 + ED * r2 - EB * g2) / (BC_DA + ED - EB), bl = b10 - l2, k2 = (E * (g2 - l2) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l2 * (1 - l2)), h2 = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l2, o2.opacity);
}
function cubehelix(h2, s2, l2, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend2(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
    return new Rgb(
      255 * (l2 + a3 * (A * cosh2 + B * sinh2)),
      255 * (l2 + a3 * (C * cosh2 + D * sinh2)),
      255 * (l2 + a3 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values3) {
  var n2 = values3.length - 1;
  return function(t4) {
    var i2 = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n2 - 1) : Math.floor(t4 * n2), v1 = values3[i2], v2 = values3[i2 + 1], v0 = i2 > 0 ? values3[i2 - 1] : 2 * v1 - v2, v3 = i2 < n2 - 1 ? values3[i2 + 2] : 2 * v2 - v1;
    return basis((t4 - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values3) {
  var n2 = values3.length;
  return function(t4) {
    var i2 = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n2), v0 = values3[(i2 + n2 - 1) % n2], v1 = values3[i2 % n2], v2 = values3[(i2 + 1) % n2], v3 = values3[(i2 + 2) % n2];
    return basis((t4 - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x4) => () => x4;

// node_modules/d3-interpolate/src/color.js
function linear(a3, d2) {
  return function(t4) {
    return a3 + t4 * d2;
  };
}
function exponential(a3, b10, y4) {
  return a3 = Math.pow(a3, y4), b10 = Math.pow(b10, y4) - a3, y4 = 1 / y4, function(t4) {
    return Math.pow(a3 + t4 * b10, y4);
  };
}
function hue(a3, b10) {
  var d2 = b10 - a3;
  return d2 ? linear(a3, d2 > 180 || d2 < -180 ? d2 - 360 * Math.round(d2 / 360) : d2) : constant_default(isNaN(a3) ? b10 : a3);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a3, b10) {
    return b10 - a3 ? exponential(a3, b10, y4) : constant_default(isNaN(a3) ? b10 : a3);
  };
}
function nogamma(a3, b10) {
  var d2 = b10 - a3;
  return d2 ? linear(a3, d2) : constant_default(isNaN(a3) ? b10 : a3);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color3 = gamma(y4);
  function rgb2(start, end2) {
    var r2 = color3((start = rgb(start)).r, (end2 = rgb(end2)).r), g2 = color3(start.g, end2.g), b10 = color3(start.b, end2.b), opacity = nogamma(start.opacity, end2.opacity);
    return function(t4) {
      start.r = r2(t4);
      start.g = g2(t4);
      start.b = b10(t4);
      start.opacity = opacity(t4);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r2 = new Array(n2), g2 = new Array(n2), b10 = new Array(n2), i2, color3;
    for (i2 = 0; i2 < n2; ++i2) {
      color3 = rgb(colors[i2]);
      r2[i2] = color3.r || 0;
      g2[i2] = color3.g || 0;
      b10[i2] = color3.b || 0;
    }
    r2 = spline(r2);
    g2 = spline(g2);
    b10 = spline(b10);
    color3.opacity = 1;
    return function(t4) {
      color3.r = r2(t4);
      color3.g = g2(t4);
      color3.b = b10(t4);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a3, b10) {
  if (!b10) b10 = [];
  var n2 = a3 ? Math.min(b10.length, a3.length) : 0, c3 = b10.slice(), i2;
  return function(t4) {
    for (i2 = 0; i2 < n2; ++i2) c3[i2] = a3[i2] * (1 - t4) + b10[i2] * t4;
    return c3;
  };
}
function isNumberArray(x4) {
  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default(a3, b10) {
  return (isNumberArray(b10) ? numberArray_default : genericArray)(a3, b10);
}
function genericArray(a3, b10) {
  var nb = b10 ? b10.length : 0, na2 = a3 ? Math.min(nb, a3.length) : 0, x4 = new Array(na2), c3 = new Array(nb), i2;
  for (i2 = 0; i2 < na2; ++i2) x4[i2] = value_default(a3[i2], b10[i2]);
  for (; i2 < nb; ++i2) c3[i2] = b10[i2];
  return function(t4) {
    for (i2 = 0; i2 < na2; ++i2) c3[i2] = x4[i2](t4);
    return c3;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a3, b10) {
  var d2 = /* @__PURE__ */ new Date();
  return a3 = +a3, b10 = +b10, function(t4) {
    return d2.setTime(a3 * (1 - t4) + b10 * t4), d2;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a3, b10) {
  return a3 = +a3, b10 = +b10, function(t4) {
    return a3 * (1 - t4) + b10 * t4;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a3, b10) {
  var i2 = {}, c3 = {}, k2;
  if (a3 === null || typeof a3 !== "object") a3 = {};
  if (b10 === null || typeof b10 !== "object") b10 = {};
  for (k2 in b10) {
    if (k2 in a3) {
      i2[k2] = value_default(a3[k2], b10[k2]);
    } else {
      c3[k2] = b10[k2];
    }
  }
  return function(t4) {
    for (k2 in i2) c3[k2] = i2[k2](t4);
    return c3;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero4(b10) {
  return function() {
    return b10;
  };
}
function one(b10) {
  return function(t4) {
    return b10(t4) + "";
  };
}
function string_default(a3, b10) {
  var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a3 = a3 + "", b10 = b10 + "";
  while ((am = reA.exec(a3)) && (bm = reB.exec(b10))) {
    if ((bs = bm.index) > bi2) {
      bs = b10.slice(bi2, bs);
      if (s2[i2]) s2[i2] += bs;
      else s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2]) s2[i2] += bm;
      else s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: number_default(am, bm) });
    }
    bi2 = reB.lastIndex;
  }
  if (bi2 < b10.length) {
    bs = b10.slice(bi2);
    if (s2[i2]) s2[i2] += bs;
    else s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero4(b10) : (b10 = q2.length, function(t4) {
    for (var i3 = 0, o2; i3 < b10; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t4);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a3, b10) {
  var t4 = typeof b10, c3;
  return b10 == null || t4 === "boolean" ? constant_default(b10) : (t4 === "number" ? number_default : t4 === "string" ? (c3 = color(b10)) ? (b10 = c3, rgb_default) : string_default : b10 instanceof color ? rgb_default : b10 instanceof Date ? date_default : isNumberArray(b10) ? numberArray_default : Array.isArray(b10) ? genericArray : typeof b10.valueOf !== "function" && typeof b10.toString !== "function" || isNaN(b10) ? object_default : number_default)(a3, b10);
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity8 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a3, b10, c3, d2, e8, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b10 * b10)) a3 /= scaleX, b10 /= scaleX;
  if (skewX = a3 * c3 + b10 * d2) c3 -= a3 * skewX, d2 -= b10 * skewX;
  if (scaleY = Math.sqrt(c3 * c3 + d2 * d2)) c3 /= scaleY, d2 /= scaleY, skewX /= scaleY;
  if (a3 * d2 < b10 * c3) a3 = -a3, b10 = -b10, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e8,
    translateY: f2,
    rotate: Math.atan2(b10, a3) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity8 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null) return identity8;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity8;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate7(xa2, ya2, xb, yb, s2, q2) {
    if (xa2 !== xb || ya2 !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i2 - 4, x: number_default(xa2, xb) }, { i: i2 - 2, x: number_default(ya2, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate9(a3, b10, s2, q2) {
    if (a3 !== b10) {
      if (a3 - b10 > 180) b10 += 360;
      else if (b10 - a3 > 180) a3 += 360;
      q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a3, b10) });
    } else if (b10) {
      s2.push(pop(s2) + "rotate(" + b10 + degParen);
    }
  }
  function skewX(a3, b10, s2, q2) {
    if (a3 !== b10) {
      q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a3, b10) });
    } else if (b10) {
      s2.push(pop(s2) + "skewX(" + b10 + degParen);
    }
  }
  function scale12(xa2, ya2, xb, yb, s2, q2) {
    if (xa2 !== xb || ya2 !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q2.push({ i: i2 - 4, x: number_default(xa2, xb) }, { i: i2 - 2, x: number_default(ya2, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b10) {
    var s2 = [], q2 = [];
    a3 = parse2(a3), b10 = parse2(b10);
    translate7(a3.translateX, a3.translateY, b10.translateX, b10.translateY, s2, q2);
    rotate9(a3.rotate, b10.rotate, s2, q2);
    skewX(a3.skewX, b10.skewX, s2, q2);
    scale12(a3.scaleX, a3.scaleY, b10.scaleX, b10.scaleY, s2, q2);
    a3 = b10 = null;
    return function(t4) {
      var i2 = -1, n2 = q2.length, o2;
      while (++i2 < n2) s2[(o2 = q2[i2]).i] = o2.x(t4);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x4) {
  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;
}
function sinh(x4) {
  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;
}
function tanh(x4) {
  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
    if (d2 < epsilon2) {
      S2 = Math.log(w1 / w0) / rho;
      i2 = function(t4) {
        return [
          ux0 + t4 * dx,
          uy0 + t4 * dy,
          w0 * Math.exp(rho * t4 * S2)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S2 = (r1 - r0) / rho;
      i2 = function(t4) {
        var s2 = t4 * S2, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u2 * dx,
          uy0 + u2 * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i2.duration = S2 * 1e3 * rho / Math.SQRT2;
    return i2;
  }
  zoom.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end2) {
    var h2 = hue2((start = hsl(start)).h, (end2 = hsl(end2)).h), s2 = nogamma(start.s, end2.s), l2 = nogamma(start.l, end2.l), opacity = nogamma(start.opacity, end2.opacity);
    return function(t4) {
      start.h = h2(t4);
      start.s = s2(t4);
      start.l = l2(t4);
      start.opacity = opacity(t4);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end2) {
    var h2 = hue2((start = hcl(start)).h, (end2 = hcl(end2)).h), c3 = nogamma(start.c, end2.c), l2 = nogamma(start.l, end2.l), opacity = nogamma(start.opacity, end2.opacity);
    return function(t4) {
      start.h = h2(t4);
      start.c = c3(t4);
      start.l = l2(t4);
      start.opacity = opacity(t4);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start, end2) {
      var h2 = hue2((start = cubehelix(start)).h, (end2 = cubehelix(end2)).h), s2 = nogamma(start.s, end2.s), l2 = nogamma(start.l, end2.l), opacity = nogamma(start.opacity, end2.opacity);
      return function(t4) {
        start.h = h2(t4);
        start.s = s2(t4);
        start.l = l2(Math.pow(t4, y4));
        start.opacity = opacity(t4);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-ease/src/index.js
var src_exports = {};
__export(src_exports, {
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear2,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut
});

// node_modules/d3-ease/src/linear.js
function linear2(t4) {
  return +t4;
}

// node_modules/d3-ease/src/quad.js
function quadIn(t4) {
  return t4 * t4;
}
function quadOut(t4) {
  return t4 * (2 - t4);
}
function quadInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 : --t4 * (2 - t4) + 1) / 2;
}

// node_modules/d3-ease/src/cubic.js
function cubicIn(t4) {
  return t4 * t4 * t4;
}
function cubicOut(t4) {
  return --t4 * t4 * t4 + 1;
}
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e8) {
  e8 = +e8;
  function polyIn2(t4) {
    return Math.pow(t4, e8);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e8) {
  e8 = +e8;
  function polyOut2(t4) {
    return 1 - Math.pow(1 - t4, e8);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e8) {
  e8 = +e8;
  function polyInOut2(t4) {
    return ((t4 *= 2) <= 1 ? Math.pow(t4, e8) : 2 - Math.pow(2 - t4, e8)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;
function sinIn(t4) {
  return +t4 === 1 ? 1 : 1 - Math.cos(t4 * halfPi);
}
function sinOut(t4) {
  return Math.sin(t4 * halfPi);
}
function sinInOut(t4) {
  return (1 - Math.cos(pi * t4)) / 2;
}

// node_modules/d3-ease/src/math.js
function tpmt(x4) {
  return (Math.pow(2, -10 * x4) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/exp.js
function expIn(t4) {
  return tpmt(1 - +t4);
}
function expOut(t4) {
  return 1 - tpmt(t4);
}
function expInOut(t4) {
  return ((t4 *= 2) <= 1 ? tpmt(1 - t4) : 2 - tpmt(t4 - 1)) / 2;
}

// node_modules/d3-ease/src/circle.js
function circleIn(t4) {
  return 1 - Math.sqrt(1 - t4 * t4);
}
function circleOut(t4) {
  return Math.sqrt(1 - --t4 * t4);
}
function circleInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - Math.sqrt(1 - t4 * t4) : Math.sqrt(1 - (t4 -= 2) * t4) + 1) / 2;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t4) {
  return 1 - bounceOut(1 - t4);
}
function bounceOut(t4) {
  return (t4 = +t4) < b1 ? b0 * t4 * t4 : t4 < b3 ? b0 * (t4 -= b2) * t4 + b4 : t4 < b6 ? b0 * (t4 -= b5) * t4 + b7 : b0 * (t4 -= b8) * t4 + b9;
}
function bounceInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - bounceOut(1 - t4) : bounceOut(t4 - 1) + 1) / 2;
}

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s2) {
  s2 = +s2;
  function backIn2(t4) {
    return (t4 = +t4) * t4 * (s2 * (t4 - 1) + t4);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s2) {
  s2 = +s2;
  function backOut2(t4) {
    return --t4 * t4 * ((t4 + 1) * s2 + t4) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s2) {
  s2 = +s2;
  function backInOut2(t4) {
    return ((t4 *= 2) < 1 ? t4 * t4 * ((s2 + 1) * t4 - s2) : (t4 -= 2) * t4 * ((s2 + 1) * t4 + s2) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a3, p2) {
  var s2 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p2 /= tau);
  function elasticIn2(t4) {
    return a3 * tpmt(- --t4) * Math.sin((s2 - t4) / p2);
  }
  elasticIn2.amplitude = function(a4) {
    return custom7(a4, p2 * tau);
  };
  elasticIn2.period = function(p3) {
    return custom7(a3, p3);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a3, p2) {
  var s2 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p2 /= tau);
  function elasticOut2(t4) {
    return 1 - a3 * tpmt(t4 = +t4) * Math.sin((t4 + s2) / p2);
  }
  elasticOut2.amplitude = function(a4) {
    return custom8(a4, p2 * tau);
  };
  elasticOut2.period = function(p3) {
    return custom8(a3, p3);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a3, p2) {
  var s2 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p2 /= tau);
  function elasticInOut2(t4) {
    return ((t4 = t4 * 2 - 1) < 0 ? a3 * tpmt(-t4) * Math.sin((s2 - t4) / p2) : 2 - a3 * tpmt(t4) * Math.sin((s2 + t4) / p2)) / 2;
  }
  elasticInOut2.amplitude = function(a4) {
    return custom9(a4, p2 * tau);
  };
  elasticInOut2.period = function(p3) {
    return custom9(a3, p3);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/@antv/g-base/esm/animate/register.js
var EASING_MAP = {};
function getEasing(type) {
  return EASING_MAP[type.toLowerCase()] || src_exports[type];
}

// node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

// node_modules/@antv/g-base/esm/animate/timeline.js
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation, ratio) {
  var cProps = {};
  var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k2 in toAttrs) {
    if (!is_equal_default(fromAttrs[k2], toAttrs[k2])) {
      if (k2 === "path") {
        var toPath = toAttrs[k2];
        var fromPath = fromAttrs[k2];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString(toAttrs[k2]);
          fromPath = parsePathString(fromAttrs[k2]);
          fromPath = fillPathByDiff(fromPath, toPath);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
        } else if (!animation.pathFormatted) {
          toPath = parsePathString(toAttrs[k2]);
          fromPath = parsePathString(fromAttrs[k2]);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
          animation.pathFormatted = true;
        }
        cProps[k2] = [];
        for (var i2 = 0; i2 < toPath.length; i2++) {
          var toPathPoint = toPath[i2];
          var fromPathPoint = fromPath[i2];
          var cPathPoint = [];
          for (var j2 = 0; j2 < toPathPoint.length; j2++) {
            if (is_number_default(toPathPoint[j2]) && fromPathPoint && is_number_default(fromPathPoint[j2])) {
              interf = value_default(fromPathPoint[j2], toPathPoint[j2]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j2]);
            }
          }
          cProps[k2].push(cPathPoint);
        }
      } else if (k2 === "matrix") {
        var matrixFn = array_default(fromAttrs[k2] || IDENTITY_MATRIX, toAttrs[k2] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k2] = currentMatrix;
      } else if (isColorProp(k2) && isGradientColor(toAttrs[k2])) {
        cProps[k2] = toAttrs[k2];
      } else if (!is_function_default(toAttrs[k2])) {
        interf = value_default(fromAttrs[k2], toAttrs[k2]);
        cProps[k2] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation, elapsed) {
  var startTime = animation.startTime, delay = animation.delay;
  if (elapsed < startTime + delay || animation._paused) {
    return false;
  }
  var ratio;
  var duration = animation.duration;
  var easing = animation.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation.delay;
  if (animation.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation.onFrame) {
        shape.attr(animation.onFrame(1));
      } else {
        shape.attr(animation.toAttrs);
      }
      return true;
    }
  }
  if (animation.onFrame) {
    var attrs = animation.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation, ratio);
  }
  return false;
}
var Timeline = (
  /** @class */
  function() {
    function Timeline2(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline2.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i2 = _this.animators.length - 1; i2 >= 0; i2--) {
            shape = _this.animators[i2];
            if (shape.destroyed) {
              _this.removeAnimator(i2);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j2 = animations.length - 1; j2 >= 0; j2--) {
                animation = animations[j2];
                isFinished = update(shape, animation, elapsed);
                if (isFinished) {
                  animations.splice(j2, 1);
                  isFinished = false;
                  if (animation.callback) {
                    animation.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i2);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline2.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline2.prototype.removeAnimator = function(index2) {
      this.animators.splice(index2, 1);
    };
    Timeline2.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline2.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline2.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline2.prototype.getTime = function() {
      return this.current;
    };
    return Timeline2;
  }()
);
var timeline_default = Timeline;

// node_modules/@antv/g-base/esm/event/event-contoller.js
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController = (
  /** @class */
  function() {
    function EventController4(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController4.prototype.init = function() {
      this._bindEvents();
    };
    EventController4.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController4.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController4.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
      var eventObj = new graph_event_default(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point.x;
      eventObj.y = point.y;
      eventObj.clientX = point.clientX;
      eventObj.clientY = point.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController4.prototype._getShape = function(point, ev) {
      return this.canvas.getShape(point.x, point.y, ev);
    };
    EventController4.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point = canvas.getPointByEvent(ev);
      return {
        x: point.x,
        y: point.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController4.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController4.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController4.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController4.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController4.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController4.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController4.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController4.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now2 = event.timeStamp;
          var timeWindow = now2 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist4 = dx * dx + dy * dy;
          if (timeWindow > 120 || dist4 > CLICK_OFFSET) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController4.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent(canvas, type, eventObj);
      }
    };
    EventController4.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController4;
  }()
);
var event_contoller_default = EventController;

// node_modules/@antv/g-base/esm/abstract/canvas.js
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas = (
  /** @class */
  function(_super) {
    __extends2(Canvas4, _super);
    function Canvas4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas4.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas4.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas4.prototype.initEvents = function() {
      var eventController = new event_contoller_default({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas4.prototype.initTimeline = function() {
      var timeline = new timeline_default(this);
      this.set("timeline", timeline);
    };
    Canvas4.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser) {
        el.style.width = width + PX_SUFFIX;
        el.style.height = height + PX_SUFFIX;
      }
    };
    Canvas4.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas4.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas4.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas4.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas4.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a2 = this.getClientByEvent(ev), clientX = _a2.x, clientY = _a2.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas4.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas4.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas4.prototype.getClientByPoint = function(x4, y4) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x4 + bbox.left,
        y: y4 + bbox.top
      };
    };
    Canvas4.prototype.draw = function() {
    };
    Canvas4.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas4.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas4.prototype.isCanvas = function() {
      return true;
    };
    Canvas4.prototype.getParent = function() {
      return null;
    };
    Canvas4.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas4;
  }(container_default)
);
var canvas_default = Canvas;

// node_modules/@antv/g-base/esm/abstract/group.js
init_tslib_es6();
var AbstractGroup = (
  /** @class */
  function(_super) {
    __extends2(AbstractGroup2, _super);
    function AbstractGroup2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup2.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup2.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup2.prototype.clone = function() {
      var clone13 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i2 = 0; i2 < children.length; i2++) {
        var child = children[i2];
        clone13.add(child.clone());
      }
      return clone13;
    };
    return AbstractGroup2;
  }(container_default)
);
var group_default2 = AbstractGroup;

// node_modules/@antv/g-base/esm/abstract/shape.js
init_tslib_es6();
var AbstractShape = (
  /** @class */
  function(_super) {
    __extends2(AbstractShape2, _super);
    function AbstractShape2(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape2.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape2.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape2.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape2.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a2 = attrs.shadowBlur, shadowBlur = _a2 === void 0 ? 0 : _a2, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY = Math.max(maxY, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    AbstractShape2.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape2.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape2.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape2.prototype.isHit = function(x4, y4) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x4, y4, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape2;
  }(element_default)
);
var shape_default = AbstractShape;

// node_modules/@antv/g-base/esm/bbox/register.js
var cache = /* @__PURE__ */ new Map();
function register(type, method) {
  cache.set(type, method);
}
function getMethod(type) {
  return cache.get(type);
}

// node_modules/@antv/g-base/esm/bbox/rect.js
function rect_default(shape) {
  var attrs = shape.attr();
  var x4 = attrs.x, y4 = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x: x4,
    y: y4,
    width,
    height
  };
}

// node_modules/@antv/g-base/esm/bbox/circle.js
function circle_default(shape) {
  var _a2 = shape.attr(), x4 = _a2.x, y4 = _a2.y, r2 = _a2.r;
  return {
    x: x4 - r2,
    y: y4 - r2,
    width: r2 * 2,
    height: r2 * 2
  };
}

// node_modules/@antv/g-math/esm/util.js
var util_exports = {};
__export(util_exports, {
  distance: () => distance6,
  getBBoxByArray: () => getBBoxByArray,
  getBBoxRange: () => getBBoxRange,
  isNumberEqual: () => isNumberEqual2,
  piMod: () => piMod
});
init_esm();
function distance6(x1, y1, x22, y22) {
  var dx = x1 - x22;
  var dy = y1 - y22;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x22, y22) {
  return {
    minX: min_default([x1, x22]),
    maxX: max_default([x1, x22]),
    minY: min_default([y1, y22]),
    maxY: max_default([y1, y22])
  };
}
function piMod(angle3) {
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}

// node_modules/@antv/g-math/esm/line.js
init_vec2();
var line_default = {
  /**
   * 计算线段的包围盒
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {object} 包围盒对象
   */
  box: function(x1, y1, x22, y22) {
    return getBBoxByArray([x1, x22], [y1, y22]);
  },
  /**
   * 线段的长度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 距离
   */
  length: function(x1, y1, x22, y22) {
    return distance6(x1, y1, x22, y22);
  },
  /**
   * 根据比例获取点
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} t 指定比例
   * @return {object} 包含 x, y 的点
   */
  pointAt: function(x1, y1, x22, y22, t4) {
    return {
      x: (1 - t4) * x1 + t4 * x22,
      y: (1 - t4) * y1 + t4 * y22
    };
  },
  /**
   * 点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointDistance: function(x1, y1, x22, y22, x4, y4) {
    var cross6 = (x22 - x1) * (x4 - x1) + (y22 - y1) * (y4 - y1);
    if (cross6 < 0) {
      return distance6(x1, y1, x4, y4);
    }
    var lengthSquare = (x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1);
    if (cross6 > lengthSquare) {
      return distance6(x22, y22, x4, y4);
    }
    return this.pointToLine(x1, y1, x22, y22, x4, y4);
  },
  /**
   * 点到直线的距离，而不是点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointToLine: function(x1, y1, x22, y22, x4, y4) {
    var d2 = [x22 - x1, y22 - y1];
    if (exactEquals9(d2, [0, 0])) {
      return Math.sqrt((x4 - x1) * (x4 - x1) + (y4 - y1) * (y4 - y1));
    }
    var u2 = [-d2[1], d2[0]];
    normalize5(u2, u2);
    var a3 = [x4 - x1, y4 - y1];
    return Math.abs(dot5(a3, u2));
  },
  /**
   * 线段的角度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 导数
   */
  tangentAngle: function(x1, y1, x22, y22) {
    return Math.atan2(y22 - y1, x22 - x1);
  }
};

// node_modules/@antv/g-math/esm/bezier.js
var EPSILON2 = 1e-4;
function nearestPoint(xArr, yArr, x4, y4, tCallback, length6) {
  var t4;
  var d2 = Infinity;
  var v0 = [x4, y4];
  var segNum = 20;
  if (length6 && length6 > 200) {
    segNum = length6 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i2 = 0; i2 <= segNum; i2++) {
    var _t2 = i2 * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t2])), tCallback.apply(null, yArr.concat([_t2]))];
    var d1 = distance6(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d2) {
      t4 = _t2;
      d2 = d1;
    }
  }
  if (t4 === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t4 === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d2 = Infinity;
  for (var i2 = 0; i2 < 32; i2++) {
    if (interval2 < EPSILON2) {
      break;
    }
    var prev = t4 - interval2;
    var next = t4 + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance6(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d2) {
      t4 = prev;
      d2 = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d22 = distance6(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d2) {
        t4 = next;
        d2 = d22;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t4])),
    y: tCallback.apply(null, yArr.concat([t4]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i2 = 0; i2 < count; i2++) {
    var x4 = xArr[i2];
    var y4 = yArr[i2];
    var nextX = xArr[(i2 + 1) % count];
    var nextY = yArr[(i2 + 1) % count];
    totalLength += distance6(x4, y4, nextX, nextY);
  }
  return totalLength / 2;
}

// node_modules/@antv/g-math/esm/quadratic.js
function quadraticAt(p0, p1, p2, t4) {
  var onet = 1 - t4;
  return onet * onet * p0 + 2 * t4 * onet * p1 + t4 * t4 * p2;
}
function extrema(p0, p1, p2) {
  var a3 = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a3, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a3;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t4) {
  return 2 * (1 - t4) * (p1 - p0) + 2 * t4 * (p2 - p1);
}
function divideQuadratic(x1, y1, x22, y22, x32, y32, t4) {
  var xt2 = quadraticAt(x1, x22, x32, t4);
  var yt2 = quadraticAt(y1, y22, y32, t4);
  var controlPoint1 = line_default.pointAt(x1, y1, x22, y22, t4);
  var controlPoint2 = line_default.pointAt(x22, y22, x32, y32, t4);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt2, yt2],
    [xt2, yt2, controlPoint2.x, controlPoint2.y, x32, y32]
  ];
}
function quadraticLength(x1, y1, x22, y22, x32, y32, iterationCount) {
  if (iterationCount === 0) {
    return (distance6(x1, y1, x22, y22) + distance6(x22, y22, x32, y32) + distance6(x1, y1, x32, y32)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x22, y22, x32, y32, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
}
var quadratic_default = {
  box: function(x1, y1, x22, y22, x32, y32) {
    var xExtrema2 = extrema(x1, x22, x32)[0];
    var yExtrema2 = extrema(y1, y22, y32)[0];
    var xArr = [x1, x32];
    var yArr = [y1, y32];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x22, x32, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y22, y32, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x22, y22, x32, y32) {
    return quadraticLength(x1, y1, x22, y22, x32, y32, 3);
  },
  nearestPoint: function(x1, y1, x22, y22, x32, y32, x0, y0) {
    return nearestPoint([x1, x22, x32], [y1, y22, y32], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x22, y22, x32, y32, x0, y0) {
    var point = this.nearestPoint(x1, y1, x22, y22, x32, y32, x0, y0);
    return distance6(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x22, y22, x32, y32, t4) {
    return {
      x: quadraticAt(x1, x22, x32, t4),
      y: quadraticAt(y1, y22, y32, t4)
    };
  },
  divide: function(x1, y1, x22, y22, x32, y32, t4) {
    return divideQuadratic(x1, y1, x22, y22, x32, y32, t4);
  },
  tangentAngle: function(x1, y1, x22, y22, x32, y32, t4) {
    var dx = derivativeAt(x1, x22, x32, t4);
    var dy = derivativeAt(y1, y22, y32, t4);
    var angle3 = Math.atan2(dy, dx);
    return piMod(angle3);
  }
};

// node_modules/@antv/g-math/esm/cubic.js
function cubicAt(p0, p1, p2, p3, t4) {
  var onet = 1 - t4;
  return onet * onet * onet * p0 + 3 * p1 * t4 * onet * onet + 3 * p2 * t4 * t4 * onet + p3 * t4 * t4 * t4;
}
function derivativeAt2(p0, p1, p2, p3, t4) {
  var onet = 1 - t4;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t4 * (p2 - p1) + t4 * t4 * (p3 - p2));
}
function extrema2(p0, p1, p2, p3) {
  var a3 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b10 = 6 * p0 - 12 * p1 + 6 * p2;
  var c3 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual2(a3, 0)) {
    if (!isNumberEqual2(b10, 0)) {
      t12 = -c3 / b10;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b10 * b10 - 4 * a3 * c3;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b10 / (2 * a3));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b10 + discSqrt) / (2 * a3);
      t22 = (-b10 - discSqrt) / (2 * a3);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x22, y22, x32, y32, x4, y4, t4) {
  var xt2 = cubicAt(x1, x22, x32, x4, t4);
  var yt2 = cubicAt(y1, y22, y32, y4, t4);
  var c1 = line_default.pointAt(x1, y1, x22, y22, t4);
  var c22 = line_default.pointAt(x22, y22, x32, y32, t4);
  var c3 = line_default.pointAt(x32, y32, x4, y4, t4);
  var c12 = line_default.pointAt(c1.x, c1.y, c22.x, c22.y, t4);
  var c23 = line_default.pointAt(c22.x, c22.y, c3.x, c3.y, t4);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt2, yt2],
    [xt2, yt2, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x22, y22, x32, y32, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x22, x32, x4], [y1, y22, y32, y4]);
  }
  var cubics = divideCubic(x1, y1, x22, y22, x32, y32, x4, y4, 0.5);
  var left = cubics[0];
  var right = cubics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return cubicLength.apply(null, left) + cubicLength.apply(null, right);
}
var cubic_default = {
  extrema: extrema2,
  box: function(x1, y1, x22, y22, x32, y32, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema2(x1, x22, x32, x4);
    var yExtrema2 = extrema2(y1, y22, y32, y4);
    for (var i2 = 0; i2 < xExtrema2.length; i2++) {
      xArr.push(cubicAt(x1, x22, x32, x4, xExtrema2[i2]));
    }
    for (var i2 = 0; i2 < yExtrema2.length; i2++) {
      yArr.push(cubicAt(y1, y22, y32, y4, yExtrema2[i2]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x22, y22, x32, y32, x4, y4) {
    return cubicLength(x1, y1, x22, y22, x32, y32, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x22, y22, x32, y32, x4, y4, x0, y0, length6) {
    return nearestPoint([x1, x22, x32, x4], [y1, y22, y32, y4], x0, y0, cubicAt, length6);
  },
  pointDistance: function(x1, y1, x22, y22, x32, y32, x4, y4, x0, y0, length6) {
    var point = this.nearestPoint(x1, y1, x22, y22, x32, y32, x4, y4, x0, y0, length6);
    return distance6(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x22, y22, x32, y32, x4, y4, t4) {
    return {
      x: cubicAt(x1, x22, x32, x4, t4),
      y: cubicAt(y1, y22, y32, y4, t4)
    };
  },
  divide: function(x1, y1, x22, y22, x32, y32, x4, y4, t4) {
    return divideCubic(x1, y1, x22, y22, x32, y32, x4, y4, t4);
  },
  tangentAngle: function(x1, y1, x22, y22, x32, y32, x4, y4, t4) {
    var dx = derivativeAt2(x1, x22, x32, x4, t4);
    var dy = derivativeAt2(y1, y22, y32, y4, t4);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/ellipse.js
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse_default = {
  /**
   * 包围盒计算
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {object} 包围盒
   */
  box: function(x4, y4, rx, ry) {
    return {
      x: x4 - rx,
      y: y4 - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  /**
   * 计算周长，使用近似法
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {number} 椭圆周长
   */
  length: function(x4, y4, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  /**
   * 距离椭圆最近的点
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {object} 椭圆上距离指定点最近的点
   */
  nearestPoint: function(x4, y4, rx, ry, x0, y0) {
    var a3 = rx;
    var b10 = ry;
    if (a3 === 0 || b10 === 0) {
      return {
        x: x4,
        y: y4
      };
    }
    var relativeX = x0 - x4;
    var relativeY = y0 - y4;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a3 * a3;
    var squareB = b10 * b10;
    var t4 = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i2 = 0; i2 < 4; i2++) {
      nearestX = a3 * Math.cos(t4);
      nearestY = b10 * Math.sin(t4);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t4), 3) / a3;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t4), 3) / b10;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r2 = Math.hypot(ry1, rx1);
      var q2 = Math.hypot(qy, qx);
      var delta_c = r2 * Math.asin((rx1 * qy - ry1 * qx) / (r2 * q2));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t4 += delta_t;
      t4 = Math.min(Math.PI / 2, Math.max(0, t4));
    }
    return {
      x: x4 + copysign(nearestX, relativeX),
      y: y4 + copysign(nearestY, relativeY)
    };
  },
  /**
   * 点到椭圆最近的距离
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {number} 点到椭圆的距离
   */
  pointDistance: function(x4, y4, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x4, y4, rx, ry, x0, y0);
    return distance6(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  /**
   * 根据比例获取点
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例，x轴方向为 0
   * @return {object} 点
   */
  pointAt: function(x4, y4, rx, ry, t4) {
    var angle3 = 2 * Math.PI * t4;
    return {
      x: x4 + rx * Math.cos(angle3),
      y: y4 + ry * Math.sin(angle3)
    };
  },
  /**
   * 根据比例计算切线角度
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整
   * @return {number} 角度，在 0 - 2PI 之间
   */
  tangentAngle: function(x4, y4, rx, ry, t4) {
    var angle3 = 2 * Math.PI * t4;
    var tangentAngle = Math.atan2(ry * Math.cos(angle3), -rx * Math.sin(angle3));
    return piMod(tangentAngle);
  }
};

// node_modules/@antv/g-math/esm/arc.js
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle3) - ry * Math.sin(xRotation) * Math.cos(angle3);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle3) + ry * Math.cos(xRotation) * Math.cos(angle3);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
}
function getAngle2(rx, ry, x0, y0) {
  var angle3 = Math.atan2(y0 * rx, x0 * ry);
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle3) {
  return {
    x: rx * Math.cos(angle3),
    y: ry * Math.sin(angle3)
  };
}
function rotate8(x4, y4, angle3) {
  var cos3 = Math.cos(angle3);
  var sin3 = Math.sin(angle3);
  return [x4 * cos3 - y4 * sin3, x4 * sin3 + y4 * cos3];
}
var arc_default = {
  /**
   * 计算包围盒
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @return {object} 包围盒对象
   */
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var xAngle = xDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i2 = 0; i2 < xs.length; i2++) {
      var x4 = xAt(cx, cy, rx, ry, xRotation, xs[i2]);
      if (x4 < minX) {
        minX = x4;
      }
      if (x4 > maxX) {
        maxX = x4;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var yAngle = yDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i2 = 0; i2 < ys.length; i2++) {
      var y4 = yAt(cx, cy, rx, ry, xRotation, ys[i2]);
      if (y4 < minY) {
        minY = y4;
      }
      if (y4 > maxY) {
        maxY = y4;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  /**
   * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，
   * 仅跟 rx, ry, startAngle, endAngle 相关
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   */
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  /**
   * 获取指定点到圆弧的最近距离的点
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @param {number} x0         指定点的 x
   * @param {number} y0         指定点的 y
   * @return {object} 到指定点最近距离的点
   */
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate8(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle3 = getAngle2(rx, ry, relativePoint.x, relativePoint.y);
    if (angle3 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle3 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate8(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance6(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t4) {
    var angle3 = (endAngle - startAngle) * t4 + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle3),
      y: yAt(cx, cy, rx, ry, xRotation, angle3)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t4) {
    var angle3 = (endAngle - startAngle) * t4 + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/segments.js
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to2 = points[i2 + 1];
    var length_1 = distance6(from[0], from[1], to2[0], to2[1]);
    var seg = {
      from,
      to: to2,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to2 = points[i2 + 1];
    totalLength += distance6(from[0], from[1], to2[0], to2[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t4) {
  if (t4 > 1 || t4 < 0 || points.length < 2) {
    return null;
  }
  var _a2 = analyzePoints(points), segments = _a2.segments, totalLength = _a2.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point = null;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to2 = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t4 >= startRatio && t4 <= startRatio + currentRatio) {
      var localRatio = (t4 - startRatio) / currentRatio;
      point = line_default.pointAt(from[0], from[1], to2[0], to2[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point;
}
function angleAtSegments(points, t4) {
  if (t4 > 1 || t4 < 0 || points.length < 2) {
    return 0;
  }
  var _a2 = analyzePoints(points), segments = _a2.segments, totalLength = _a2.totalLength;
  var startRatio = 0;
  var angle3 = 0;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to2 = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t4 >= startRatio && t4 <= startRatio + currentRatio) {
      angle3 = Math.atan2(to2[1] - from[1], to2[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle3;
}
function distanceAtSegment(points, x4, y4) {
  var minDistance = Infinity;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var point = points[i2];
    var nextPoint = points[i2 + 1];
    var distance_1 = line_default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x4, y4);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}

// node_modules/@antv/g-math/esm/polyline.js
var polyline_default = {
  /**
   * 计算多折线的包围盒
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 包围盒
   */
  box: function(points) {
    var xArr = [];
    var yArr = [];
    for (var i2 = 0; i2 < points.length; i2++) {
      var point = points[i2];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  /**
   * 计算多折线的长度
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 多条边的长度
   */
  length: function(points) {
    return lengthOfSegment(points);
  },
  /**
   * 根据比例获取多折线的点
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的点
   */
  pointAt: function(points, t4) {
    return pointAtSegments(points, t4);
  },
  /**
   * 指定点到多折线的距离
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} x 指定点的 x
   * @param {number} y 指定点的 y
   * @return {number} 点到多折线的距离
   */
  pointDistance: function(points, x4, y4) {
    return distanceAtSegment(points, x4, y4);
  },
  /**
   * 根据比例获取多折线的切线角度
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的角度
   */
  tangentAngle: function(points, t4) {
    return angleAtSegments(points, t4);
  }
};

// node_modules/@antv/g-base/esm/bbox/util.js
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}

// node_modules/@antv/g-base/esm/bbox/polyline.js
function polyline_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point = points[i2];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  var _a2 = util_exports.getBBoxByArray(xArr, yArr), x4 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x4,
    minY: y4,
    maxX: x4 + width,
    maxY: y4 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/polygon.js
function polygon_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point = points[i2];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  return util_exports.getBBoxByArray(xArr, yArr);
}

// node_modules/@antv/g-base/esm/util/offscreen.js
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}

// node_modules/@antv/g-base/esm/util/text.js
function getTextHeight(text, fontSize, lineHeight) {
  var lineCount = 1;
  if (is_string_default(text)) {
    lineCount = text.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text, font) {
  var context = getOffScreenContext();
  var width = 0;
  if (is_nil_default(text) || text === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (is_string_default(text) && text.includes("\n")) {
    var textArr = text.split("\n");
    each_default(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}

// node_modules/@antv/g-base/esm/bbox/text.js
function text_default(shape) {
  var attrs = shape.attr();
  var x4 = attrs.x, y4 = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text, font);
  var bbox;
  if (!width) {
    bbox = {
      x: x4,
      y: y4,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text, fontSize, lineHeight);
    var point = {
      x: x4,
      y: y4 - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point.x -= width;
      } else if (textAlign === "center") {
        point.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point.y += height;
      } else if (textBaseline === "middle") {
        point.y += height / 2;
      }
    }
    bbox = {
      x: point.x,
      y: point.y,
      width,
      height
    };
  }
  return bbox;
}

// node_modules/@antv/path-util/esm/parse-path.js
init_esm();
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p2) {
  var path = p2 || [];
  if (is_array_default(path)) {
    return path;
  }
  if (is_string_default(path)) {
    path = path.match(regexTags);
    each_default(path, function(item, index2) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each_default(item, function(sub8, i2) {
        if (!isNaN(sub8)) {
          item[i2] = +sub8;
        }
      });
      path[index2] = item;
    });
    return path;
  }
}
var parse_path_default = parsePath;

// node_modules/@antv/path-util/node_modules/@antv/matrix-util/esm/index.js
init_esm2();

// node_modules/@antv/path-util/node_modules/@antv/matrix-util/esm/ext.js
init_esm2();

// node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min6;
  var max8;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min6 = constraint[0], max8 = constraint[1];
    for (var i2 = 0, l2 = points.length; i2 < l2; i2 += 1) {
      var point = points[i2];
      min6 = vec2_exports.min([0, 0], min6, point);
      max8 = vec2_exports.max([0, 0], max8, point);
    }
  }
  for (var i2 = 0, len6 = points.length; i2 < len6; i2 += 1) {
    var point = points[i2];
    if (i2 === 0 && !isLoop) {
      cp0 = point;
    } else if (i2 === len6 - 1 && !isLoop) {
      cp1 = point;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i2 ? i2 - 1 : len6 - 1, i2 - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i2 + 1) % len6 : i2 + 1];
      var v2 = [0, 0];
      v2 = vec2_exports.sub(v2, nextPoint, prevPoint);
      v2 = vec2_exports.scale(v2, v2, smooth);
      var d0 = vec2_exports.distance(point, prevPoint);
      var d1 = vec2_exports.distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = vec2_exports.scale([0, 0], v2, -d0);
      var v22 = vec2_exports.scale([0, 0], v2, d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      nextCp0 = vec2_exports.add([0, 0], point, v22);
      nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
      nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
      v1 = vec2_exports.sub([0, 0], nextCp0, point);
      v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
      cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
      v22 = vec2_exports.sub([0, 0], point, cp1);
      v22 = vec2_exports.scale([0, 0], v22, d1 / d0);
      nextCp0 = vec2_exports.add([0, 0], point, v22);
      if (hasConstraint) {
        cp1 = vec2_exports.max([0, 0], cp1, min6);
        cp1 = vec2_exports.min([0, 0], cp1, max8);
        nextCp0 = vec2_exports.max([0, 0], nextCp0, min6);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, max8);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z2, constraint) {
  if (z2 === void 0) {
    z2 = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z2;
  var pointList = [];
  for (var i2 = 0, l2 = crp.length; i2 < l2; i2 += 2) {
    pointList.push([crp[i2], crp[i2 + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len6 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i2 = 0; i2 < len6 - 1; i2 += 1) {
    cp1 = controlPointList[i2 * 2];
    cp2 = controlPointList[i2 * 2 + 1];
    p2 = pointList[i2 + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len6];
    cp2 = controlPointList[len6 + 1];
    p2 = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}
var catmull_rom_2_bezier_default = catmullRom2Bezier;

// node_modules/@antv/path-util/esm/fill-path-by-diff.js
init_esm();

// node_modules/@antv/path-util/esm/path-intersection.js
init_esm();

// node_modules/@antv/path-util/esm/parse-path-string.js
init_esm();
var SPACES2 = "	\n\v\f\r   ᠎             　\u2028\u2029";
var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");
function parsePathString2(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND2, function(a3, b10, c3) {
    var params = [];
    var name = b10.toLowerCase();
    c3.replace(PATH_VALUES2, function(a4, b11) {
      b11 && params.push(+b11);
    });
    if (name === "m" && params.length > 2) {
      data.push([b10].concat(params.splice(0, 2)));
      name = "l";
      b10 = b10 === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b10, params[0]]);
    }
    if (name === "r") {
      data.push([b10].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b10].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data;
}

// node_modules/@antv/path-util/esm/path-2-absolute.js
var REGEX_MD = /[a-z]/;
function toSymmetry(p2, c3) {
  return [
    c3[0] + (c3[0] - p2[0]),
    c3[1] + (c3[1] - p2[1])
  ];
}
function pathToAbsolute2(pathString) {
  var pathArray = parsePathString2(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i2 = 0; i2 < pathArray.length; i2++) {
    var cmd = pathArray[i2][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x4 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x4 = +first[1];
    y4 = +first[2];
    mx = x4;
    my = y4;
    start++;
    res[0] = ["M", x4, y4];
  }
  for (var i2 = start, ii2 = pathArray.length; i2 < ii2; i2++) {
    var pa2 = pathArray[i2];
    var preParams = res[i2 - 1];
    var r2 = [];
    var cmd = pa2[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r2[0] = upCmd;
      switch (upCmd) {
        case "A":
          r2[1] = pa2[1];
          r2[2] = pa2[2];
          r2[3] = pa2[3];
          r2[4] = pa2[4];
          r2[5] = pa2[5];
          r2[6] = +pa2[6] + x4;
          r2[7] = +pa2[7] + y4;
          break;
        case "V":
          r2[1] = +pa2[1] + y4;
          break;
        case "H":
          r2[1] = +pa2[1] + x4;
          break;
        case "M":
          mx = +pa2[1] + x4;
          my = +pa2[2] + y4;
          r2[1] = mx;
          r2[2] = my;
          break;
        default:
          for (var j2 = 1, jj = pa2.length; j2 < jj; j2++) {
            r2[j2] = +pa2[j2] + (j2 % 2 ? x4 : y4);
          }
      }
    } else {
      r2 = pathArray[i2];
    }
    switch (upCmd) {
      case "Z":
        x4 = +mx;
        y4 = +my;
        break;
      case "H":
        x4 = r2[1];
        r2 = ["L", x4, y4];
        break;
      case "V":
        y4 = r2[1];
        r2 = ["L", x4, y4];
        break;
      case "T":
        x4 = r2[1];
        y4 = r2[2];
        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r2 = ["Q", symetricT[0], symetricT[1], x4, y4];
        break;
      case "S":
        x4 = r2[r2.length - 2];
        y4 = r2[r2.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r2 = ["C", symetricS[0], symetricS[1], r2[1], r2[2], x4, y4];
        break;
      case "M":
        mx = r2[r2.length - 2];
        my = r2[r2.length - 1];
        break;
      default:
        x4 = r2[r2.length - 2];
        y4 = r2[r2.length - 1];
    }
    res.push(r2);
  }
  return res;
}

// node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;

// node_modules/@antv/path-util/esm/get-arc-params.js
init_esm();
function vMag(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio(u2, v2) {
  return vMag(u2) * vMag(v2) ? (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2)) : 1;
}
function vAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x22 = params[6];
  var y22 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x22) / 2 + Math.sin(xRotation) * (y1 - y22) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x22) / 2 + Math.cos(xRotation) * (y1 - y22) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x1 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u2);
  var dTheta = vAngle(u2, v2);
  if (vRatio(u2, v2) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry2(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
function getSegments(path) {
  path = parse_path_default(path);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    nextParams = path[i2 + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i2;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len6 = params.length;
      currentPoint = [params[len6 - 2], params[len6 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i2 - 1];
      var cp = toSymmetry2(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i2 - 1];
      var cp1 = toSymmetry2(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d2 = 1e-3;
      var _a2 = segment["arcParams"] || {}, _b = _a2.cx, cx = _b === void 0 ? 0 : _b, _c = _a2.cy, cy = _c === void 0 ? 0 : _c, _d = _a2.rx, rx = _d === void 0 ? 0 : _d, _e2 = _a2.ry, ry = _e2 === void 0 ? 0 : _e2, _f = _a2.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a2.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a2.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d2 *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d2) + cx;
      var dy1 = ry * Math.sin(startAngle - d2) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d2) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d2) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}

// node_modules/@antv/path-util/esm/is-polygons-intersect.js
init_esm();

// node_modules/@antv/g-base/esm/bbox/path.js
init_esm();
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var i2 = 0; i2 < segmentsWithAngle.length; i2++) {
    var segment = segmentsWithAngle[i2];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 水平方向投影
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 垂直方向投影
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path_default(shape) {
  var attrs = shape.attr();
  var path = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path);
  var _a2 = getPathBox(segments, lineWidth), x4 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x4,
    minY: y4,
    maxX: x4 + width,
    maxY: y4 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/line.js
function line_default2(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x22 = attrs.x2, y22 = attrs.y2;
  var minX = Math.min(x1, x22);
  var maxX = Math.max(x1, x22);
  var minY = Math.min(y1, y22);
  var maxY = Math.max(y1, y22);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/ellipse.js
function ellipse_default2(shape) {
  var attrs = shape.attr();
  var x4 = attrs.x, y4 = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x4 - rx,
    y: y4 - ry,
    width: rx * 2,
    height: ry * 2
  };
}

// node_modules/@antv/g-base/esm/bbox/index.js
register("rect", rect_default);
register("image", rect_default);
register("circle", circle_default);
register("marker", circle_default);
register("polyline", polyline_default2);
register("polygon", polygon_default2);
register("text", text_default);
register("path", path_default);
register("line", line_default2);
register("ellipse", ellipse_default2);

// node_modules/@antv/g6-core/es/interface/behavior.js
var G6GraphEvent = (
  /** @class */
  function(_super) {
    __extends3(G6GraphEvent2, _super);
    function G6GraphEvent2(type, event) {
      var _this = _super.call(this, type, event) || this;
      _this.item = event.item;
      _this.canvasX = event.canvasX;
      _this.canvasY = event.canvasY;
      _this.wheelDelta = event.wheelDelta;
      _this.detail = event.detail;
      return _this;
    }
    return G6GraphEvent2;
  }(graph_event_default)
);

// node_modules/@antv/g6-core/es/util/base.js
var uniqueId3 = function uniqueId4(type) {
  return "".concat(type, "-").concat(Math.random()).concat(Date.now());
};
var formatPadding = function formatPadding2(padding) {
  if (is_array_default(padding)) {
    switch (padding.length) {
      case 4:
        return padding;
      case 3:
        padding.push(padding[1]);
        return padding;
      case 2:
        return padding.concat(padding);
      case 1:
        return [padding[0], padding[0], padding[0], padding[0]];
      default:
        return [0, 0, 0, 0];
    }
  }
  if (is_number_default(padding)) {
    return [padding, padding, padding, padding];
  } else if (is_string_default(padding)) {
    var intPadding = parseInt(padding, 10);
    return [intPadding, intPadding, intPadding, intPadding];
  }
  return [0, 0, 0, 0];
};
var cloneEvent = function cloneEvent2(e8) {
  var event = new G6GraphEvent(e8.type, e8);
  event.clientX = e8.clientX;
  event.clientY = e8.clientY;
  event.x = e8.x;
  event.y = e8.y;
  event.target = e8.target;
  event.currentTarget = e8.currentTarget;
  event.bubbles = true;
  event.item = e8.item;
  return event;
};
var isViewportChanged = function isViewportChanged2(matrix) {
  if (!matrix) {
    return false;
  }
  var MATRIX_LEN = 9;
  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0; i2 < MATRIX_LEN; i2++) {
    if (matrix[i2] !== ORIGIN_MATRIX[i2]) {
      return true;
    }
  }
  return false;
};
var isNaN2 = function isNaN3(input) {
  return Number.isNaN(Number(input));
};
var calculationItemsBBox = function calculationItemsBBox2(items) {
  var minx = Infinity;
  var maxx = -Infinity;
  var miny = Infinity;
  var maxy = -Infinity;
  for (var i2 = 0; i2 < items.length; i2++) {
    var element = items[i2];
    var bbox = element.getBBox();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
    if (minX < minx) {
      minx = minX;
    }
    if (minY < miny) {
      miny = minY;
    }
    if (maxX > maxx) {
      maxx = maxX;
    }
    if (maxY > maxy) {
      maxy = maxY;
    }
  }
  var x4 = Math.floor(minx);
  var y4 = Math.floor(miny);
  var width = Math.ceil(maxx) - Math.floor(minx);
  var height = Math.ceil(maxy) - Math.floor(miny);
  return {
    x: x4,
    y: y4,
    width,
    height,
    minX: minx,
    minY: miny,
    maxX: maxx,
    maxY: maxy
  };
};
var processParallelEdges = function processParallelEdges2(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {
  if (offsetDiff === void 0) {
    offsetDiff = 15;
  }
  if (multiEdgeType === void 0) {
    multiEdgeType = "quadratic";
  }
  if (singleEdgeType === void 0) {
    singleEdgeType = void 0;
  }
  if (loopEdgeType === void 0) {
    loopEdgeType = void 0;
  }
  var len6 = edges.length;
  var cod = offsetDiff * 2;
  var loopPosition = ["top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left"];
  var edgeMap = {};
  var tags = [];
  var reverses = {};
  for (var i2 = 0; i2 < len6; i2++) {
    var edge = edges[i2];
    var source = edge.source, target = edge.target;
    var sourceTarget = "".concat(source, "-").concat(target);
    if (tags[i2]) continue;
    if (!edgeMap[sourceTarget]) {
      edgeMap[sourceTarget] = [];
    }
    tags[i2] = true;
    edgeMap[sourceTarget].push(edge);
    for (var j2 = 0; j2 < len6; j2++) {
      if (i2 === j2) continue;
      var sedge = edges[j2];
      var src = sedge.source;
      var dst = sedge.target;
      if (!tags[j2]) {
        if (source === dst && target === src) {
          edgeMap[sourceTarget].push(sedge);
          tags[j2] = true;
          reverses["".concat(src, "|").concat(dst, "|").concat(edgeMap[sourceTarget].length - 1)] = true;
        } else if (source === src && target === dst) {
          edgeMap[sourceTarget].push(sedge);
          tags[j2] = true;
        }
      }
    }
  }
  for (var key in edgeMap) {
    var arcEdges = edgeMap[key];
    var length_1 = arcEdges.length;
    for (var k2 = 0; k2 < length_1; k2++) {
      var current = arcEdges[k2];
      if (current.source === current.target) {
        if (loopEdgeType) current.type = loopEdgeType;
        current.loopCfg = {
          position: loopPosition[k2 % 8],
          dist: Math.floor(k2 / 8) * 20 + 50
        };
        continue;
      }
      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {
        current.type = singleEdgeType;
        continue;
      }
      current.type = multiEdgeType;
      var sign = (k2 % 2 === 0 ? 1 : -1) * (reverses["".concat(current.source, "|").concat(current.target, "|").concat(k2)] ? -1 : 1);
      if (length_1 % 2 === 1) {
        current.curveOffset = sign * Math.ceil(k2 / 2) * cod;
      } else {
        current.curveOffset = sign * (Math.floor(k2 / 2) * cod + offsetDiff);
      }
    }
  }
  return edges;
};

// node_modules/@antv/g6-core/es/graph/controller/view.js
var import_ext = __toESM(require_ext());
var ViewController = (
  /** @class */
  function() {
    function ViewController2(graph) {
      this.destroyed = false;
      this.graph = graph;
      this.destroyed = false;
    }
    ViewController2.prototype.getViewCenter = function() {
      var padding = this.getFormatPadding();
      var graph = this.graph;
      var width = this.graph.get("width");
      var height = graph.get("height");
      return {
        x: (width - padding[1] - padding[3]) / 2 + padding[3],
        y: (height - padding[0] - padding[2]) / 2 + padding[0]
      };
    };
    ViewController2.prototype.fitCenter = function(animate, animateCfg) {
      var graph = this.graph;
      var group = graph.get("group");
      var bbox;
      var nodes = graph.getNodes();
      if (nodes.length > graph.get("optimizeThreshold")) {
        var minX_1 = Infinity;
        var minY_1 = Infinity;
        var maxX_1 = -Infinity;
        var maxY_1 = -Infinity;
        nodes.forEach(function(node) {
          var _a3 = node.getModel(), x4 = _a3.x, y4 = _a3.y;
          if (minX_1 > x4) minX_1 = x4;
          if (minY_1 > y4) minY_1 = y4;
          if (maxX_1 < x4) maxX_1 = x4;
          if (maxY_1 < y4) maxY_1 = y4;
        });
        var matrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        var _a2 = applyMatrix({
          x: minX_1,
          y: minY_1
        }, matrix), transMinX = _a2.x, transMinY = _a2.y;
        var _b = applyMatrix({
          x: maxX_1,
          y: maxY_1
        }, matrix), transMaxX = _b.x, transMaxY = _b.y;
        bbox = {
          minX: transMinX,
          maxX: transMaxX,
          minY: transMinY,
          maxY: transMaxY,
          width: transMaxX - transMinX,
          height: transMaxY - transMinY,
          x: transMinX,
          y: transMinY
        };
      } else {
        bbox = group.getCanvasBBox();
      }
      if (bbox.width === 0 || bbox.height === 0) return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y, animate, animateCfg);
    };
    ViewController2.prototype.animatedFitView = function(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, zoomToFit) {
      var graph = this.graph;
      animateCfg = animateCfg ? animateCfg : {
        duration: 500,
        easing: "easeCubic"
      };
      var matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var vx = bbox.x + viewCenter.x - groupCenter.x - bbox.minX;
      var vy = bbox.y + viewCenter.y - groupCenter.y - bbox.minY;
      if (isNaN2(vx) || isNaN2(vy)) return;
      var translatedMatrix = (0, import_ext.transform)(matrix, [["t", vx, vy]]);
      if (!zoomToFit) {
        var animationConfig_1 = getAnimateCfgWithCallback({
          animateCfg,
          callback: function callback() {
            graph.emit("viewportchange", {
              action: "translate",
              matrix: translatedMatrix
            });
          }
        });
        group.animate(function(ratio2) {
          return {
            matrix: lerpArray(startMatrix, translatedMatrix, ratio2)
          };
        }, animationConfig_1);
        return;
      }
      var minZoom = graph.get("minZoom");
      var maxZoom = graph.get("maxZoom");
      var realRatio = ratio;
      if (minZoom && ratio < minZoom) {
        realRatio = minZoom;
        console.warn("fitview failed, ratio out of range, ratio: %f", ratio, "graph minzoom has been used instead");
      } else if (maxZoom && ratio > maxZoom) {
        realRatio = maxZoom;
        console.warn("fitview failed, ratio out of range, ratio: %f", ratio, "graph maxzoom has been used instead");
      }
      var zoomedMatrix = (0, import_ext.transform)(translatedMatrix, [["t", -viewCenter.x, -viewCenter.y], ["s", realRatio, realRatio], ["t", viewCenter.x, viewCenter.y]]);
      var animationConfig = getAnimateCfgWithCallback({
        animateCfg,
        callback: function callback() {
          group.setMatrix(zoomedMatrix);
          graph.emit("viewportchange", {
            action: "translate",
            matrix: translatedMatrix
          });
          graph.emit("viewportchange", {
            action: "zoom",
            matrix: zoomedMatrix
          });
        }
      });
      group.stopAnimate();
      group.setMatrix(startMatrix);
      group.animate(function(ratio2) {
        return {
          matrix: lerpArray(startMatrix, zoomedMatrix, ratio2)
        };
      }, animationConfig);
    };
    ViewController2.prototype.fitView = function(animate, animateCfg) {
      var graph = this.graph;
      var padding = this.getFormatPadding();
      var width = graph.get("width");
      var height = graph.get("height");
      var group = graph.get("group");
      var startMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      group.resetMatrix();
      var bbox;
      var nodes = graph.getNodes();
      if (nodes.length > graph.get("optimizeThreshold")) {
        var minX_2 = Infinity;
        var minY_2 = Infinity;
        var maxX_2 = -Infinity;
        var maxY_2 = -Infinity;
        nodes.forEach(function(node) {
          var _a2 = node.getModel(), x4 = _a2.x, y4 = _a2.y;
          if (minX_2 > x4) minX_2 = x4;
          if (minY_2 > y4) minY_2 = y4;
          if (maxX_2 < x4) maxX_2 = x4;
          if (maxY_2 < y4) maxY_2 = y4;
        });
        bbox = {
          minX: minX_2,
          maxX: maxX_2,
          minY: minY_2,
          maxY: maxY_2,
          width: maxX_2 - minX_2,
          height: maxY_2 - minY_2,
          x: minX_2,
          y: minY_2
        };
      } else {
        bbox = group.getCanvasBBox();
      }
      if (bbox.width === 0 || bbox.height === 0) return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      var w2 = (width - padding[1] - padding[3]) / bbox.width;
      var h2 = (height - padding[0] - padding[2]) / bbox.height;
      var ratio = w2;
      if (w2 > h2) {
        ratio = h2;
      }
      if (animate) {
        this.animatedFitView(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, true);
      } else {
        var dx = viewCenter.x - groupCenter.x;
        var dy = viewCenter.y - groupCenter.y;
        if (isNaN2(dx) || isNaN2(dy)) return;
        graph.translate(dx, dy);
        if (!graph.zoom(ratio, viewCenter)) {
          console.warn("zoom failed, ratio out of range, ratio: %f", ratio);
        }
      }
    };
    ViewController2.prototype.fitViewByRules = function(rules, animate, animateCfg) {
      var _a2 = rules.onlyOutOfViewPort, onlyOutOfViewPort = _a2 === void 0 ? false : _a2, _b = rules.direction, direction3 = _b === void 0 ? "both" : _b, _c = rules.ratioRule, ratioRule = _c === void 0 ? "min" : _c;
      var graph = this.graph;
      var padding = this.getFormatPadding();
      var width = graph.get("width");
      var height = graph.get("height");
      var group = graph.get("group");
      var startMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      group.resetMatrix();
      var bbox;
      var nodes = graph.getNodes();
      if (nodes.length > graph.get("optimizeThreshold")) {
        var minX_3 = Infinity;
        var minY_3 = Infinity;
        var maxX_3 = -Infinity;
        var maxY_3 = -Infinity;
        nodes.forEach(function(node) {
          var _a3 = node.getModel(), x4 = _a3.x, y4 = _a3.y;
          if (minX_3 > x4) minX_3 = x4;
          if (minY_3 > y4) minY_3 = y4;
          if (maxX_3 < x4) maxX_3 = x4;
          if (maxY_3 < y4) maxY_3 = y4;
        });
        bbox = {
          minX: minX_3,
          maxX: maxX_3,
          minY: minY_3,
          maxY: maxY_3,
          width: maxX_3 - minX_3,
          height: maxY_3 - minY_3,
          x: minX_3,
          y: minY_3
        };
      } else {
        bbox = group.getCanvasBBox();
      }
      if (bbox.width === 0 || bbox.height === 0) return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      var wRatio = (width - padding[1] - padding[3]) / bbox.width;
      var hRatio = (height - padding[0] - padding[2]) / bbox.height;
      var ratio;
      if (direction3 === "x") {
        ratio = wRatio;
      } else if (direction3 === "y") {
        ratio = hRatio;
      } else {
        ratio = ratioRule === "max" ? Math.max(wRatio, hRatio) : Math.min(wRatio, hRatio);
      }
      if (onlyOutOfViewPort) {
        ratio = ratio < 1 ? ratio : 1;
      }
      if (animate) {
        this.animatedFitView(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, true);
      } else {
        var initZoomRatio = graph.getZoom();
        var endZoom = initZoomRatio * ratio;
        var minZoom = graph.get("minZoom");
        if (endZoom < minZoom) {
          endZoom = minZoom;
          console.warn("fitview failed, ratio out of range, ratio: %f", ratio, "graph minzoom has been used instead");
        }
        graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);
        graph.zoomTo(endZoom, viewCenter);
      }
    };
    ViewController2.prototype.getFormatPadding = function() {
      var padding = this.graph.get("fitViewPadding");
      return formatPadding(padding);
    };
    ViewController2.prototype.focusPoint = function(point, animate, animateCfg) {
      var _this = this;
      var viewCenter = this.getViewCenter();
      var modelCenter = this.getPointByCanvas(viewCenter.x, viewCenter.y);
      var viewportMatrix = this.graph.get("group").getMatrix();
      if (!viewportMatrix) viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (animate) {
        var dx_1 = (modelCenter.x - point.x) * viewportMatrix[0];
        var dy_1 = (modelCenter.y - point.y) * viewportMatrix[4];
        var lastX_1 = 0;
        var lastY_1 = 0;
        var newX_1 = 0;
        var newY_1 = 0;
        this.graph.get("canvas").animate(function(ratio) {
          newX_1 = dx_1 * ratio;
          newY_1 = dy_1 * ratio;
          _this.graph.translate(newX_1 - lastX_1, newY_1 - lastY_1);
          lastX_1 = newX_1;
          lastY_1 = newY_1;
        }, __assign3({}, animateCfg));
      } else {
        this.graph.translate((modelCenter.x - point.x) * viewportMatrix[0], (modelCenter.y - point.y) * viewportMatrix[4]);
      }
    };
    ViewController2.prototype.getPointByCanvas = function(canvasX, canvasY) {
      var viewportMatrix = this.graph.get("group").getMatrix();
      if (!viewportMatrix) {
        viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      var point = invertMatrix({
        x: canvasX,
        y: canvasY
      }, viewportMatrix);
      return point;
    };
    ViewController2.prototype.getPointByClient = function(clientX, clientY) {
      var canvas = this.graph.get("canvas");
      var canvasPoint = canvas.getPointByClient(clientX, clientY);
      return this.getPointByCanvas(canvasPoint.x, canvasPoint.y);
    };
    ViewController2.prototype.getClientByPoint = function(x4, y4) {
      var canvas = this.graph.get("canvas");
      var canvasPoint = this.getCanvasByPoint(x4, y4);
      var point = canvas.getClientByPoint(canvasPoint.x, canvasPoint.y);
      return {
        x: point.x,
        y: point.y
      };
    };
    ViewController2.prototype.getCanvasByPoint = function(x4, y4) {
      var viewportMatrix = this.graph.get("group").getMatrix();
      if (!viewportMatrix) {
        viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      return applyMatrix({
        x: x4,
        y: y4
      }, viewportMatrix);
    };
    ViewController2.prototype.focus = function(item, animate, animateCfg) {
      if (is_string_default(item)) {
        item = this.graph.findById(item);
      }
      if (item) {
        var x4 = 0, y4 = 0;
        if (item.getType && item.getType() === "edge") {
          var sourceMatrix = item.getSource().get("group").getMatrix();
          var targetMatrix = item.getTarget().get("group").getMatrix();
          if (sourceMatrix && targetMatrix) {
            x4 = (sourceMatrix[6] + targetMatrix[6]) / 2;
            y4 = (sourceMatrix[7] + targetMatrix[7]) / 2;
          } else if (sourceMatrix || targetMatrix) {
            x4 = sourceMatrix ? sourceMatrix[6] : targetMatrix[6];
            y4 = sourceMatrix ? sourceMatrix[7] : targetMatrix[7];
          }
        } else {
          var group = item.get("group");
          var matrix = group.getMatrix();
          if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          x4 = matrix[6];
          y4 = matrix[7];
        }
        this.focusPoint({
          x: x4,
          y: y4
        }, animate, animateCfg);
      }
    };
    ViewController2.prototype.focusItems = function(items, zoomToFit, animate, animateCfg) {
      if (!items.length) {
        return;
      }
      var graph = this.graph;
      var padding = this.getFormatPadding();
      var width = graph.get("width");
      var height = graph.get("height");
      var group = graph.get("group");
      var startMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      group.resetMatrix();
      var bbox = {
        x: 0,
        y: 0,
        minX: Number.MAX_SAFE_INTEGER,
        minY: Number.MAX_SAFE_INTEGER,
        maxX: Number.MIN_SAFE_INTEGER,
        maxY: Number.MIN_SAFE_INTEGER,
        width: 0,
        height: 0
      };
      for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
        var item = items_1[_i2];
        var itemBBox = item.getBBox();
        if (itemBBox.minX < bbox.minX) {
          bbox.minX = itemBBox.minX;
        }
        if (itemBBox.minY < bbox.minY) {
          bbox.minY = itemBBox.minY;
        }
        if (itemBBox.maxX > bbox.maxX) {
          bbox.maxX = itemBBox.maxX;
        }
        if (itemBBox.maxY > bbox.maxY) {
          bbox.maxY = itemBBox.maxY;
        }
      }
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      if (bbox.width === 0 || bbox.height === 0) return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      var w2 = (width - padding[1] - padding[3]) / bbox.width;
      var h2 = (height - padding[0] - padding[2]) / bbox.height;
      var ratio = w2;
      if (w2 > h2) {
        ratio = h2;
      }
      if (animate) {
        this.animatedFitView(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, zoomToFit);
      } else {
        graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);
        if (zoomToFit && !graph.zoom(ratio, viewCenter)) {
          console.warn("zoom failed, ratio out of range, ratio: %f", ratio);
        }
      }
    };
    ViewController2.prototype.changeSize = function(width, height) {
      var graph = this.graph;
      if (!is_number_default(width) || !is_number_default(height)) {
        throw Error("invalid canvas width & height, please make sure width & height type is number");
      }
      graph.set({
        width,
        height
      });
      var canvas = graph.get("canvas");
      canvas.changeSize(width, height);
      var plugins = graph.get("plugins");
      plugins.forEach(function(plugin) {
        if (plugin.get("gridContainer")) {
          plugin.positionInit();
        }
      });
    };
    ViewController2.prototype.destroy = function() {
      this.graph = null;
      this.destroyed = false;
    };
    return ViewController2;
  }()
);
var view_default = ViewController;

// node_modules/@antv/g6-core/es/graph/controller/item.js
init_esm();

// node_modules/@antv/g6-core/es/item/edge.js
init_esm();

// node_modules/@antv/g6-core/es/item/item.js
init_esm();

// node_modules/@antv/g6-core/es/element/shape.js
init_esm();

// node_modules/@antv/g6-core/es/element/xml.js
init_esm();
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function looseJSONParse(text) {
  if (typeof text !== "string") {
    return text;
  }
  var safeParse = function safeParse2(str11) {
    if (typeof str11 !== "string") {
      return str11;
    }
    try {
      return JSON.parse(str11.trim());
    } catch (e8) {
      return str11.trim();
    }
  };
  var firstAttempt = safeParse(text);
  if (typeof firstAttempt !== "string") {
    return firstAttempt;
  }
  var tail = function tail2(arr) {
    return arr[arr.length - 1];
  };
  var str10 = text.trim();
  var objectStack = [];
  var syntaxStack = [];
  var isLastPair = function isLastPair2() {
    var syntaxes = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      syntaxes[_i2] = arguments[_i2];
    }
    return syntaxes.some(function(syntax) {
      return tail(syntaxStack) === syntax;
    });
  };
  var getValueStore = function getValueStore2() {
    return tail(objectStack);
  };
  var rst = null;
  var i2 = 0;
  var temp = "";
  while (i2 < str10.length) {
    var nowChar = str10[i2];
    var isInString = isLastPair('"', "'");
    if (!isInString && !nowChar.trim()) {
      i2 += 1;
      continue;
    }
    var isLastTranslate = str10[i2 - 1] === "\\";
    var isInObject = isLastPair("}");
    var isInArray = isLastPair("]");
    var isWaitingValue = isLastPair(",");
    var tempArr = getValueStore();
    if (isInString) {
      if (tail(syntaxStack) === nowChar && !isLastTranslate) {
        syntaxStack.pop();
        var value = safeParse(temp);
        tempArr.push(value);
        rst = value;
        temp = "";
      } else {
        temp += nowChar;
      }
    } else if (isInArray && nowChar === ",") {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
    } else if (isInObject && nowChar === ":") {
      syntaxStack.push(",");
      if (temp) {
        tempArr.push(temp);
        temp = "";
      }
    } else if (isWaitingValue && nowChar === ",") {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      syntaxStack.pop();
    } else if (nowChar === "}" && (isInObject || isWaitingValue)) {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      if (isWaitingValue) {
        syntaxStack.pop();
      }
      var obj = {};
      for (var c3 = 1; c3 < tempArr.length; c3 += 2) {
        obj[tempArr[c3 - 1]] = tempArr[c3];
      }
      objectStack.pop();
      if (objectStack.length) {
        tail(objectStack).push(obj);
      }
      syntaxStack.pop();
      rst = obj;
    } else if (nowChar === "]" && isInArray) {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      objectStack.pop();
      if (objectStack.length) {
        tail(objectStack).push(tempArr);
      }
      syntaxStack.pop();
      rst = tempArr;
    } else if (nowChar === "{") {
      objectStack.push([]);
      syntaxStack.push("}");
    } else if (nowChar === "[") {
      objectStack.push([]);
      syntaxStack.push("]");
    } else if (nowChar === '"') {
      syntaxStack.push('"');
    } else if (nowChar === "'") {
      syntaxStack.push("'");
    } else {
      temp += nowChar;
    }
    i2 += 1;
  }
  return rst || temp;
}
var keyConvert = function keyConvert2(str10) {
  return str10.split("-").reduce(function(a3, b10) {
    return a3 + b10.charAt(0).toUpperCase() + b10.slice(1);
  });
};
var xmlDataRenderer = function xmlDataRenderer2(xml) {
  return function(data) {
    var len6 = xml.length;
    var arr = [];
    var i2 = 0;
    var tmp = "";
    while (i2 < len6) {
      if (xml[i2] === "{" && xml[i2 + 1] === "{") {
        arr.push(tmp);
        tmp = "";
        i2 += 2;
      } else if (xml[i2] === "}" && xml[i2 + 1] === "}") {
        if (arr.length) {
          var last3 = arr.pop();
          tmp = get_default(data, tmp, last3.endsWith("=") ? '"{'.concat(tmp, '}"') : tmp);
          arr.push(last3 + tmp);
        }
        i2 += 2;
        tmp = "";
      } else {
        tmp += xml[i2];
        i2 += 1;
      }
    }
    arr.push(tmp);
    return arr.map(function(e8, index2) {
      return arr[index2 - 1] && arr[index2 - 1].endsWith("=") ? '"{'.concat(e8, '}"') : e8;
    }).join("");
  };
};
function parseXML(xml, cfg) {
  var attrs = {};
  var keys3 = xml.getAttributeNames && xml.getAttributeNames() || [];
  var children = xml.children && Array.from(xml.children).map(function(e8) {
    return parseXML(e8, cfg);
  });
  var rst = {};
  var tagName = xml.tagName ? xml.tagName.toLowerCase() : "group";
  if (tagName === "text") {
    attrs.text = xml.innerText;
  }
  rst.type = tagName;
  if (tagName === "img") {
    rst.type = "image";
  }
  Array.from(keys3).forEach(function(k2) {
    var key = keyConvert(k2);
    var val = xml.getAttribute(k2);
    try {
      if (key === "style" || key === "attrs") {
        var style = looseJSONParse(val);
        attrs = __assign3(__assign3({}, attrs), style);
      } else {
        rst[key] = looseJSONParse(val);
      }
    } catch (e8) {
      if (key === "style") {
        throw e8;
      }
      rst[key] = val;
    }
  });
  rst.attrs = attrs;
  if (cfg && cfg.style && rst.name && _typeof(cfg.style[rst.name]) === "object") {
    rst.attrs = __assign3(__assign3({}, rst.attrs), cfg.style[rst.name]);
  }
  if (cfg && cfg.style && rst.keyshape) {
    rst.attrs = __assign3(__assign3({}, rst.attrs), cfg.style);
  }
  if (children.length) {
    rst.children = children;
  }
  return rst;
}
function getBBox3(node, offset, childrenBBox) {
  var _a2 = node.attrs, attrs = _a2 === void 0 ? {} : _a2;
  var bbox = {
    x: offset.x || 0,
    y: offset.y || 0,
    width: childrenBBox.width || 0,
    height: childrenBBox.height || 0
  };
  var shapeHeight, shapeWidth;
  switch (node.type) {
    case "maker":
    case "circle":
      if (attrs.r) {
        shapeWidth = 2 * attrs.r;
        shapeHeight = 2 * attrs.r;
      }
      break;
    case "text":
      if (attrs.text) {
        shapeWidth = getTextSize(attrs.text, attrs.fontSize || 12)[0];
        shapeHeight = 16;
        bbox.y += shapeHeight;
        bbox.height = shapeHeight;
        bbox.width = shapeWidth;
        node.attrs = __assign3({
          fontSize: 12,
          fill: "#000"
        }, attrs);
      }
      break;
    default:
      if (attrs.width) {
        shapeWidth = attrs.width;
      }
      if (attrs.height) {
        shapeHeight = attrs.height;
      }
  }
  if (shapeHeight >= 0) {
    bbox.height = shapeHeight;
  }
  if (shapeWidth >= 0) {
    bbox.width = shapeWidth;
  }
  if (attrs.marginTop) {
    bbox.y += attrs.marginTop;
  }
  if (attrs.marginLeft) {
    bbox.x += attrs.marginLeft;
  }
  return bbox;
}
function generateTarget(target, lastOffset) {
  var _a2;
  if (lastOffset === void 0) {
    lastOffset = {
      x: 0,
      y: 0
    };
  }
  var defaultBbox = __assign3({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  }, lastOffset);
  if ((_a2 = target.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
    var _b = target.attrs, attrs = _b === void 0 ? {} : _b;
    var marginTop = attrs.marginTop;
    var offset = __assign3({}, lastOffset);
    if (marginTop) {
      offset.y += marginTop;
    }
    for (var index2 = 0; index2 < target.children.length; index2++) {
      target.children[index2].attrs.key = "".concat(attrs.key || "root", " -").concat(index2, " ");
      var node = generateTarget(target.children[index2], offset);
      if (node.bbox) {
        var bbox = node.bbox;
        if (node.attrs.next === "inline") {
          offset.x += node.bbox.width;
        } else {
          offset.y += node.bbox.height;
        }
        if (bbox.width + bbox.x > defaultBbox.width) {
          defaultBbox.width = bbox.width + bbox.x;
        }
        if (bbox.height + bbox.y > defaultBbox.height) {
          defaultBbox.height = bbox.height + bbox.y;
        }
      }
    }
  }
  target.bbox = getBBox3(target, lastOffset, defaultBbox);
  target.attrs = __assign3(__assign3({}, target.attrs), target.bbox);
  return target;
}
function compareTwoTarget(nowTarget, formerTarget) {
  var _a2, _b, _c, _d;
  var type = (nowTarget || {}).type;
  var key = ((formerTarget === null || formerTarget === void 0 ? void 0 : formerTarget.attrs) || {}).key;
  if (key && nowTarget) {
    nowTarget.attrs.key = key;
  }
  if (!nowTarget && formerTarget) {
    return {
      action: "delete",
      val: formerTarget,
      type,
      key
    };
  }
  if (nowTarget && !formerTarget) {
    return {
      action: "add",
      val: nowTarget,
      type
    };
  }
  if (!nowTarget && !formerTarget) {
    return {
      action: "same",
      type
    };
  }
  var children = [];
  if (((_a2 = nowTarget.children) === null || _a2 === void 0 ? void 0 : _a2.length) > 0 || ((_b = formerTarget.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {
    var length_1 = Math.max((_c = nowTarget.children) === null || _c === void 0 ? void 0 : _c.length, (_d = formerTarget.children) === null || _d === void 0 ? void 0 : _d.length);
    var formerChildren = formerTarget.children || [];
    var nowChildren = nowTarget.children || [];
    for (var index2 = 0; index2 < length_1; index2 += 1) {
      children.push(compareTwoTarget(nowChildren[index2], formerChildren[index2]));
    }
  }
  var formerKeys = Object.keys(formerTarget.attrs);
  var nowKeys = Object.keys(nowTarget.attrs);
  if (formerTarget.type !== nowTarget.type) {
    return {
      action: "restructure",
      nowTarget,
      formerTarget,
      key,
      children
    };
  }
  if (formerKeys.filter(function(e8) {
    return e8 !== "children";
  }).some(function(e8) {
    return nowTarget.attrs[e8] !== formerTarget.attrs[e8] || !nowKeys.includes(e8);
  })) {
    return {
      action: "change",
      val: nowTarget,
      children,
      type,
      key
    };
  }
  return {
    action: "same",
    children,
    type,
    key
  };
}
function createNodeFromXML(gen) {
  var structures = {};
  var compileXML = function compileXML2(cfg) {
    var rawStr = typeof gen === "function" ? gen(cfg) : gen;
    var target = xmlDataRenderer(rawStr)(cfg);
    var xmlParser = document.createElement("div");
    xmlParser.innerHTML = target;
    var xml = xmlParser.children[0];
    var result = generateTarget(parseXML(xml, cfg));
    xmlParser.remove();
    return result;
  };
  return {
    draw: function draw4(cfg, group) {
      var resultTarget = compileXML(cfg);
      var keyshape = group;
      var renderTarget = function renderTarget2(target) {
        var _a2 = target.attrs, attrs = _a2 === void 0 ? {} : _a2, bbox = target.bbox, type = target.type, children = target.children, rest = __rest3(target, ["attrs", "bbox", "type", "children"]);
        if (target.type !== "group") {
          var shape = group.addShape(target.type, __assign3({
            attrs,
            origin: {
              bbox,
              type,
              children
            }
          }, rest));
          if (target.keyshape) {
            keyshape = shape;
          }
        }
        if (target.children) {
          target.children.forEach(function(n2) {
            return renderTarget2(n2);
          });
        }
      };
      renderTarget(resultTarget);
      structures[cfg.id] = [resultTarget];
      return keyshape;
    },
    update: function update15(cfg, node) {
      if (!structures[cfg.id]) {
        structures[cfg.id] = [];
      }
      var container = node.getContainer();
      var children = container.get("children");
      var newTarget = compileXML(cfg);
      var lastTarget = structures[cfg.id].pop();
      var diffResult = compareTwoTarget(newTarget, lastTarget);
      var addShape = function addShape2(shape) {
        var _a2;
        if (shape.type !== "group") {
          container.addShape(shape.type, {
            attrs: shape.attrs
          });
        }
        if ((_a2 = shape.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
          shape.children.map(function(e8) {
            return addShape2(e8);
          });
        }
      };
      var delShape = function delShape2(shape) {
        var _a2;
        var targetShape = children.find(function(e8) {
          return e8.attrs.key === shape.attrs.key;
        });
        if (targetShape) {
          container.removeChild(targetShape);
        }
        if ((_a2 = shape.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
          shape.children.map(function(e8) {
            return delShape2(e8);
          });
        }
      };
      var updateTarget = function updateTarget2(target) {
        var key = target.key;
        if (target.type !== "group") {
          var targetShape = children.find(function(e8) {
            return e8.attrs.key === key;
          });
          switch (target.action) {
            case "change":
              if (targetShape) {
                var originAttr = target.val.keyshape ? node.getOriginStyle() : {};
                targetShape.attr(__assign3(__assign3({}, originAttr), target.val.attrs));
              }
              break;
            case "add":
              addShape(target.val);
              break;
            case "delete":
              delShape(target.val);
              break;
            case "restructure":
              delShape(target.formerTarget);
              addShape(target.nowTarget);
              break;
            default:
              break;
          }
        }
        if (target.children) {
          target.children.forEach(function(n2) {
            return updateTarget2(n2);
          });
        }
      };
      updateTarget(diffResult);
      structures[cfg.id].push(newTarget);
    },
    getAnchorPoints: function getAnchorPoints4() {
      return [[0, 0.5], [1, 0.5], [0.5, 1], [0.5, 0]];
    }
  };
}

// node_modules/@antv/g6-core/es/element/shape.js
var cache2 = {};
function ucfirst(str10) {
  if (!cache2[str10]) {
    cache2[str10] = upper_first_default(str10);
  }
  return cache2[str10];
}
var ShapeFactoryBase = {
  /**
   * 默认的形状，当没有指定/匹配 shapeType 时，使用默认的
   * @type {String}
   */
  defaultShapeType: "defaultType",
  /**
   * 形状的 className，用于搜索
   * @type {String}
   */
  className: null,
  /**
   * 获取绘制 Shape 的工具类，无状态
   * @param  {String} type 类型
   * @return {Shape} 工具类
   */
  getShape: function getShape(type) {
    var self2 = this;
    var shape = self2[type] || self2[self2.defaultShapeType] || self2["simple-circle"];
    return shape;
  },
  /**
   * 绘制图形
   * @param  {String} type  类型
   * @param  {Object} cfg 配置项
   * @param  {G.Group} group 图形的分组
   * @return {IShape} 图形对象
   */
  draw: function draw(type, cfg, group) {
    var shape = this.getShape(type);
    group["shapeMap"] = {};
    var rst = shape.draw(cfg, group);
    if (shape.afterDraw) {
      shape.afterDraw(cfg, group, rst);
    }
    return rst;
  },
  /**
   * 更新
   * @param  {String} type  类型
   * @param  {Object} cfg 配置项
   * @param  {G6.Item} item 节点、边、分组等
   */
  baseUpdate: function baseUpdate(type, cfg, item, updateType) {
    var _a2, _b;
    var shape = this.getShape(type);
    if (shape.update) {
      shape.mergeStyle = (_a2 = shape.getOptions) === null || _a2 === void 0 ? void 0 : _a2.call(shape, cfg, updateType);
      (_b = shape.update) === null || _b === void 0 ? void 0 : _b.call(shape, cfg, item, updateType);
    }
    if (shape.afterUpdate) {
      shape.afterUpdate(cfg, item);
    }
  },
  /**
   * 设置状态
   * @param {String} type  类型
   * @param {String} name  状态名
   * @param {String | Boolean} value 状态值
   * @param {G6.Item} item  节点、边、分组等
   */
  setState: function setState(type, name, value, item) {
    var shape = this.getShape(type);
    shape.setState(name, value, item);
  },
  /**
   * 是否允许更新，不重新绘制图形
   * @param  {String} type 类型
   * @return {Boolean} 是否允许使用更新
   */
  shouldUpdate: function shouldUpdate2(type) {
    var shape = this.getShape(type);
    return !!shape.update;
  },
  getControlPoints: function getControlPoints(type, cfg) {
    var shape = this.getShape(type);
    return shape.getControlPoints(cfg);
  },
  /**
   * 获取控制点
   * @param {String} type 节点、边类型
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getAnchorPoints: function getAnchorPoints(type, cfg) {
    var shape = this.getShape(type);
    return shape.getAnchorPoints(cfg);
  }
};
var ShapeFramework = {
  // 默认样式及配置
  options: {},
  /**
   * 绘制
   */
  draw: function draw2(cfg, group) {
    return this.drawShape(cfg, group);
  },
  /**
   * 绘制
   */
  drawShape: function drawShape() {
  },
  /**
   * 绘制完成后的操作，便于用户继承现有的节点、边
   */
  afterDraw: function afterDraw() {
  },
  // update(cfg, item) // 默认不定义
  afterUpdate: function afterUpdate() {
  },
  /**
   * 设置节点、边状态
   */
  setState: function setState2() {
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getControlPoints: function getControlPoints2(cfg) {
    return cfg.controlPoints;
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getAnchorPoints: function getAnchorPoints2(cfg) {
    var defaultAnchorPoints = this.options.anchorPoints;
    var anchorPoints = cfg.anchorPoints || defaultAnchorPoints;
    return anchorPoints;
  }
  /* 如果没定义 update 方法，每次都调用 draw 方法
  update(cfg, item) {
     }
  */
};
var Shape = (
  /** @class */
  function() {
    function Shape2() {
    }
    Shape2.registerFactory = function(factoryType, cfg) {
      var className = ucfirst(factoryType);
      var factoryBase = ShapeFactoryBase;
      var shapeFactory = __assign3(__assign3({}, factoryBase), cfg);
      Shape2[className] = shapeFactory;
      shapeFactory.className = className;
      return shapeFactory;
    };
    Shape2.getFactory = function(factoryType) {
      var className = ucfirst(factoryType);
      return Shape2[className];
    };
    Shape2.registerNode = function(shapeType, nodeDefinition, extendShapeType) {
      var shapeFactory = Shape2.Node;
      var shapeObj;
      if (typeof nodeDefinition === "string" || typeof nodeDefinition === "function") {
        var autoNodeDefinition = createNodeFromXML(nodeDefinition);
        shapeObj = __assign3(__assign3({}, shapeFactory.getShape("single-node")), autoNodeDefinition);
      } else if (nodeDefinition.jsx) {
        var jsx = nodeDefinition.jsx;
        var autoNodeDefinition = createNodeFromXML(jsx);
        shapeObj = __assign3(__assign3(__assign3({}, shapeFactory.getShape("single-node")), autoNodeDefinition), nodeDefinition);
      } else {
        shapeFactory.getShape(extendShapeType);
        var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
        shapeObj = __assign3(__assign3({}, extendShape), nodeDefinition);
      }
      shapeObj.type = shapeType;
      shapeObj.itemType = "node";
      shapeFactory[shapeType] = shapeObj;
      return shapeObj;
    };
    Shape2.registerEdge = function(shapeType, edgeDefinition, extendShapeType) {
      var shapeFactory = Shape2.Edge;
      var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
      var shapeObj = __assign3(__assign3({}, extendShape), edgeDefinition);
      shapeObj.type = shapeType;
      shapeObj.itemType = "edge";
      shapeFactory[shapeType] = shapeObj;
      return shapeObj;
    };
    Shape2.registerCombo = function(shapeType, comboDefinition, extendShapeType) {
      var shapeFactory = Shape2.Combo;
      var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
      var shapeObj = __assign3(__assign3({}, extendShape), comboDefinition);
      shapeObj.type = shapeType;
      shapeObj.itemType = "combo";
      shapeFactory[shapeType] = shapeObj;
      return shapeObj;
    };
    return Shape2;
  }()
);
var shape_default2 = Shape;
Shape.registerFactory("node", {
  defaultShapeType: "circle"
});
Shape.registerFactory("edge", {
  defaultShapeType: "line"
});
Shape.registerFactory("combo", {
  defaultShapeType: "circle"
});

// node_modules/@antv/g6-core/es/item/item.js
var CACHE_BBOX = "bboxCache";
var CACHE_CANVAS_BBOX = "bboxCanvasCache";
var ItemBase = (
  /** @class */
  function() {
    function ItemBase2(cfg) {
      this._cfg = {};
      this.destroyed = false;
      this.optimize = false;
      var defaultCfg2 = {
        /**
         * id
         * @type {string}
         */
        id: void 0,
        /**
         * 类型
         * @type {string}
         */
        type: "item",
        /**
         * data model
         * @type {object}
         */
        model: {},
        /**
         * g group
         * @type {G.Group}
         */
        group: void 0,
        /**
         * is open animate
         * @type {boolean}
         */
        animate: false,
        /**
         * visible - not group visible
         * @type {boolean}
         */
        visible: true,
        /**
         * locked - lock node
         * @type {boolean}
         */
        locked: false,
        /**
         * capture event
         * @type {boolean}
         */
        event: true,
        /**
         * key shape to calculate item's bbox
         * @type object
         */
        keyShape: void 0,
        /**
         * item's states, such as selected or active
         * @type Array
         */
        states: []
      };
      this._cfg = Object.assign(defaultCfg2, this.getDefaultCfg(), cfg);
      var model = this.get("model");
      var id = model.id;
      var itemType = this.get("type");
      if (typeof id === "undefined") {
        id = uniqueId3(itemType);
      } else if (typeof id !== "string") {
        id = String(id);
      }
      this.get("model").id = id;
      this.set("id", id);
      var group = cfg.group;
      if (group) {
        group.set("item", this);
        group.set("id", id);
      }
      this.init();
      this.draw();
      var shapeType = model.shape || model.type || (itemType === "edge" ? "line" : "circle");
      var shapeFactory = this.get("shapeFactory");
      if (shapeFactory && shapeFactory[shapeType]) {
        var options = shapeFactory[shapeType].options;
        if (options && options.stateStyles) {
          var styles = this.get("styles") || model.stateStyles;
          styles = deep_mix_default({}, options.stateStyles, styles);
          this.set("styles", styles);
        }
      }
    }
    ItemBase2.prototype.calculateBBox = function() {
      var keyShape = this.get("keyShape");
      var group = this.get("group");
      var bbox = getBBox(keyShape, group);
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      return bbox;
    };
    ItemBase2.prototype.calculateCanvasBBox = function() {
      var keyShape = this.get("keyShape");
      var group = this.get("group");
      var bbox = getBBox(keyShape, group);
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      return bbox;
    };
    ItemBase2.prototype.drawInner = function() {
      var self2 = this;
      var shapeFactory = self2.get("shapeFactory");
      var group = self2.get("group");
      var model = self2.get("model");
      group.clear();
      var visible = model.visible;
      if (visible !== void 0 && !visible) self2.changeVisibility(visible);
      if (!shapeFactory) {
        return;
      }
      self2.updatePosition(model);
      var cfg = self2.getShapeCfg(model);
      var shapeType = cfg.type;
      var keyShape = shapeFactory.draw(shapeType, cfg, group);
      if (keyShape) {
        self2.set("keyShape", keyShape);
        keyShape.set("isKeyShape", true);
        keyShape.set("draggable", true);
      }
      this.setOriginStyle();
      this.set("currentShape", shapeType);
      this.restoreStates(shapeFactory, shapeType);
    };
    ItemBase2.prototype.setOriginStyle = function() {
      var group = this.get("group");
      var children = group.get("children");
      var keyShape = this.getKeyShape();
      var self2 = this;
      var keyShapeName = keyShape.get("name");
      if (!this.get("originStyle")) {
        var originStyles = {};
        for (var i2 = 0; i2 < children.length; i2++) {
          var child = children[i2];
          var shapeType = child.get("type");
          var name_1 = child.get("name");
          if (name_1 && name_1 !== keyShapeName) {
            originStyles[name_1] = shapeType !== "image" ? clone_default(child.attr()) : self2.getShapeStyleByName(name_1);
            if (shapeType === "text" && originStyles[name_1]) {
              delete originStyles[name_1].x;
              delete originStyles[name_1].y;
              delete originStyles[name_1].matrix;
            }
          } else {
            var keyShapeStyle = self2.getShapeStyleByName();
            delete keyShapeStyle.path;
            delete keyShapeStyle.matrix;
            if (!keyShapeName) {
              Object.assign(originStyles, keyShapeStyle);
            } else {
              if (!name_1) {
                var shapeName = uniqueId3("shape");
                child.set("name", shapeName);
                group["shapeMap"][shapeName] = child;
                originStyles[shapeName] = shapeType !== "image" ? clone_default(child.attr()) : self2.getShapeStyleByName(name_1);
              } else {
                originStyles[keyShapeName] = keyShapeStyle;
              }
            }
          }
        }
        self2.set("originStyle", originStyles);
      } else {
        var styles_1 = this.get("originStyle");
        if (keyShapeName && !styles_1[keyShapeName]) styles_1[keyShapeName] = {};
        var currentStatesStyle_1 = this.getCurrentStatesStyle();
        var _loop_1 = function _loop_12(i3) {
          var child2 = children[i3];
          var name_2 = child2.get("name");
          var shapeAttrs = child2.attr();
          if (name_2 && name_2 !== keyShapeName) {
            var shapeStateStyle_1 = currentStatesStyle_1[name_2];
            if (!styles_1[name_2]) styles_1[name_2] = {};
            if (shapeStateStyle_1) {
              Object.keys(shapeAttrs).forEach(function(key) {
                var value = shapeAttrs[key];
                if (value !== shapeStateStyle_1[key]) styles_1[name_2][key] = value;
              });
            } else {
              styles_1[name_2] = child2.get("type") !== "image" ? clone_default(shapeAttrs) : self2.getShapeStyleByName(name_2);
            }
          } else {
            var shapeAttrs_1 = child2.attr();
            var keyShapeStateStyles_1 = {};
            Object.keys(currentStatesStyle_1).forEach(function(styleKey) {
              var subStyle = currentStatesStyle_1[styleKey];
              if (styleKey === keyShapeName || !is_plain_object_default(subStyle)) {
                keyShapeStateStyles_1[styleKey] = subStyle;
              }
            });
            Object.keys(shapeAttrs_1).forEach(function(key) {
              var value = shapeAttrs_1[key];
              if (keyShapeStateStyles_1[key] !== value) {
                if (keyShapeName) styles_1[keyShapeName][key] = value;
                else styles_1[key] = value;
              }
            });
          }
        };
        for (var i2 = 0; i2 < children.length; i2++) {
          _loop_1(i2);
        }
        delete styles_1.path;
        delete styles_1.matrix;
        delete styles_1.x;
        delete styles_1.y;
        if (styles_1[keyShapeName]) {
          delete styles_1[keyShapeName].x;
          delete styles_1[keyShapeName].y;
          delete styles_1[keyShapeName].matrix;
          delete styles_1[keyShapeName].path;
        }
        self2.set("originStyle", styles_1);
      }
    };
    ItemBase2.prototype.restoreStates = function(shapeFactory, shapeType) {
      var self2 = this;
      var states = self2.get("states");
      each_default(states, function(state) {
        shapeFactory.setState(shapeType, state, true, self2);
      });
    };
    ItemBase2.prototype.init = function() {
      var shapeFactory = shape_default2.getFactory(this.get("type"));
      this.set("shapeFactory", shapeFactory);
    };
    ItemBase2.prototype.get = function(key) {
      return this._cfg[key];
    };
    ItemBase2.prototype.set = function(key, val) {
      if (is_plain_object_default(key)) {
        this._cfg = __assign3(__assign3({}, this._cfg), key);
      } else {
        this._cfg[key] = val;
      }
    };
    ItemBase2.prototype.getDefaultCfg = function() {
      return {};
    };
    ItemBase2.prototype.clearCache = function() {
      this.set(CACHE_BBOX, null);
      this.set(CACHE_CANVAS_BBOX, null);
    };
    ItemBase2.prototype.beforeDraw = function() {
    };
    ItemBase2.prototype.afterDraw = function() {
    };
    ItemBase2.prototype.afterUpdate = function() {
    };
    ItemBase2.prototype.draw = function() {
      this.beforeDraw();
      this.drawInner();
      this.afterDraw();
    };
    ItemBase2.prototype.getShapeStyleByName = function(name) {
      var group = this.get("group");
      var currentShape;
      if (name) {
        currentShape = group["shapeMap"][name] || group.find(function(element) {
          return element.get("name") === name;
        });
      } else {
        currentShape = this.getKeyShape();
      }
      if (currentShape) {
        var styles_2 = {};
        each_default(currentShape.attr(), function(val, key) {
          if (key !== "img" || is_string_default(val)) {
            styles_2[key] = val;
          }
        });
        return styles_2;
      }
      return {};
    };
    ItemBase2.prototype.getShapeCfg = function(model, updateType) {
      var styles = this.get("styles");
      if (styles) {
        var newModel = model;
        newModel.style = __assign3(__assign3({}, styles), model.style);
        return newModel;
      }
      return model;
    };
    ItemBase2.prototype.getStateStyle = function(state) {
      var styles = this.get("styles");
      var stateStyle = styles && styles[state];
      return stateStyle;
    };
    ItemBase2.prototype.getOriginStyle = function() {
      return this.get("originStyle");
    };
    ItemBase2.prototype.getCurrentStatesStyle = function() {
      var self2 = this;
      var styles = {};
      var states = self2.getStates();
      if (!states || !states.length) {
        return this.get("originStyle");
      }
      each_default(self2.getStates(), function(state) {
        styles = Object.assign(styles, self2.getStateStyle(state));
      });
      return styles;
    };
    ItemBase2.prototype.setState = function(state, value) {
      var states = this.get("states");
      var shapeFactory = this.get("shapeFactory");
      var stateName = state;
      var filterStateName = state;
      if (is_string_default(value)) {
        stateName = "".concat(state, ":").concat(value);
        filterStateName = "".concat(state, ":");
      }
      var newStates = states;
      if (is_boolean_default(value)) {
        var index2 = states.indexOf(filterStateName);
        if (value) {
          if (index2 > -1) {
            return;
          }
          states.push(stateName);
        } else if (index2 > -1) {
          states.splice(index2, 1);
        }
      } else if (is_string_default(value)) {
        var filterStates = states.filter(function(name) {
          return name.includes(filterStateName);
        });
        if (filterStates.length > 0) {
          this.clearStates(filterStates);
        }
        newStates = newStates.filter(function(name) {
          return !name.includes(filterStateName);
        });
        newStates.push(stateName);
        this.set("states", newStates);
      }
      if (shapeFactory) {
        var model = this.get("model");
        var type = model.type;
        shapeFactory.setState(type, state, value, this);
      }
    };
    ItemBase2.prototype.clearStates = function(states) {
      var self2 = this;
      var originStates = self2.getStates();
      var shapeFactory = self2.get("shapeFactory");
      var model = self2.get("model");
      var shape = model.type;
      if (!states) {
        states = originStates;
      }
      if (is_string_default(states)) {
        states = [states];
      }
      var newStates = originStates.filter(function(state) {
        return states.indexOf(state) === -1;
      });
      self2.set("states", newStates);
      states.forEach(function(state) {
        shapeFactory.setState(shape, state, false, self2);
      });
    };
    ItemBase2.prototype.setOptimize = function(enableOptimize) {
      this.optimize = enableOptimize;
    };
    ItemBase2.prototype.getContainer = function() {
      return this.get("group");
    };
    ItemBase2.prototype.getKeyShape = function() {
      return this.get("keyShape");
    };
    ItemBase2.prototype.getModel = function() {
      return this.get("model");
    };
    ItemBase2.prototype.getType = function() {
      return this.get("type");
    };
    ItemBase2.prototype.getID = function() {
      return this.get("id");
    };
    ItemBase2.prototype.isItem = function() {
      return true;
    };
    ItemBase2.prototype.getStates = function() {
      return this.get("states");
    };
    ItemBase2.prototype.hasState = function(state) {
      var states = this.getStates();
      return states.indexOf(state) >= 0;
    };
    ItemBase2.prototype.refresh = function(updateType) {
      var model = this.get("model");
      this.updatePosition(model);
      this.updateShape(updateType);
      this.afterUpdate();
      this.clearCache();
    };
    ItemBase2.prototype.getUpdateType = function(cfg) {
      return void 0;
    };
    ItemBase2.prototype.update = function(cfg, updateType) {
      if (updateType === void 0) {
        updateType = void 0;
      }
      var model = this.get("model");
      if (updateType === "move") {
        this.updatePosition(cfg);
      } else {
        var oriVisible = model.visible;
        var cfgVisible = cfg.visible;
        if (oriVisible !== cfgVisible && cfgVisible !== void 0) this.changeVisibility(cfgVisible);
        var originPosition = {
          x: model.x,
          y: model.y
        };
        cfg.x = isNaN(+cfg.x) ? model.x : +cfg.x;
        cfg.y = isNaN(+cfg.y) ? model.y : +cfg.y;
        var styles = this.get("styles");
        if (cfg.stateStyles) {
          var stateStyles = cfg.stateStyles;
          mix(styles, stateStyles);
          delete cfg.stateStyles;
        }
        Object.assign(model, cfg);
        if (originPosition.x !== cfg.x || originPosition.y !== cfg.y) {
          this.updatePosition(cfg);
        }
        this.updateShape(updateType);
      }
      this.afterUpdate();
      this.clearCache();
    };
    ItemBase2.prototype.updateShape = function(updateType) {
      var shapeFactory = this.get("shapeFactory");
      var model = this.get("model");
      var shape = model.type;
      if (shapeFactory.shouldUpdate(shape) && shape === this.get("currentShape")) {
        var updateCfg2 = this.getShapeCfg(model, updateType);
        shapeFactory.baseUpdate(shape, updateCfg2, this, updateType);
        if (updateType !== "move") this.setOriginStyle();
      } else {
        this.draw();
      }
      this.restoreStates(shapeFactory, shape);
    };
    ItemBase2.prototype.updatePosition = function(cfg) {
      var model = this.get("model");
      var x4 = isNaN(+cfg.x) ? +model.x : +cfg.x;
      var y4 = isNaN(+cfg.y) ? +model.y : +cfg.y;
      var group = this.get("group");
      if (isNaN(x4) || isNaN(y4)) {
        return false;
      }
      model.x = x4;
      model.y = y4;
      var matrix = group.getMatrix();
      if (matrix && matrix[6] === x4 && matrix[7] === y4) return false;
      group.resetMatrix();
      translate5(group, {
        x: x4,
        y: y4
      });
      this.clearCache();
      return true;
    };
    ItemBase2.prototype.getBBox = function() {
      var bbox = this.get(CACHE_BBOX);
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set(CACHE_BBOX, bbox);
      }
      return bbox;
    };
    ItemBase2.prototype.getCanvasBBox = function() {
      var bbox = this.get(CACHE_CANVAS_BBOX);
      if (!bbox) {
        bbox = this.calculateCanvasBBox();
        this.set(CACHE_CANVAS_BBOX, bbox);
      }
      return bbox;
    };
    ItemBase2.prototype.toFront = function() {
      var group = this.get("group");
      group.toFront();
    };
    ItemBase2.prototype.toBack = function() {
      var group = this.get("group");
      group.toBack();
    };
    ItemBase2.prototype.show = function() {
      this.changeVisibility(true);
    };
    ItemBase2.prototype.hide = function() {
      this.changeVisibility(false);
    };
    ItemBase2.prototype.changeVisibility = function(visible) {
      var group = this.get("group");
      if (visible) {
        group.show();
      } else {
        group.hide();
      }
      this.set("visible", visible);
    };
    ItemBase2.prototype.isVisible = function() {
      return this.get("visible");
    };
    ItemBase2.prototype.enableCapture = function(enable) {
      var group = this.get("group");
      if (group) {
        group.set("capture", enable);
      }
    };
    ItemBase2.prototype.destroy = function() {
      if (!this.destroyed) {
        var animate = this.get("animate");
        var group = this.get("group");
        if (animate) {
          group.stopAnimate();
        }
        group["shapeMap"] = {};
        this.clearCache();
        group.remove();
        this._cfg = null;
        this.destroyed = true;
      }
    };
    return ItemBase2;
  }()
);
var item_default = ItemBase;

// node_modules/@antv/g6-core/es/item/edge.js
var END_MAP = {
  source: "start",
  target: "end"
};
var ITEM_NAME_SUFFIX = "Node";
var POINT_NAME_SUFFIX = "Point";
var ANCHOR_NAME_SUFFIX = "Anchor";
var Edge2 = (
  /** @class */
  function(_super) {
    __extends3(Edge3, _super);
    function Edge3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Edge3.prototype.getDefaultCfg = function() {
      return {
        type: "edge",
        sourceNode: null,
        targetNode: null,
        startPoint: null,
        endPoint: null,
        linkCenter: false
      };
    };
    Edge3.prototype.setEnd = function(name, value) {
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var itemName = name + ITEM_NAME_SUFFIX;
      var preItem = this.get(itemName);
      if (preItem && !preItem.destroyed) {
        preItem.removeEdge(this);
      }
      if (is_plain_object_default(value)) {
        this.set(pointName, value);
        this.set(itemName, null);
      } else if (value) {
        value.addEdge(this);
        this.set(itemName, value);
        this.set(pointName, null);
      }
    };
    Edge3.prototype.getLinkPoint = function(name, model, controlPoints) {
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var itemName = name + ITEM_NAME_SUFFIX;
      var point = this.get(pointName);
      if (!point) {
        var item = this.get(itemName);
        var anchorName = name + ANCHOR_NAME_SUFFIX;
        var prePoint = this.getPrePoint(name, controlPoints);
        var anchorIndex = model[anchorName];
        if (!is_nil_default(anchorIndex)) {
          point = item.getLinkPointByAnchor(anchorIndex);
        }
        point = point || item.getLinkPoint(prePoint);
        if (!is_nil_default(point.index)) {
          this.set("".concat(name, "AnchorIndex"), point.index);
        }
      }
      return point;
    };
    Edge3.prototype.getPrePoint = function(name, controlPoints) {
      if (controlPoints && controlPoints.length) {
        var index2 = name === "source" ? 0 : controlPoints.length - 1;
        return controlPoints[index2];
      }
      var oppositeName = name === "source" ? "target" : "source";
      return this.getEndPoint(oppositeName);
    };
    Edge3.prototype.getEndPoint = function(name) {
      var itemName = name + ITEM_NAME_SUFFIX;
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var item = this.get(itemName);
      if (item && !item.destroyed) {
        return item.get("model");
      }
      return this.get(pointName);
    };
    Edge3.prototype.getControlPointsByCenter = function(model) {
      var sourcePoint = this.getEndPoint("source");
      var targetPoint = this.getEndPoint("target");
      var shapeFactory = this.get("shapeFactory");
      var type = model.type;
      return shapeFactory.getControlPoints(type, {
        startPoint: sourcePoint,
        endPoint: targetPoint
      });
    };
    Edge3.prototype.getEndCenter = function(name) {
      var itemName = name + ITEM_NAME_SUFFIX;
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var item = this.get(itemName);
      if (item) {
        var bbox = item.getBBox();
        return {
          x: bbox.centerX,
          y: bbox.centerY
        };
      }
      return this.get(pointName);
    };
    Edge3.prototype.init = function() {
      _super.prototype.init.call(this);
      this.setSource(this.get("source"));
      this.setTarget(this.get("target"));
    };
    Edge3.prototype.getShapeCfg = function(model, updateType) {
      var self2 = this;
      var linkCenter = self2.get("linkCenter");
      var cfg = (updateType === null || updateType === void 0 ? void 0 : updateType.includes("move")) ? model : _super.prototype.getShapeCfg.call(this, model);
      if (linkCenter) {
        cfg.startPoint = self2.getEndCenter("source");
        cfg.endPoint = self2.getEndCenter("target");
      } else {
        var controlPoints = cfg.controlPoints || self2.getControlPointsByCenter(cfg);
        cfg.startPoint = self2.getLinkPoint("source", model, controlPoints);
        cfg.endPoint = self2.getLinkPoint("target", model, controlPoints);
      }
      cfg.sourceNode = self2.get("sourceNode");
      cfg.targetNode = self2.get("targetNode");
      return cfg;
    };
    Edge3.prototype.getModel = function() {
      var out = this.get("model");
      var sourceItem = this.get("source".concat(ITEM_NAME_SUFFIX));
      var targetItem = this.get("target".concat(ITEM_NAME_SUFFIX));
      if (sourceItem) {
        delete out["source".concat(ITEM_NAME_SUFFIX)];
      } else {
        out.source = this.get("start".concat(POINT_NAME_SUFFIX));
      }
      if (targetItem) {
        delete out["target".concat(ITEM_NAME_SUFFIX)];
      } else {
        out.target = this.get("end".concat(POINT_NAME_SUFFIX));
      }
      if (!is_string_default(out.source) && !is_plain_object_default(out.source)) {
        out.source = out.source.getID();
      }
      if (!is_string_default(out.target) && !is_plain_object_default(out.target)) {
        out.target = out.target.getID();
      }
      return out;
    };
    Edge3.prototype.setSource = function(source) {
      this.setEnd("source", source);
      this.set("source", source);
    };
    Edge3.prototype.setTarget = function(target) {
      this.setEnd("target", target);
      this.set("target", target);
    };
    Edge3.prototype.getSource = function() {
      return this.get("source");
    };
    Edge3.prototype.getTarget = function() {
      return this.get("target");
    };
    Edge3.prototype.updatePosition = function() {
      return false;
    };
    Edge3.prototype.update = function(cfg, updateType) {
      if (updateType === void 0) {
        updateType = void 0;
      }
      var model = this.get("model");
      var oriVisible = model.visible;
      var cfgVisible = cfg.visible;
      if (oriVisible !== cfgVisible && cfgVisible !== void 0) this.changeVisibility(cfgVisible);
      var sourceItem = this.get("source");
      var targetItem = this.get("target");
      if (!sourceItem || sourceItem.destroyed || !targetItem || targetItem.destroyed) return;
      var styles = this.get("styles");
      if (cfg.stateStyles) {
        var stateStyles = cfg.stateStyles;
        mix(styles, stateStyles);
        delete cfg.stateStyles;
      }
      Object.assign(model, cfg);
      this.updateShape(updateType);
      this.afterUpdate();
      this.clearCache();
    };
    Edge3.prototype.destroy = function() {
      var sourceItem = this.get("source".concat(ITEM_NAME_SUFFIX));
      var targetItem = this.get("target".concat(ITEM_NAME_SUFFIX));
      if (sourceItem && !sourceItem.destroyed) {
        sourceItem.removeEdge(this);
      }
      if (targetItem && !targetItem.destroyed) {
        targetItem.removeEdge(this);
      }
      _super.prototype.destroy.call(this);
    };
    return Edge3;
  }(item_default)
);
var edge_default = Edge2;

// node_modules/@antv/g6-core/es/item/node.js
init_esm();
var CACHE_ANCHOR_POINTS = "anchorPointsCache";
var CACHE_BBOX2 = "bboxCache";
var Node2 = (
  /** @class */
  function(_super) {
    __extends3(Node3, _super);
    function Node3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Node3.prototype.getNearestPoint = function(points, curPoint) {
      var index2 = 0;
      var nearestPoint2 = points[0];
      var minDistance = distance4(points[0], curPoint);
      for (var i2 = 0; i2 < points.length; i2++) {
        var point = points[i2];
        var dis = distance4(point, curPoint);
        if (dis < minDistance) {
          nearestPoint2 = point;
          minDistance = dis;
          index2 = i2;
        }
      }
      nearestPoint2.anchorIndex = index2;
      return nearestPoint2;
    };
    Node3.prototype.getDefaultCfg = function() {
      return {
        type: "node",
        edges: []
      };
    };
    Node3.prototype.getEdges = function() {
      return this.get("edges");
    };
    Node3.prototype.getInEdges = function() {
      var self2 = this;
      return this.get("edges").filter(function(edge) {
        return edge.get("target") === self2;
      });
    };
    Node3.prototype.getOutEdges = function() {
      var self2 = this;
      return this.get("edges").filter(function(edge) {
        return edge.get("source") === self2;
      });
    };
    Node3.prototype.getNeighbors = function(type) {
      var _this = this;
      var edges = this.get("edges");
      if (type === "target") {
        var neighborsConverter_1 = function neighborsConverter_12(edge) {
          return edge.getSource() === _this;
        };
        return edges.filter(neighborsConverter_1).map(function(edge) {
          return edge.getTarget();
        });
      }
      if (type === "source") {
        var neighborsConverter_2 = function neighborsConverter_22(edge) {
          return edge.getTarget() === _this;
        };
        return edges.filter(neighborsConverter_2).map(function(edge) {
          return edge.getSource();
        });
      }
      var neighborsConverter = function neighborsConverter2(edge) {
        return edge.getSource() === _this ? edge.getTarget() : edge.getSource();
      };
      return edges.map(neighborsConverter);
    };
    Node3.prototype.getLinkPointByAnchor = function(index2) {
      var anchorPoints = this.getAnchorPoints();
      return anchorPoints[index2];
    };
    Node3.prototype.getLinkPoint = function(point) {
      var keyShape = this.get("keyShape");
      var type = keyShape.get("type");
      var itemType = this.get("type");
      var centerX;
      var centerY;
      var bbox = this.getBBox();
      if (itemType === "combo") {
        centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;
        centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;
      } else {
        centerX = bbox.centerX;
        centerY = bbox.centerY;
      }
      var anchorPoints = this.getAnchorPoints();
      var intersectPoint;
      switch (type) {
        case "circle":
          intersectPoint = getCircleIntersectByPoint({
            x: centerX,
            y: centerY,
            r: bbox.width / 2
          }, point);
          break;
        case "ellipse":
          intersectPoint = getEllipseIntersectByPoint({
            x: centerX,
            y: centerY,
            rx: bbox.width / 2,
            ry: bbox.height / 2
          }, point);
          break;
        default:
          intersectPoint = getRectIntersectByPoint(bbox, point);
      }
      var linkPoint = intersectPoint;
      if (anchorPoints.length) {
        if (!linkPoint) {
          linkPoint = point;
        }
        linkPoint = this.getNearestPoint(anchorPoints, linkPoint);
      }
      if (!linkPoint) {
        linkPoint = {
          x: centerX,
          y: centerY
        };
      }
      return linkPoint;
    };
    Node3.prototype.getAnchorPoints = function() {
      var anchorPoints = this.get(CACHE_ANCHOR_POINTS);
      if (!anchorPoints) {
        anchorPoints = [];
        var shapeFactory = this.get("shapeFactory");
        var bbox_1 = this.getBBox();
        var model = this.get("model");
        var shapeCfg = this.getShapeCfg(model);
        var type = model.type;
        var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];
        each_default(points, function(pointArr, index2) {
          var point = {
            x: bbox_1.minX + pointArr[0] * bbox_1.width,
            y: bbox_1.minY + pointArr[1] * bbox_1.height,
            anchorIndex: index2
          };
          anchorPoints.push(point);
        });
        this.set(CACHE_ANCHOR_POINTS, anchorPoints);
      }
      return anchorPoints;
    };
    Node3.prototype.addEdge = function(edge) {
      this.get("edges").push(edge);
    };
    Node3.prototype.lock = function() {
      this.set("locked", true);
    };
    Node3.prototype.unlock = function() {
      this.set("locked", false);
    };
    Node3.prototype.hasLocked = function() {
      return this.get("locked");
    };
    Node3.prototype.removeEdge = function(edge) {
      var edges = this.getEdges();
      var index2 = edges.indexOf(edge);
      if (index2 > -1) edges.splice(index2, 1);
    };
    Node3.prototype.clearCache = function() {
      this.set(CACHE_BBOX2, null);
      this.set(CACHE_ANCHOR_POINTS, null);
    };
    Node3.prototype.getUpdateType = function(cfg) {
      var _a2, _b, _c, _d, _e2;
      if (!cfg) return void 0;
      var existX = !is_nil_default(cfg.x);
      var existY = !is_nil_default(cfg.y);
      var keys3 = Object.keys(cfg);
      if (keys3.length === 1 && (existX || existY) || keys3.length === 2 && existX && existY) return "move";
      if (is_number_default(cfg.x) || is_number_default(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a2 = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a2 === void 0 ? void 0 : _a2.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e2 = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e2 === void 0 ? void 0 : _e2.ry))) return "bbox|label";
      var updateLabel2 = keys3.includes("label") || keys3.includes("labelCfg");
      return updateLabel2 ? "style|label" : "style";
    };
    Node3.prototype.setState = function(state, value) {
      var _this = this;
      if (this.optimize) {
        _super.prototype.setState.call(this, state, value);
        return;
      }
      this.runWithBBoxAffected(function() {
        return _super.prototype.setState.call(_this, state, value);
      });
    };
    Node3.prototype.clearStates = function(states) {
      var _this = this;
      if (this.optimize) {
        _super.prototype.clearStates.call(this, states);
        return;
      }
      this.runWithBBoxAffected(function() {
        return _super.prototype.clearStates.call(_this, states);
      });
    };
    Node3.prototype.runWithBBoxAffected = function(fn2) {
      var bboxAffectedStyleKeys = ["r", "width", "height", "rx", "ry", "lineWidth"];
      var beforeAttrs = this.getKeyShape().attr();
      var bboxAffectedStyleBefore = {};
      Object.keys(this.getKeyShape().attr()).forEach(function(key2) {
        if (bboxAffectedStyleKeys.includes(key2)) bboxAffectedStyleBefore[key2] = beforeAttrs[key2];
      });
      fn2();
      var afterAttrs = this.getKeyShape().attr();
      for (var i2 = 0; i2 < bboxAffectedStyleKeys.length; i2++) {
        var key = bboxAffectedStyleKeys[i2];
        if (afterAttrs[key] !== bboxAffectedStyleBefore[key]) {
          this.clearCache();
          this.getEdges().forEach(function(edge) {
            return edge.refresh();
          });
          break;
        }
      }
    };
    return Node3;
  }(item_default)
);
var node_default = Node2;

// node_modules/@antv/g6-core/es/item/combo.js
init_esm();
var CACHE_BBOX3 = "bboxCache";
var CACHE_CANVAS_BBOX2 = "bboxCanvasCache";
var CACHE_SIZE = "sizeCache";
var CACHE_ANCHOR_POINTS2 = "anchorPointsCache";
var Combo = (
  /** @class */
  function(_super) {
    __extends3(Combo2, _super);
    function Combo2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Combo2.prototype.getDefaultCfg = function() {
      return {
        type: "combo",
        nodes: [],
        edges: [],
        combos: []
      };
    };
    Combo2.prototype.getShapeCfg = function(model) {
      var styles = this.get("styles");
      var bbox = this.get("bbox");
      if (styles && bbox) {
        var newModel = model;
        var modelSize = is_number_default(model.size) ? [model.size, model.size] : model.size;
        var modelFixSize = is_number_default(model.fixSize) ? [model.fixSize, model.fixSize] : model.fixSize;
        var useModelSize = modelSize || modelFixSize || global_default.defaultCombo.size;
        var size3 = {
          r: (Math.max(bbox.width, bbox.height) || Math.max(useModelSize[0], useModelSize[1])) / 2,
          width: bbox.width || useModelSize[0],
          height: bbox.height || useModelSize[1]
        };
        newModel.style = __assign3(__assign3(__assign3({}, styles), model.style), size3);
        var padding = model.padding || global_default.defaultCombo.padding;
        if (is_number_default(padding)) {
          size3.r += padding;
          size3.width += padding * 2;
          size3.height += padding * 2;
        } else {
          size3.r = size3.r + Math.max.apply(Math, padding);
          size3.width += padding[1] + padding[3] || padding[1] * 2;
          size3.height += padding[0] + padding[2] || padding[0] * 2;
        }
        this.set(CACHE_SIZE, size3);
        return newModel;
      }
      return model;
    };
    Combo2.prototype.calculateCanvasBBox = function() {
      if (this.destroyed) return;
      var keyShape = this.get("keyShape");
      var group = this.get("group");
      var cacheBBox = this.get(CACHE_BBOX3) || {};
      var oriX = cacheBBox.x;
      var oriY = cacheBBox.x;
      var cacheSize = this.get(CACHE_SIZE);
      var bbox = getBBox(keyShape, group);
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      if (cacheSize) {
        cacheSize.width = Math.max(cacheSize.width, bbox.width);
        cacheSize.height = Math.max(cacheSize.height, bbox.height);
        this.set(CACHE_SIZE, cacheSize);
        var type = keyShape.get("type");
        if (type === "circle") {
          bbox.width = cacheSize.r * 2;
          bbox.height = cacheSize.r * 2;
        } else {
          bbox.width = cacheSize.width;
          bbox.height = cacheSize.height;
        }
        bbox.minX = bbox.centerX - bbox.width / 2;
        bbox.minY = bbox.centerY - bbox.height / 2;
        bbox.maxX = bbox.centerX + bbox.width / 2;
        bbox.maxY = bbox.centerY + bbox.height / 2;
      } else {
        bbox.width = bbox.maxX - bbox.minX;
        bbox.height = bbox.maxY - bbox.minY;
        bbox.centerX = (bbox.minX + bbox.maxX) / 2;
        bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      }
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      if (bbox.x !== oriX || bbox.y !== oriY) this.set(CACHE_ANCHOR_POINTS2, null);
      return bbox;
    };
    Combo2.prototype.getChildren = function() {
      var self2 = this;
      return {
        nodes: self2.getNodes(),
        combos: self2.getCombos()
      };
    };
    Combo2.prototype.getNodes = function() {
      var self2 = this;
      return self2.get("nodes");
    };
    Combo2.prototype.getCombos = function() {
      var self2 = this;
      return self2.get("combos");
    };
    Combo2.prototype.addChild = function(item) {
      var self2 = this;
      var itemType = item.getType();
      switch (itemType) {
        case "node":
          self2.addNode(item);
          break;
        case "combo":
          self2.addCombo(item);
          break;
        default:
          console.warn("Only node or combo items are allowed to be added into a combo");
          return false;
      }
      return true;
    };
    Combo2.prototype.addCombo = function(combo) {
      var self2 = this;
      self2.get("combos").push(combo);
      return true;
    };
    Combo2.prototype.addNode = function(node) {
      var self2 = this;
      self2.get("nodes").push(node);
      return true;
    };
    Combo2.prototype.removeChild = function(item) {
      var self2 = this;
      var itemType = item.getType();
      switch (itemType) {
        case "node":
          self2.removeNode(item);
          break;
        case "combo":
          self2.removeCombo(item);
          break;
        default:
          console.warn("Only node or combo items are allowed to be added into a combo");
          return false;
      }
      return true;
    };
    Combo2.prototype.removeCombo = function(combo) {
      if (!combo) return;
      var combos = this.getCombos();
      var index2 = combos.indexOf(combo);
      if (index2 > -1) {
        combos.splice(index2, 1);
        return true;
      }
      return false;
    };
    Combo2.prototype.removeNode = function(node) {
      if (!node) return;
      var nodes = this.getNodes();
      var index2 = nodes.indexOf(node);
      if (index2 > -1) {
        nodes.splice(index2, 1);
        return true;
      }
      return false;
    };
    Combo2.prototype.getUpdateType = function(cfg) {
      return void 0;
    };
    Combo2.prototype.getBBox = function() {
      this.set(CACHE_CANVAS_BBOX2, null);
      var bbox = this.calculateCanvasBBox();
      return bbox;
    };
    Combo2.prototype.clearCache = function() {
      this.set(CACHE_BBOX3, null);
      this.set(CACHE_CANVAS_BBOX2, null);
      this.set(CACHE_ANCHOR_POINTS2, null);
    };
    Combo2.prototype.destroy = function() {
      if (!this.destroyed) {
        var animate = this.get("animate");
        var group = this.get("group");
        if (animate) {
          group.stopAnimate();
        }
        group["shapeMap"] = {};
        this.clearCache();
        this.set(CACHE_SIZE, null);
        this.set("bbox", null);
        group.remove();
        this._cfg = null;
        this.destroyed = true;
      }
    };
    return Combo2;
  }(node_default)
);
var combo_default = Combo;

// node_modules/@antv/g6-core/es/graph/controller/item.js
var NODE = "node";
var EDGE = "edge";
var VEDGE = "vedge";
var COMBO = "combo";
var CFG_PREFIX = "default";
var MAPPER_SUFFIX = "Mapper";
var STATE_SUFFIX = "stateStyles";
var ItemController = (
  /** @class */
  function() {
    function ItemController2(graph) {
      var _this = this;
      this.edgeToBeUpdateMap = {};
      this.throttleRefresh = throttle_default(function(_2) {
        var graph2 = _this.graph;
        if (!graph2 || graph2.get("destroyed")) return;
        var edgeToBeUpdateMap = _this.edgeToBeUpdateMap;
        if (!edgeToBeUpdateMap) return;
        var edgeValues = Object.values(edgeToBeUpdateMap);
        if (!edgeValues.length) return;
        edgeValues.forEach(function(obj) {
          var edge = obj.edge;
          if (!edge || edge.destroyed) return;
          var source = edge.getSource();
          var target = edge.getTarget();
          if (!source || source.destroyed || !target || target.destroyed) return;
          edge.refresh(obj.updateType);
        });
        _this.edgeToBeUpdateMap = {};
      }, 16, {
        trailing: true,
        leading: true
      });
      this.graph = graph;
      this.destroyed = false;
    }
    ItemController2.prototype.addItem = function(type, model) {
      var graph = this.graph;
      var vType = type === VEDGE ? EDGE : type;
      var parent = graph.get("".concat(vType, "Group")) || graph.get("group");
      var upperType = upper_first_default(vType);
      var item = null;
      var styles = graph.get(vType + upper_first_default(STATE_SUFFIX)) || {};
      var defaultModel = graph.get(CFG_PREFIX + upperType);
      if (model[STATE_SUFFIX]) {
        styles = model[STATE_SUFFIX];
      }
      if (defaultModel) {
        each_default(defaultModel, function(val, cfg) {
          if (is_object_default(val) && !is_array_default(val)) {
            model[cfg] = deep_mix_default({}, val, model[cfg]);
          } else if (is_array_default(val)) {
            model[cfg] = model[cfg] || clone_default(defaultModel[cfg]);
          } else {
            model[cfg] = model[cfg] || defaultModel[cfg];
          }
        });
      }
      var mapper = graph.get(vType + MAPPER_SUFFIX);
      if (mapper) {
        var mappedModel_1 = mapper(model);
        if (mappedModel_1[STATE_SUFFIX]) {
          styles = mappedModel_1[STATE_SUFFIX];
          delete mappedModel_1[STATE_SUFFIX];
        }
        each_default(mappedModel_1, function(val, cfg) {
          if (is_object_default(val) && !is_array_default(val)) {
            model[cfg] = deep_mix_default({}, model[cfg], val);
          } else {
            model[cfg] = mappedModel_1[cfg] || model[cfg];
          }
        });
      }
      graph.emit("beforeadditem", {
        type,
        model
      });
      if (type === EDGE || type === VEDGE) {
        var source = void 0;
        var target = void 0;
        source = model.source;
        target = model.target;
        if (source && is_string_default(source)) {
          source = graph.findById(source);
        }
        if (target && is_string_default(target)) {
          target = graph.findById(target);
        }
        if (!source || !target) {
          console.warn("The source or target node of edge ".concat(model.id, " does not exist!"));
          return;
        }
        if (source.getType && source.getType() === "combo") {
          model.isComboEdge = true;
        }
        if (target.getType && target.getType() === "combo") {
          model.isComboEdge = true;
        }
        item = new edge_default({
          model,
          source,
          target,
          styles,
          linkCenter: graph.get("linkCenter"),
          group: parent.addGroup()
        });
      } else if (type === NODE) {
        item = new node_default({
          model,
          styles,
          group: parent.addGroup()
        });
      } else if (type === COMBO) {
        var children = model.children;
        var comboBBox = getComboBBox(children, graph);
        var bboxX = void 0, bboxY = void 0;
        if (!isNaN(comboBBox.x)) bboxX = comboBBox.x;
        else if (isNaN(model.x)) bboxX = Math.random() * 100;
        if (!isNaN(comboBBox.y)) bboxY = comboBBox.y;
        else if (isNaN(model.y)) bboxY = Math.random() * 100;
        if (isNaN(model.x) || isNaN(model.y)) {
          model.x = bboxX;
          model.y = bboxY;
        } else {
          var dx = model.x - bboxX;
          var dy = model.y - bboxY;
          this.updateComboSucceeds(model.id, dx, dy, children);
        }
        var comboGroup = parent.addGroup();
        comboGroup.setZIndex(model.depth);
        item = new combo_default({
          model,
          styles,
          animate: graph.get("animate"),
          bbox: model.collapsed ? getComboBBox([], graph) : comboBBox,
          group: comboGroup
        });
        if (!model.collapsed && item.getKeyShape().get("type") === "circle") {
          comboBBox.width = Math.hypot(comboBBox.height, comboBBox.width);
          comboBBox.height = comboBBox.width;
          item.set("bbox", comboBBox);
          item.refresh();
        }
        var comboModel_1 = item.getModel();
        (children || []).forEach(function(child) {
          var childItem = graph.findById(child.id);
          item.addChild(childItem);
          child.depth = comboModel_1.depth + 2;
        });
      }
      if (item) {
        item.setOptimize(graph.getNodes().length > graph.get("optimizeThreshold"));
        graph.get("".concat(type, "s")).push(item);
        graph.get("itemMap")[item.get("id")] = item;
        graph.emit("afteradditem", {
          item,
          model
        });
        return item;
      }
    };
    ItemController2.prototype.updateItem = function(item, cfg) {
      var _this = this;
      var _a2, _b;
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      if (!item || item.destroyed) {
        return;
      }
      var type = "";
      if (item.getType) type = item.getType();
      var mapper = graph.get(type + MAPPER_SUFFIX);
      var model = item.getModel();
      var oriX = model.x, oriY = model.y;
      var updateType = item.getUpdateType(cfg);
      if (mapper) {
        var result = deep_mix_default({}, model, cfg);
        var mappedModel = mapper(result);
        var newModel = deep_mix_default({}, model, mappedModel, cfg);
        if (mappedModel[STATE_SUFFIX]) {
          item.set("styles", newModel[STATE_SUFFIX]);
          delete newModel[STATE_SUFFIX];
        }
        each_default(newModel, function(val, key) {
          cfg[key] = val;
        });
      } else {
        each_default(cfg, function(val, key) {
          if (model[key]) {
            if (is_object_default(val) && !is_array_default(val)) {
              cfg[key] = __assign3(__assign3({}, model[key]), cfg[key]);
            }
          }
        });
      }
      graph.emit("beforeupdateitem", {
        item,
        cfg
      });
      if (type === EDGE) {
        if (cfg.source) {
          var source = cfg.source;
          if (is_string_default(source)) {
            source = graph.findById(source);
          }
          item.setSource(source);
        }
        if (cfg.target) {
          var target = cfg.target;
          if (is_string_default(target)) {
            target = graph.findById(target);
          }
          item.setTarget(target);
        }
        item.update(cfg);
      } else if (type === NODE) {
        item.update(cfg, updateType);
        var edges = item.getEdges();
        if (updateType === "move") {
          each_default(edges, function(edge) {
            _this.edgeToBeUpdateMap[edge.getID()] = {
              edge,
              updateType
            };
            _this.throttleRefresh();
          });
        } else if (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox")) {
          each_default(edges, function(edge) {
            edge.refresh(updateType);
          });
        }
      } else if (type === COMBO) {
        item.update(cfg, updateType);
        if (!isNaN(cfg.x) || !isNaN(cfg.y)) {
          var dx = cfg.x - oriX || 0;
          var dy = cfg.y - oriY || 0;
          this.updateComboSucceeds(model.id, dx, dy);
        }
        var edges_1 = item.getEdges();
        var refreshEdge = (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox")) || updateType === "move";
        if (refreshEdge && type === COMBO) {
          var shapeFactory = item.get("shapeFactory");
          var shapeType = model.type || "circle";
          var comboAnimate = model.animate === void 0 || cfg.animate === void 0 ? (_b = (_a2 = shapeFactory[shapeType]) === null || _a2 === void 0 ? void 0 : _a2.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate || cfg.animate;
          if (comboAnimate) {
            setTimeout(function() {
              if (!item || item.destroyed) return;
              var keyShape = item.getKeyShape();
              if (!keyShape || keyShape.destroyed) return;
              each_default(edges_1, function(edge) {
                if (edge && !edge.destroyed) edge.refresh();
              });
            }, 201);
          } else {
            each_default(edges_1, function(edge) {
              edge.refresh();
            });
          }
        }
      }
      item.setOptimize(graph.getNodes().length > graph.get("optimizeThreshold"));
      graph.emit("afterupdateitem", {
        item,
        cfg
      });
    };
    ItemController2.prototype.updateCombo = function(combo, children, followCombo) {
      var _this = this;
      var _a2, _b;
      var graph = this.graph;
      if (is_string_default(combo)) {
        combo = graph.findById(combo);
      }
      if (!combo || combo.destroyed) {
        return;
      }
      var model = combo.getModel();
      var comboBBox = getComboBBox(children, graph, combo);
      var comboX = comboBBox.x, comboY = comboBBox.y;
      combo.set("bbox", comboBBox);
      var x4 = comboX, y4 = comboY;
      if (followCombo) {
        x4 = isNaN(model.x) ? comboX : model.x;
        y4 = isNaN(model.y) ? comboY : model.y;
      } else {
        x4 = isNaN(comboX) ? model.x : comboX;
        y4 = isNaN(comboY) ? model.y : comboY;
      }
      combo.update({
        x: x4,
        y: y4
      });
      var shapeFactory = combo.get("shapeFactory");
      var shapeType = model.type || "circle";
      var comboAnimate = model.animate === void 0 ? (_b = (_a2 = shapeFactory[shapeType]) === null || _a2 === void 0 ? void 0 : _a2.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate;
      if (comboAnimate) {
        setTimeout(function() {
          if (!combo || combo.destroyed) return;
          var keyShape = combo.getKeyShape();
          if (!keyShape || keyShape.destroyed) return;
          combo.getShapeCfg(model);
          _this.updateComboEdges(combo);
        }, 201);
      } else {
        this.updateComboEdges(combo);
      }
    };
    ItemController2.prototype.updateComboEdges = function(combo) {
      var _a2, _b;
      var combEdges = combo.getEdges() || [];
      for (var i2 = 0; i2 < combEdges.length; i2++) {
        var edge = combEdges[i2];
        if (!(edge === null || edge === void 0 ? void 0 : edge.destroyed) && !((_a2 = edge === null || edge === void 0 ? void 0 : edge.getSource()) === null || _a2 === void 0 ? void 0 : _a2.destroyed) && !((_b = edge === null || edge === void 0 ? void 0 : edge.getTarget()) === null || _b === void 0 ? void 0 : _b.destroyed)) {
          edge.refresh();
        }
      }
    };
    ItemController2.prototype.collapseCombo = function(combo, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var graph = this.graph;
      if (is_string_default(combo)) {
        combo = graph.findById(combo);
      }
      var children = combo.getChildren();
      children.nodes.forEach(function(node) {
        graph.hideItem(node, stack);
      });
      children.combos.forEach(function(c3) {
        graph.hideItem(c3, stack);
      });
    };
    ItemController2.prototype.updateComboSucceeds = function(comboId, dx, dy, children) {
      var _this = this;
      if (children === void 0) {
        children = [];
      }
      var graph = this.graph;
      if (!dx && !dy) return;
      var kids = children;
      if (!(kids === null || kids === void 0 ? void 0 : kids.length)) {
        var comboTrees = graph.get("comboTrees");
        comboTrees === null || comboTrees === void 0 ? void 0 : comboTrees.forEach(function(child) {
          traverseTree(child, function(subTree) {
            if (subTree.id === comboId) {
              kids = subTree.children;
              return false;
            }
            return true;
          });
        });
      }
      kids === null || kids === void 0 ? void 0 : kids.forEach(function(child) {
        var childItem = graph.findById(child.id);
        if (childItem) {
          var childModel = childItem.getModel();
          _this.updateItem(child.id, {
            x: (childModel.x || 0) + dx,
            y: (childModel.y || 0) + dy
          });
        }
      });
    };
    ItemController2.prototype.expandCombo = function(combo, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var graph = this.graph;
      if (is_string_default(combo)) {
        combo = graph.findById(combo);
      }
      var children = combo.getChildren();
      var edgeSet = /* @__PURE__ */ new Set();
      children.nodes.forEach(function(node) {
        graph.showItem(node, stack);
        node.getEdges().forEach(function(edge) {
          return edgeSet.add(edge);
        });
      });
      children.combos.forEach(function(c3) {
        if (c3.getModel().collapsed) {
          c3.show();
        } else {
          graph.showItem(c3, stack);
        }
        c3.getEdges().forEach(function(edge) {
          return edgeSet.add(edge);
        });
      });
      edgeSet.forEach(function(edge) {
        return edge.refresh();
      });
    };
    ItemController2.prototype.removeItem = function(item) {
      var _this = this;
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      if (!item || item.destroyed) {
        return;
      }
      var itemModel = clone_default(item.getModel());
      var type = "";
      if (item.getType) type = item.getType();
      graph.emit("beforeremoveitem", {
        item: itemModel,
        type
      });
      var items = graph.get("".concat(type, "s"));
      var index2 = items.indexOf(item);
      if (index2 > -1) items.splice(index2, 1);
      if (type === EDGE) {
        var vitems = graph.get("v".concat(type, "s"));
        var vindex = vitems.indexOf(item);
        if (vindex > -1) vitems.splice(vindex, 1);
      }
      var itemId = item.get("id");
      var itemMap = graph.get("itemMap");
      delete itemMap[itemId];
      var comboTrees = graph.get("comboTrees");
      var id = item.get("id");
      if (type === NODE) {
        var comboId = item.getModel().comboId;
        if (comboTrees && comboId) {
          var brothers_1 = comboTrees;
          var found_1 = false;
          comboTrees.forEach(function(ctree) {
            if (found_1) return;
            traverseTree(ctree, function(combo) {
              if (combo.id === id && brothers_1) {
                var bidx = brothers_1.indexOf(combo);
                brothers_1.splice(bidx, 1);
                found_1 = true;
                return false;
              }
              brothers_1 = combo.children;
              return true;
            });
          });
        }
        var edges = item.getEdges();
        for (var i2 = edges.length - 1; i2 >= 0; i2--) {
          graph.removeItem(edges[i2], false);
        }
        if (comboId) graph.updateCombo(comboId);
      } else if (type === COMBO) {
        var parentId = item.getModel().parentId;
        var comboInTree_1;
        var found_2 = false;
        (comboTrees || []).forEach(function(ctree) {
          if (found_2) return;
          traverseTree(ctree, function(combo) {
            if (combo.id === id) {
              comboInTree_1 = combo;
              found_2 = true;
              return false;
            }
            return true;
          });
        });
        comboInTree_1.removed = true;
        if (comboInTree_1 && comboInTree_1.children) {
          comboInTree_1.children.forEach(function(child) {
            _this.removeItem(child.id);
          });
        }
        var edges = item.getEdges();
        for (var i2 = edges.length; i2 >= 0; i2--) {
          graph.removeItem(edges[i2], false);
        }
        if (parentId) graph.updateCombo(parentId);
      }
      item.destroy();
      graph.emit("afterremoveitem", {
        item: itemModel,
        type
      });
    };
    ItemController2.prototype.setItemState = function(item, state, value) {
      var graph = this.graph;
      var stateName = state;
      if (is_string_default(value)) {
        stateName = "".concat(state, ":").concat(value);
      }
      if (item.hasState(stateName) === value && value || // 当该状态已经存在且现在需要设置为 true 时，不需要继续。当该状态不存在，且设置为 false 时，需要继续
      is_string_default(value) && item.hasState(stateName)) {
        return;
      }
      graph.emit("beforeitemstatechange", {
        item,
        state: stateName,
        enabled: value
      });
      item.setState(state, value);
      graph.autoPaint();
      graph.emit("afteritemstatechange", {
        item,
        state: stateName,
        enabled: value
      });
    };
    ItemController2.prototype.priorityState = function(item, state) {
      var graph = this.graph;
      var currentItem = item;
      if (is_string_default(item)) {
        currentItem = graph.findById(item);
      }
      this.setItemState(currentItem, state, false);
      this.setItemState(currentItem, state, true);
    };
    ItemController2.prototype.clearItemStates = function(item, states) {
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      graph.emit("beforeitemstatesclear", {
        item,
        states
      });
      item.clearStates(states);
      graph.emit("afteritemstatesclear", {
        item,
        states
      });
    };
    ItemController2.prototype.refreshItem = function(item) {
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      graph.emit("beforeitemrefresh", {
        item
      });
      item.refresh();
      graph.emit("afteritemrefresh", {
        item
      });
    };
    ItemController2.prototype.addCombos = function(comboTrees, comboModels) {
      var _this = this;
      var graph = this.graph;
      (comboTrees || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          var comboModel;
          comboModels.forEach(function(model) {
            if (model.id === child.id) {
              model.children = child.children;
              model.depth = child.depth;
              comboModel = model;
            }
          });
          if (comboModel) {
            _this.addItem("combo", comboModel);
          }
          return true;
        });
      });
      var comboGroup = graph.get("comboGroup");
      if (comboGroup) comboGroup.sort();
    };
    ItemController2.prototype.changeItemVisibility = function(item, visible) {
      var _this = this;
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      if (!item) {
        console.warn("The item to be shown or hidden does not exist!");
        return;
      }
      graph.emit("beforeitemvisibilitychange", {
        item,
        visible
      });
      item.changeVisibility(visible);
      if (item.getType && item.getType() === NODE) {
        var edges = item.getEdges();
        each_default(edges, function(edge) {
          if (visible && !(edge.get("source").isVisible() && edge.get("target").isVisible())) {
            return;
          }
          _this.changeItemVisibility(edge, visible);
        });
      } else if (item.getType && item.getType() === COMBO) {
        var comboTrees = graph.get("comboTrees");
        var id_1 = item.get("id");
        var children_1 = [];
        var found_3 = false;
        (comboTrees || []).forEach(function(ctree) {
          if (found_3) return;
          if (!ctree.children || ctree.children.length === 0) return;
          traverseTree(ctree, function(combo) {
            if (combo.id === id_1) {
              children_1 = combo.children;
              found_3 = true;
              return false;
            }
            return true;
          });
        });
        if (children_1 && (!visible || visible && !item.getModel().collapsed)) {
          children_1.forEach(function(child) {
            var childItem = graph.findById(child.id);
            _this.changeItemVisibility(childItem, visible);
          });
        }
        var edges = item.getEdges();
        each_default(edges, function(edge) {
          if (visible && !(edge.get("source").isVisible() && edge.get("target").isVisible())) {
            return;
          }
          _this.changeItemVisibility(edge, visible);
        });
      }
      graph.emit("afteritemvisibilitychange", {
        item,
        visible
      });
      return item;
    };
    ItemController2.prototype.destroy = function() {
      this.graph = null;
      this.destroyed = true;
    };
    return ItemController2;
  }()
);
var item_default2 = ItemController;

// node_modules/@antv/g6-core/es/graph/controller/state.js
init_esm();
var StateController = (
  /** @class */
  function() {
    function StateController2(graph) {
      this.graph = graph;
      this.destroyed = false;
    }
    StateController2.prototype.updateState = function(item, state, enabled) {
      var graphStates = this.graph.get("states");
      var key = state;
      if (is_string_default(enabled)) key = "".concat(state, ":").concat(enabled);
      if (!graphStates[key]) graphStates[key] = [];
      if (enabled) graphStates[key].push(item);
      else graphStates[key] = graphStates[key].filter(function(itemInState) {
        return itemInState !== item;
      });
      this.graph.set("states", graphStates);
      this.graph.emit("graphstatechange", {
        states: graphStates
      });
    };
    StateController2.prototype.updateStates = function(item, states, enabled) {
      var graphStates = this.graph.get("states");
      var stateNames = is_string_default(states) ? [states] : states;
      stateNames.forEach(function(stateName) {
        var key = stateName;
        if (!graphStates[key]) graphStates[key] = [];
        if (is_string_default(enabled)) key = "".concat(stateName, ":").concat(enabled);
        if (enabled) graphStates[key].push(item);
        else graphStates[key] = graphStates[key].filter(function(itemInState) {
          return itemInState !== item;
        });
      });
      this.graph.set("states", graphStates);
      this.graph.emit("graphstatechange", {
        states
      });
    };
    StateController2.prototype.destroy = function() {
      this.graph = null;
      this.destroyed = true;
    };
    return StateController2;
  }()
);
var state_default = StateController;

// node_modules/@antv/g6-core/es/item/hull.js
init_esm();

// node_modules/@antv/g6-core/es/util/path.js
var path_exports2 = {};
__export(path_exports2, {
  getClosedSpline: () => getClosedSpline,
  getControlPoint: () => getControlPoint,
  getSpline: () => getSpline,
  getStarPath: () => getStarPath,
  paddedHull: () => paddedHull,
  pathToPoints: () => pathToPoints,
  pointsToPolygon: () => pointsToPolygon,
  roundedHull: () => roundedHull
});
var substitute2 = function substitute3(str10, o2) {
  if (!str10 || !o2) {
    return str10;
  }
  return str10.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    var res = o2[name];
    if (res === 0) res = "0";
    return res || "";
  });
};
var getSpline = function getSpline2(points) {
  var data = [];
  if (points.length < 2) {
    throw new Error("point length must largn than 2, now it's ".concat(points.length));
  }
  for (var _i2 = 0, points_1 = points; _i2 < points_1.length; _i2++) {
    var point = points_1[_i2];
    var x4 = point.x, y4 = point.y;
    data.push(x4);
    data.push(y4);
  }
  var spliePath = catmull_rom_2_bezier_default(data);
  spliePath.unshift(["M", points[0].x, points[0].y]);
  return spliePath;
};
var getControlPoint = function getControlPoint2(startPoint, endPoint, percent, offset) {
  if (percent === void 0) {
    percent = 0;
  }
  if (offset === void 0) {
    offset = 0;
  }
  var point = {
    x: (1 - percent) * startPoint.x + percent * endPoint.x,
    y: (1 - percent) * startPoint.y + percent * endPoint.y
  };
  var tangent = [0, 0];
  vec2_exports.normalize(tangent, [endPoint.x - startPoint.x, endPoint.y - startPoint.y]);
  if (!tangent || !tangent[0] && !tangent[1]) {
    tangent = [0, 0];
  }
  var perpendicular = [-tangent[1] * offset, tangent[0] * offset];
  point.x += perpendicular[0];
  point.y += perpendicular[1];
  return point;
};
var pointsToPolygon = function pointsToPolygon2(points, z2) {
  var length6 = points.length;
  if (!length6) {
    return "";
  }
  var path = "";
  var str10 = "";
  for (var i2 = 0; i2 < length6; i2++) {
    var item = points[i2];
    if (i2 === 0) {
      str10 = "M{x} {y}";
    } else {
      str10 = "L{x} {y}";
    }
    path += substitute2(str10, item);
  }
  if (z2) {
    path += "Z";
  }
  return path;
};
var pathToPoints = function pathToPoints2(path) {
  var points = [];
  path.forEach(function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i2 = 1; i2 < seg.length; i2 = i2 + 2) {
        points.push([seg[i2], seg[i2 + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points;
};
var getClosedSpline = function getClosedSpline2(points) {
  if (points.length < 2) {
    throw new Error("point length must larger than 2, now it's ".concat(points.length));
  }
  var first = points[0];
  var second = points[1];
  var last3 = points[points.length - 1];
  var lastSecond = points[points.length - 2];
  points.unshift(last3);
  points.unshift(lastSecond);
  points.push(first);
  points.push(second);
  var closedPath = [];
  for (var i2 = 1; i2 < points.length - 2; i2 += 1) {
    var x0 = points[i2 - 1].x;
    var y0 = points[i2 - 1].y;
    var x1 = points[i2].x;
    var y1 = points[i2].y;
    var x22 = points[i2 + 1].x;
    var y22 = points[i2 + 1].y;
    var x32 = i2 !== points.length - 2 ? points[i2 + 2].x : x22;
    var y32 = i2 !== points.length - 2 ? points[i2 + 2].y : y22;
    var cp1x = x1 + (x22 - x0) / 6;
    var cp1y = y1 + (y22 - y0) / 6;
    var cp2x = x22 - (x32 - x1) / 6;
    var cp2y = y22 - (y32 - y1) / 6;
    closedPath.push(["C", cp1x, cp1y, cp2x, cp2y, x22, y22]);
  }
  closedPath.unshift(["M", last3.x, last3.y]);
  return closedPath;
};
var vecScaleTo = function vecScaleTo2(v2, length6) {
  return vec2_exports.scale([0, 0], vec2_exports.normalize([0, 0], v2), length6);
};
var unitNormal = function unitNormal2(p0, p1) {
  var n2 = [p0[1] - p1[1], p1[0] - p0[0]];
  var nLength = Math.sqrt(n2[0] * n2[0] + n2[1] * n2[1]);
  if (nLength === 0) {
    throw new Error("p0 should not be equal to p1");
  }
  return [n2[0] / nLength, n2[1] / nLength];
};
var vecFrom = function vecFrom2(p0, p1) {
  return [p1[0] - p0[0], p1[1] - p0[1]];
};
function roundedHull(polyPoints, padding) {
  var roundedHull1 = function roundedHull12(points) {
    var p12 = [points[0][0], points[0][1] - padding];
    var p2 = [points[0][0], points[0][1] + padding];
    return "M ".concat(p12, " A ").concat(padding, ",").concat(padding, ",0,0,0,").concat(p2, " A ").concat(padding, ",").concat(padding, ",0,0,0,").concat(p12);
  };
  var roundedHull2 = function roundedHull22(points) {
    var offsetVector = vec2_exports.scale([0, 0], unitNormal(points[0], points[1]), padding);
    var invOffsetVector = vec2_exports.scale([0, 0], offsetVector, -1);
    var p02 = vec2_exports.add([0, 0], points[0], offsetVector);
    var p12 = vec2_exports.add([0, 0], points[1], offsetVector);
    var p2 = vec2_exports.add([0, 0], points[1], invOffsetVector);
    var p3 = vec2_exports.add([0, 0], points[0], invOffsetVector);
    return "M ".concat(p02, " L ").concat(p12, " A ").concat([padding, padding, "0,0,0", p2].join(","), " L ").concat(p3, " A ").concat([padding, padding, "0,0,0", p02].join(","));
  };
  if (!polyPoints || polyPoints.length < 1) return "";
  if (polyPoints.length === 1) return roundedHull1(polyPoints);
  if (polyPoints.length === 2) return roundedHull2(polyPoints);
  var segments = new Array(polyPoints.length);
  for (var segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {
    var p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];
    var p1 = polyPoints[segmentIndex];
    var offset = vec2_exports.scale([0, 0], unitNormal(p0, p1), padding);
    segments[segmentIndex] = [vec2_exports.add([0, 0], p0, offset), vec2_exports.add([0, 0], p1, offset)];
  }
  var arcData = "A ".concat([padding, padding, "0,0,0,"].join(","));
  segments = segments.map(function(segment, index2) {
    var pathFragment = "";
    if (index2 === 0) {
      pathFragment = "M ".concat(segments[segments.length - 1][1], " ");
    }
    pathFragment += "".concat(arcData + segment[0], " L ").concat(segment[1]);
    return pathFragment;
  });
  return segments.join(" ");
}
function paddedHull(polyPoints, padding) {
  var pointCount = polyPoints.length;
  var smoothHull1 = function smoothHull12(points) {
    var p1 = [points[0][0], points[0][1] - padding];
    var p2 = [points[0][0], points[0][1] + padding];
    return "M ".concat(p1, " A ").concat([padding, padding, "0,0,0", p2].join(","), " A ").concat([padding, padding, "0,0,0", p1].join(","));
  };
  var smoothHull2 = function smoothHull22(points) {
    var v2 = vecFrom(points[0], points[1]);
    var extensionVec2 = vecScaleTo(v2, padding);
    var extension0 = vec2_exports.add([0, 0], points[0], vec2_exports.scale([0, 0], extensionVec2, -1));
    var extension1 = vec2_exports.add([0, 0], points[1], extensionVec2);
    var tangentHalfLength = 1.2 * padding;
    var controlDelta = vecScaleTo(vec2_exports.normalize([0, 0], v2), tangentHalfLength);
    var invControlDelta = vec2_exports.scale([0, 0], controlDelta, -1);
    var control0 = vec2_exports.add([0, 0], extension0, invControlDelta);
    var control1 = vec2_exports.add([0, 0], extension1, invControlDelta);
    var control3 = vec2_exports.add([0, 0], extension0, controlDelta);
    return "M ".concat(extension0, " C ").concat([control0, control1, extension1].join(","), " S ").concat([control3, extension0].join(","), " Z");
  };
  if (!polyPoints || pointCount < 1) return "";
  if (pointCount === 1) return smoothHull1(polyPoints);
  if (pointCount === 2) return smoothHull2(polyPoints);
  var hullPoints = polyPoints.map(function(point, index2) {
    var pNext = polyPoints[(index2 + 1) % pointCount];
    return {
      p: point,
      v: vec2_exports.normalize([0, 0], vecFrom(point, pNext))
    };
  });
  for (var i2 = 0; i2 < hullPoints.length; ++i2) {
    var priorIndex = i2 > 0 ? i2 - 1 : pointCount - 1;
    var extensionVec = vec2_exports.normalize([0, 0], vec2_exports.add([0, 0], hullPoints[priorIndex].v, vec2_exports.scale([0, 0], hullPoints[i2].v, -1)));
    hullPoints[i2].p = vec2_exports.add([0, 0], hullPoints[i2].p, vec2_exports.scale([0, 0], extensionVec, padding));
  }
  return hullPoints.map(function(obj) {
    var point = obj.p;
    return {
      x: point[0],
      y: point[1]
    };
  });
}
var getStarPath = function getStarPath2(outerR, innerR) {
  var path = [];
  for (var i2 = 0; i2 < 5; i2++) {
    var x1 = Math.cos((18 + 72 * i2) / 180 * Math.PI) * outerR;
    var y1 = Math.sin((18 + 72 * i2) / 180 * Math.PI) * outerR;
    var x22 = Math.cos((54 + 72 * i2) / 180 * Math.PI) * innerR;
    var y22 = Math.sin((54 + 72 * i2) / 180 * Math.PI) * innerR;
    if (i2 === 0) {
      path.push(["M", x1, -y1]);
    } else {
      path.push(["L", x1, -y1]);
    }
    path.push(["L", x22, -y22]);
  }
  path.push(["Z"]);
  return path;
};

// node_modules/@antv/g6-core/es/element/hull/convexHull.js
var cross4 = function cross5(a3, b10, o2) {
  return (a3.y - o2.y) * (b10.x - o2.x) - (a3.x - o2.x) * (b10.y - o2.y);
};
var genConvexHull = function genConvexHull2(items) {
  var points = items.map(function(item) {
    return {
      x: item.getModel().x,
      y: item.getModel().y
    };
  });
  points.sort(function(a3, b10) {
    return a3.x === b10.x ? a3.y - b10.y : a3.x - b10.x;
  });
  var pointMap = {};
  for (var i2 = points.length - 1; i2 >= 0; i2--) {
    var _a2 = points[i2], x4 = _a2.x, y4 = _a2.y;
    if (pointMap["".concat(x4, "-").concat(y4)]) points.splice(i2, 1);
    pointMap["".concat(x4, "-").concat(y4)] = true;
  }
  if (points.length === 1) {
    return points;
  }
  var lower = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    while (lower.length >= 2 && cross4(lower[lower.length - 2], lower[lower.length - 1], points[i2]) <= 0) {
      lower.pop();
    }
    lower.push(points[i2]);
  }
  var upper = [];
  for (var i2 = points.length - 1; i2 >= 0; i2--) {
    while (upper.length >= 2 && cross4(upper[upper.length - 2], upper[upper.length - 1], points[i2]) <= 0) {
      upper.pop();
    }
    upper.push(points[i2]);
  }
  upper.pop();
  lower.pop();
  var strictHull = lower.concat(upper);
  return strictHull;
};

// node_modules/@antv/g6-core/es/element/hull/bubbleset.js
var defaultOps = {
  maxRoutingIterations: 100,
  maxMarchingIterations: 100,
  pixelGroupSize: 2,
  edgeR0: 10,
  edgeR1: 10,
  nodeR0: 5,
  nodeR1: 10,
  morphBuffer: 5,
  threshold: 1e-3,
  skip: 16,
  nodeInfluenceFactor: 1,
  edgeInfluenceFactor: 1,
  negativeNodeInfluenceFactor: -0.5
};
function MarchingSquares(contour, potentialArea, threshold) {
  var marched = false;
  var getVal = function getVal2(x4, y4) {
    return potentialArea.cells[x4 + y4 * potentialArea.width];
  };
  var getState = function getState2(x4, y4) {
    var squareVal = 0;
    if (getVal(x4 - 1, y4 - 1) >= threshold) {
      squareVal += 1;
    }
    if (getVal(x4, y4 - 1) > threshold) {
      squareVal += 2;
    }
    if (getVal(x4 - 1, y4) > threshold) {
      squareVal += 4;
    }
    if (getVal(x4, y4) > threshold) {
      squareVal += 8;
    }
    return squareVal;
  };
  var doMarch = function doMarch2(xPos, yPos) {
    var x4 = xPos;
    var y4 = yPos;
    var prevX;
    var prevY;
    for (var i2 = 0; i2 < potentialArea.width * potentialArea.height; i2++) {
      prevX = x4;
      prevY = y4;
      if (contour.findIndex(function(item) {
        return item.x === x4 && item.y === y4;
      }) > -1) {
        if (contour[0].x !== x4 || contour[0].y !== y4) {
        } else {
          return true;
        }
      } else {
        contour.push({
          x: x4,
          y: y4
        });
      }
      var state = getState(x4, y4);
      switch (state) {
        case -1:
          console.warn("Marched out of bounds");
          return true;
        case 0:
        case 3:
        case 2:
        case 7:
          x4++;
          break;
        case 12:
        case 14:
        case 4:
          x4--;
          break;
        case 6:
          if (prevX === 0) {
            if (prevY === -1) {
              x4 -= 1;
            } else {
              x4 += 1;
            }
          }
          break;
        case 1:
        case 13:
        case 5:
          y4--;
          break;
        case 9:
          if (prevX === 1) {
            if (prevY === 0) {
              y4 -= 1;
            } else {
              y4 += 1;
            }
          }
          break;
        case 10:
        case 8:
        case 11:
          y4++;
          break;
        default:
          console.warn("Marching squares invalid state: ".concat(state));
          return true;
      }
    }
  };
  this.march = function() {
    for (var x4 = 0; x4 < potentialArea.width && !marched; x4 += 1) {
      for (var y4 = 0; y4 < potentialArea.height && !marched; y4 += 1) {
        if (getVal(x4, y4) > threshold && getState(x4, y4) !== 15) {
          marched = doMarch(x4, y4);
        }
      }
    }
    return marched;
  };
}
var initGridCells = function initGridCells2(width, height, pixelGroupSize) {
  var scaleWidth = Math.ceil(width / pixelGroupSize);
  var scaleHeight = Math.ceil(height / pixelGroupSize);
  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);
  return {
    cells: gridCells,
    width: scaleWidth,
    height: scaleHeight
  };
};
var pickBestNeighbor = function pickBestNeighbor2(item, visited, nonMembers) {
  var closestNeighbour = null;
  var minCost = Number.POSITIVE_INFINITY;
  visited.forEach(function(neighbourItem) {
    var itemP = {
      x: item.getModel().x,
      y: item.getModel().y
    };
    var neighbourItemP = {
      x: neighbourItem.getModel().x,
      y: neighbourItem.getModel().y
    };
    var dist4 = squareDist(itemP, neighbourItemP);
    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);
    var numberObstacles = nonMembers.reduce(function(count, _item) {
      if (fractionToLine(_item, directLine) > 0) {
        return count + 1;
      }
      return count;
    }, 0);
    if (dist4 * Math.pow(numberObstacles + 1, 2) < minCost) {
      closestNeighbour = neighbourItem;
      minCost = dist4 * Math.pow(numberObstacles + 1, 2);
    }
  });
  return closestNeighbour;
};
var getIntersectItem = function getIntersectItem2(items, line) {
  var minDistance = Number.POSITIVE_INFINITY;
  var closestItem = null;
  items.forEach(function(item) {
    var distance11 = fractionToLine(item, line);
    if (distance11 >= 0 && distance11 < minDistance) {
      closestItem = item;
      minDistance = distance11;
    }
  });
  return closestItem;
};
var computeRoute = function computeRoute2(directLine, nonMembers, maxRoutingIterations, morphBuffer) {
  var checkedLines = [];
  var linesToCheck = [];
  linesToCheck.push(directLine);
  var hasIntersection = true;
  var iterations = 0;
  var pointExists = function pointExists2(point, lines) {
    var flag = false;
    lines.forEach(function(line) {
      if (flag) return;
      if (isPointsOverlap(point, {
        x: line.x1,
        y: line.y1
      }) || isPointsOverlap(point, {
        x: line.x2,
        y: line.y2
      })) {
        flag = true;
      }
    });
    return flag;
  };
  var isPointInNonMembers = function isPointInNonMembers2(point, _nonMembers) {
    for (var _i2 = 0, _nonMembers_1 = _nonMembers; _i2 < _nonMembers_1.length; _i2++) {
      var item = _nonMembers_1[_i2];
      var bbox = item.getBBox();
      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];
      if (isPointInPolygon(itemContour, point.x, point.y)) {
        return true;
      }
    }
    return false;
  };
  while (hasIntersection && iterations < maxRoutingIterations) {
    hasIntersection = false;
    var _loop_1 = function _loop_12() {
      var line = linesToCheck.pop();
      var closestItem = getIntersectItem(nonMembers, line);
      if (closestItem) {
        var _a2 = itemIntersectByLine(closestItem, line), intersections_1 = _a2[0], countIntersections = _a2[1];
        if (countIntersections === 2) {
          var testReroute = function testReroute2(isFirst) {
            var tempMorphBuffer = morphBuffer;
            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);
            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);
            var pointInside = isPointInNonMembers(virtualNode, nonMembers);
            while (!exist && pointInside && tempMorphBuffer >= 1) {
              tempMorphBuffer /= 1.5;
              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);
              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);
              pointInside = isPointInNonMembers(virtualNode, nonMembers);
            }
            if (virtualNode && !exist && (!isFirst || !pointInside)) {
              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));
              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));
              hasIntersection = true;
            }
          };
          testReroute(true);
          if (!hasIntersection) {
            testReroute(false);
          }
        }
      }
      if (!hasIntersection) {
        checkedLines.push(line);
      }
      iterations += 1;
    };
    while (!hasIntersection && linesToCheck.length) {
      _loop_1();
    }
  }
  while (linesToCheck.length) {
    checkedLines.push(linesToCheck.pop());
  }
  return checkedLines;
};
function getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {
  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);
  if (optimalNeighbor === null) {
    return [];
  }
  var mergeLines = function mergeLines2(checkedLines2) {
    var finalRoute2 = [];
    while (checkedLines2.length > 0) {
      var line1 = checkedLines2.pop();
      if (checkedLines2.length === 0) {
        finalRoute2.push(line1);
        break;
      }
      var line2 = checkedLines2.pop();
      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);
      var closestItem = getIntersectItem(nonMembers, mergeLine);
      if (!closestItem) {
        checkedLines2.push(mergeLine);
      } else {
        finalRoute2.push(line1);
        checkedLines2.push(line2);
      }
    }
    return finalRoute2;
  };
  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);
  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);
  var finalRoute = mergeLines(checkedLines);
  return finalRoute;
}
var genBubbleSet = function genBubbleSet2(members, nonMembers, ops) {
  var options = Object.assign(defaultOps, ops);
  var centroid = getPointsCenter(members.map(function(item) {
    return {
      x: item.getModel().x,
      y: item.getModel().y
    };
  }));
  members = members.sort(function(a3, b10) {
    return squareDist({
      x: a3.getModel().x,
      y: a3.getModel().y
    }, centroid) - squareDist({
      x: b10.getModel().x,
      y: b10.getModel().y
    }, centroid);
  });
  var visited = [];
  var virtualEdges = [];
  members.forEach(function(item) {
    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);
    lines.forEach(function(l2) {
      virtualEdges.push(l2);
    });
    visited.push(item);
  });
  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);
  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize);
  var contour = [];
  var hull = [];
  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {
    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);
    contour = [];
    hull = [];
    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;
    var marchedPath = contour.map(function(point) {
      return {
        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),
        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)
      };
    });
    if (marchedPath) {
      var size3 = marchedPath.length;
      if (options.skip > 1) {
        size3 = Math.floor(marchedPath.length / options.skip);
        while (size3 < 3 && options.skip > 1) {
          options.skip -= 1;
          size3 = Math.floor(marchedPath.length / options.skip);
        }
      }
      for (var i2 = 0, j2 = 0; j2 < size3; j2 += 1, i2 += options.skip) {
        hull.push({
          x: marchedPath[i2].x,
          y: marchedPath[i2].y
        });
      }
    }
    var isContourValid = function isContourValid2() {
      for (var _i2 = 0, members_1 = members; _i2 < members_1.length; _i2++) {
        var item = members_1[_i2];
        var hullPoints = hull.map(function(point) {
          return [point.x, point.y];
        });
        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;
      }
      return true;
    };
    if (hull && isContourValid()) {
      return hull;
    }
    options.threshold *= 0.9;
    if (iterations <= options.maxMarchingIterations * 0.5) {
      options.memberInfluenceFactor *= 1.2;
      options.edgeInfluenceFactor *= 1.2;
    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {
      options.nonMemberInfluenceFactor *= 0.8;
    } else {
      break;
    }
  }
  return hull;
};
function getActiveRregion(members, edges, offset) {
  var activeRegion = {
    minX: Number.POSITIVE_INFINITY,
    minY: Number.POSITIVE_INFINITY,
    maxX: Number.NEGATIVE_INFINITY,
    maxY: Number.NEGATIVE_INFINITY,
    width: 0,
    height: 0,
    x: 0,
    y: 0
  };
  var bboxes = [];
  members.forEach(function(item) {
    bboxes.push(item.getBBox());
  });
  edges.forEach(function(l2) {
    bboxes.push(l2.getBBox());
  });
  for (var _i2 = 0, bboxes_1 = bboxes; _i2 < bboxes_1.length; _i2++) {
    var bbox = bboxes_1[_i2];
    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;
    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;
    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;
    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;
  }
  activeRegion.width = activeRegion.maxX - activeRegion.minX;
  activeRegion.height = activeRegion.maxY - activeRegion.minY;
  activeRegion.x = activeRegion.minX;
  activeRegion.y = activeRegion.minY;
  return activeRegion;
}
function fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {
  function pos2GridIx3(x4, offset) {
    var gridIx = Math.floor((x4 - offset) / options.pixelGroupSize);
    return gridIx < 0 ? 0 : gridIx;
  }
  function gridIx2Pos(x4, offset) {
    return x4 * options.pixelGroupSize + offset;
  }
  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);
  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);
  var getAffectedRegion = function getAffectedRegion2(bbox, thresholdR) {
    var startX = Math.min(pos2GridIx3(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);
    var startY = Math.min(pos2GridIx3(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);
    var endX = Math.min(pos2GridIx3(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);
    var endY = Math.min(pos2GridIx3(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);
    return [startX, startY, endX, endY];
  };
  var addItemInfluence = function addItemInfluence2(item, influenceFactor) {
    var bbox = item.getBBox();
    var _a2 = getAffectedRegion(bbox, options.nodeR1), startX = _a2[0], startY = _a2[1], endX = _a2[2], endY = _a2[3];
    for (var y4 = startY; y4 < endY; y4 += 1) {
      for (var x4 = startX; x4 < endX; x4 += 1) {
        if (influenceFactor < 0 && potentialArea[x4 + y4 * potentialArea.width] <= 0) {
          continue;
        }
        var tempX = gridIx2Pos(x4, activeRegion.minX);
        var tempY = gridIx2Pos(y4, activeRegion.minY);
        var distanceSq = pointRectSquareDist({
          x: tempX,
          y: tempY
        }, {
          x: bbox.minX,
          y: bbox.minY,
          width: bbox.width,
          height: bbox.height
        });
        if (distanceSq < Math.pow(options.nodeR1, 2)) {
          var dr2 = Math.sqrt(distanceSq) - options.nodeR1;
          potentialArea.cells[x4 + y4 * potentialArea.width] += influenceFactor * dr2 * dr2;
        }
      }
    }
  };
  var addEdgeInfluence = function addEdgeInfluence2(line, influenceFactor) {
    var bbox = line.getBBox();
    var _a2 = getAffectedRegion(bbox, options.edgeR1), startX = _a2[0], startY = _a2[1], endX = _a2[2], endY = _a2[3];
    for (var y4 = startY; y4 < endY; y4 += 1) {
      for (var x4 = startX; x4 < endX; x4 += 1) {
        if (influenceFactor < 0 && potentialArea.cells[x4 + y4 * potentialArea.width] <= 0) {
          continue;
        }
        var tempX = gridIx2Pos(x4, activeRegion.minX);
        var tempY = gridIx2Pos(y4, activeRegion.minY);
        var minDistanceSq = pointLineSquareDist({
          x: tempX,
          y: tempY
        }, line);
        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {
          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;
          potentialArea.cells[x4 + y4 * potentialArea.width] += influenceFactor * mdr * mdr;
        }
      }
    }
  };
  if (options.nodeInfluenceFactor) {
    members.forEach(function(item) {
      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);
    });
  }
  if (options.edgeInfluenceFactor) {
    edges.forEach(function(edge) {
      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);
    });
  }
  if (options.negativeNodeInfluenceFactor) {
    nonMembers.forEach(function(item) {
      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);
    });
  }
}
function rerouteLine(item, buffer, intersections, wrapNormal) {
  var bbox = item.getBBox();
  var topIntersect = intersections[0], leftIntersect = intersections[1], bottomIntersect = intersections[2], rightIntersect = intersections[3];
  var cornerPos = {
    topLeft: {
      x: bbox.minX - buffer,
      y: bbox.minY - buffer
    },
    topRight: {
      x: bbox.maxX + buffer,
      y: bbox.minY - buffer
    },
    bottomLeft: {
      x: bbox.minX - buffer,
      y: bbox.maxY + buffer
    },
    bottomRight: {
      x: bbox.maxX + buffer,
      y: bbox.maxY + buffer
    }
  };
  var totalArea = bbox.height * bbox.width;
  function calcHalfArea(intersect1, intersect2) {
    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);
  }
  if (leftIntersect) {
    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
    var topArea = calcHalfArea(leftIntersect, rightIntersect);
    if (topArea < totalArea * 0.5) {
      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
    }
    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
  }
  if (rightIntersect) {
    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
  }
  var leftArea = calcHalfArea(topIntersect, bottomIntersect);
  if (leftArea < totalArea * 0.5) {
    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
  }
  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
}

// node_modules/@antv/g6-core/es/item/hull.js
var Hull = (
  /** @class */
  function() {
    function Hull2(graph, cfg) {
      this.cfg = deep_mix_default(this.getDefaultCfg(), cfg);
      this.graph = graph;
      this.id = this.cfg.id;
      this.group = this.cfg.group;
      this.members = this.cfg.members.map(function(item) {
        return is_string_default(item) ? graph.findById(item) : item;
      });
      this.nonMembers = this.cfg.nonMembers.map(function(item) {
        return is_string_default(item) ? graph.findById(item) : item;
      });
      this.setPadding();
      this.setType();
      this.path = this.calcPath(this.members, this.nonMembers);
      this.render();
    }
    Hull2.prototype.getDefaultCfg = function() {
      return {
        id: "g6-hull",
        type: "round-convex",
        members: [],
        nonMembers: [],
        style: {
          fill: "lightblue",
          stroke: "blue",
          opacity: 0.2
        },
        padding: 10
      };
    };
    Hull2.prototype.setPadding = function() {
      var nodeSize = this.members.length && this.members[0].getKeyShape().getCanvasBBox().width / 2;
      this.padding = this.cfg.padding > 0 ? this.cfg.padding + nodeSize : 10 + nodeSize;
      this.cfg.bubbleCfg = {
        nodeR0: this.padding - nodeSize,
        nodeR1: this.padding - nodeSize,
        morphBuffer: this.padding - nodeSize
      };
    };
    Hull2.prototype.setType = function() {
      this.type = this.cfg.type;
      if (this.members.length < 3) {
        this.type = "round-convex";
      }
      if (this.type !== "round-convex" && this.type !== "smooth-convex" && this.type !== "bubble") {
        console.warn("The hull type should be either round-convex, smooth-convex or bubble, round-convex is used by default.");
        this.type = "round-convex";
      }
    };
    Hull2.prototype.calcPath = function(members, nonMembers) {
      var contour, path, hull;
      switch (this.type) {
        case "round-convex":
          contour = genConvexHull(members);
          hull = roundedHull(contour.map(function(p2) {
            return [p2.x, p2.y];
          }), this.padding);
          path = parsePathString2(hull);
          break;
        case "smooth-convex":
          contour = genConvexHull(members);
          if (contour.length === 2) {
            hull = roundedHull(contour.map(function(p2) {
              return [p2.x, p2.y];
            }), this.padding);
            path = parsePathString2(hull);
          } else if (contour.length > 2) {
            hull = paddedHull(contour.map(function(p2) {
              return [p2.x, p2.y];
            }), this.padding);
            path = getClosedSpline(hull);
          }
          break;
        case "bubble":
          contour = genBubbleSet(members, nonMembers, this.cfg.bubbleCfg);
          path = contour.length >= 2 && getClosedSpline(contour);
          break;
        default:
      }
      return path;
    };
    Hull2.prototype.render = function() {
      this.group.addShape("path", {
        attrs: __assign3({
          path: this.path
        }, this.cfg.style),
        id: this.id,
        name: this.cfg.id,
        capture: false
      });
      this.group.toBack();
    };
    Hull2.prototype.addMember = function(item) {
      if (!item) return;
      if (is_string_default(item)) item = this.graph.findById(item);
      this.members.push(item);
      var index2 = this.nonMembers.indexOf(item);
      if (index2 > -1) {
        this.nonMembers.splice(index2, 1);
      }
      this.updateData(this.members, this.nonMembers);
      return true;
    };
    Hull2.prototype.addNonMember = function(item) {
      if (!item) return;
      if (is_string_default(item)) item = this.graph.findById(item);
      this.nonMembers.push(item);
      var index2 = this.members.indexOf(item);
      if (index2 > -1) {
        this.members.splice(index2, 1);
      }
      this.updateData(this.members, this.nonMembers);
      return true;
    };
    Hull2.prototype.removeMember = function(item) {
      if (!item) return;
      if (is_string_default(item)) item = this.graph.findById(item);
      var index2 = this.members.indexOf(item);
      if (index2 > -1) {
        this.members.splice(index2, 1);
        this.updateData(this.members, this.nonMembers);
        return true;
      }
      return false;
    };
    Hull2.prototype.removeNonMember = function(item) {
      if (!item) return;
      if (is_string_default(item)) item = this.graph.findById(item);
      var index2 = this.nonMembers.indexOf(item);
      if (index2 > -1) {
        this.nonMembers.splice(index2, 1);
        this.updateData(this.members, this.nonMembers);
        return true;
      }
      return false;
    };
    Hull2.prototype.updateData = function(members, nonMembers) {
      var _this = this;
      this.group.findById(this.id).remove();
      if (members) this.members = members.map(function(item) {
        return is_string_default(item) ? _this.graph.findById(item) : item;
      });
      if (nonMembers) this.nonMembers = nonMembers.map(function(item) {
        return is_string_default(item) ? _this.graph.findById(item) : item;
      });
      this.path = this.calcPath(this.members, this.nonMembers);
      this.render();
    };
    Hull2.prototype.updateStyle = function(cfg) {
      var path = this.group.findById(this.id);
      path.attr(__assign3({}, cfg));
    };
    Hull2.prototype.updateCfg = function(cfg) {
      var _this = this;
      this.cfg = deep_mix_default(this.cfg, cfg);
      this.id = this.cfg.id;
      this.group = this.cfg.group;
      if (cfg.members) {
        this.members = this.cfg.members.map(function(item) {
          return is_string_default(item) ? _this.graph.findById(item) : item;
        });
      }
      if (cfg.nonMembers) {
        this.nonMembers = this.cfg.nonMembers.map(function(item) {
          return is_string_default(item) ? _this.graph.findById(item) : item;
        });
      }
      this.setPadding();
      this.setType();
      this.path = this.calcPath(this.members, this.nonMembers);
      this.render();
    };
    Hull2.prototype.contain = function(item) {
      var _this = this;
      var nodeItem;
      if (is_string_default(item)) {
        nodeItem = this.graph.findById(item);
      } else {
        nodeItem = item;
      }
      var shapePoints;
      var shape = nodeItem.getKeyShape();
      if (nodeItem.get("type") === "path") {
        shapePoints = pathToPoints(shape.attr("path"));
      } else {
        var shapeBBox = shape.getCanvasBBox();
        shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];
      }
      shapePoints = shapePoints.map(function(canvasPoint) {
        var point = _this.graph.getPointByCanvas(canvasPoint[0], canvasPoint[1]);
        return [point.x, point.y];
      });
      return isPolygonsIntersect(shapePoints, pathToPoints(this.path));
    };
    Hull2.prototype.destroy = function() {
      this.group.remove();
      this.cfg = null;
    };
    return Hull2;
  }()
);
var hull_default = Hull;

// node_modules/@antv/g6-core/es/graph/graph.js
var transform5 = ext_exports.transform;
var NODE2 = "node";
var AbstractGraph = (
  /** @class */
  function(_super) {
    __extends3(AbstractGraph2, _super);
    function AbstractGraph2(cfg) {
      var _this = _super.call(this) || this;
      _this.sortCombos = debounce_default(function() {
        var comboSorted = _this.get("comboSorted");
        if (!_this || _this.destroyed || comboSorted) return;
        _this.set("comboSorted", true);
        var depthMap = [];
        var dataDepthMap = {};
        var comboTrees = _this.get("comboTrees");
        (comboTrees || []).forEach(function(cTree) {
          traverseTree(cTree, function(child) {
            if (depthMap[child.depth]) depthMap[child.depth].push(child.id);
            else depthMap[child.depth] = [child.id];
            dataDepthMap[child.id] = child.depth;
            return true;
          });
        });
        var edges = _this.getEdges().concat(_this.get("vedges"));
        (edges || []).forEach(function(edgeItem) {
          var edge = edgeItem.getModel();
          var sourceDepth = dataDepthMap[edge.source] || 0;
          var targetDepth = dataDepthMap[edge.target] || 0;
          var depth = Math.max(sourceDepth, targetDepth);
          if (depthMap[depth]) depthMap[depth].push(edge.id);
          else depthMap[depth] = [edge.id];
        });
        depthMap.forEach(function(array) {
          if (!array || !array.length) return;
          for (var i2 = array.length - 1; i2 >= 0; i2--) {
            var item = _this.findById(array[i2]);
            if (item) item.toFront();
          }
        });
      }, 500, false);
      _this.cfg = deep_mix_default(_this.getDefaultCfg(), cfg);
      _this.init();
      _this.animating = false;
      _this.destroyed = false;
      if (_this.cfg.enabledStack) {
        _this.undoStack = new stack_default(_this.cfg.maxStep);
        _this.redoStack = new stack_default(_this.cfg.maxStep);
      }
      return _this;
    }
    AbstractGraph2.prototype.init = function() {
      this.initCanvas();
      var viewController = new view_default(this);
      var modeController = new mode_default(this);
      var itemController = new item_default2(this);
      var stateController = new state_default(this);
      this.set({
        viewController,
        modeController,
        itemController,
        stateController
      });
      this.initLayoutController();
      this.initEventController();
      this.initGroups();
      this.initPlugins();
    };
    AbstractGraph2.prototype.initGroups = function() {
      var canvas = this.get("canvas");
      if (!canvas) return;
      var el = canvas.get("el");
      var _a2 = (el || {}).id, id = _a2 === void 0 ? "g6" : _a2;
      var group = canvas.addGroup({
        id: "".concat(id, "-root"),
        className: global_default.rootContainerClassName
      });
      if (this.get("groupByTypes")) {
        var edgeGroup = group.addGroup({
          id: "".concat(id, "-edge"),
          className: global_default.edgeContainerClassName
        });
        var nodeGroup = group.addGroup({
          id: "".concat(id, "-node"),
          className: global_default.nodeContainerClassName
        });
        var comboGroup = group.addGroup({
          id: "".concat(id, "-combo"),
          className: global_default.comboContainerClassName
        });
        comboGroup.toBack();
        this.set({
          nodeGroup,
          edgeGroup,
          comboGroup
        });
      }
      var delegateGroup = group.addGroup({
        id: "".concat(id, "-delegate"),
        className: global_default.delegateContainerClassName
      });
      this.set({
        delegateGroup
      });
      this.set("group", group);
    };
    AbstractGraph2.prototype.getDefaultCfg = function() {
      return {
        /**
         * Container could be dom object or dom id
         */
        container: void 0,
        /**
         * Canvas width
         * unit pixel if undefined force fit width
         */
        width: void 0,
        /**
         * Canvas height
         * unit pixel if undefined force fit height
         */
        height: void 0,
        /**
         * renderer canvas or svg
         * @type {string}
         */
        renderer: "canvas",
        /**
         * control graph behaviors
         */
        modes: {},
        /**
         * 注册插件
         */
        plugins: [],
        /**
         * source data
         */
        data: {},
        /**
         * Fit view padding (client scale)
         */
        fitViewPadding: 10,
        /**
         * Minimum scale size
         */
        minZoom: 0.02,
        /**
         * Maxmum scale size
         */
        maxZoom: 10,
        /**
         *  capture events
         */
        event: true,
        /**
         * group node & edges into different graphic groups
         */
        groupByTypes: true,
        /**
         * determine if it's a directed graph
         */
        directed: false,
        /**
         * when data or shape changed, should canvas draw automatically
         */
        autoPaint: true,
        /**
         * store all the node instances
         */
        nodes: [],
        /**
         * store all the edge instances
         */
        edges: [],
        /**
         * store all the combo instances
         */
        combos: [],
        /**
         * store all the edge instances which are virtual edges related to collapsed combo
         */
        vedges: [],
        /**
         * all the instances indexed by id
         */
        itemMap: {},
        /**
         * 边直接连接到节点的中心，不再考虑锚点
         */
        linkCenter: false,
        /**
         * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：
         * defaultNode: {
         *  type: 'rect',
         *  size: [60, 40],
         *  style: {
         *    //... 样式配置项
         *  }
         * }
         * 若数据项为 { id: 'node', x: 100, y: 100 }
         * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }
         * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }
         * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }
         */
        defaultNode: {},
        /**
         * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode
         */
        defaultEdge: {},
        /**
         * 节点默认样式，也可以添加状态样式
         * 例如：
         * const graph = new G6.Graph({
         *  nodeStateStyles: {
         *    selected: { fill: '#ccc', stroke: '#666' },
         *    active: { lineWidth: 2 }
         *  },
         *  ...
         * });
         *
         */
        nodeStateStyles: {},
        /**
         * 边默认样式，用法同nodeStateStyle
         */
        edgeStateStyles: {},
        /**
         * graph 状态
         */
        states: {},
        /**
         * 是否启用全局动画
         */
        animate: false,
        /**
         * 动画设置,仅在 animate 为 true 时有效
         */
        animateCfg: {
          /**
           * 帧回调函数，用于自定义节点运动路径，为空时线性运动
           */
          onFrame: void 0,
          /**
           * 动画时长(ms)
           */
          duration: 500,
          /**
           * 指定动画动效
           */
          easing: "easeLinear"
        },
        callback: void 0,
        // 默认不启用 undo & redo 功能
        enabledStack: false,
        // 只有当 enabledStack 为 true 时才起作用
        maxStep: 10,
        // 存储图上的 tooltip dom，方便销毁
        tooltips: [],
        // 达到这一节点数量(默认值 1000)，将开启性能优化模式。目前包括：节点状态样式变更是否影响相关边的更新
        optimizeThreshold: 1e3
      };
    };
    AbstractGraph2.prototype.set = function(key, val) {
      if (is_plain_object_default(key)) {
        this.cfg = __assign3(__assign3({}, this.cfg), key);
      } else {
        this.cfg[key] = val;
      }
      if (key === "enabledStack" && val && !this.undoStack && !this.redoStack) {
        this.undoStack = new stack_default(this.cfg.maxStep);
        this.redoStack = new stack_default(this.cfg.maxStep);
      }
      return this;
    };
    AbstractGraph2.prototype.get = function(key) {
      var _a2;
      return (_a2 = this.cfg) === null || _a2 === void 0 ? void 0 : _a2[key];
    };
    AbstractGraph2.prototype.getGroup = function() {
      return this.get("group");
    };
    AbstractGraph2.prototype.getContainer = function() {
      return this.get("container");
    };
    AbstractGraph2.prototype.getMinZoom = function() {
      return this.get("minZoom");
    };
    AbstractGraph2.prototype.setMinZoom = function(ratio) {
      return this.set("minZoom", ratio);
    };
    AbstractGraph2.prototype.getMaxZoom = function() {
      return this.get("maxZoom");
    };
    AbstractGraph2.prototype.setMaxZoom = function(ratio) {
      return this.set("maxZoom", ratio);
    };
    AbstractGraph2.prototype.getWidth = function() {
      return this.get("width");
    };
    AbstractGraph2.prototype.getHeight = function() {
      return this.get("height");
    };
    AbstractGraph2.prototype.clearItemStates = function(item, states) {
      if (is_string_default(item)) {
        item = this.findById(item);
      }
      var itemController = this.get("itemController");
      if (!states) {
        states = item.get("states");
      }
      itemController.clearItemStates(item, states);
      var stateController = this.get("stateController");
      stateController.updateStates(item, states, false);
    };
    AbstractGraph2.prototype.node = function(nodeFn) {
      if (typeof nodeFn === "function") {
        this.set("nodeMapper", nodeFn);
      }
    };
    AbstractGraph2.prototype.edge = function(edgeFn) {
      if (typeof edgeFn === "function") {
        this.set("edgeMapper", edgeFn);
      }
    };
    AbstractGraph2.prototype.combo = function(comboFn) {
      if (typeof comboFn === "function") {
        this.set("comboMapper", comboFn);
      }
    };
    AbstractGraph2.prototype.findById = function(id) {
      return this.get("itemMap")[id];
    };
    AbstractGraph2.prototype.find = function(type, fn2) {
      var result;
      var items = this.get("".concat(type, "s"));
      each_default(items, function(item, i2) {
        if (fn2(item, i2)) {
          result = item;
          return result;
        }
      });
      return result;
    };
    AbstractGraph2.prototype.findAll = function(type, fn2) {
      var result = [];
      each_default(this.get("".concat(type, "s")), function(item, i2) {
        if (fn2(item, i2)) {
          result.push(item);
        }
      });
      return result;
    };
    AbstractGraph2.prototype.findAllByState = function(type, state, additionalFilter) {
      if (additionalFilter) {
        return this.findAll(type, function(item) {
          return item.hasState(state) && additionalFilter(item);
        });
      } else {
        return this.findAll(type, function(item) {
          return item.hasState(state);
        });
      }
    };
    AbstractGraph2.prototype.translate = function(dx, dy, animate, animateCfg) {
      var _this = this;
      var group = this.get("group");
      var matrix = clone_default(group.getMatrix());
      if (!matrix) {
        matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      if (animate) {
        var animateConfig = getAnimateCfgWithCallback({
          animateCfg,
          callback: function callback() {
            return _this.emit("viewportchange", {
              action: "translate",
              matrix: group.getMatrix()
            });
          }
        });
        move(group, {
          x: group.getCanvasBBox().x + dx,
          y: group.getCanvasBBox().y + dy
        }, animate, animateConfig || {
          duration: 500,
          easing: "easeCubic"
        });
      } else {
        matrix = transform5(matrix, [["t", dx, dy]]);
        group.setMatrix(matrix);
        this.emit("viewportchange", {
          action: "translate",
          matrix
        });
        this.autoPaint();
      }
    };
    AbstractGraph2.prototype.moveTo = function(x4, y4, animate, animateCfg) {
      var group = this.get("group");
      move(group, {
        x: x4,
        y: y4
      }, animate, animateCfg || {
        duration: 500,
        easing: "easeCubic"
      });
      this.emit("viewportchange", {
        action: "move",
        matrix: group.getMatrix()
      });
    };
    AbstractGraph2.prototype.fitView = function(padding, rules, animate, animateCfg) {
      if (padding) {
        this.set("fitViewPadding", padding);
      }
      var viewController = this.get("viewController");
      if (rules) {
        viewController.fitViewByRules(rules, animate, animateCfg);
      } else {
        viewController.fitView(animate, animateCfg);
      }
      this.autoPaint();
    };
    AbstractGraph2.prototype.fitCenter = function(animate, animateCfg) {
      var viewController = this.get("viewController");
      viewController.fitCenter(animate, animateCfg);
      this.autoPaint();
    };
    AbstractGraph2.prototype.addBehaviors = function(behaviors2, modes) {
      var modeController = this.get("modeController");
      modeController.manipulateBehaviors(behaviors2, modes, true);
      return this;
    };
    AbstractGraph2.prototype.removeBehaviors = function(behaviors2, modes) {
      var modeController = this.get("modeController");
      modeController.manipulateBehaviors(behaviors2, modes, false);
      return this;
    };
    AbstractGraph2.prototype.updateBehavior = function(behavior, newCfg, mode) {
      var modeController = this.get("modeController");
      modeController.updateBehavior(behavior, newCfg, mode);
      return this;
    };
    AbstractGraph2.prototype.zoom = function(ratio, center, animate, animateCfg) {
      var _this = this;
      var group = this.get("group");
      var matrix = clone_default(group.getMatrix()) || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var minZoom = this.get("minZoom");
      var maxZoom = this.get("maxZoom");
      var currentZoom = this.getZoom() || 1;
      var targetZoom = currentZoom * ratio;
      var finalRatio = ratio;
      var failed = false;
      if (minZoom && targetZoom < minZoom) {
        finalRatio = minZoom / currentZoom;
        failed = true;
      } else if (maxZoom && targetZoom > maxZoom) {
        finalRatio = maxZoom / currentZoom;
        failed = true;
      }
      if (center) {
        matrix = transform5(matrix, [["t", -center.x, -center.y], ["s", finalRatio, finalRatio], ["t", center.x, center.y]]);
      } else {
        matrix = transform5(matrix, [["s", finalRatio, finalRatio]]);
      }
      if (animate) {
        var aniMatrix_1 = clone_default(group.getMatrix());
        if (!aniMatrix_1) {
          aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        }
        var initialRatio_1 = aniMatrix_1[0];
        var targetRatio_1 = initialRatio_1 * finalRatio;
        var animateConfig = getAnimateCfgWithCallback({
          animateCfg,
          callback: function callback() {
            return _this.emit("viewportchange", {
              action: "zoom",
              matrix: group.getMatrix()
            });
          }
        });
        group.animate(function(ratio2) {
          if (ratio2 === 1) {
            aniMatrix_1 = matrix;
          } else {
            var scale12 = lerp6(initialRatio_1, targetRatio_1, ratio2) / aniMatrix_1[0];
            if (center) {
              aniMatrix_1 = transform5(aniMatrix_1, [["t", -center.x, -center.y], ["s", scale12, scale12], ["t", center.x, center.y]]);
            } else {
              aniMatrix_1 = transform5(aniMatrix_1, [["s", scale12, scale12]]);
            }
          }
          return {
            matrix: aniMatrix_1
          };
        }, animateConfig);
      } else {
        group.setMatrix(matrix);
        this.emit("viewportchange", {
          action: "zoom",
          matrix
        });
        this.autoPaint();
      }
      return !failed;
    };
    AbstractGraph2.prototype.zoomTo = function(toRatio, center, animate, animateCfg) {
      var ratio = toRatio / this.getZoom();
      return this.zoom(ratio, center, animate, animateCfg);
    };
    AbstractGraph2.prototype.focusItem = function(item, animate, animateCfg) {
      var viewController = this.get("viewController");
      var isAnimate = false;
      if (animate) isAnimate = true;
      else if (animate === void 0) isAnimate = this.get("animate");
      var curAniamteCfg = {};
      if (animateCfg) curAniamteCfg = animateCfg;
      else if (animateCfg === void 0) curAniamteCfg = this.get("animateCfg");
      viewController.focus(item, isAnimate, curAniamteCfg);
      this.autoPaint();
    };
    AbstractGraph2.prototype.focusItems = function(items, zoomToFit, animate, animateCfg) {
      var viewController = this.get("viewController");
      viewController.focusItems(items, zoomToFit, animate, animateCfg);
    };
    AbstractGraph2.prototype.autoPaint = function() {
      if (this.get("autoPaint")) {
        this.paint();
      }
    };
    AbstractGraph2.prototype.paint = function() {
      this.emit("beforepaint");
      this.get("canvas").draw();
      this.emit("afterpaint");
    };
    AbstractGraph2.prototype.getPointByClient = function(clientX, clientY) {
      var viewController = this.get("viewController");
      return viewController.getPointByClient(clientX, clientY);
    };
    AbstractGraph2.prototype.getClientByPoint = function(x4, y4) {
      var viewController = this.get("viewController");
      return viewController.getClientByPoint(x4, y4);
    };
    AbstractGraph2.prototype.getPointByCanvas = function(canvasX, canvasY) {
      var viewController = this.get("viewController");
      return viewController.getPointByCanvas(canvasX, canvasY);
    };
    AbstractGraph2.prototype.getCanvasByPoint = function(x4, y4) {
      var viewController = this.get("viewController");
      return viewController.getCanvasByPoint(x4, y4);
    };
    AbstractGraph2.prototype.getGraphCenterPoint = function() {
      var bbox = this.get("group").getCanvasBBox();
      return {
        x: (bbox.minX + bbox.maxX) / 2,
        y: (bbox.minY + bbox.maxY) / 2
      };
    };
    AbstractGraph2.prototype.getViewPortCenterPoint = function() {
      return this.getPointByCanvas(this.get("width") / 2, this.get("height") / 2);
    };
    AbstractGraph2.prototype.showItem = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      var object = itemController.changeItemVisibility(item, true);
      if (stack && this.get("enabledStack")) {
        var id = object.getID();
        var type = object.getType();
        var before = {};
        var after = {};
        switch (type) {
          case "node":
            before.nodes = [{
              id,
              visible: false
            }];
            after.nodes = [{
              id,
              visible: true
            }];
            break;
          case "edge":
            before.nodes = [{
              id,
              visible: false
            }];
            after.edges = [{
              id,
              visible: true
            }];
            break;
          case "combo":
            before.nodes = [{
              id,
              visible: false
            }];
            after.combos = [{
              id,
              visible: true
            }];
            break;
          default:
            break;
        }
        this.pushStack("visible", {
          before,
          after
        });
      }
    };
    AbstractGraph2.prototype.hideItem = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      var object = itemController.changeItemVisibility(item, false);
      if (stack && this.get("enabledStack")) {
        var id = object.getID();
        var type = object.getType();
        var before = {};
        var after = {};
        switch (type) {
          case "node":
            before.nodes = [{
              id,
              visible: true
            }];
            after.nodes = [{
              id,
              visible: false
            }];
            break;
          case "edge":
            before.nodes = [{
              id,
              visible: true
            }];
            after.edges = [{
              id,
              visible: false
            }];
            break;
          case "combo":
            before.nodes = [{
              id,
              visible: true
            }];
            after.combos = [{
              id,
              visible: false
            }];
            break;
          default:
            break;
        }
        this.pushStack("visible", {
          before,
          after
        });
      }
    };
    AbstractGraph2.prototype.refreshItem = function(item) {
      var itemController = this.get("itemController");
      itemController.refreshItem(item);
    };
    AbstractGraph2.prototype.setAutoPaint = function(auto) {
      var self2 = this;
      self2.set("autoPaint", auto);
      var canvas = self2.get("canvas");
      canvas.set("autoDraw", auto);
    };
    AbstractGraph2.prototype.remove = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      this.removeItem(item, stack);
    };
    AbstractGraph2.prototype.removeItem = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var nodeItem = item;
      if (is_string_default(item)) nodeItem = this.findById(item);
      if (!nodeItem && is_string_default(item)) {
        console.warn("The item ".concat(item, " to be removed does not exist!"));
      } else if (nodeItem) {
        var type = "";
        if (nodeItem.getType) type = nodeItem.getType();
        if (stack && this.get("enabledStack")) {
          var deletedModel = __assign3(__assign3({}, nodeItem.getModel()), {
            itemType: type
          });
          var before = {};
          switch (type) {
            case "node": {
              before.nodes = [deletedModel];
              before.edges = [];
              var edges = nodeItem.getEdges();
              for (var i2 = edges.length - 1; i2 >= 0; i2--) {
                before.edges.push(__assign3(__assign3({}, edges[i2].getModel()), {
                  itemType: "edge"
                }));
              }
              break;
            }
            case "edge":
              before.edges = [deletedModel];
              break;
            case "combo":
              before.combos = [deletedModel];
              break;
            default:
              break;
          }
          this.pushStack("delete", {
            before,
            after: {}
          });
        }
        if (type === "node") {
          var model = nodeItem.getModel();
          if (model.comboId) {
            this.updateComboTree(nodeItem, void 0, false);
          }
        }
        var itemController = this.get("itemController");
        itemController.removeItem(nodeItem);
        if (type === "combo") {
          var newComboTrees = reconstructTree(this.get("comboTrees"));
          this.set("comboTrees", newComboTrees);
        }
      }
    };
    AbstractGraph2.prototype.innerAddItem = function(type, model, itemController) {
      if (!singleDataValidation(type, model)) {
        return false;
      }
      if (model.id && this.findById(model.id)) {
        console.warn("This item exists already. Be sure the id %c".concat(model.id, "%c is unique."), "font-size: 20px; color: red;", "");
        return;
      }
      var item;
      var comboTrees = this.get("comboTrees") || [];
      if (type === "combo") {
        var itemMap_1 = this.get("itemMap");
        var foundParent_1 = false;
        comboTrees.forEach(function(ctree) {
          if (foundParent_1) return;
          traverseTreeUp(ctree, function(child) {
            if (model.parentId === child.id) {
              foundParent_1 = true;
              var newCombo2 = __assign3({
                id: model.id,
                depth: child.depth + 2
              }, model);
              if (child.children) child.children.push(newCombo2);
              else child.children = [newCombo2];
              model.depth = newCombo2.depth;
              item = itemController.addItem(type, model);
            }
            var childItem = itemMap_1[child.id];
            if (foundParent_1 && childItem && childItem.getType && childItem.getType() === "combo") {
              itemController.updateCombo(childItem, child.children);
            }
            return true;
          });
        });
        if (!foundParent_1) {
          var newCombo = __assign3({
            id: model.id,
            depth: 0
          }, model);
          model.depth = newCombo.depth;
          comboTrees.push(newCombo);
          item = itemController.addItem(type, model);
        }
        this.set("comboTrees", comboTrees);
        if (model.collapsed) {
          this.collapseCombo(item, false);
          this.updateCombo(item);
        }
      } else if (type === "node" && is_string_default(model.comboId) && comboTrees) {
        var parentCombo = this.findById(model.comboId);
        if (parentCombo && parentCombo.getType && parentCombo.getType() !== "combo") {
          console.warn("'".concat(model.comboId, "' is not a id of a combo in the graph, the node will be added without combo."));
        }
        item = itemController.addItem(type, model);
        var itemMap_2 = this.get("itemMap");
        var foundParent_2 = false, foundNode_1 = false;
        comboTrees.forEach(function(ctree) {
          if (foundNode_1 || foundParent_2) return;
          traverseTreeUp(ctree, function(child) {
            if (child.id === model.id) {
              foundNode_1 = true;
              return false;
            }
            if (model.comboId === child.id && !foundNode_1) {
              foundParent_2 = true;
              var cloneNode = clone_default(model);
              cloneNode.itemType = "node";
              if (child.children) child.children.push(cloneNode);
              else child.children = [cloneNode];
              cloneNode.depth = child.depth + 1;
            }
            if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === "combo") {
              itemController.updateCombo(itemMap_2[child.id], child.children);
            }
            return true;
          });
        });
      } else {
        item = itemController.addItem(type, model);
      }
      if (type === "node" && model.comboId || type === "combo" && model.parentId) {
        var parentCombo = this.findById(model.comboId || model.parentId);
        if (parentCombo && parentCombo.getType && parentCombo.getType() === "combo") parentCombo.addChild(item);
      }
      return item;
    };
    AbstractGraph2.prototype.addItem = function(type, model, stack, sortCombo) {
      if (stack === void 0) {
        stack = true;
      }
      if (sortCombo === void 0) {
        sortCombo = true;
      }
      var currentComboSorted = this.get("comboSorted");
      this.set("comboSorted", currentComboSorted && !sortCombo);
      var itemController = this.get("itemController");
      var item = this.innerAddItem(type, model, itemController);
      if (item === false || item === true) {
        return item;
      }
      var combos = this.get("combos");
      if (combos && combos.length > 0) {
        this.sortCombos();
      }
      this.autoPaint();
      if (stack && this.get("enabledStack")) {
        var addedModel = __assign3(__assign3({}, item.getModel()), {
          itemType: type
        });
        var after = {};
        switch (type) {
          case "node":
            after.nodes = [addedModel];
            break;
          case "edge":
            after.edges = [addedModel];
            break;
          case "combo":
            after.combos = [addedModel];
            break;
          default:
            break;
        }
        this.pushStack("add", {
          before: {},
          after
        });
      }
      return item;
    };
    AbstractGraph2.prototype.addItems = function(items, stack, sortCombo) {
      if (items === void 0) {
        items = [];
      }
      if (stack === void 0) {
        stack = true;
      }
      if (sortCombo === void 0) {
        sortCombo = true;
      }
      var currentComboSorted = this.get("comboSorted");
      this.set("comboSorted", currentComboSorted && !sortCombo);
      var itemController = this.get("itemController");
      var returnItems = [];
      for (var i2 = 0; i2 < items.length; i2++) {
        var item = items[i2];
        if (item.type !== "edge" && item.type !== "vedge") {
          returnItems.push(this.innerAddItem(item.type, item.model, itemController));
        } else {
          returnItems.push(void 0);
        }
      }
      for (var i2 = 0; i2 < items.length; i2++) {
        var item = items[i2];
        if (item.type === "edge" || item.type === "vedge") {
          returnItems[i2] = this.innerAddItem(item.type, item.model, itemController);
        }
      }
      if (sortCombo) {
        var combos = this.get("combos");
        if (combos && combos.length > 0) {
          this.sortCombos();
        }
      }
      this.autoPaint();
      if (stack && this.get("enabledStack")) {
        var after = {
          nodes: [],
          edges: [],
          combos: []
        };
        for (var i2 = 0; i2 < items.length; i2++) {
          var type = items[i2].type;
          var returnItem = returnItems[i2];
          if (!!returnItem && returnItem !== true) {
            var addedModel = __assign3(__assign3({}, returnItem.getModel()), {
              itemType: type
            });
            switch (type) {
              case "node":
                after.nodes.push(addedModel);
                break;
              case "edge":
                after.edges.push(addedModel);
                break;
              case "combo":
                after.combos.push(addedModel);
                break;
              default:
                break;
            }
          }
        }
        this.pushStack("addItems", {
          before: {},
          after
        });
      }
      return returnItems;
    };
    AbstractGraph2.prototype.add = function(type, model, stack, sortCombo) {
      if (stack === void 0) {
        stack = true;
      }
      if (sortCombo === void 0) {
        sortCombo = true;
      }
      return this.addItem(type, model, stack, sortCombo);
    };
    AbstractGraph2.prototype.updateItem = function(item, cfg, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      var currentItem;
      if (is_string_default(item)) {
        currentItem = this.findById(item);
      } else {
        currentItem = item;
      }
      var stackEnabled = stack && this.get("enabledStack");
      var unupdatedModel;
      if (stackEnabled) {
        unupdatedModel = clone_default(currentItem.getModel());
      }
      var type = "";
      if (currentItem.getType) type = currentItem.getType();
      var states = __spreadArray2([], currentItem.getStates(), true);
      if (type === "combo") {
        each_default(states, function(state) {
          return _this.setItemState(currentItem, state, false);
        });
      }
      itemController.updateItem(currentItem, cfg);
      if (type === "combo") {
        each_default(states, function(state) {
          return _this.setItemState(currentItem, state, true);
        });
      }
      if (stackEnabled) {
        var before = {
          nodes: [],
          edges: [],
          combos: []
        };
        var after = {
          nodes: [],
          edges: [],
          combos: []
        };
        var afterModel = __assign3({
          id: unupdatedModel.id
        }, cfg);
        switch (type) {
          case "node":
            before.nodes.push(unupdatedModel);
            after.nodes.push(afterModel);
            break;
          case "edge":
            before.edges.push(unupdatedModel);
            after.edges.push(afterModel);
            break;
          case "combo":
            before.combos.push(unupdatedModel);
            after.combos.push(afterModel);
            break;
          default:
            break;
        }
        this.pushStack("update", {
          before,
          after
        });
      }
    };
    AbstractGraph2.prototype.update = function(item, cfg, stack) {
      if (stack === void 0) {
        stack = true;
      }
      this.updateItem(item, cfg, stack);
    };
    AbstractGraph2.prototype.setItemState = function(item, state, value) {
      if (is_string_default(item)) {
        item = this.findById(item);
      }
      var itemController = this.get("itemController");
      itemController.setItemState(item, state, value);
      var stateController = this.get("stateController");
      stateController.updateState(item, state, value);
    };
    AbstractGraph2.prototype.priorityState = function(item, state) {
      var itemController = this.get("itemController");
      itemController.priorityState(item, state);
    };
    AbstractGraph2.prototype.data = function(data) {
      dataValidation(data);
      this.set("data", data);
    };
    AbstractGraph2.prototype.render = function() {
      var self2 = this;
      this.set("comboSorted", false);
      var data = this.get("data");
      if (this.get("enabledStack")) {
        this.clearStack();
      }
      if (!data) {
        throw new Error("data must be defined first");
      }
      var _a2 = data.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = data.edges, edges = _b === void 0 ? [] : _b, _c = data.combos, combos = _c === void 0 ? [] : _c;
      this.clear(true);
      this.emit("beforerender");
      self2.addItems(nodes.map(function(node) {
        return {
          type: "node",
          model: node
        };
      }), false, false);
      if ((combos === null || combos === void 0 ? void 0 : combos.length) !== 0) {
        var comboTrees = plainCombosToTrees(combos, nodes);
        this.set("comboTrees", comboTrees);
        self2.addCombos(combos);
      }
      self2.addItems(edges.map(function(edge) {
        return {
          type: "edge",
          model: edge
        };
      }), false, false);
      var animate = self2.get("animate");
      if (self2.get("fitView") || self2.get("fitCenter")) {
        self2.set("animate", false);
      }
      var layoutController = self2.get("layoutController");
      if (layoutController) {
        layoutController.layout(success);
        if (this.destroyed) return;
      } else {
        success();
      }
      function success() {
        (self2.get("comboTrees") || []).forEach(function(ctree) {
          traverseTreeUp(ctree, function(child) {
            var item = self2.findById(child.id);
            if (item.getType() === "combo" && child.collapsed) {
              self2.collapseCombo(child.id, false);
              self2.updateCombo(item);
            }
            return true;
          });
        });
        if (self2.get("fitView")) {
          self2.fitView();
        } else if (self2.get("fitCenter")) {
          self2.fitCenter();
        }
        self2.autoPaint();
        self2.emit("afterrender");
        if (self2.get("fitView") || self2.get("fitCenter")) {
          self2.set("animate", animate);
        }
        setTimeout(function() {
          var _a3;
          (_a3 = self2.getCombos()) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(combo) {
            combo.set("animate", true);
          });
        }, 0);
      }
      if (!this.get("groupByTypes")) {
        if (combos && combos.length !== 0) {
          this.sortCombos();
        } else {
          if (data.nodes && data.edges && data.nodes.length < data.edges.length) {
            var nodesArr = this.getNodes();
            nodesArr.forEach(function(node) {
              node.toFront();
            });
          } else {
            var edgesArr = this.getEdges();
            edgesArr.forEach(function(edge) {
              edge.toBack();
            });
          }
        }
      }
    };
    AbstractGraph2.prototype.read = function(data) {
      this.data(data);
      this.render();
    };
    AbstractGraph2.prototype.diffItems = function(type, items, models) {
      var self2 = this;
      var item;
      var itemMap = this.get("itemMap");
      each_default(models, function(model) {
        item = itemMap[model.id];
        if (item) {
          if (self2.get("animate") && type === NODE2) {
            var containerMatrix = item.getContainer().getMatrix();
            if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            item.set("originAttrs", {
              x: containerMatrix[6],
              y: containerMatrix[7]
            });
          }
          self2.updateItem(item, model, false);
        } else {
          item = self2.addItem(type, model, false);
        }
        if (item) items["".concat(type, "s")].push(item);
      });
    };
    AbstractGraph2.prototype.changeData = function(propsData, stack) {
      var _this = this;
      var _a2;
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var data = propsData || self2.get("data");
      if (!dataValidation(data)) {
        return this;
      }
      this.emit("beforechangedata");
      if (stack && this.get("enabledStack")) {
        this.pushStack("changedata", {
          before: self2.save(),
          after: data
        });
      }
      this.set("comboSorted", false);
      this.removeHulls();
      this.getNodes().map(function(node) {
        return self2.clearItemStates(node);
      });
      this.getEdges().map(function(edge) {
        return self2.clearItemStates(edge);
      });
      var canvas = this.get("canvas");
      var localRefresh = canvas.get("localRefresh");
      canvas.set("localRefresh", false);
      if (!self2.get("data")) {
        self2.data(data);
        self2.render();
      }
      var itemMap = this.get("itemMap");
      var items = {
        nodes: [],
        edges: []
      };
      var combosData = data.combos;
      if (combosData) {
        var comboTrees = plainCombosToTrees(combosData, data.nodes);
        this.set("comboTrees", comboTrees);
      } else {
        this.set("comboTrees", []);
      }
      this.diffItems("node", items, data.nodes);
      each_default(itemMap, function(item, id) {
        itemMap[id].getModel().depth = 0;
        if (item.getType && item.getType() === "edge") return;
        if (item.getType && item.getType() === "combo") {
          delete itemMap[id];
          item.destroy();
        } else if (items.nodes.indexOf(item) < 0) {
          delete itemMap[id];
          self2.remove(item, false);
        }
      });
      var comboItems = this.getCombos();
      var combosLength = comboItems.length;
      for (var i2 = combosLength - 1; i2 >= 0; i2--) {
        if (comboItems[i2].destroyed) {
          comboItems.splice(i2, 1);
        }
      }
      if (combosData) {
        self2.addCombos(combosData);
        if (!this.get("groupByTypes")) {
          this.sortCombos();
        }
      }
      this.diffItems("edge", items, data.edges);
      each_default(itemMap, function(item, id) {
        if (item.getType && (item.getType() === "node" || item.getType() === "combo")) return;
        if (items.edges.indexOf(item) < 0) {
          delete itemMap[id];
          self2.remove(item, false);
        }
      });
      (this.get("comboTrees") || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          var item = _this.findById(child.id);
          if (item.getType() === "combo" && child.collapsed) {
            _this.collapseCombo(child.id, false);
          }
          return true;
        });
      });
      this.set({
        nodes: items.nodes,
        edges: items.edges
      });
      var _b = (this.get("layout") || {}).relayoutAtChangeData, relayoutAtChangeData = _b === void 0 ? true : _b;
      var layoutController = this.get("layoutController");
      if (relayoutAtChangeData && layoutController) {
        layoutController.changeData(function() {
          setTimeout(function() {
            var _a3;
            (_a3 = self2.getCombos()) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(combo) {
              combo.set("animate", true);
            });
          }, 0);
        });
        if (self2.get("animate") && !layoutController.getLayoutType()) {
          self2.positionsAnimate();
          (_a2 = self2.getCombos()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(combo) {
            return combo.set("animate", true);
          });
        } else {
          self2.autoPaint();
        }
      }
      setTimeout(function() {
        canvas.set("localRefresh", localRefresh);
      }, 16);
      this.set("data", data);
      this.emit("afterchangedata");
      return this;
    };
    AbstractGraph2.prototype.addCombos = function(combos) {
      var self2 = this;
      var comboTrees = self2.get("comboTrees");
      var itemController = this.get("itemController");
      itemController.addCombos(comboTrees, combos);
    };
    AbstractGraph2.prototype.createCombo = function(combo, childrenIds, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      this.set("comboSorted", false);
      var comboId = "";
      var comboConfig;
      if (!combo) return;
      if (is_string_default(combo)) {
        comboId = combo;
        comboConfig = {
          id: combo
        };
      } else {
        comboId = combo.id;
        if (!comboId) {
          console.warn("Create combo failed. Please assign a unique string id for the adding combo.");
          return;
        }
        comboConfig = combo;
      }
      var shouldStack = stack && this.get("enabledStack");
      var childrenParentCache = {
        nodes: [],
        combos: []
      };
      if (shouldStack) {
        childrenIds.forEach(function(childId) {
          var childItem = _this.findById(childId);
          var childType = childItem.getType();
          if (childType !== "node" && childType !== "combo") return;
          var childModel = childItem.getModel();
          childrenParentCache["".concat(childType, "s")].push({
            id: childId,
            parentId: childType === "node" ? childModel.comboId : childModel.parentId
          });
        });
      }
      var comboTrees = this.get("comboTrees");
      var childrenIdsSet = new Set(childrenIds);
      var pulledComboTreesById = /* @__PURE__ */ new Map();
      if (comboTrees) {
        comboTrees.forEach(function(ctree) {
          traverseTreeUp(ctree, function(treeNode, parentTreeNode, index2) {
            if (childrenIdsSet.has(treeNode.id)) {
              if (parentTreeNode) {
                var parentItem = _this.findById(parentTreeNode.id);
                var item = _this.findById(treeNode.id);
                parentTreeNode.children.splice(index2, 1);
                parentItem.removeChild(item);
                itemController.updateCombo(parentItem, parentTreeNode.children);
              }
              if (treeNode.itemType === "combo") {
                pulledComboTreesById.set(treeNode.id, treeNode);
              }
            }
            return true;
          });
        });
        comboTrees = comboTrees.filter(function(ctree) {
          return !childrenIdsSet.has(ctree.id);
        });
        this.set("comboTrees", comboTrees);
      }
      var newChildrenParent = {
        nodes: [],
        combos: []
      };
      var trees = childrenIds.map(function(elementId) {
        var item = _this.findById(elementId);
        var model = item.getModel();
        var type = "";
        if (item.getType) type = item.getType();
        var cItem = pulledComboTreesById.get(elementId) || {
          id: item.getID(),
          itemType: type
        };
        if (type === "combo") {
          cItem.parentId = comboId;
          model.parentId = comboId;
        } else if (type === "node") {
          cItem.comboId = comboId;
          model.comboId = comboId;
        }
        if (shouldStack) {
          newChildrenParent["".concat(type, "s")].push({
            id: model.id,
            parentId: comboId
          });
        }
        return cItem;
      });
      comboConfig.children = trees;
      this.addItem("combo", comboConfig, false);
      this.set("comboSorted", false);
      if (comboTrees) {
        comboTrees.forEach(function(ctree) {
          traverseTree(ctree, function(treeNode) {
            if (treeNode.id === comboId) {
              treeNode.itemType = "combo";
              treeNode.children = trees;
              return false;
            }
            return true;
          });
        });
        this.sortCombos();
      }
      if (shouldStack) {
        newChildrenParent.combos.push(comboConfig);
        this.pushStack("createCombo", {
          before: childrenParentCache,
          after: newChildrenParent
        });
      }
      var comboItem = this.findById(comboId);
      if (!comboItem.getModel().parentId && comboItem.getChildren().combos.length) {
        this.updateComboTree(comboItem, void 0, false);
      }
      setTimeout(function() {
        comboItem.set("animate", true);
      }, 0);
    };
    AbstractGraph2.prototype.uncombo = function(combo, stack) {
      var _this = this;
      var _a2, _b;
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var comboItem = combo;
      if (is_string_default(combo)) {
        comboItem = this.findById(combo);
      }
      if (!comboItem || comboItem.getType && comboItem.getType() !== "combo") {
        console.warn("The item is not a combo!");
        return;
      }
      var comboModel = comboItem.getModel();
      var parentId = comboItem.getModel().parentId;
      var comboTrees = self2.get("comboTrees");
      if (!comboTrees) comboTrees = [];
      var itemMap = this.get("itemMap");
      var comboId = comboItem.get("id");
      var treeToBeUncombo;
      var brothers = [];
      var comboItems = this.get("combos");
      var parentItem = this.findById(parentId);
      var shouldStack = stack && this.get("enabledStack");
      var comboConfig = {};
      if (shouldStack) {
        comboConfig = clone_default(comboModel);
        comboConfig.children = [];
      }
      comboTrees.forEach(function(ctree) {
        if (treeToBeUncombo) return;
        traverseTreeUp(ctree, function(subtree) {
          var _a3;
          if (subtree.id === comboId) {
            treeToBeUncombo = subtree;
            var edgeIds = comboItem.getEdges().map(function(edge) {
              return edge.getID();
            });
            edgeIds.forEach(function(edgeId) {
              _this.removeItem(edgeId, false);
            });
            var index3 = comboItems.indexOf(comboItem);
            comboItems.splice(index3, 1);
            delete itemMap[comboId];
            var itemModel = clone_default(comboItem.getModel());
            comboItem.destroy();
            _this.emit("afterremoveitem", {
              item: itemModel,
              type: "combo"
            });
          }
          if (parentId && treeToBeUncombo && subtree.id === parentId) {
            parentItem.removeCombo(comboItem);
            brothers = subtree.children;
            var index3 = brothers.indexOf(treeToBeUncombo);
            if (index3 !== -1) {
              brothers.splice(index3, 1);
            }
            (_a3 = treeToBeUncombo.children) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(child) {
              var item = _this.findById(child.id);
              var childModel = item.getModel();
              if (item.getType && item.getType() === "combo") {
                child.parentId = parentId;
                delete child.comboId;
                childModel.parentId = parentId;
                delete childModel.comboId;
              } else if (item.getType && item.getType() === "node") {
                child.comboId = parentId;
                childModel.comboId = parentId;
              }
              parentItem.addChild(item);
              brothers.push(child);
            });
            _this.updateCombo(parentItem);
            return false;
          }
          return true;
        });
      });
      if (!parentId && treeToBeUncombo) {
        var index2 = comboTrees.indexOf(treeToBeUncombo);
        comboTrees.splice(index2, 1);
        (_a2 = treeToBeUncombo.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          child.parentId = void 0;
          var childModel = _this.findById(child.id).getModel();
          delete childModel.parentId;
          delete childModel.comboId;
          if (child.itemType !== "node") comboTrees.push(child);
        });
      }
      if (shouldStack) {
        var childrenParentCache_1 = {
          nodes: [],
          combos: []
        };
        var childNewParent_1 = {
          nodes: [],
          combos: []
        };
        (_b = treeToBeUncombo.children) === null || _b === void 0 ? void 0 : _b.forEach(function(child) {
          var childItem = _this.findById(child.id);
          var childType = childItem.getType();
          if (childType !== "node" && childType !== "combo") return;
          childrenParentCache_1["".concat(childType, "s")].push({
            id: child.id,
            parentId: comboId
          });
          childNewParent_1["".concat(childType, "s")].push({
            id: child.id,
            parentId
          });
        });
        childrenParentCache_1.combos.push(comboConfig);
        this.pushStack("uncombo", {
          before: childrenParentCache_1,
          after: childNewParent_1
        });
      }
    };
    AbstractGraph2.prototype.updateCombos = function(followCombo) {
      var _this = this;
      if (followCombo === void 0) {
        followCombo = false;
      }
      var self2 = this;
      var comboTrees = this.get("comboTrees");
      var itemController = self2.get("itemController");
      var itemMap = self2.get("itemMap");
      (comboTrees || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          var _a2;
          if (!child) {
            return true;
          }
          var childItem = itemMap[child.id];
          if (((_a2 = childItem === null || childItem === void 0 ? void 0 : childItem.getType) === null || _a2 === void 0 ? void 0 : _a2.call(childItem)) === "combo") {
            var states = __spreadArray2([], childItem.getStates(), true);
            each_default(states, function(state) {
              return _this.setItemState(childItem, state, false);
            });
            itemController.updateCombo(childItem, child.children, followCombo);
            each_default(states, function(state) {
              return _this.setItemState(childItem, state, true);
            });
          }
          return true;
        });
      });
      self2.sortCombos();
    };
    AbstractGraph2.prototype.updateCombo = function(combo) {
      var _this = this;
      var self2 = this;
      var comboItem = combo;
      var comboId;
      if (is_string_default(combo)) {
        comboItem = this.findById(combo);
      }
      if (!comboItem || comboItem.getType && comboItem.getType() !== "combo") {
        console.warn("The item to be updated is not a combo!");
        return;
      }
      comboId = comboItem.get("id");
      var comboTrees = this.get("comboTrees");
      var itemController = self2.get("itemController");
      var itemMap = self2.get("itemMap");
      (comboTrees || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          if (!child) {
            return true;
          }
          var childItem = itemMap[child.id];
          if (comboId === child.id && childItem && childItem.getType && childItem.getType() === "combo") {
            var states = __spreadArray2([], childItem.getStates(), true);
            each_default(states, function(state) {
              if (childItem.getStateStyle(state)) {
                _this.setItemState(childItem, state, false);
              }
            });
            itemController.updateCombo(childItem, child.children);
            each_default(states, function(state) {
              if (childItem.getStateStyle(state)) {
                _this.setItemState(childItem, state, true);
              }
            });
            if (comboId) comboId = child.parentId;
          }
          return true;
        });
      });
    };
    AbstractGraph2.prototype.updateComboTree = function(item, parentId, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      this.set("comboSorted", false);
      var uItem;
      if (is_string_default(item)) {
        uItem = self2.findById(item);
      } else {
        uItem = item;
      }
      var model = uItem.getModel();
      var oldParentId = model.comboId || model.parentId;
      var type = "";
      if (uItem.getType) type = uItem.getType();
      if (parentId && type === "combo") {
        var comboTrees = this.get("comboTrees");
        var valid_1 = true;
        var itemSubTree_1;
        (comboTrees || []).forEach(function(ctree) {
          if (itemSubTree_1) return;
          traverseTree(ctree, function(subTree) {
            if (itemSubTree_1) return;
            if (subTree.id === uItem.getID()) {
              itemSubTree_1 = subTree;
            }
            return true;
          });
        });
        traverseTree(itemSubTree_1, function(subTree) {
          if (subTree.id === parentId) {
            valid_1 = false;
            return false;
          }
          return true;
        });
        if (!valid_1) {
          console.warn("Failed to update the combo tree! The parentId points to a descendant of the combo!");
          return;
        }
      }
      if (stack && this.get("enabledStack")) {
        var beforeData = {}, afterData = {};
        if (type === "combo") {
          beforeData.combos = [{
            id: model.id,
            parentId: model.parentId
          }];
          afterData.combos = [{
            id: model.id,
            parentId
          }];
        } else if (type === "node") {
          beforeData.nodes = [{
            id: model.id,
            parentId: model.comboId
          }];
          afterData.nodes = [{
            id: model.id,
            parentId
          }];
        }
        this.pushStack("updateComboTree", {
          before: beforeData,
          after: afterData
        });
      }
      if (model.parentId || model.comboId) {
        var combo = this.findById(model.parentId || model.comboId);
        if (combo) {
          combo.removeChild(uItem);
        }
      }
      if (type === "combo") {
        model.parentId = parentId;
      } else if (type === "node") {
        model.comboId = parentId;
      }
      if (parentId) {
        var parentCombo = this.findById(parentId);
        if (parentCombo) {
          parentCombo.addChild(uItem);
        }
      }
      if (oldParentId) {
        var parentCombo = this.findById(oldParentId);
        if (parentCombo) {
          parentCombo.removeChild(uItem);
        }
      }
      var newComboTrees = reconstructTree(this.get("comboTrees"), model.id, parentId);
      this.set("comboTrees", newComboTrees);
      this.updateCombos();
    };
    AbstractGraph2.prototype.save = function() {
      var nodes = [];
      var edges = [];
      var combos = [];
      each_default(this.get("nodes"), function(node) {
        nodes.push(node.getModel());
      });
      each_default(this.get("edges"), function(edge) {
        edges.push(edge.getModel());
      });
      each_default(this.get("combos"), function(combo) {
        combos.push(combo.getModel());
      });
      return {
        nodes,
        edges,
        combos
      };
    };
    AbstractGraph2.prototype.changeSize = function(width, height) {
      var viewController = this.get("viewController");
      viewController.changeSize(width, height);
      return this;
    };
    AbstractGraph2.prototype.refresh = function() {
      var self2 = this;
      self2.emit("beforegraphrefresh");
      if (self2.get("animate")) {
        self2.positionsAnimate();
      } else {
        var nodes = self2.get("nodes");
        var edges = self2.get("edges");
        var vedges = self2.get("edges");
        each_default(nodes, function(node) {
          node.refresh();
        });
        each_default(edges, function(edge) {
          edge.refresh();
        });
        each_default(vedges, function(vedge) {
          vedge.refresh();
        });
      }
      self2.emit("aftergraphrefresh");
      self2.autoPaint();
    };
    AbstractGraph2.prototype.getNodes = function() {
      return this.get("nodes");
    };
    AbstractGraph2.prototype.getEdges = function() {
      return this.get("edges");
    };
    AbstractGraph2.prototype.getCombos = function() {
      return this.get("combos");
    };
    AbstractGraph2.prototype.getComboChildren = function(combo) {
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo || combo.getType && combo.getType() !== "combo") {
        console.warn("The combo does not exist!");
        return;
      }
      return combo.getChildren();
    };
    AbstractGraph2.prototype.positionsAnimate = function(referComboModel) {
      var self2 = this;
      self2.emit("beforeanimate");
      var animateCfg = self2.get("animateCfg");
      var onFrame = animateCfg.onFrame;
      var nodes = referComboModel ? self2.getNodes().concat(self2.getCombos()) : self2.getNodes();
      var toNodes = nodes.map(function(node) {
        var model = node.getModel();
        return {
          id: model.id,
          x: model.x,
          y: model.y
        };
      });
      self2.stopAnimate();
      var canvas = self2.get("canvas");
      self2.animating = true;
      setTimeout(function() {
        canvas.animate(function(ratio) {
          each_default(toNodes, function(data) {
            var node = self2.findById(data.id);
            if (!node || node.destroyed) {
              return;
            }
            var originAttrs = node.get("originAttrs");
            var model = node.get("model");
            var containerMatrix = node.getContainer().getMatrix();
            if (originAttrs === void 0 || originAttrs === null) {
              if (containerMatrix) {
                originAttrs = {
                  x: containerMatrix[6],
                  y: containerMatrix[7]
                };
              }
              node.set("originAttrs", originAttrs || 0);
            }
            if (onFrame) {
              var attrs = onFrame(node, ratio, data, originAttrs || {
                x: 0,
                y: 0
              });
              node.set("model", Object.assign(model, attrs));
            } else if (originAttrs) {
              model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;
              model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;
            } else {
              model.x = data.x;
              model.y = data.y;
            }
          });
          self2.refreshPositions(referComboModel);
        }, {
          duration: animateCfg.duration,
          easing: animateCfg.easing,
          callback: function callback() {
            each_default(nodes, function(node) {
              node.set("originAttrs", null);
            });
            if (animateCfg.callback) {
              animateCfg.callback();
            }
            self2.emit("afteranimate");
            self2.animating = false;
          }
        });
      }, 0);
    };
    AbstractGraph2.prototype.refreshPositions = function(referComboModel) {
      var self2 = this;
      self2.emit("beforegraphrefreshposition");
      var nodes = self2.get("nodes");
      var edges = self2.get("edges");
      var vedges = self2.get("vedges");
      var combos = self2.get("combos");
      var model;
      var updatedNodes = {};
      var updateItems = function updateItems2(items) {
        each_default(items, function(item) {
          model = item.getModel();
          var originAttrs = item.get("originAttrs");
          if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {
            return;
          }
          var changed = item.updatePosition({
            x: model.x,
            y: model.y
          });
          updatedNodes[model.id] = changed;
          if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;
          if (model.parentId) updatedNodes[model.parentId] = updatedNodes[model.parentId] || changed;
        });
      };
      updateItems(combos);
      updateItems(nodes);
      if (combos && combos.length !== 0) {
        if (referComboModel) {
          updateItems(combos);
          self2.updateCombos();
        } else {
          self2.updateCombos();
        }
      }
      each_default(edges, function(edge) {
        var sourceModel = edge.getSource().getModel();
        var target = edge.getTarget();
        if (!is_plain_object_default(target)) {
          var targetModel = target.getModel();
          if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {
            edge.refresh();
          }
        }
      });
      each_default(vedges, function(vedge) {
        vedge.refresh();
      });
      self2.emit("aftergraphrefreshposition");
      self2.autoPaint();
    };
    AbstractGraph2.prototype.stopAnimate = function() {
      var canvas = this.get("canvas");
      var timeline = canvas.cfg.timeline;
      if (timeline) {
        timeline.stopAllAnimations();
      }
    };
    AbstractGraph2.prototype.isAnimating = function() {
      return this.animating;
    };
    AbstractGraph2.prototype.getZoom = function() {
      var matrix = this.get("group").getMatrix();
      return matrix ? matrix[0] : 1;
    };
    AbstractGraph2.prototype.getCurrentMode = function() {
      var modeController = this.get("modeController");
      return modeController.getMode();
    };
    AbstractGraph2.prototype.setMode = function(mode) {
      var modeController = this.get("modeController");
      modeController.setMode(mode);
      return this;
    };
    AbstractGraph2.prototype.clear = function(avoidEmit) {
      var _a2;
      if (avoidEmit === void 0) {
        avoidEmit = false;
      }
      (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.clear();
      this.initGroups();
      this.set({
        itemMap: {},
        nodes: [],
        edges: [],
        vedges: [],
        groups: [],
        combos: [],
        comboTrees: []
      });
      if (!avoidEmit) this.emit("afterrender");
      return this;
    };
    AbstractGraph2.prototype.updateLayout = function(cfg, align, alignPoint, stack) {
      var _this = this;
      if (cfg === void 0) {
        cfg = {};
      }
      if (stack === void 0) {
        stack = true;
      }
      var layoutController = this.get("layoutController");
      if (is_string_default(cfg)) {
        cfg = {
          type: cfg
        };
      }
      if (align) {
        var toPoint_1 = alignPoint;
        if (!toPoint_1) {
          if (align === "begin") toPoint_1 = {
            x: 0,
            y: 0
          };
          else toPoint_1 = {
            x: this.getWidth() / 2,
            y: this.getHeight() / 2
          };
        }
        toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);
        var forceTypes = ["force", "gForce", "fruchterman", "force2"];
        if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {
          cfg.center = [toPoint_1.x, toPoint_1.y];
        } else {
          this.once("afterlayout", function(e8) {
            var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
            toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];
            toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];
            var _a2 = _this.getGroup().getCanvasBBox(), minX = _a2.minX, maxX = _a2.maxX, minY = _a2.minY, maxY = _a2.maxY;
            var bboxPoint = {
              x: (minX + maxX) / 2,
              y: (minY + maxY) / 2
            };
            if (align === "begin") {
              bboxPoint.x = minX;
              bboxPoint.y = minY;
            }
            _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);
          });
        }
      }
      var oriLayoutCfg = __assign3({}, this.get("layout"));
      var layoutCfg = {};
      Object.assign(layoutCfg, oriLayoutCfg, cfg);
      if (cfg.pipes && !cfg.type) delete layoutCfg.type;
      else if (!cfg.pipes && layoutCfg.type) delete layoutCfg.pipes;
      this.set("layout", layoutCfg);
      if (!layoutController) return;
      if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {
        layoutController.updateLayoutCfg(layoutCfg);
      } else {
        layoutController.changeLayout(layoutCfg);
      }
      if (stack && this.get("enabledStack")) {
        this.pushStack("layout", {
          before: oriLayoutCfg,
          after: layoutCfg
        });
      }
    };
    AbstractGraph2.prototype.destroyLayout = function() {
      var layoutController = this.get("layoutController");
      layoutController === null || layoutController === void 0 ? void 0 : layoutController.destroyLayout();
    };
    AbstractGraph2.prototype.layout = function() {
      var _a2;
      var layoutController = this.get("layoutController");
      var layoutCfg = this.get("layout");
      if (!layoutCfg || !layoutController) return;
      if (layoutCfg.workerEnabled) {
        layoutController.layout();
        return;
      }
      if ((_a2 = layoutController.layoutMethods) === null || _a2 === void 0 ? void 0 : _a2.length) {
        layoutController.relayout(true);
      } else {
        layoutController.layout();
      }
    };
    AbstractGraph2.prototype.collapseCombo = function(combo, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      if (this.destroyed) return;
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo) {
        console.warn("The combo to be collapsed does not exist!");
        return;
      }
      this.emit("beforecollapseexpandcombo", {
        action: "collapse",
        item: combo
      });
      var comboModel = combo.getModel();
      var itemController = this.get("itemController");
      itemController.collapseCombo(combo, stack);
      comboModel.collapsed = true;
      var edges = this.getEdges().concat(this.get("vedges"));
      var cNodesCombos = [];
      var comboTrees = this.get("comboTrees");
      var found = false;
      (comboTrees || []).forEach(function(ctree) {
        if (found) return;
        traverseTree(ctree, function(subTree) {
          if (found && subTree.depth <= comboModel.depth) return false;
          if (comboModel.id === subTree.id) found = true;
          if (found) {
            var item = _this.findById(subTree.id);
            if (item && item.getType && item.getType() === "combo") {
              cNodesCombos = cNodesCombos.concat(item.getNodes());
              cNodesCombos = cNodesCombos.concat(item.getCombos());
            }
          }
          return true;
        });
      });
      var addedVEdgeMap = {};
      edges.forEach(function(edge) {
        var _a2 = edge.getModel(), isVEdge = _a2.isVEdge, _b = _a2.size, size3 = _b === void 0 ? 1 : _b;
        if (edge.isVisible() && !isVEdge) return;
        var source = edge.getSource();
        var target = edge.getTarget();
        var otherEnd = null;
        var otherEndIsSource;
        if (source.getModel().id === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {
          otherEnd = target;
          otherEndIsSource = false;
        } else if (target.getModel().id === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {
          otherEnd = source;
          otherEndIsSource = true;
        }
        if (otherEnd) {
          if (isVEdge) {
            _this.removeItem(edge, false);
            return;
          }
          var otherEndModel = otherEnd.getModel();
          while (!otherEnd.isVisible()) {
            var otherEndPId = otherEndModel.parentId, otherEndCId = otherEndModel.comboId;
            var otherEndParentId = otherEndPId || otherEndCId;
            otherEnd = _this.findById(otherEndParentId);
            if (!otherEnd || !otherEndParentId) return;
            otherEndModel = otherEnd.getModel();
          }
          var otherEndId = otherEndModel.id;
          var vEdgeInfo = otherEndIsSource ? {
            source: otherEndId,
            target: comboModel.id,
            size: size3,
            isVEdge: true
          } : {
            source: comboModel.id,
            target: otherEndId,
            size: size3,
            isVEdge: true
          };
          var key = "".concat(vEdgeInfo.source, "-").concat(vEdgeInfo.target);
          if (addedVEdgeMap[key]) {
            addedVEdgeMap[key].size += size3;
            return;
          }
          addedVEdgeMap[key] = vEdgeInfo;
        }
      });
      this.addItems(Object.values(addedVEdgeMap).map(function(edgeInfo) {
        return {
          type: "vedge",
          model: edgeInfo
        };
      }), false);
      this.emit("aftercollapseexpandcombo", {
        action: "collapse",
        item: combo
      });
    };
    AbstractGraph2.prototype.expandCombo = function(combo, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo || combo.getType && combo.getType() !== "combo") {
        console.warn("The combo to be collapsed does not exist!");
        return;
      }
      this.emit("beforecollapseexpandcombo", {
        action: "expand",
        item: combo
      });
      var comboModel = combo.getModel();
      var itemController = this.get("itemController");
      itemController.expandCombo(combo, stack);
      comboModel.collapsed = false;
      var edges = this.getEdges().concat(this.get("vedges"));
      var cNodesCombos = [];
      var comboTrees = this.get("comboTrees");
      var found = false;
      (comboTrees || []).forEach(function(ctree) {
        if (found) return;
        traverseTree(ctree, function(subTree) {
          if (found && subTree.depth <= comboModel.depth) return false;
          if (comboModel.id === subTree.id) found = true;
          if (found) {
            var item = _this.findById(subTree.id);
            if (item && item.getType && item.getType() === "combo") {
              cNodesCombos = cNodesCombos.concat(item.getNodes());
              cNodesCombos = cNodesCombos.concat(item.getCombos());
            }
          }
          return true;
        });
      });
      var addedVEdgeMap = {};
      edges.forEach(function(edge) {
        if (edge.isVisible() && !edge.getModel().isVEdge) return;
        var source = edge.getSource();
        var target = edge.getTarget();
        var sourceId = source.get("id");
        var targetId = target.get("id");
        var otherEnd = null;
        var otherEndIsSource;
        if (sourceId === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {
          otherEnd = target;
          otherEndIsSource = false;
        } else if (targetId === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {
          otherEnd = source;
          otherEndIsSource = true;
        } else if (cNodesCombos.includes(source) && cNodesCombos.includes(target)) {
          if (source.isVisible() && target.isVisible()) {
            edge.show();
          }
        }
        if (otherEnd) {
          var _a2 = edge.getModel(), isVEdge = _a2.isVEdge, _b = _a2.size, size3 = _b === void 0 ? 1 : _b;
          if (isVEdge) {
            _this.removeItem(edge, false);
            return;
          }
          var otherEndModel = otherEnd.getModel();
          while (!otherEnd.isVisible()) {
            var otherEndPId = otherEndModel.parentId, otherEndCId = otherEndModel.comboId;
            var otherEndParentId = otherEndPId || otherEndCId;
            otherEnd = _this.findById(otherEndParentId);
            if (!otherEnd || !otherEndParentId) {
              return;
            }
            otherEndModel = otherEnd.getModel();
          }
          var otherEndId = otherEndModel.id;
          var selfEnd = otherEndIsSource ? target : source;
          var selfEndModel = selfEnd.getModel();
          while (!selfEnd.isVisible()) {
            var selfEndPId = selfEndModel.parentId, selfEndCId = selfEndModel.comboId;
            var selfEndParentId = selfEndPId || selfEndCId;
            selfEnd = _this.findById(selfEndParentId);
            if (!selfEnd || !selfEndParentId) {
              return;
            }
            if (selfEndModel.comboId === comboModel.id || selfEndModel.parentId === comboModel.id) {
              break;
            }
            selfEndModel = selfEnd.getModel();
          }
          var selfEndId = selfEndModel.id;
          if (otherEndId) {
            var vEdgeInfo = otherEndIsSource ? {
              source: otherEndId,
              target: selfEndId,
              isVEdge: true,
              size: size3
            } : {
              source: selfEndId,
              target: otherEndId,
              isVEdge: true,
              size: size3
            };
            var vedgeId = "".concat(vEdgeInfo.source, "-").concat(vEdgeInfo.target);
            if (addedVEdgeMap[vedgeId]) {
              addedVEdgeMap[vedgeId].size += size3;
              return;
            }
            addedVEdgeMap[vedgeId] = vEdgeInfo;
          }
        }
      });
      this.addItems(Object.values(addedVEdgeMap).map(function(edgeInfo) {
        return {
          type: "vedge",
          model: edgeInfo
        };
      }), false);
      this.emit("aftercollapseexpandcombo", {
        action: "expand",
        item: combo
      });
    };
    AbstractGraph2.prototype.collapseExpandCombo = function(combo, stack) {
      if (stack === void 0) {
        stack = true;
      }
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo || combo.getType && combo.getType() !== "combo") return;
      var comboModel = combo.getModel();
      var parentItem = this.findById(comboModel.parentId);
      while (parentItem) {
        var parentModel = parentItem.getModel();
        if (parentModel.collapsed) {
          console.warn("Fail to expand the combo since it's ancestor combo is collapsed.");
          parentItem = void 0;
          return;
        }
        parentItem = this.findById(parentModel.parentId);
      }
      var collapsed = comboModel.collapsed;
      if (collapsed) {
        this.expandCombo(combo, stack);
      } else {
        this.collapseCombo(combo, stack);
      }
      this.updateCombo(combo);
    };
    AbstractGraph2.prototype.getNeighbors = function(node, type) {
      var item = node;
      if (is_string_default(node)) {
        item = this.findById(node);
      }
      return item.getNeighbors(type);
    };
    AbstractGraph2.prototype.getNodeDegree = function(node, type, refresh) {
      if (type === void 0) {
        type = void 0;
      }
      if (refresh === void 0) {
        refresh = false;
      }
      var item = node;
      if (is_string_default(node)) {
        item = this.findById(node);
      }
      var degrees3 = this.get("degrees");
      if (!degrees3 || refresh) {
        degrees3 = degree_default(this.save());
        this.set("degrees", degrees3);
      }
      var nodeDegrees = degrees3[item.getID()];
      var res = 0;
      if (!nodeDegrees) {
        return 0;
      }
      switch (type) {
        case "in":
          res = nodeDegrees.inDegree;
          break;
        case "out":
          res = nodeDegrees.outDegree;
          break;
        case "all":
          res = nodeDegrees;
          break;
        default:
          res = nodeDegrees.degree;
          break;
      }
      return res;
    };
    AbstractGraph2.prototype.getUndoStack = function() {
      return this.undoStack;
    };
    AbstractGraph2.prototype.getRedoStack = function() {
      return this.redoStack;
    };
    AbstractGraph2.prototype.getStackData = function() {
      if (!this.get("enabledStack")) {
        return null;
      }
      return {
        undoStack: this.undoStack.toArray(),
        redoStack: this.redoStack.toArray()
      };
    };
    AbstractGraph2.prototype.clearStack = function() {
      if (this.get("enabledStack")) {
        this.undoStack.clear();
        this.redoStack.clear();
        this.emit("stackchange", {
          undoStack: this.undoStack,
          redoStack: this.redoStack
        });
      }
    };
    AbstractGraph2.prototype.pushStack = function(action, data, stackType) {
      if (action === void 0) {
        action = "update";
      }
      if (stackType === void 0) {
        stackType = "undo";
      }
      if (!this.get("enabledStack")) {
        console.warn("请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !");
        return;
      }
      var stackData = data ? clone_default(data) : {
        before: {},
        after: clone_default(this.save())
      };
      if (stackType === "redo") {
        this.redoStack.push({
          action,
          data: stackData
        });
      } else {
        this.undoStack.push({
          action,
          data: stackData
        });
      }
      this.emit("stackchange", {
        action,
        stackType,
        undoStack: this.undoStack,
        redoStack: this.redoStack
      });
    };
    AbstractGraph2.prototype.getAdjMatrix = function(cache3, directed) {
      if (cache3 === void 0) {
        cache3 = true;
      }
      if (directed === void 0) directed = this.get("directed");
      var currentAdjMatrix = this.get("adjMatrix");
      if (!currentAdjMatrix || !cache3) {
        currentAdjMatrix = adjacent_matrix_default(this.save(), directed);
        this.set("adjMatrix", currentAdjMatrix);
      }
      return currentAdjMatrix;
    };
    AbstractGraph2.prototype.getShortestPathMatrix = function(cache3, directed) {
      if (cache3 === void 0) {
        cache3 = true;
      }
      if (directed === void 0) directed = this.get("directed");
      var currentAdjMatrix = this.get("adjMatrix");
      var currentShourtestPathMatrix = this.get("shortestPathMatrix");
      if (!currentAdjMatrix || !cache3) {
        currentAdjMatrix = adjacent_matrix_default(this.save(), directed);
        this.set("adjMatrix", currentAdjMatrix);
      }
      if (!currentShourtestPathMatrix || !cache3) {
        currentShourtestPathMatrix = floydWarshall_default(this.save(), directed);
        this.set("shortestPathMatrix", currentShourtestPathMatrix);
      }
      return currentShourtestPathMatrix;
    };
    AbstractGraph2.prototype.on = function(eventName, callback, once) {
      return _super.prototype.on.call(this, eventName, callback, once);
    };
    AbstractGraph2.prototype.destroy = function() {
      var _a2, _b, _c, _d, _e2;
      this.emit("beforedestroy");
      this.clear();
      this.clearStack();
      (_a2 = this.get("itemController")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.get("modeController")) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.get("viewController")) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.get("stateController")) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e2 = this.get("canvas")) === null || _e2 === void 0 ? void 0 : _e2.destroy();
      this.cfg = null;
      this.destroyed = true;
      this.redoStack = null;
      this.undoStack = null;
      this.emit("afterdestroy");
    };
    AbstractGraph2.prototype.createHull = function(cfg) {
      if (!cfg.members || cfg.members.length < 1) {
        console.warn("Create hull failed! The members is empty.");
        return;
      }
      var parent = this.get("hullGroup");
      var hullMap = this.get("hullMap");
      if (!hullMap) {
        hullMap = {};
        this.set("hullMap", hullMap);
      }
      if (!parent || parent.get("destroyed")) {
        parent = this.get("group").addGroup({
          id: "hullGroup"
        });
        parent.toBack();
        this.set("hullGroup", parent);
      }
      if (hullMap[cfg.id]) {
        console.warn("Existed hull id.");
        return hullMap[cfg.id];
      }
      var group = parent.addGroup({
        id: "".concat(cfg.id, "-container")
      });
      var hull = new hull_default(this, __assign3(__assign3({}, cfg), {
        group
      }));
      var hullId = hull.id;
      hullMap[hullId] = hull;
      return hull;
    };
    AbstractGraph2.prototype.getHulls = function() {
      return this.get("hullMap");
    };
    AbstractGraph2.prototype.getHullById = function(hullId) {
      return this.get("hullMap")[hullId];
    };
    AbstractGraph2.prototype.removeHull = function(hull) {
      var _a2;
      var hullInstance;
      if (is_string_default(hull)) {
        hullInstance = this.getHullById(hull);
      } else {
        hullInstance = hull;
      }
      (_a2 = this.get("hullMap")) === null || _a2 === void 0 ? true : delete _a2[hullInstance.id];
      hullInstance.destroy();
    };
    AbstractGraph2.prototype.removeHulls = function() {
      var hulls = this.getHulls();
      if (!hulls || !Object.keys(hulls).length) return;
      Object.keys(hulls).forEach(function(key) {
        var hull = hulls[key];
        hull.destroy();
      });
      this.set("hullMap", {});
    };
    return AbstractGraph2;
  }(esm_default)
);
var graph_default = AbstractGraph;

// node_modules/@antv/g6-core/es/element/node.js
init_esm();

// node_modules/@antv/g6-core/es/element/shapeBase.js
init_esm();
function _typeof2(o2) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof2(o2);
}
var transform6 = ext_exports.transform;
var CLS_SHAPE_SUFFIX = "-shape";
var CLS_LABEL_SUFFIX = "-label";
var ARROWS = ["startArrow", "endArrow"];
var SHAPE_DEFAULT_ATTRS = {
  lineWidth: 1,
  stroke: void 0,
  fill: void 0,
  lineAppendWidth: 1,
  opacity: void 0,
  strokeOpacity: void 0,
  fillOpacity: void 0,
  x: 0,
  y: 0,
  r: 10,
  width: 20,
  height: 20,
  shadowColor: void 0,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var PATH_SHAPE_DEFAULT_ATTRS = {
  lineWidth: 1,
  stroke: "#000",
  lineDash: void 0,
  startArrow: false,
  endArrow: false,
  opacity: void 0,
  strokeOpacity: void 0,
  fillOpacity: void 0,
  shadowColor: void 0,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var SHAPES_DEFAULT_ATTRS = {
  edge: PATH_SHAPE_DEFAULT_ATTRS,
  node: SHAPE_DEFAULT_ATTRS,
  combo: SHAPE_DEFAULT_ATTRS
};
var CLS_LABEL_BG_SUFFIX = "-label-bg";
var shapeBase = {
  // 默认样式及配置
  options: {
    labelCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    },
    descriptionCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    }
  },
  itemType: "",
  /**
   * 形状的类型，例如 circle，ellipse，polyline...
   */
  type: "",
  getCustomConfig: function getCustomConfig(cfg) {
    return {};
  },
  getOptions: function getOptions(cfg, updateType) {
    if (updateType === "move" || (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox"))) return cfg;
    return deep_mix_default({}, this.options, this.getCustomConfig(cfg) || {}, cfg);
  },
  /**
   * 绘制节点/边，包含文本
   * @override
   * @param  {Object} cfg 节点的配置项
   * @param  {G.Group} group 节点的容器
   * @return {IShape} 绘制的图形
   */
  draw: function draw3(cfg, group) {
    group["shapeMap"] = {};
    this.mergeStyle = this.getOptions(cfg);
    var shape = this.drawShape(cfg, group);
    shape.set("className", this.itemType + CLS_SHAPE_SUFFIX);
    group["shapeMap"][this.itemType + CLS_SHAPE_SUFFIX] = shape;
    if (cfg.label) {
      var label = this.drawLabel(cfg, group);
      label.set("className", this.itemType + CLS_LABEL_SUFFIX);
      group["shapeMap"][this.itemType + CLS_LABEL_SUFFIX] = label;
    }
    return shape;
  },
  /**
   * 绘制完成后的操作，便于用户继承现有的节点、边
   * @param cfg
   * @param group
   * @param keyShape
   */
  afterDraw: function afterDraw2(cfg, group, keyShape) {
  },
  drawShape: function drawShape2(cfg, group) {
    return null;
  },
  drawLabel: function drawLabel(cfg, group) {
    var defaultLabelCfg = (this.mergeStyle || this.getOptions(cfg) || {}).labelCfg;
    var labelCfg = defaultLabelCfg || {};
    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);
    var rotate9 = labelStyle.rotate;
    delete labelStyle.rotate;
    var label = group.addShape("text", {
      attrs: labelStyle,
      draggable: true,
      className: "text-shape",
      name: "text-shape",
      labelRelated: true
    });
    group["shapeMap"]["text-shape"] = label;
    if (!isNaN(rotate9) && rotate9 !== "") {
      var labelBBox = label.getBBox();
      var labelMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (labelStyle.rotateCenter) {
        switch (labelStyle.rotateCenter) {
          case "center":
            labelMatrix = transform6(labelMatrix, [["t", -labelBBox.width / 2, -labelBBox.height / 2], ["r", rotate9], ["t", labelBBox.width / 2, labelBBox.height / 2]]);
            break;
          case "lefttop":
            labelMatrix = transform6(labelMatrix, [["t", -labelStyle.x, -labelStyle.y], ["r", rotate9], ["t", labelStyle.x, labelStyle.y]]);
            break;
          case "leftcenter":
            labelMatrix = transform6(labelMatrix, [["t", -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ["r", rotate9], ["t", labelStyle.x, labelStyle.y + labelBBox.height / 2]]);
            break;
          default:
            labelMatrix = transform6(labelMatrix, [["t", -labelBBox.width / 2, -labelBBox.height / 2], ["r", rotate9], ["t", labelBBox.width / 2, labelBBox.height / 2]]);
            break;
        }
      } else {
        labelMatrix = transform6(labelMatrix, [["t", -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ["r", rotate9], ["t", labelStyle.x, labelStyle.y + labelBBox.height / 2]]);
      }
      label.setMatrix(labelMatrix);
    }
    if (labelStyle.background) {
      var rect2 = this.drawLabelBg(cfg, group, label);
      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;
      rect2.set("classname", labelBgClassname);
      group["shapeMap"][labelBgClassname] = rect2;
      label.toFront();
    }
    return label;
  },
  drawLabelBg: function drawLabelBg(cfg, group, label) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = mix({}, defaultLabelCfg, cfg.labelCfg);
    var style = this.getLabelBgStyleByPosition(label, labelCfg);
    var rect2 = group.addShape("rect", {
      name: "text-bg-shape",
      attrs: style,
      labelRelated: true
    });
    group["shapeMap"]["text-bg-shape"] = rect2;
    return rect2;
  },
  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {
    return {
      text: cfg.label
    };
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, labelCfg) {
    return {};
  },
  /**
   * 获取文本的配置项
   * @param cfg 节点的配置项
   * @param labelCfg 文本的配置项
   * @param group 父容器，label 的定位可能与图形相关
   */
  getLabelStyle: function getLabelStyle(cfg, labelCfg, group) {
    var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);
    var attrName = "".concat(this.itemType, "Label");
    var defaultStyle = global_default[attrName] ? global_default[attrName].style : null;
    return __assign3(__assign3(__assign3({}, defaultStyle), calculateStyle), labelCfg.style);
  },
  /**
   * 获取图形的配置项
   * @param cfg
   */
  getShapeStyle: function getShapeStyle(cfg) {
    return cfg.style;
  },
  /**
   * 更新节点，包含文本
   * @override
   * @param  {Object} cfg 节点/边的配置项
   * @param  {G6.Item} item 节点/边
   */
  update: function update2(cfg, item, updateType) {
    this.updateShapeStyle(cfg, item, updateType);
    this.updateLabel(cfg, item, updateType);
  },
  updateShapeStyle: function updateShapeStyle(cfg, item, updateType) {
    var _a2;
    var group = item.getContainer();
    var shape = item.getKeyShape();
    var shapeStyle = mix({}, shape.attr(), cfg.style);
    var _loop_1 = function _loop_12(key2) {
      var _b;
      var style = shapeStyle[key2];
      if (is_plain_object_default(style)) {
        var subShape = ((_a2 = group["shapeMap"]) === null || _a2 === void 0 ? void 0 : _a2[key2]) || group.find(function(element) {
          return element.get("name") === key2;
        });
        subShape === null || subShape === void 0 ? void 0 : subShape.attr(style);
      } else {
        shape.attr((_b = {}, _b[key2] = style, _b));
      }
    };
    for (var key in shapeStyle) {
      _loop_1(key);
    }
  },
  updateLabel: function updateLabel(cfg, item, updateType) {
    var _a2, _b;
    var group = item.getContainer();
    var _c = (this.mergeStyle || this.getOptions({}, updateType) || {}).labelCfg, labelCfg = _c === void 0 ? {} : _c;
    var labelClassName = this.itemType + CLS_LABEL_SUFFIX;
    var label = group["shapeMap"][labelClassName] || group.find(function(ele) {
      return ele.get("className") === labelClassName;
    });
    var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;
    var labelBg = group["shapeMap"][labelBgClassname] || group.find(function(ele) {
      return ele.get("className") === labelBgClassname;
    });
    if (label && cfg.label === void 0) {
      group.removeChild(label);
      delete group["shapeMap"][labelClassName];
      if (labelBg) {
        group.removeChild(labelBg);
        delete group["shapeMap"][labelBgClassname];
      }
    }
    if (cfg.label || cfg.label === "") {
      if (!label) {
        var newLabel = this.drawLabel(cfg, group);
        newLabel.set("className", labelClassName);
        group["shapeMap"][labelClassName] = newLabel;
      } else {
        if (!updateType || updateType === "bbox|label" || this.itemType === "edge" && updateType !== "style") {
          labelCfg = deep_mix_default(labelCfg, cfg.labelCfg);
        }
        var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);
        var cfgStyle = (_a2 = cfg.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style;
        var labelStyle = __assign3(__assign3({}, calculateStyle), cfgStyle);
        var rotate9 = labelStyle.rotate;
        delete labelStyle.rotate;
        if (!isNaN(rotate9) && rotate9 !== "") {
          var rotateMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          rotateMatrix = transform6(rotateMatrix, [["t", -labelStyle.x, -labelStyle.y], ["r", rotate9], ["t", labelStyle.x, labelStyle.y]]);
          labelStyle.matrix = rotateMatrix;
          label.attr(labelStyle);
        } else {
          if (((_b = label.getMatrix()) === null || _b === void 0 ? void 0 : _b[4]) !== 1) {
            label.resetMatrix();
          }
          label.attr(labelStyle);
        }
        if (!labelBg) {
          if (labelStyle.background) {
            labelBg = this.drawLabelBg(cfg, group, label);
            labelBg.set("classname", labelBgClassname);
            group["shapeMap"][labelBgClassname] = labelBg;
            label.toFront();
          }
        } else if (labelStyle.background) {
          var calculateBgStyle = this.getLabelBgStyleByPosition(label, labelCfg);
          labelBg.attr(calculateBgStyle);
        } else {
          group.removeChild(labelBg);
        }
      }
    }
  },
  // update(cfg, item) // 默认不定义
  afterUpdate: function afterUpdate2(cfg, item) {
  },
  /**
   * 设置节点的状态，主要是交互状态，业务状态请在 draw 方法中实现
   * 单图形的节点仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法
   * @override
   * @param  {String} name 状态名称
   * @param  {String | Boolean} value 状态值
   * @param  {G6.Item} item 节点
   */
  setState: function setState3(name, value, item) {
    var _a2, _b;
    var _c;
    var shape = item.get("keyShape");
    if (!shape || shape.destroyed) return;
    var type = item.getType();
    var stateName = is_boolean_default(value) ? name : "".concat(name, ":").concat(value);
    var shapeStateStyle = this.getStateStyle(stateName, item);
    var itemStateStyle = item.getStateStyle(stateName);
    if (!itemStateStyle && !shapeStateStyle) {
      return;
    }
    var styles = mix({}, itemStateStyle || shapeStateStyle);
    var group = item.getContainer();
    var keptAttrs = {
      x: 1,
      y: 1,
      cx: 1,
      cy: 1,
      matrix: 1
    };
    if (type === "combo") {
      keptAttrs.r = 1;
      keptAttrs.width = 1;
      keptAttrs.height = 1;
    }
    if (value) {
      var _loop_2 = function _loop_22(key2) {
        var _d;
        var style = styles[key2];
        if (is_plain_object_default(style) && !ARROWS.includes(key2)) {
          var subShape = ((_c = group["shapeMap"]) === null || _c === void 0 ? void 0 : _c[key2]) || group.find(function(element) {
            return element.get("name") === key2;
          });
          subShape === null || subShape === void 0 ? void 0 : subShape.attr(style);
        } else {
          shape.attr((_d = {}, _d[key2] = style, _d));
        }
      };
      for (var key in styles) {
        _loop_2(key);
      }
    } else {
      var enableStatesStyle = cloneBesidesImg(item.getCurrentStatesStyle());
      var model = item.getModel();
      var originStyle_1 = mix({}, model.style, cloneBesidesImg(item.getOriginStyle()));
      var keyShapeName_1 = shape.get("name");
      var shapeAttrs_1 = shape.attr();
      var keyShapeStyles_1 = {};
      Object.keys(shapeAttrs_1).forEach(function(key2) {
        if (key2 === "img") return;
        var attr = shapeAttrs_1[key2];
        if (attr && _typeof2(attr) === "object") {
          keyShapeStyles_1[key2] = clone_default(attr);
        } else {
          keyShapeStyles_1[key2] = attr;
        }
      });
      var filtetDisableStatesStyle = {};
      var _loop_3 = function _loop_32(p3) {
        var style = styles[p3];
        if (is_plain_object_default(style) && !ARROWS.includes(p3)) {
          var subShape_1 = group["shapeMap"][p3] || group.find(function(ele) {
            return ele.get("name") === p3;
          });
          if (subShape_1) {
            var subShapeStyles_1 = cloneBesidesImg(subShape_1.attr());
            each_default(style, function(v2, key2) {
              if (p3 === keyShapeName_1 && keyShapeStyles_1[key2] && !keptAttrs[key2]) {
                delete keyShapeStyles_1[key2];
                var value_1 = originStyle_1[p3][key2] || SHAPES_DEFAULT_ATTRS[type][key2];
                shape.attr(key2, value_1);
              } else if (subShapeStyles_1[key2] || subShapeStyles_1[key2] === 0) {
                delete subShapeStyles_1[key2];
                var value_2 = originStyle_1[p3][key2] || SHAPES_DEFAULT_ATTRS[type][key2];
                subShape_1.attr(key2, value_2);
              }
            });
            filtetDisableStatesStyle[p3] = subShapeStyles_1;
          }
        } else {
          if (keyShapeStyles_1[p3] && !keptAttrs[p3]) {
            delete keyShapeStyles_1[p3];
            var value_3 = originStyle_1[p3] || (originStyle_1[keyShapeName_1] ? originStyle_1[keyShapeName_1][p3] : void 0) || SHAPES_DEFAULT_ATTRS[type][p3];
            shape.attr(p3, value_3);
          }
        }
      };
      for (var p2 in styles) {
        _loop_3(p2);
      }
      if (!keyShapeName_1) {
        mix(filtetDisableStatesStyle, keyShapeStyles_1);
      } else {
        filtetDisableStatesStyle[keyShapeName_1] = keyShapeStyles_1;
      }
      for (var key in enableStatesStyle) {
        if (keptAttrs[key]) continue;
        var enableStyle = enableStatesStyle[key];
        if (!is_plain_object_default(enableStyle) || ARROWS.includes(key)) {
          if (!keyShapeName_1) {
            mix(originStyle_1, (_a2 = {}, _a2[key] = enableStyle, _a2));
          } else {
            mix(originStyle_1[keyShapeName_1], (_b = {}, _b[key] = enableStyle, _b));
            delete originStyle_1[key];
          }
          delete enableStatesStyle[key];
        }
      }
      var originstyles = {};
      deep_mix_default(originstyles, originStyle_1, filtetDisableStatesStyle, enableStatesStyle);
      var keyShapeSetted = false;
      var _loop_4 = function _loop_42(originKey2) {
        var _e2, _f;
        var style = originstyles[originKey2];
        if (is_plain_object_default(style) && !ARROWS.includes(originKey2)) {
          var subShape = group["shapeMap"][originKey2] || group.find(function(ele) {
            return ele.get("name") === originKey2;
          });
          if (subShape) {
            if (subShape.get("type") === "text" || subShape.get("labelRelated")) {
              delete style.x;
              delete style.y;
              delete style.matrix;
            }
            if (originKey2 === keyShapeName_1) {
              if (type === "combo") {
                delete style.r;
                delete style.width;
                delete style.height;
              }
              keyShapeSetted = true;
            }
            subShape.attr(style);
          }
        } else if (!keyShapeSetted) {
          var value_4 = style || SHAPES_DEFAULT_ATTRS[type][originKey2];
          if (type === "combo") {
            if (!keyShapeName_1) {
              shape.attr((_e2 = {}, _e2[originKey2] = value_4, _e2));
            }
          } else {
            shape.attr((_f = {}, _f[originKey2] = value_4, _f));
          }
        }
      };
      for (var originKey in originstyles) {
        _loop_4(originKey);
      }
    }
  },
  /**
   * 获取不同状态下的样式
   *
   * @param {string} name 状态名称
   * @param {Item} item Node或Edge的实例
   * @return {object} 样式
   */
  getStateStyle: function getStateStyle(name, item) {
    var model = item.getModel();
    var type = item.getType();
    var _a2 = this.getOptions(model), stateStyles = _a2.stateStyles, _b = _a2.style, style = _b === void 0 ? {} : _b;
    var modelStateStyle = model.stateStyles ? model.stateStyles[name] : stateStyles && stateStyles[name];
    if (type === "combo") {
      return clone_default(modelStateStyle);
    }
    return mix({}, style, modelStateStyle);
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getControlPoints: function getControlPoints3(cfg) {
    return cfg.controlPoints;
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 锚点的数组,如果为 null，则没有锚点
   */
  getAnchorPoints: function getAnchorPoints3(cfg) {
    var _a2, _b;
    var anchorPoints = (cfg === null || cfg === void 0 ? void 0 : cfg.anchorPoints) || ((_a2 = this.getCustomConfig(cfg)) === null || _a2 === void 0 ? void 0 : _a2.anchorPoints) || ((_b = this.options) === null || _b === void 0 ? void 0 : _b.anchorPoints);
    return anchorPoints;
  }
};

// node_modules/@antv/g6-core/es/element/node.js
var singleNode = {
  itemType: "node",
  // 单个图形的类型
  shapeType: "single-node",
  /**
   * 文本相对图形的位置，默认以中心点
   * 位置包括： top, bottom, left, right, center
   * @type {String}
   */
  labelPosition: "center",
  /**
   * 文本相对偏移，当 labelPosition 不为 center 时有效
   * @type {Number}
   */
  offset: global_default.nodeLabel.offset,
  /**
   * 获取节点宽高
   * @internal 返回节点的大小，以 [width, height] 的方式维护
   * @param  {Object} cfg 节点的配置项
   * @return {Array} 宽高
   */
  getSize: function getSize(cfg) {
    var _a2;
    var size3 = ((_a2 = this.mergeStyle) === null || _a2 === void 0 ? void 0 : _a2.size) || cfg.size || this.getOptions({}).size || global_default.defaultNode.size;
    if (is_array_default(size3) && size3.length === 1) {
      size3 = [size3[0], size3[0]];
    }
    if (!is_array_default(size3)) {
      size3 = [size3, size3];
    }
    return size3;
  },
  // 私有方法，不希望扩展的节点复写这个方法
  getLabelStyleByPosition: function getLabelStyleByPosition2(cfg, labelCfg) {
    var labelMaxLength = labelCfg.maxLength;
    var text = cfg.label;
    if (labelMaxLength) {
      text = truncateLabelByLength(text, labelMaxLength);
    }
    var labelPosition = labelCfg.position || this.labelPosition;
    if (labelPosition === "center") {
      return {
        x: 0,
        y: 0,
        text,
        textBaseline: "middle",
        textAlign: "center"
      };
    }
    var offset = labelCfg.offset;
    if (is_nil_default(offset)) {
      offset = this.offset;
    }
    var size3 = this.getSize(cfg);
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: 0,
          y: -size3[1] / 2 - offset,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: size3[1] / 2 + offset,
          textBaseline: "top",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: -size3[0] / 2 - offset,
          y: 0,
          textBaseline: "middle",
          textAlign: "right"
        };
        break;
      default:
        style = {
          x: size3[0] / 2 + offset,
          y: 0,
          textBaseline: "middle",
          textAlign: "left"
        };
        break;
    }
    style.text = text;
    return style;
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition2(label, labelCfg) {
    var _a2;
    if (!label) return {};
    var backgroundStyle = (_a2 = labelCfg.style) === null || _a2 === void 0 ? void 0 : _a2.background;
    if (!backgroundStyle) return {};
    var bbox = label.getBBox();
    var padding = formatPadding(backgroundStyle.padding);
    var backgroundWidth = bbox.width + padding[1] + padding[3];
    var backgroundHeight = bbox.height + padding[0] + padding[2];
    return __assign3(__assign3({
      x: bbox.minX - padding[3],
      y: bbox.minY - padding[0]
    }, backgroundStyle), {
      width: backgroundWidth,
      height: backgroundHeight
    });
  },
  drawShape: function drawShape3(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    var shape = group.addShape(shapeType, {
      attrs: style,
      draggable: true,
      name: "node-shape"
    });
    group["shapeMap"]["node-shape"] = shape;
    return shape;
  },
  /**
   * 更新linkPoints
   * @param {Object} cfg 节点数据配置项
   * @param {Group} group Item所在的group
   */
  updateLinkPoints: function updateLinkPoints(cfg, group) {
    var defaultLinkPoints = (this.mergeStyle || this.getOptions(cfg)).linkPoints;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markBottom = group["shapeMap"]["link-point-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-bottom";
    });
    var currentLinkPoints;
    if (markLeft) {
      currentLinkPoints = markLeft.attr();
    }
    if (markRight && !currentLinkPoints) {
      currentLinkPoints = markRight.attr();
    }
    if (markTop && !currentLinkPoints) {
      currentLinkPoints = markTop.attr();
    }
    if (markBottom && !currentLinkPoints) {
      currentLinkPoints = markBottom.attr();
    }
    if (!currentLinkPoints) currentLinkPoints = defaultLinkPoints;
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize) markSize = linkPoints.r;
    var _a2 = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }, left = _a2.left, right = _a2.right, top = _a2.top, bottom = _a2.bottom;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    if (markLeft) {
      if (!left && left !== void 0) {
        markLeft.remove();
        delete group["shapeMap"]["link-point-left"];
      } else {
        markLeft.attr(__assign3(__assign3({}, styles), {
          x: -width / 2,
          y: 0
        }));
      }
    } else if (left) {
      var name_1 = "link-point-left";
      group["shapeMap"][name_1] = group.addShape("circle", {
        attrs: __assign3(__assign3({}, styles), {
          x: -width / 2,
          y: 0
        }),
        className: name_1,
        name: name_1,
        isAnchorPoint: true
      });
    }
    if (markRight) {
      if (!right && right !== void 0) {
        markRight.remove();
        delete group["shapeMap"]["link-point-right"];
      }
      markRight.attr(__assign3(__assign3({}, styles), {
        x: width / 2,
        y: 0
      }));
    } else if (right) {
      var name_2 = "link-point-right";
      group["shapeMap"][name_2] = group.addShape("circle", {
        attrs: __assign3(__assign3({}, styles), {
          x: width / 2,
          y: 0
        }),
        className: name_2,
        name: name_2,
        isAnchorPoint: true
      });
    }
    if (markTop) {
      if (!top && top !== void 0) {
        markTop.remove();
        delete group["shapeMap"]["link-point-top"];
      }
      markTop.attr(__assign3(__assign3({}, styles), {
        x: 0,
        y: -height / 2
      }));
    } else if (top) {
      var name_3 = "link-point-top";
      group["shapeMap"][name_3] = group.addShape("circle", {
        attrs: __assign3(__assign3({}, styles), {
          x: 0,
          y: -height / 2
        }),
        className: name_3,
        name: name_3,
        isAnchorPoint: true
      });
    }
    if (markBottom) {
      if (!bottom && bottom !== void 0) {
        markBottom.remove();
        delete group["shapeMap"]["link-point-bottom"];
      } else {
        markBottom.attr(__assign3(__assign3({}, styles), {
          x: 0,
          y: height / 2
        }));
      }
    } else if (bottom) {
      var name_4 = "link-point-bottom";
      group["shapeMap"][name_4] = group.addShape("circle", {
        attrs: __assign3(__assign3({}, styles), {
          x: 0,
          y: height / 2
        }),
        className: name_4,
        name: name_4,
        isAnchorPoint: true
      });
    }
  },
  updateShape: function updateShape(cfg, item, keyShapeStyle, hasIcon, updateType) {
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign3({}, keyShapeStyle));
    if (true) {
      this.updateLabel(cfg, item, updateType);
    }
    if (hasIcon) {
      this.updateIcon(cfg, item);
    }
  },
  updateIcon: function updateIcon(cfg, item) {
    var _this = this;
    var group = item.getContainer();
    var icon = (this.mergeStyle || this.getOptions(cfg)).icon;
    var _a2 = cfg.icon ? cfg.icon : {
      show: void 0,
      text: void 0
    }, show = _a2.show, text = _a2.text;
    var iconShape = group["shapeMap"]["".concat(this.type, "-icon")] || group.find(function(ele) {
      return ele.get("name") === "".concat(_this.type, "-icon");
    });
    if (iconShape) {
      if (show || show === void 0) {
        var iconConfig = mix({}, iconShape.attr(), icon);
        var _b = iconConfig.width, w2 = _b === void 0 ? 20 : _b, _c = iconConfig.height, h2 = _c === void 0 ? 20 : _c;
        if (iconConfig.fontFamily === "iconfont" || iconConfig.hasOwnProperty("text")) {
          w2 = 0;
          h2 = 0;
        }
        iconShape.attr(__assign3(__assign3({}, iconConfig), {
          x: -w2 / 2,
          y: -h2 / 2
        }));
      } else {
        iconShape.remove();
        delete group["shapeMap"]["".concat(this.type, "-icon")];
      }
    } else if (show) {
      var name_5 = "".concat(this.type, "-icon");
      if (text) {
        group["shapeMap"][name_5] = group.addShape("text", {
          attrs: __assign3({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: name_5,
          name: name_5
        });
      } else {
        var w2 = icon.width, h2 = icon.height;
        group["shapeMap"][name_5] = group.addShape("image", {
          attrs: __assign3(__assign3({}, icon), {
            x: -w2 / 2,
            y: -h2 / 2
          }),
          className: name_5,
          name: name_5
        });
      }
      var labelShape = group["shapeMap"]["node-label"] || group.find(function(ele) {
        return ele.get("name") === "node-label";
      });
      if (labelShape) {
        labelShape.toFront();
      }
    }
  }
};
var singleNodeDef = __assign3(__assign3({}, shapeBase), singleNode);
shape_default2.registerNode("single-node", singleNodeDef);

// node_modules/@antv/g6-core/es/element/edge.js
init_esm();
var CLS_SHAPE = "edge-shape";
function revertAlign(labelPosition) {
  var textAlign = labelPosition;
  if (labelPosition === "start") {
    textAlign = "end";
  } else if (labelPosition === "end") {
    textAlign = "start";
  }
  return textAlign;
}
var singleEdge = {
  itemType: "edge",
  /**
   * 文本的位置
   * @type {String}
   */
  labelPosition: "center",
  /**
   * 文本的 x 偏移
   * @type {Number}
   */
  refX: 0,
  /**
   * 文本的 y 偏移
   * @type {Number}
   */
  refY: 0,
  /**
   * 文本是否跟着线自动旋转，默认 false
   * @type {Boolean}
   */
  labelAutoRotate: false,
  // 自定义边时的配置
  options: {
    size: global_default.defaultEdge.size,
    style: {
      x: 0,
      y: 0,
      stroke: global_default.defaultEdge.style.stroke,
      lineAppendWidth: global_default.defaultEdge.style.lineAppendWidth
    },
    labelCfg: {
      style: {
        fill: global_default.edgeLabel.style.fill,
        fontSize: global_default.edgeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign3({}, global_default.edgeStateStyles)
  },
  /**
   * 获取边的 path
   * @internal 供扩展的边覆盖
   * @param  {Array} points 构成边的点的集合
   * @return {Array} 构成 path 的数组
   */
  getPath: function getPath(points) {
    var path = [];
    each_default(points, function(point, index2) {
      if (index2 === 0) {
        path.push(["M", point.x, point.y]);
      } else {
        path.push(["L", point.x, point.y]);
      }
    });
    return path;
  },
  getShapeStyle: function getShapeStyle2(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var size3 = cfg.size || global_default.defaultEdge.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var path = this.getPath(points);
    var styles = mix({}, global_default.defaultEdge.style, {
      stroke: global_default.defaultEdge.color,
      lineWidth: size3,
      path
    }, style);
    return styles;
  },
  updateShapeStyle: function updateShapeStyle2(cfg, item, updateType) {
    var _a2;
    var group = item.getContainer();
    var shape = ((_a2 = item.getKeyShape) === null || _a2 === void 0 ? void 0 : _a2.call(item)) || group["shapeMap"]["edge-shape"];
    var size3 = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var currentAttr = shape.attr();
    var previousStyle = cfg.style || {};
    if (previousStyle.stroke === void 0) {
      previousStyle.stroke = cfg.color;
    }
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var routeCfg = {
      radius: previousStyle.radius
    };
    if (!controlPoints) {
      routeCfg = {
        source,
        target,
        offset: previousStyle.offset,
        radius: previousStyle.radius
      };
    }
    var path = this.getPath(points, routeCfg);
    var style = {};
    if (updateType === "move") {
      style = {
        path
      };
    } else {
      if (currentAttr.endArrow && previousStyle.endArrow === false) {
        cfg.style.endArrow = {
          path: ""
        };
      }
      if (currentAttr.startArrow && previousStyle.startArrow === false) {
        cfg.style.startArrow = {
          path: ""
        };
      }
      style = __assign3({}, cfg.style);
      if (style.lineWidth === void 0) style.lineWidth = (is_number_default(size3) ? size3 : size3 === null || size3 === void 0 ? void 0 : size3[0]) || currentAttr.lineWidth;
      if (style.path === void 0) style.path = path;
      if (style.stroke === void 0) style.stroke = currentAttr.stroke || cfg.color;
    }
    if (shape) {
      shape.attr(style);
    }
  },
  getLabelStyleByPosition: function getLabelStyleByPosition3(cfg, labelCfg, group) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var style = {};
    var pathShape = group === null || group === void 0 ? void 0 : group["shapeMap"][CLS_SHAPE];
    var pointPercent;
    if (labelPosition === "start") {
      pointPercent = 0;
    } else if (labelPosition === "end") {
      pointPercent = 1;
    } else {
      pointPercent = 0.5;
    }
    var offsetX = labelCfg.refX || this.refX;
    var offsetY = labelCfg.refY || this.refY;
    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {
      style.x = cfg.startPoint.x + offsetX;
      style.y = cfg.startPoint.y + offsetY;
      style.text = cfg.label;
      return style;
    }
    var autoRotate;
    if (is_nil_default(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;
    else autoRotate = labelCfg.autoRotate;
    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);
    style.x = offsetStyle.x;
    style.y = offsetStyle.y;
    style.rotate = offsetStyle.rotate;
    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);
    style.text = cfg.label;
    return style;
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition3(label, labelCfg) {
    if (!label) {
      return {};
    }
    var bbox = label.getBBox();
    var backgroundStyle = labelCfg.style && labelCfg.style.background;
    if (!backgroundStyle) {
      return {};
    }
    var padding = backgroundStyle.padding;
    var backgroundWidth = bbox.width + padding[1] + padding[3];
    var backgroundHeight = bbox.height + padding[0] + padding[2];
    var style = __assign3(__assign3({}, backgroundStyle), {
      width: backgroundWidth,
      height: backgroundHeight,
      x: bbox.minX - padding[3],
      y: bbox.minY - padding[0],
      matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    });
    var autoRotate;
    if (is_nil_default(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;
    else autoRotate = labelCfg.autoRotate;
    if (autoRotate) {
      style.matrix = label.attr("matrix") || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    return style;
  },
  // 获取文本对齐方式
  _getTextAlign: function _getTextAlign(labelPosition, angle3) {
    var textAlign = "center";
    if (!angle3) {
      return labelPosition;
    }
    angle3 = angle3 % (Math.PI * 2);
    if (labelPosition !== "center") {
      if (angle3 >= 0 && angle3 <= Math.PI / 2 || angle3 >= 3 / 2 * Math.PI && angle3 < 2 * Math.PI) {
        textAlign = labelPosition;
      } else {
        textAlign = revertAlign(labelPosition);
      }
    }
    return textAlign;
  },
  /**
   * @internal 获取边的控制点
   * @param  {Object} cfg 边的配置项
   * @return {Array} 控制点的数组
   */
  getControlPoints: function getControlPoints4(cfg) {
    return cfg.controlPoints;
  },
  /**
   * @internal 处理需要重计算点和边的情况
   * @param {Object} cfg 边的配置项
   * @return {Object} 边的配置项
   */
  getPathPoints: function getPathPoints(cfg) {
    return cfg;
  },
  /**
   * 绘制边
   * @override
   * @param  {Object} cfg   边的配置项
   * @param  {G.Group} group 边的容器
   * @return {IShape} 图形
   */
  drawShape: function drawShape4(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    var shape = group.addShape("path", {
      className: CLS_SHAPE,
      name: CLS_SHAPE,
      attrs: shapeStyle
    });
    group["shapeMap"][CLS_SHAPE] = shape;
    return shape;
  },
  drawLabel: function drawLabel2(cfg, group) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = deep_mix_default({}, defaultLabelCfg, cfg.labelCfg);
    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);
    var rotate9 = labelStyle.rotate;
    delete labelStyle.rotate;
    var label = group.addShape("text", {
      attrs: labelStyle,
      name: "text-shape",
      labelRelated: true,
      draggable: true
    });
    group["shapeMap"]["text-shape"] = label;
    if (!isNaN(rotate9) && rotate9 !== "") {
      label.rotateAtStart(rotate9);
    }
    if (labelStyle.background) {
      var rect2 = this.drawLabelBg(cfg, group, label, labelStyle, rotate9);
      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;
      rect2.set("classname", labelBgClassname);
      group["shapeMap"][labelBgClassname] = rect2;
      label.toFront();
    }
    return label;
  },
  drawLabelBg: function drawLabelBg2(cfg, group, label, labelStyle, rotate9) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = deep_mix_default({}, defaultLabelCfg, cfg.labelCfg);
    var style = this.getLabelBgStyleByPosition(label, labelCfg);
    var rect2 = group.addShape("rect", {
      name: "text-bg-shape",
      attrs: style,
      labelRelated: true
    });
    group["shapeMap"]["text-bg-shape"] = rect2;
    return rect2;
  }
};
var singleEdgeDef = __assign3(__assign3({}, shapeBase), singleEdge);
shape_default2.registerEdge("single-edge", singleEdgeDef);
shape_default2.registerEdge("line", {
  // 控制点不生效
  getControlPoints: function getControlPoints5() {
    return void 0;
  }
}, "single-edge");
shape_default2.registerEdge("spline", {
  getPath: function getPath2(points) {
    var path = getSpline(points);
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("arc", {
  curveOffset: 20,
  clockwise: 1,
  getControlPoints: function getControlPoints6(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var midPoint2 = {
      x: (startPoint.x + endPoint.x) / 2,
      y: (startPoint.y + endPoint.y) / 2
    };
    var center;
    var arcPoint;
    if (cfg.controlPoints !== void 0) {
      arcPoint = cfg.controlPoints[0];
      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);
      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 0 : 1;
      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 1 : 0;
      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {
        this.clockwise = center.y < arcPoint.y ? 0 : 1;
      } else {
        this.clockwise = center.y < arcPoint.y ? 1 : 0;
      }
      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {
        return [];
      }
    } else {
      if (cfg.curveOffset === void 0) {
        cfg.curveOffset = this.curveOffset;
      }
      if (is_array_default(cfg.curveOffset)) {
        cfg.curveOffset = cfg.curveOffset[0];
      }
      if (cfg.curveOffset < 0) {
        this.clockwise = 0;
      } else {
        this.clockwise = 1;
      }
      var vec = {
        x: endPoint.x - startPoint.x,
        y: endPoint.y - startPoint.y
      };
      var edgeAngle = Math.atan2(vec.y, vec.x);
      arcPoint = {
        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint2.x,
        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint2.y
      };
      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);
    }
    var radius = distance4(startPoint, center);
    var controlPoints = [{
      x: radius,
      y: radius
    }];
    return controlPoints;
  },
  getPath: function getPath3(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    if (points.length === 2) {
      path.push(["L", points[1].x, points[1].y]);
    } else {
      path.push(["A", points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);
    }
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("quadratic", {
  curvePosition: 0.5,
  curveOffset: -20,
  getControlPoints: function getControlPoints7(cfg) {
    var controlPoints = cfg.controlPoints;
    if (!controlPoints || !controlPoints.length) {
      var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
      if (cfg.curveOffset === void 0) cfg.curveOffset = this.curveOffset;
      if (cfg.curvePosition === void 0) cfg.curvePosition = this.curvePosition;
      if (is_array_default(cfg.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];
      if (is_array_default(cfg.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];
      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);
      controlPoints = [innerPoint];
    }
    return controlPoints;
  },
  getPath: function getPath4(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    path.push(["Q", points[1].x, points[1].y, points[2].x, points[2].y]);
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("cubic", {
  curvePosition: [1 / 2, 1 / 2],
  curveOffset: [-20, 20],
  getControlPoints: function getControlPoints8(cfg) {
    var controlPoints = cfg.controlPoints;
    if (cfg.curveOffset === void 0) cfg.curveOffset = this.curveOffset;
    if (cfg.curvePosition === void 0) cfg.curvePosition = this.curvePosition;
    if (is_number_default(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {
      var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);
      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);
      controlPoints = [innerPoint1, innerPoint2];
    }
    return controlPoints;
  },
  getPath: function getPath5(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    path.push(["C", points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("cubic-vertical", {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: void 0,
  getControlPoints: function getControlPoints9(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    if (cfg.curvePosition === void 0) cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === void 0) cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === void 0) cfg.minCurveOffset = this.minCurveOffset;
    if (is_number_default(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if (is_number_default(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var yDist = endPoint.y - startPoint.y;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x,
      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]
    };
    var innerPoint2 = {
      x: endPoint.x,
      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]
    };
    return [innerPoint1, innerPoint2];
  }
}, "cubic");
shape_default2.registerEdge("cubic-horizontal", {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: void 0,
  getControlPoints: function getControlPoints10(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    if (cfg.curvePosition === void 0) cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === void 0) cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === void 0) cfg.minCurveOffset = this.minCurveOffset;
    if (is_number_default(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if (is_number_default(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var xDist = endPoint.x - startPoint.x;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],
      y: startPoint.y
    };
    var innerPoint2 = {
      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],
      y: endPoint.y
    };
    var controlPoints = [innerPoint1, innerPoint2];
    return controlPoints;
  }
}, "cubic");
shape_default2.registerEdge("loop", {
  getPathPoints: function getPathPoints2(cfg) {
    return getLoopCfgs(cfg);
  },
  getControlPoints: function getControlPoints11(cfg) {
    return cfg.controlPoints;
  },
  afterDraw: function afterDraw3(cfg) {
    cfg.controlPoints = void 0;
  },
  afterUpdate: function afterUpdate3(cfg) {
    cfg.controlPoints = void 0;
  }
}, "cubic");

// node_modules/@antv/g6-core/es/element/combo.js
init_esm();
var singleCombo = {
  itemType: "combo",
  // 单个图形的类型
  shapeType: "single-combo",
  /**
   * Combo 标题文本相对图形的位置，默认为 top
   * 位置包括： top, bottom, left, right, center
   * @type {String}
   */
  labelPosition: "top",
  /**
   * 标题文本相对偏移，当 labelPosition 不为 center 时有效
   * @type {Number}
   */
  refX: global_default.comboLabel.refX,
  refY: global_default.comboLabel.refY,
  options: {
    style: {
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign3({}, global_default.comboStateStyles),
    collapsedSubstituteIcon: {
      show: false,
      img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*RsnHRqLfJn4AAAAAAAAAAAAAARQnAQ"
    }
  },
  /**
   * 获取 Combo 宽高
   * @internal 返回 Combo 的大小，以 [width, height] 的方式维护
   * @param  {Object} cfg Combo 的配置项
   * @return {Array} 宽高
   */
  getSize: function getSize2(cfg) {
    var size3 = clone_default(cfg.size || this.options.size || global_default.defaultCombo.size);
    if (is_array_default(size3) && size3.length === 1) {
      size3 = [size3[0], size3[0]];
    }
    if (!is_array_default(size3)) {
      size3 = [size3, size3];
    }
    return size3;
  },
  // 私有方法，不希望扩展的 Combo 复写这个方法
  getLabelStyleByPosition: function getLabelStyleByPosition4(cfg, labelCfg) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var cfgStyle = cfg.style;
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding)) padding = Math.max.apply(Math, padding);
    var refX = labelCfg.refX, refY = labelCfg.refY;
    if (is_nil_default(refX)) {
      refX = this.refX;
    }
    if (is_nil_default(refY)) {
      refY = this.refY;
    }
    var size3 = this.getSize(cfg);
    var r2 = Math.max(cfgStyle.r, size3[0] / 2) || size3[0] / 2;
    var dis = r2 + padding;
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: 0,
          y: -dis - refY,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: dis + refY,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: -dis + refX,
          y: 0,
          textAlign: "left"
        };
        break;
      case "center":
        style = {
          x: 0,
          y: 0,
          text: cfg.label,
          textAlign: "center"
        };
        break;
      default:
        style = {
          x: dis + refX,
          y: 0,
          textAlign: "right"
        };
        break;
    }
    style.text = cfg.label;
    return style;
  },
  drawShape: function drawShape5(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    var shape = group.addShape(shapeType, {
      attrs: style,
      draggable: true,
      name: "combo-shape"
    });
    return shape;
  },
  updateCollapsedIcon: function updateCollapsedIcon(cfg, item, keyShapeStyle) {
    var collapsed = cfg.collapsed, _a2 = cfg.collapsedSubstituteIcon, collapsedSubstituteIcon = _a2 === void 0 ? {} : _a2;
    var substituteIconConfig = Object.assign({}, this.options.collapsedSubstituteIcon, collapsedSubstituteIcon);
    var show = substituteIconConfig.show, img = substituteIconConfig.img, width = substituteIconConfig.width, height = substituteIconConfig.height;
    var group = item.getContainer();
    var collapsedIconShape = group.find(function(ele) {
      return ele.get("name") === "combo-collapsed-substitute-icon";
    });
    var iconShapeExist = collapsedIconShape && !collapsedIconShape.destroyed;
    var keyShape = item.get("keyShape");
    if (collapsed && show) {
      if (iconShapeExist) {
        collapsedIconShape.show();
      } else {
        var sizeAttr = {
          width: width || keyShapeStyle.r * 2 || keyShapeStyle.width,
          height: height || keyShapeStyle.r * 2 || keyShapeStyle.height
        };
        collapsedIconShape = group.addShape("image", {
          attrs: __assign3({
            img,
            x: -sizeAttr.width / 2,
            y: -sizeAttr.height / 2
          }, sizeAttr),
          name: "combo-collapsed-substitute-icon",
          draggable: true
        });
      }
      keyShape.hide();
    } else if (iconShapeExist) {
      collapsedIconShape.hide();
      keyShape.show();
    }
  },
  updateShape: function updateShape2(cfg, item, keyShapeStyle) {
    var _this = this;
    var keyShape = item.get("keyShape");
    var itemAnimate = item.get("animate");
    var animate = itemAnimate && (cfg.animate === void 0 ? this.options.animate : cfg.animate);
    if (animate && keyShape.animate) {
      if (!cfg.collapsed) {
        this.updateCollapsedIcon(cfg, item, keyShapeStyle);
      }
      keyShape.animate(keyShapeStyle, {
        duration: 200,
        easing: "easeLinear",
        callback: function callback() {
          if (cfg.collapsed) {
            _this.updateCollapsedIcon(cfg, item, keyShapeStyle);
          }
        }
      });
    } else {
      keyShape.attr(__assign3({}, keyShapeStyle));
      this.updateCollapsedIcon(cfg, item, keyShapeStyle);
    }
    this.updateLabel(cfg, item);
  }
};
var singleComboDef = __assign3(__assign3({}, shapeBase), singleCombo);
shape_default2.registerCombo("single-combo", singleComboDef);

// node_modules/@antv/g6-core/es/element/combos/circle.js
init_esm();
shape_default2.registerCombo("circle", {
  // 自定义节点时的配置
  options: {
    size: [global_default.defaultCombo.size[0], global_default.defaultCombo.size[0]],
    padding: Math.max.apply(Math, global_default.defaultCombo.padding),
    animate: true,
    style: {
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize
      },
      refX: 0,
      refY: 0
    },
    stateStyles: __assign3({}, global_default.comboStateStyles),
    collapsedSubstituteIcon: {
      show: false,
      img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*RsnHRqLfJn4AAAAAAAAAAAAAARQnAQ"
    }
  },
  shapeType: "circle",
  // 文本位置
  labelPosition: "top",
  drawShape: function drawShape6(cfg, group) {
    var style = this.getShapeStyle(cfg);
    delete style.height;
    delete style.width;
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "circle-combo",
      name: "circle-combo",
      draggable: true
    });
    return keyShape;
  },
  /**
   * 获取 Combo 的样式，供基于该 Combo 自定义时使用
   * @param {Object} cfg Combo 数据模型
   * @return {Object} Combo 的样式
   */
  getShapeStyle: function getShapeStyle3(cfg) {
    var defaultStyle = this.options.style;
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding)) padding = Math.max.apply(Math, padding);
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    var r2;
    if (fixSize) {
      r2 = is_number_default(fixSize) ? fixSize / 2 : fixSize[0] / 2;
    } else {
      var size3 = this.getSize(cfg);
      if (!is_number_default(style.r) || isNaN(style.r)) r2 = size3[0] / 2 || global_default.defaultCombo.style.r;
      else r2 = Math.max(style.r, size3[0] / 2) || size3[0] / 2;
    }
    style.r = r2 + padding;
    var styles = __assign3({
      x: 0,
      y: 0
    }, style);
    if (cfg.style) cfg.style.r = r2;
    else {
      cfg.style = {
        r: r2
      };
    }
    return styles;
  },
  update: function update3(cfg, item) {
    var size3 = this.getSize(cfg);
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding)) padding = Math.max.apply(Math, padding);
    var cfgStyle = clone_default(cfg.style);
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    var r2;
    if (fixSize) {
      r2 = is_number_default(fixSize) ? fixSize / 2 : fixSize[0] / 2;
    } else {
      r2 = Math.max(cfgStyle.r, size3[0] / 2) || size3[0] / 2;
    }
    cfgStyle.r = r2 + padding;
    var itemCacheSize = item.get("sizeCache");
    if (itemCacheSize) {
      itemCacheSize.r = cfgStyle.r;
    }
    var strokeStyle = {
      stroke: cfg.color
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, keyShape.attr(), strokeStyle, cfgStyle);
    if (cfg.style) cfg.style.r = r2;
    else {
      cfg.style = {
        r: r2
      };
    }
    this.updateShape(cfg, item, style, true);
  }
}, "single-combo");

// node_modules/@antv/g6-core/es/element/combos/rect.js
init_esm();
shape_default2.registerCombo("rect", {
  // 自定义 Combo 时的配置
  options: {
    size: [40, 5],
    padding: [25, 20, 15, 20],
    animate: true,
    style: {
      radius: 0,
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    // 连接点，默认为左右
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign3({}, global_default.comboStateStyles),
    collapsedSubstituteIcon: {
      show: false,
      img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*RsnHRqLfJn4AAAAAAAAAAAAAARQnAQ"
    }
  },
  shapeType: "rect",
  labelPosition: "top",
  drawShape: function drawShape7(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "rect-combo",
      name: "rect-combo",
      draggable: true
    });
    return keyShape;
  },
  // 私有方法，不希望扩展的 Combo 复写这个方法
  getLabelStyleByPosition: function getLabelStyleByPosition5(cfg, labelCfg) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var cfgStyle = cfg.style;
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding)) padding = [padding, padding, padding, padding];
    var refX = labelCfg.refX, refY = labelCfg.refY;
    if (is_nil_default(refX)) {
      refX = this.refX;
    }
    if (is_nil_default(refY)) {
      refY = this.refY;
    }
    var left = -cfgStyle.width / 2 - padding[3];
    var right = cfgStyle.width / 2 + padding[1];
    var top = -cfgStyle.height / 2 - padding[0];
    var bottom = cfgStyle.height / 2 + padding[2];
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: left + refX,
          y: top + refY,
          textBaseline: "top",
          textAlign: "left"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: bottom + refY,
          textBaseline: "top",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: left + refY,
          y: 0,
          textAlign: "left"
        };
        break;
      case "center":
        style = {
          x: 0,
          y: 0,
          text: cfg.label,
          textAlign: "center"
        };
        break;
      case "top-center":
        style = {
          x: 0,
          y: top + refY,
          textBaseline: "top",
          textAlign: "center"
        };
        break;
      default:
        style = {
          x: right + refX,
          y: 0,
          textAlign: "right"
        };
        break;
    }
    style.text = cfg.label;
    return style;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle4(cfg) {
    var defaultStyle = this.options.style;
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding)) padding = [padding, padding, padding, padding];
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var size3 = this.getSize(cfg);
    var width;
    var height;
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    if (fixSize) {
      if (is_number_default(fixSize)) {
        width = fixSize;
        height = fixSize;
      } else {
        width = fixSize[0];
        height = fixSize[1];
      }
    } else {
      if (!is_number_default(style.width) || isNaN(style.width)) width = size3[0] || global_default.defaultCombo.style.width;
      else width = Math.max(style.width, size3[0]) || size3[0];
      if (!is_number_default(style.height) || isNaN(style.height)) height = size3[1] || global_default.defaultCombo.style.height;
      else height = Math.max(style.height, size3[1]) || size3[1];
    }
    var x4 = -width / 2 - padding[3];
    var y4 = -height / 2 - padding[0];
    style.width = width + padding[1] + padding[3];
    style.height = height + padding[0] + padding[2];
    var styles = __assign3({
      x: x4,
      y: y4
    }, style);
    if (!cfg.style) {
      cfg.style = {
        width,
        height
      };
    } else {
      cfg.style.width = width;
      cfg.style.height = height;
    }
    return styles;
  },
  update: function update4(cfg, item) {
    var size3 = this.getSize(cfg);
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding)) padding = [padding, padding, padding, padding];
    var cfgStyle = clone_default(cfg.style);
    var width, height;
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    if (fixSize) {
      if (is_number_default(fixSize)) {
        width = fixSize;
        height = fixSize;
      } else {
        width = fixSize[0];
        height = fixSize[1];
      }
    } else {
      width = Math.max(cfgStyle.width, size3[0]) || size3[0];
      height = Math.max(cfgStyle.height, size3[1]) || size3[1];
    }
    cfgStyle.width = width + padding[1] + padding[3];
    cfgStyle.height = height + padding[0] + padding[2];
    var itemCacheSize = item.get("sizeCache");
    if (itemCacheSize) {
      itemCacheSize.width = cfgStyle.width;
      itemCacheSize.height = cfgStyle.height;
    }
    cfgStyle.x = -width / 2 - padding[3];
    cfgStyle.y = -height / 2 - padding[0];
    var strokeStyle = {
      stroke: cfg.color
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, keyShape.attr(), strokeStyle, cfgStyle);
    if (cfg.style) {
      cfg.style.width = width;
      cfg.style.height = height;
    } else {
      cfg.style = {
        width,
        height
      };
    }
    this.updateShape(cfg, item, style, false);
  }
}, "single-combo");

// node_modules/@antv/g6-core/es/element/nodes/simple-circle.js
init_esm();
shape_default2.registerNode("simple-circle", {
  // 自定义节点时的配置
  options: {
    size: global_default.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: global_default.defaultNode.style.stroke,
      fill: global_default.defaultNode.style.fill,
      lineWidth: global_default.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.nodeLabel.style.fill,
        fontSize: global_default.nodeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign3({}, global_default.nodeStateStyles)
  },
  shapeType: "simple-circle",
  // 文本位置
  labelPosition: "center",
  shapeMap: {},
  drawShape: function drawShape8(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var name = "".concat(this.type, "-keyShape");
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name,
      draggable: true
    });
    group["shapeMap"][name] = keyShape;
    return keyShape;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle5(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = deep_mix_default({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var r2 = size3[0] / 2;
    var styles = __assign3({
      x: 0,
      y: 0,
      r: r2
    }, style);
    return styles;
  },
  update: function update5(cfg, item, updateType) {
    var size3 = this.getSize(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      r: size3[0] / 2
    };
    var keyShape = item.get("keyShape");
    var style = deep_mix_default({}, keyShape.attr(), strokeStyle, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/nodes/simple-rect.js
init_esm();
shape_default2.registerNode("simple-rect", {
  // 自定义节点时的配置
  options: {
    size: [100, 30],
    style: {
      radius: 0,
      stroke: global_default.defaultNode.style.stroke,
      fill: global_default.defaultNode.style.fill,
      lineWidth: global_default.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: global_default.nodeLabel.style.fill,
        fontSize: global_default.nodeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    // 连接点，默认为左右
    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign3({}, global_default.nodeStateStyles)
  },
  shapeType: "simple-rect",
  labelPosition: "center",
  drawShape: function drawShape9(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    return keyShape;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle6(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var width = style.width || size3[0];
    var height = style.height || size3[1];
    var styles = __assign3({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update6(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var size3 = this.getSize(cfg);
    var keyShape = item.get("keyShape");
    if (!cfg.size) {
      size3[0] = keyShape.attr("width") || defaultStyle.width;
      size3[1] = keyShape.attr("height") || defaultStyle.height;
    }
    var strokeStyle = {
      stroke: cfg.color,
      x: -size3[0] / 2,
      y: -size3[1] / 2,
      width: size3[0],
      height: size3[1]
    };
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, false, updateType);
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/nodes/image.js
shape_default2.registerNode("image", {
  options: {
    img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ",
    size: 200,
    labelCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    },
    clipCfg: {
      show: false,
      type: "circle",
      // circle
      r: 50,
      // ellipse
      rx: 50,
      ry: 35,
      // rect
      width: 50,
      height: 35,
      // polygon
      points: [[30, 12], [12, 30], [30, 48], [48, 30]],
      // path
      path: [["M", 25, 25], ["L", 50, 25], ["A", 12.5, 12.5, 0, 1, 1, 50, 50], ["A", 12.5, 12.5, 0, 1, 0, 50, 50], ["L", 25, 75], ["Z"]],
      // 坐标
      x: 0,
      y: 0
      // clip 的属性样式
      // style: {
      //   lineWidth: 1
      // },
    }
  },
  shapeType: "image",
  labelPosition: "bottom",
  drawShape: function drawShape10(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    delete style.fill;
    var shape = group.addShape(shapeType, {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    this.drawClip(cfg, shape);
    return shape;
  },
  drawClip: function drawClip(cfg, shape) {
    var clip = (this.mergeStyle || this.getOptions(cfg)).clipCfg;
    if (!clip.show) {
      return;
    }
    var type = clip.type, x4 = clip.x, y4 = clip.y, style = clip.style;
    if (type === "circle") {
      var r2 = clip.r;
      shape.setClip({
        type: "circle",
        attrs: __assign3({
          r: r2,
          x: x4,
          y: y4
        }, style)
      });
    } else if (type === "rect") {
      var width = clip.width, height = clip.height;
      var rectX = x4 - width / 2;
      var rectY = y4 - height / 2;
      shape.setClip({
        type: "rect",
        attrs: __assign3({
          x: rectX,
          y: rectY,
          width,
          height
        }, style)
      });
    } else if (type === "ellipse") {
      var rx = clip.rx, ry = clip.ry;
      shape.setClip({
        type: "ellipse",
        attrs: __assign3({
          x: x4,
          y: y4,
          rx,
          ry
        }, style)
      });
    } else if (type === "polygon") {
      var points = clip.points;
      shape.setClip({
        type: "polygon",
        attrs: __assign3({
          points
        }, style)
      });
    } else if (type === "path") {
      var path = clip.path;
      shape.setClip({
        type: "path",
        attrs: __assign3({
          path
        }, style)
      });
    }
  },
  getShapeStyle: function getShapeStyle7(cfg) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), defaultStyle = _a2.style, img = _a2.img;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (defaultStyle) {
      width = defaultStyle.width || size3[0];
      height = defaultStyle.height || size3[1];
    }
    var style = __assign3({
      x: -width / 2,
      y: -height / 2,
      width,
      height,
      img
    }, defaultStyle);
    return style;
  },
  updateShapeStyle: function updateShapeStyle3(cfg, item) {
    var group = item.getContainer();
    var shapeClassName = "".concat(this.itemType, "-shape");
    var shape = group["shapeMap"][shapeClassName] || group.find(function(element) {
      return element.get("className") === shapeClassName;
    }) || item.getKeyShape();
    var shapeStyle = this.getShapeStyle(cfg);
    if (shape && !shape.destroyed) {
      shape.attr(shapeStyle);
    }
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/arrow.js
var arrow_default = {
  triangle: function triangle(width, length6, d2) {
    if (width === void 0) {
      width = 10;
    }
    if (length6 === void 0) {
      length6 = 15;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 L ").concat(begin + length6, ",-").concat(width / 2, " L ").concat(begin + length6, ",").concat(width / 2, " Z");
    return path;
  },
  vee: function vee(width, length6, d2) {
    if (width === void 0) {
      width = 15;
    }
    if (length6 === void 0) {
      length6 = 20;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 L ").concat(begin + length6, ",-").concat(width / 2, "\n        L ").concat(begin + 2 * length6 / 3, ",0 L ").concat(begin + length6, ",").concat(width / 2, " Z");
    return path;
  },
  circle: function circle(r2, d2) {
    if (r2 === void 0) {
      r2 = 5;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ", 0\n            a ").concat(r2, ",").concat(r2, " 0 1,0 ").concat(r2 * 2, ",0\n            a ").concat(r2, ",").concat(r2, " 0 1,0 ").concat(-r2 * 2, ",0");
    return path;
  },
  rect: function rect(width, length6, d2) {
    if (width === void 0) {
      width = 10;
    }
    if (length6 === void 0) {
      length6 = 10;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",").concat(-width / 2, " \n        L ").concat(begin + length6, ",").concat(-width / 2, " \n        L ").concat(begin + length6, ",").concat(width / 2, " \n        L ").concat(begin, ",").concat(width / 2, " Z");
    return path;
  },
  diamond: function diamond(width, length6, d2) {
    if (width === void 0) {
      width = 15;
    }
    if (length6 === void 0) {
      length6 = 15;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 \n        L ").concat(begin + length6 / 2, ",").concat(-width / 2, " \n        L ").concat(begin + length6, ",0 \n        L ").concat(begin + length6 / 2, ",").concat(width / 2, " Z");
    return path;
  },
  triangleRect: function triangleRect(tWidth, tLength, rWidth, rLength, gap, d2) {
    if (tWidth === void 0) {
      tWidth = 15;
    }
    if (tLength === void 0) {
      tLength = 15;
    }
    if (rWidth === void 0) {
      rWidth = 15;
    }
    if (rLength === void 0) {
      rLength = 3;
    }
    if (gap === void 0) {
      gap = 5;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var rectBegin = begin + tLength + gap;
    var path = "M ".concat(begin, ",0 L ").concat(begin + tLength, ",-").concat(tWidth / 2, " L ").concat(begin + tLength, ",").concat(tWidth / 2, " Z\n            M ").concat(rectBegin, ", -").concat(rWidth / 2, "\n            L ").concat(rectBegin + rLength, " -").concat(rWidth / 2, "\n            L ").concat(rectBegin + rLength, " ").concat(rWidth / 2, "\n            L ").concat(rectBegin, " ").concat(rWidth / 2, "\n            Z");
    return path;
  }
};

// node_modules/@antv/g6-core/es/element/marker.js
var marker_default = {
  collapse: function collapse(x4, y4, r2) {
    return [["M", x4 - r2, y4], ["a", r2, r2, 0, 1, 0, r2 * 2, 0], ["a", r2, r2, 0, 1, 0, -r2 * 2, 0], ["M", x4 - r2 + 4, y4], ["L", x4 + r2 - 4, y4]];
  },
  expand: function expand(x4, y4, r2) {
    return [["M", x4 - r2, y4], ["a", r2, r2, 0, 1, 0, r2 * 2, 0], ["a", r2, r2, 0, 1, 0, -r2 * 2, 0], ["M", x4 - r2 + 4, y4], ["L", x4 - r2 + 2 * r2 - 4, y4], ["M", x4 - r2 + r2, y4 - r2 + 4], ["L", x4, y4 + r2 - 4]];
  },
  upTriangle: function upTriangle(x4, y4, r2) {
    var l1 = r2 * Math.cos(Math.PI / 6);
    var l2 = r2 * Math.sin(Math.PI / 6);
    return [["M", x4 - l1, y4 + l2], ["L", x4 + l1, y4 + l2], ["L", x4, y4 - r2], ["Z"]];
  },
  downTriangle: function downTriangle(x4, y4, r2) {
    var l1 = r2 * Math.cos(Math.PI / 6);
    var l2 = r2 * Math.sin(Math.PI / 6);
    return [["M", x4 - l1, y4 - l2], ["L", x4 + l1, y4 - l2], ["L", x4, y4 + r2], ["Z"]];
  }
};

// node_modules/@antv/g6-core/es/element/index.js
var element_default2 = shape_default2;

// node_modules/@antv/g6-core/es/util/color.js
var color_exports = {};
__export(color_exports, {
  defaultSubjectColors: () => defaultSubjectColors
});
var defaultSubjectColors = ["#5F95FF", "#61DDAA", "#65789B", "#F6BD16", "#7262FD", "#78D3F8", "#9661BC", "#F6903D", "#008685", "#F08BB4"];

// node_modules/@antv/g6-core/es/util/layout.js
var layout_exports = {};
__export(layout_exports, {
  isForce: () => isForce
});
var isForce = function isForce2(layoutType) {
  return layoutType === "force" || layoutType === "g6force" || layoutType === "gForce" || layoutType === "force2";
};

// node_modules/@antv/g6-core/es/util/index.js
var transform7 = ext_exports.transform;
var Util = __assign3(__assign3(__assign3(__assign3(__assign3(__assign3(__assign3({}, base_exports), graphic_exports), path_exports2), math_exports), color_exports), layout_exports), {
  transform: transform7,
  mat3: mat3_exports
});
var util_default = Util;

// node_modules/@antv/g6-core/es/graph/controller/layout.js
init_esm();
var LayoutController = (
  /** @class */
  function() {
    function LayoutController3(graph) {
      this.graph = graph;
      this.layoutCfg = graph.get("layout") || {};
      this.layoutType = this.getLayoutType();
      this.layoutMethods = [];
      this.initLayout();
    }
    LayoutController3.prototype.initLayout = function() {
    };
    LayoutController3.prototype.getLayoutType = function() {
      return this.getLayoutCfgType(this.layoutCfg);
    };
    LayoutController3.prototype.getLayoutCfgType = function(layoutCfg) {
      var type = layoutCfg.type;
      if (type) {
        return type;
      }
      var pipes = layoutCfg.pipes;
      if (Array.isArray(pipes)) {
        return pipes.map(function(pipe) {
          return (pipe === null || pipe === void 0 ? void 0 : pipe.type) || "";
        });
      }
      return null;
    };
    LayoutController3.prototype.isLayoutTypeSame = function(cfg) {
      var current = this.getLayoutCfgType(cfg);
      var preHasPipes = Array.isArray(this.layoutType);
      var currentHasPipes = Array.isArray(current);
      if (preHasPipes && currentHasPipes) {
        return this.layoutType.every(function(type, index2) {
          return type === current[index2];
        });
      }
      if (Array.isArray(current) || Array.isArray(this.layoutType)) {
        return false;
      }
      return (cfg === null || cfg === void 0 ? void 0 : cfg.type) === this.layoutType;
    };
    LayoutController3.prototype.refreshLayout = function() {
      var _a2 = this, graph = _a2.graph, layoutType = _a2.layoutType, _b = _a2.layoutCfg, layoutCfg = _b === void 0 ? {} : _b;
      if (!graph) return;
      var animate = layoutCfg.animate;
      var isDefaultAnimateLayout = animate === void 0 && (layoutType === "force" || layoutType === "force2");
      var forceAnimate = isForce(layoutType) && (animate || isDefaultAnimateLayout);
      if (graph.get("animate") && !forceAnimate) {
        graph.positionsAnimate(layoutType === "comboCombined");
      } else {
        graph.refreshPositions(layoutType === "comboCombined");
      }
    };
    LayoutController3.prototype.changeLayout = function(cfg) {
      var disableTriggerLayout = cfg.disableTriggerLayout, otherCfgs = __rest3(cfg, ["disableTriggerLayout"]);
      this.layoutCfg = otherCfgs;
      this.layoutType = otherCfgs.type || this.layoutType;
      if (disableTriggerLayout) return;
      this.layout();
    };
    LayoutController3.prototype.changeData = function(success) {
      this.layout(success);
    };
    LayoutController3.prototype.destoryLayoutMethods = function() {
      var layoutMethods = this.layoutMethods;
      var destroyedLayoutTypes = [];
      layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function(layoutMethod) {
        var _a2;
        var layoutType = (_a2 = layoutMethod.getType) === null || _a2 === void 0 ? void 0 : _a2.call(layoutMethod);
        if (layoutType) destroyedLayoutTypes.push(layoutType);
        layoutMethod.destroy();
      });
      this.layoutMethods = [];
      return destroyedLayoutTypes;
    };
    LayoutController3.prototype.destroyLayout = function() {
      this.destoryLayoutMethods();
      var graph = this.graph;
      if (graph && !graph.get("destroyed")) {
        graph.set("layout", void 0);
      }
      this.layoutCfg = void 0;
      this.layoutType = void 0;
      this.layoutMethods = void 0;
    };
    LayoutController3.prototype.setDataFromGraph = function() {
      var _a2;
      var nodes = [];
      var hiddenNodes = [];
      var edges = [];
      var hiddenEdges = [];
      var comboEdges = [];
      var combos = [];
      var hiddenCombos = [];
      var nodeItems = this.graph.getNodes();
      var edgeItems = this.graph.getEdges();
      var comboItems = this.graph.getCombos();
      var nodeLength = nodeItems.length;
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var nodeItem = nodeItems[i2];
        if (!nodeItem || nodeItem.destroyed) continue;
        var model = nodeItem.getModel();
        if (!nodeItem.isVisible()) {
          hiddenNodes.push(model);
          continue;
        }
        nodes.push(model);
      }
      var edgeLength = edgeItems.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edgeItem = edgeItems[i2];
        if (!edgeItem || edgeItem.destroyed) continue;
        var model = edgeItem.getModel();
        if (!edgeItem.isVisible()) {
          hiddenEdges.push(model);
          continue;
        }
        if (!model.isComboEdge) edges.push(model);
        else comboEdges.push(model);
      }
      var comboLength = comboItems.length;
      for (var i2 = 0; i2 < comboLength; i2++) {
        var comboItem = comboItems[i2];
        if (comboItem.destroyed) continue;
        var model = comboItem.getModel();
        if (!comboItem.isVisible()) {
          hiddenCombos.push(model);
          continue;
        }
        combos.push(model);
      }
      return {
        nodes,
        hiddenNodes,
        edges,
        hiddenEdges,
        combos,
        hiddenCombos,
        comboEdges,
        vedges: (_a2 = this.graph.get("vedges")) === null || _a2 === void 0 ? void 0 : _a2.map(function(edge) {
          return edge.getModel();
        })
      };
    };
    LayoutController3.prototype.relayout = function(reloadData) {
      var _this = this;
      var _a2 = this, graph = _a2.graph, layoutMethods = _a2.layoutMethods, layoutCfg = _a2.layoutCfg;
      if (!graph || graph.get("destroyed")) return;
      var start = Promise.resolve();
      if (reloadData) {
        this.data = this.setDataFromGraph();
        var nodes = this.data.nodes;
        if (!nodes) {
          return false;
        }
        start = this.initPositions(layoutCfg.center, nodes);
      }
      graph.emit("beforelayout");
      layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function(layoutMethod, index2) {
        var currentCfg = layoutCfg[index2] || layoutCfg;
        start = start.then(function() {
          var _a3;
          var relayoutPromise = _this.execLayoutMethod(currentCfg, index2);
          if (index2 === layoutMethods.length - 1) {
            (_a3 = layoutCfg.onAllLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(layoutCfg);
          }
          return relayoutPromise;
        });
      });
    };
    LayoutController3.prototype.filterLayoutData = function(data, cfg) {
      var nodes = data.nodes, edges = data.edges, rest = __rest3(data, ["nodes", "edges"]);
      if (!nodes) {
        return data;
      }
      var nodesFilter;
      var edegsFilter;
      if (is_function_default(cfg === null || cfg === void 0 ? void 0 : cfg.nodesFilter)) {
        nodesFilter = cfg.nodesFilter;
      } else {
        nodesFilter = function nodesFilter2() {
          return true;
        };
      }
      var fNodes = nodes.filter(nodesFilter);
      if (is_function_default(cfg === null || cfg === void 0 ? void 0 : cfg.edgesFilter)) {
        edegsFilter = cfg.edgesFilter;
      } else {
        var nodesMap_1 = fNodes.reduce(function(acc, cur) {
          acc[cur.id] = true;
          return acc;
        }, {});
        edegsFilter = function edegsFilter2(edge) {
          return nodesMap_1[edge.source] && nodesMap_1[edge.target];
        };
      }
      return __assign3({
        nodes: fNodes,
        edges: edges.filter(edegsFilter)
      }, rest);
    };
    LayoutController3.prototype.getLayoutBBox = function(nodes) {
      var graph = this.graph;
      var graphGroupNodes = group_by_default(graph.getNodes(), function(n2) {
        return n2.getModel().layoutOrder;
      });
      var layoutNodes = Object.values(graphGroupNodes).map(function(value) {
        var bbox = calculationItemsBBox(value);
        bbox.size = [bbox.width, bbox.height];
        return bbox;
      });
      var groupNodes = Object.values(group_by_default(nodes, "layoutOrder"));
      return {
        groupNodes,
        layoutNodes
      };
    };
    LayoutController3.prototype.layoutAnimate = function() {
    };
    LayoutController3.prototype.moveToZero = function() {
      var graph = this.graph;
      var data = graph.get("data");
      var nodes = data.nodes;
      if (nodes[0].x === void 0 || nodes[0].x === null || isNaN2(nodes[0].x)) {
        return;
      }
      var meanCenter = [0, 0];
      var nodeLength = nodes.length;
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var node = nodes[i2];
        meanCenter[0] += node.x;
        meanCenter[1] += node.y;
      }
      meanCenter[0] /= nodes.length;
      meanCenter[1] /= nodes.length;
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var node = nodes[i2];
        node.x -= meanCenter[0];
        node.y -= meanCenter[1];
      }
    };
    LayoutController3.prototype.initPositions = function(center, nodes) {
      var _a2;
      return __awaiter3(this, void 0, void 0, function() {
        var graph, nodesToInit, nodeLength;
        return __generator3(this, function(_b) {
          graph = this.graph;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
            return [2, Promise.resolve()];
          }
          nodesToInit = nodes.filter(function(node) {
            return isNaN2(node.x) || isNaN2(node.y);
          });
          nodeLength = nodesToInit ? nodesToInit.length : 0;
          if (!nodeLength) return [
            2
            /*return*/
          ];
          return [2, (_a2 = this.initWithPreset) === null || _a2 === void 0 ? void 0 : _a2.call(
            this,
            function() {
            },
            // onFullfillment
            function() {
              var width = graph.get("width") * 0.85;
              var height = graph.get("height") * 0.85;
              var horiNum = Math.ceil(Math.sqrt(nodeLength) * (width / height));
              var vertiNum = Math.ceil(nodeLength / horiNum);
              var horiGap = width / (horiNum - 1);
              var vertiGap = height / (vertiNum - 1);
              if (!isFinite(horiGap) || !horiGap) horiGap = 0;
              if (!isFinite(vertiGap) || !horiGap) vertiGap = 0;
              var beginX = center[0] - width / 2;
              var beginY = center[1] - height / 2;
              var allHavePos = true;
              for (var i2 = 0; i2 < nodeLength; i2++) {
                var node = nodesToInit[i2];
                if (isNaN2(+node.x)) {
                  allHavePos = false;
                  node.x = i2 % horiNum * horiGap + beginX;
                }
                if (isNaN2(+node.y)) {
                  allHavePos = false;
                  node.y = Math.floor(i2 / horiNum) * vertiGap + beginY;
                }
              }
            }
          )];
        });
      });
    };
    LayoutController3.prototype.destroy = function() {
      this.graph = null;
      this.destoryLayoutMethods();
      this.destroyed = true;
    };
    return LayoutController3;
  }()
);
var layout_default = LayoutController;

// node_modules/@antv/g6-core/es/graph/controller/event.js
var EventController2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventController4(graph) {
      this.graph = graph;
      this.destroyed = false;
      this.initEvents();
    }
    return EventController4;
  }()
);
var event_default = EventController2;

// node_modules/@antv/g6-core/es/index.js
var registerNode = element_default2.registerNode;
var registerEdge = element_default2.registerEdge;
var registerCombo = element_default2.registerCombo;
var registerBehavior = behavior_default2.registerBehavior;
var BaseGlobal = global_default;
var es_default2 = {
  version: global_default.version,
  AbstractGraph: graph_default,
  BaseGlobal,
  Util: util_default,
  Shape: element_default2,
  Node: node_default,
  Edge: edge_default,
  Combo: combo_default,
  Hull: hull_default,
  registerNode: element_default2.registerNode,
  registerEdge: element_default2.registerEdge,
  registerCombo: element_default2.registerCombo,
  registerBehavior: behavior_default2.registerBehavior,
  Arrow: arrow_default,
  Marker: marker_default,
  AbstractLayout: layout_default,
  AbstractEvent: event_default
};

// node_modules/@antv/g6-pc/es/index.js
var AlgorithmAsync = __toESM(require_asyncIndex());

// node_modules/@antv/g-canvas/esm/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Base: () => base_default2,
  Circle: () => circle_default2,
  Ellipse: () => ellipse_default3,
  Image: () => image_default,
  Line: () => line_default3,
  Marker: () => marker_default2,
  Path: () => path_default2,
  Polygon: () => polygon_default3,
  Polyline: () => polyline_default3,
  Rect: () => rect_default2,
  Text: () => text_default2
});

// node_modules/@antv/g-canvas/esm/shape/base.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/util.js
init_esm();
function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
function distance7(x1, y1, x22, y22) {
  var dx = x1 - x22;
  var dy = y1 - y22;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x4, y4) {
  return x4 >= minX && x4 <= minX + width && y4 >= minY && y4 <= minY + height;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint2(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

// node_modules/@antv/g-canvas/esm/util/draw.js
init_esm();

// node_modules/@antv/g-canvas/esm/util/parse.js
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop(steps, gradient2) {
  var arr = steps.match(regexColorStop);
  each_default(arr, function(item) {
    var itemArr = item.split(":");
    gradient2.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG.exec(gradientStr);
  var angle3 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end2;
  if (angle3 >= 0 && angle3 < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end2 = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle3 && angle3 < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end2 = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle3 && angle3 < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end2 = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end2 = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle3);
  var tanTheta2 = tanTheta * tanTheta;
  var x4 = (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y4 = tanTheta * (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient2 = context.createLinearGradient(start.x, start.y, x4, y4);
  addStop(steps, gradient2);
  return gradient2;
}
function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr2 = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr2 === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r2 = Math.sqrt(width * width + height * height) / 2;
  var gradient2 = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr2 * r2);
  addStop(steps, gradient2);
  return gradient2;
}
function parsePattern(context, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  function onload() {
    pattern = context.createPattern(img, repeat);
    element.set("pattern", pattern);
    element.set("patternSource", patternStr);
  }
  switch (repeat) {
    case "a":
      repeat = "repeat";
      break;
    case "x":
      repeat = "repeat-x";
      break;
    case "y":
      repeat = "repeat-y";
      break;
    case "n":
      repeat = "no-repeat";
      break;
    default:
      repeat = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern;
}
function parseStyle(context, element, color3) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color3;
  }
  if (is_string_default(color3)) {
    if (color3[1] === "(" || color3[2] === "(") {
      if (color3[0] === "l") {
        return parseLineGradient(context, element, color3);
      }
      if (color3[0] === "r") {
        return parseRadialGradient(context, element, color3);
      }
      if (color3[0] === "p") {
        return parsePattern(context, element, color3);
      }
    }
    return color3;
  }
  if (color3 instanceof CanvasPattern) {
    return color3;
  }
}
function parseRadius2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}

// node_modules/@antv/g-canvas/esm/util/arc-params.js
function vMag2(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio2(u2, v2) {
  return vMag2(u2) * vMag2(v2) ? (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag2(u2) * vMag2(v2)) : 1;
}
function vAngle2(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio2(u2, v2));
}
function getArcParams2(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x22 = params[6];
  var y22 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x22) / 2 + Math.sin(xRotation) * (y1 - y22) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x22) / 2 + Math.cos(xRotation) * (y1 - y22) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x1 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle2([1, 0], u2);
  var dTheta = vAngle2(u2, v2);
  if (vRatio2(u2, v2) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio2(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint2(startPoint, [x22, y22]) ? 0 : rx,
    ry: isSamePoint2(startPoint, [x22, y22]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/g-canvas/esm/util/arrow.js
init_tslib_es6();
var sin2 = Math.sin;
var cos2 = Math.cos;
var atan2 = Math.atan2;
var PI2 = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x22, y22, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x4 = x1 - x22;
  var y4 = y1 - y22;
  var rad = atan2(y4, x4);
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      // 默认箭头的边长为 10，夹角为 60 度
      path: "M" + 10 * cos2(PI2 / 6) + "," + 10 * sin2(PI2 / 6) + " L0,0 L" + 10 * cos2(PI2 / 6) + ",-" + 10 * sin2(PI2 / 6),
      // 使用 shape stroke 值
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x22, y22);
  arrowShape.rotateAtPoint(x22, y22, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x22, y22, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d2 = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest2(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x4 = x1 - x22;
  var y4 = y1 - y22;
  var rad = atan2(y4, x4);
  if (d2) {
    x22 = x22 - cos2(rad) * d2;
    y22 = y22 - sin2(rad) * d2;
  }
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign2(__assign2({}, restAttrs), {
      // 支持单独设置箭头的 stroke 和 lineWidth，若为空则使用 shape 的值
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      // 箭头是否填充需要手动设置，不会继承自 shape 的值
      fill: arrowFill
    })
  });
  arrowShape.translate(x22, y22);
  arrowShape.rotateAtPoint(x22, y22, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x22, y22, d2) {
  var rad = atan2(y22 - y1, x22 - x1);
  return {
    dx: cos2(rad) * d2,
    dy: sin2(rad) * d2
  };
}
function addStartArrow(shape, attrs, x1, y1, x22, y22) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x22, y22, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x22, y22, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x22, y22) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x22, y22, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x22, y22, false);
  } else {
    shape.set("startArrowShape", null);
  }
}

// node_modules/@antv/g-canvas/esm/util/draw.js
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k2 in attrs) {
    var v2 = attrs[k2];
    var name_1 = SHAPE_ATTRS_MAP[k2] ? SHAPE_ATTRS_MAP[k2] : k2;
    if (name_1 === "matrix" && v2) {
      context.transform(v2[0], v2[1], v2[3], v2[4], v2[6], v2[7]);
    } else if (name_1 === "lineDash" && context.setLineDash) {
      is_array_default(v2) && context.setLineDash(v2);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v2 = parseStyle(context, element, v2);
      } else if (name_1 === "globalAlpha") {
        v2 = v2 * context.globalAlpha;
      }
      context[name_1] = v2;
    }
  }
}
function drawChildren(context, children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each_default(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i2 = 0; i2 < elements.length; i2++) {
    var el = elements[i2];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (!child.cfg.visible) {
      continue;
    }
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"), region);
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);
  return isAllow;
}
function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance11 = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i2 = 0; i2 < path.length; i2++) {
    var params = path[i2];
    var command = params[0];
    if (i2 === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance11 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i2 === path.length - 2 && path[i2 + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path[i2 + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance11 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i2 === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance11 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance11.dx, dy = distance11.dy;
    switch (command) {
      case "M":
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i2];
          if (!arcParams) {
            arcParams = getArcParams2(currentPoint, params);
            arcParamsCache[i2] = arcParams;
          }
        } else {
          arcParams = getArcParams2(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r2 = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r2, startAngle, endAngle, 1 - sweepFlag);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len6 = params.length;
      currentPoint = [params[len6 - 2], params[len6 - 1]];
    }
  }
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each_default(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min_default(minXArr),
    minY: min_default(minYArr),
    maxX: max_default(maxXArr),
    maxY: max_default(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

// node_modules/@antv/g-canvas/esm/group.js
init_tslib_es6();
init_esm();
var Group = (
  /** @class */
  function(_super) {
    __extends2(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    Group3.prototype.cacheCanvasBBox = function() {
      var children = this.cfg.children;
      var xArr = [];
      var yArr = [];
      each_default(children, function(child) {
        var bbox2 = child.cfg.cacheCanvasBBox;
        if (bbox2 && child.cfg.isInView) {
          xArr.push(bbox2.minX, bbox2.maxX);
          yArr.push(bbox2.minY, bbox2.maxY);
        }
      });
      var bbox = null;
      if (xArr.length) {
        var minX = min_default(xArr);
        var maxX = max_default(xArr);
        var minY = min_default(yArr);
        var maxY = max_default(yArr);
        bbox = {
          minX,
          minY,
          x: minX,
          y: minY,
          maxX,
          maxY,
          width: maxX - minX,
          height: maxY - minY
        };
        var canvas = this.cfg.canvas;
        if (canvas) {
          var viewRange = canvas.getViewRange();
          this.set("isInView", intersectRect(bbox, viewRange));
        }
      } else {
        this.set("isInView", false);
      }
      this.set("cacheCanvasBBox", bbox);
    };
    Group3.prototype.draw = function(context, region) {
      var children = this.cfg.children;
      var allowDraw = region ? this.cfg.refresh : true;
      if (children.length && allowDraw) {
        context.save();
        applyAttrsToContext(context, this);
        this._applyClip(context, this.getClip());
        drawChildren(context, children, region);
        context.restore();
        this.cacheCanvasBBox();
      }
      this.cfg.refresh = null;
      this.set("hasChanged", false);
    };
    Group3.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("hasChanged", false);
    };
    return Group3;
  }(group_default2)
);
var group_default3 = Group;

// node_modules/@antv/g-canvas/esm/shape/base.js
var ShapeBase = (
  /** @class */
  function(_super) {
    __extends2(ShapeBase3, _super);
    function ShapeBase3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeBase3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase3.prototype.getShapeBase = function() {
      return shape_exports;
    };
    ShapeBase3.prototype.getGroupBase = function() {
      return group_default3;
    };
    ShapeBase3.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    ShapeBase3.prototype.calculateBBox = function() {
      var type = this.get("type");
      var lineWidth = this.getHitLineWidth();
      var bboxMethod = getMethod(type);
      var box2 = bboxMethod(this);
      var halfLineWidth = lineWidth / 2;
      var minX = box2.x - halfLineWidth;
      var minY = box2.y - halfLineWidth;
      var maxX = box2.x + box2.width + halfLineWidth;
      var maxY = box2.y + box2.height + halfLineWidth;
      return {
        x: minX,
        minX,
        y: minY,
        minY,
        width: box2.width + lineWidth,
        height: box2.height + lineWidth,
        maxX,
        maxY
      };
    };
    ShapeBase3.prototype.isFill = function() {
      return !!this.attrs["fill"] || this.isClipShape();
    };
    ShapeBase3.prototype.isStroke = function() {
      return !!this.attrs["stroke"];
    };
    ShapeBase3.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    ShapeBase3.prototype.draw = function(context, region) {
      var clip = this.cfg.clipShape;
      if (region) {
        if (this.cfg.refresh === false) {
          this.set("hasChanged", false);
          return;
        }
        var bbox = this.getCanvasBBox();
        if (!intersectRect(region, bbox)) {
          this.set("hasChanged", false);
          if (this.cfg.isInView) {
            this._afterDraw();
          }
          return;
        }
      }
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, clip);
      this.drawPath(context);
      context.restore();
      this._afterDraw();
    };
    ShapeBase3.prototype.getCanvasViewBox = function() {
      var canvas = this.cfg.canvas;
      if (canvas) {
        return canvas.getViewRange();
      }
      return null;
    };
    ShapeBase3.prototype.cacheCanvasBBox = function() {
      var canvasBBox = this.getCanvasViewBox();
      if (canvasBBox) {
        var bbox = this.getCanvasBBox();
        var isInView = intersectRect(bbox, canvasBBox);
        this.set("isInView", isInView);
        if (isInView) {
          this.set("cacheCanvasBBox", bbox);
        } else {
          this.set("cacheCanvasBBox", null);
        }
      }
    };
    ShapeBase3.prototype._afterDraw = function() {
      this.cacheCanvasBBox();
      this.set("hasChanged", false);
      this.set("refresh", null);
    };
    ShapeBase3.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("isInView", null);
      this.set("hasChanged", false);
    };
    ShapeBase3.prototype.drawPath = function(context) {
      this.createPath(context);
      this.strokeAndFill(context);
      this.afterDrawPath(context);
    };
    ShapeBase3.prototype.fill = function(context) {
      context.fill();
    };
    ShapeBase3.prototype.stroke = function(context) {
      context.stroke();
    };
    ShapeBase3.prototype.strokeAndFill = function(context) {
      var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = strokeOpacity;
          }
          this.stroke(context);
        }
      }
      this.afterDrawPath(context);
    };
    ShapeBase3.prototype.createPath = function(context) {
    };
    ShapeBase3.prototype.afterDrawPath = function(context) {
    };
    ShapeBase3.prototype.isInShape = function(refX, refY) {
      var isStroke = this.isStroke();
      var isFill = this.isFill();
      var lineWidth = this.getHitLineWidth();
      return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
    };
    ShapeBase3.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      return false;
    };
    ShapeBase3.prototype.getHitLineWidth = function() {
      if (!this.isStroke()) {
        return 0;
      }
      var attrs = this.attrs;
      return attrs["lineWidth"] + attrs["lineAppendWidth"];
    };
    return ShapeBase3;
  }(shape_default)
);
var base_default2 = ShapeBase;

// node_modules/@antv/g-canvas/esm/shape/circle.js
init_tslib_es6();
var Circle = (
  /** @class */
  function(_super) {
    __extends2(Circle3, _super);
    function Circle3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle3.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r2 = attrs.r;
      var halfLineWidth = lineWidth / 2;
      var absDistance = distance7(cx, cy, x4, y4);
      if (isFill && isStroke) {
        return absDistance <= r2 + halfLineWidth;
      }
      if (isFill) {
        return absDistance <= r2;
      }
      if (isStroke) {
        return absDistance >= r2 - halfLineWidth && absDistance <= r2 + halfLineWidth;
      }
      return false;
    };
    Circle3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r2 = attrs.r;
      context.beginPath();
      context.arc(cx, cy, r2, 0, Math.PI * 2, false);
      context.closePath();
    };
    return Circle3;
  }(base_default2)
);
var circle_default2 = Circle;

// node_modules/@antv/g-canvas/esm/shape/ellipse.js
init_tslib_es6();
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse = (
  /** @class */
  function(_super) {
    __extends2(Ellipse3, _super);
    function Ellipse3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var halfLineWith = lineWidth / 2;
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx, ry = attrs.ry;
      var squareX = (x4 - cx) * (x4 - cx);
      var squareY = (y4 - cy) * (y4 - cy);
      if (isFill && isStroke) {
        return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      if (isFill) {
        return ellipseDistance(squareX, squareY, rx, ry) <= 1;
      }
      if (isStroke) {
        return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      return false;
    };
    Ellipse3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx;
      var ry = attrs.ry;
      context.beginPath();
      if (context.ellipse) {
        context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
      } else {
        var r2 = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        context.save();
        context.translate(cx, cy);
        context.scale(scaleX, scaleY);
        context.arc(0, 0, r2, 0, Math.PI * 2);
        context.restore();
        context.closePath();
      }
    };
    return Ellipse3;
  }(base_default2)
);
var ellipse_default3 = Ellipse;

// node_modules/@antv/g-canvas/esm/shape/image.js
init_tslib_es6();
function isCanvas(dom) {
  return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = (
  /** @class */
  function(_super) {
    __extends2(ImageShape2, _super);
    function ImageShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageShape2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    ImageShape2.prototype.initAttrs = function(attrs) {
      this._setImage(attrs.img);
    };
    ImageShape2.prototype.isStroke = function() {
      return false;
    };
    ImageShape2.prototype.isOnlyHitBox = function() {
      return true;
    };
    ImageShape2.prototype._afterLoading = function() {
      if (this.get("toDraw") === true) {
        var canvas = this.get("canvas");
        if (canvas) {
          canvas.draw();
        } else {
          this.createPath(this.get("context"));
        }
      }
    };
    ImageShape2.prototype._setImage = function(img) {
      var _this = this;
      var attrs = this.attrs;
      if (is_string_default(img)) {
        var image_1 = new Image();
        image_1.onload = function() {
          if (_this.destroyed) {
            return false;
          }
          _this.attr("img", image_1);
          _this.set("loading", false);
          _this._afterLoading();
          var callback = _this.get("callback");
          if (callback) {
            callback.call(_this);
          }
        };
        image_1.crossOrigin = "Anonymous";
        image_1.src = img;
        this.set("loading", true);
      } else if (img instanceof Image) {
        if (!attrs.width) {
          attrs.width = img.width;
        }
        if (!attrs.height) {
          attrs.height = img.height;
        }
      } else if (isCanvas(img)) {
        if (!attrs.width) {
          attrs.width = Number(img.getAttribute("width"));
        }
        if (!attrs.height) {
          attrs.height, Number(img.getAttribute("height"));
        }
      }
    };
    ImageShape2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "img") {
        this._setImage(value);
      }
    };
    ImageShape2.prototype.createPath = function(context) {
      if (this.get("loading")) {
        this.set("toDraw", true);
        this.set("context", context);
        return;
      }
      var attrs = this.attr();
      var x4 = attrs.x, y4 = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
      var img = attrs.img;
      if (img instanceof Image || isCanvas(img)) {
        if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) {
          context.drawImage(img, sx, sy, swidth, sheight, x4, y4, width, height);
        } else {
          context.drawImage(img, x4, y4, width, height);
        }
      }
    };
    return ImageShape2;
  }(base_default2)
);
var image_default = ImageShape;

// node_modules/@antv/g-canvas/esm/shape/line.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
function inLine(x1, y1, x22, y22, lineWidth, x4, y4) {
  var minX = Math.min(x1, x22);
  var maxX = Math.max(x1, x22);
  var minY = Math.min(y1, y22);
  var maxY = Math.max(y1, y22);
  var halfWidth = lineWidth / 2;
  if (!(x4 >= minX - halfWidth && x4 <= maxX + halfWidth && y4 >= minY - halfWidth && y4 <= maxY + halfWidth)) {
    return false;
  }
  return line_default.pointToLine(x1, y1, x22, y22, x4, y4) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/shape/line.js
var Line2 = (
  /** @class */
  function(_super) {
    __extends2(Line4, _super);
    function Line4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line4.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    Line4.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
    };
    Line4.prototype.setArrow = function() {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x22 = attrs.x2, y22 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        addStartArrow(this, attrs, x22, y22, x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, x1, y1, x22, y22);
      }
    };
    Line4.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      return inLine(x1, y1, x22, y22, lineWidth, x4, y4);
    };
    Line4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x22 = attrs.x2, y22 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      var startArrowDistance = {
        dx: 0,
        dy: 0
      };
      var endArrowDistance = {
        dx: 0,
        dy: 0
      };
      if (startArrow && startArrow.d) {
        startArrowDistance = getShortenOffset(x1, y1, x22, y22, attrs.startArrow.d);
      }
      if (endArrow && endArrow.d) {
        endArrowDistance = getShortenOffset(x1, y1, x22, y22, attrs.endArrow.d);
      }
      context.beginPath();
      context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
      context.lineTo(x22 - endArrowDistance.dx, y22 - endArrowDistance.dy);
    };
    Line4.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Line4.prototype.getTotalLength = function() {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      return line_default.length(x1, y1, x22, y22);
    };
    Line4.prototype.getPoint = function(ratio) {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      return line_default.pointAt(x1, y1, x22, y22, ratio);
    };
    return Line4;
  }(base_default2)
);
var line_default3 = Line2;

// node_modules/@antv/g-canvas/esm/shape/marker.js
init_tslib_es6();
init_esm();
var Symbols = {
  // 圆
  circle: function(x4, y4, r2) {
    return [
      ["M", x4 - r2, y4],
      ["A", r2, r2, 0, 1, 0, x4 + r2, y4],
      ["A", r2, r2, 0, 1, 0, x4 - r2, y4]
    ];
  },
  // 正方形
  square: function(x4, y4, r2) {
    return [["M", x4 - r2, y4 - r2], ["L", x4 + r2, y4 - r2], ["L", x4 + r2, y4 + r2], ["L", x4 - r2, y4 + r2], ["Z"]];
  },
  // 菱形
  diamond: function(x4, y4, r2) {
    return [["M", x4 - r2, y4], ["L", x4, y4 - r2], ["L", x4 + r2, y4], ["L", x4, y4 + r2], ["Z"]];
  },
  // 三角形
  triangle: function(x4, y4, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x4 - r2, y4 + diffY], ["L", x4, y4 - diffY], ["L", x4 + r2, y4 + diffY], ["Z"]];
  },
  // 倒三角形
  "triangle-down": function(x4, y4, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x4 - r2, y4 - diffY], ["L", x4 + r2, y4 - diffY], ["L", x4, y4 + diffY], ["Z"]];
  }
};
var Marker = (
  /** @class */
  function(_super) {
    __extends2(Marker3, _super);
    function Marker3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker3.prototype.initAttrs = function(attrs) {
      this._resetParamsCache();
    };
    Marker3.prototype._resetParamsCache = function() {
      this.set("paramsCache", {});
    };
    Marker3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
        this._resetParamsCache();
      }
    };
    Marker3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Marker3.prototype._getR = function(attrs) {
      return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x4 = attrs.x, y4 = attrs.y;
      var symbol = attrs.symbol || "circle";
      var r2 = this._getR(attrs);
      var method;
      var path;
      if (is_function_default(symbol)) {
        method = symbol;
        path = method(x4, y4, r2);
        path = pathToAbsolute2(path);
      } else {
        method = Marker3.Symbols[symbol];
        if (!method) {
          console.warn(symbol + " marker is not supported.");
          return null;
        }
        path = method(x4, y4, r2);
      }
      return path;
    };
    Marker3.prototype.createPath = function(context) {
      var path = this._getPath();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, { path }, paramsCache);
    };
    Marker3.Symbols = Symbols;
    return Marker3;
  }(base_default2)
);
var marker_default2 = Marker;

// node_modules/@antv/g-canvas/esm/shape/path.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
function isPointInPath(shape, x4, y4) {
  var ctx2 = getOffScreenContext();
  shape.createPath(ctx2);
  return ctx2.isPointInPath(x4, y4);
}

// node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
var tolerance = 1e-6;
function dcmp(x4) {
  if (Math.abs(x4) < tolerance) {
    return 0;
  }
  return x4 < 0 ? -1 : 1;
}
function onSegment2(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon2(points, x4, y4) {
  var isHit = false;
  var n2 = points.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment2(p1, p2, [x4, y4])) {
      return true;
    }
    if (dcmp(p1[1] - y4) > 0 !== dcmp(p2[1] - y4) > 0 && dcmp(x4 - (y4 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/g-canvas/esm/util/path.js
init_tslib_es6();
init_vec3();

// node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
function arc(cx, cy, r2, startAngle, endAngle, lineWidth, x4, y4) {
  var angle3 = (Math.atan2(y4 - cy, x4 - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle3 < startAngle || angle3 > endAngle) {
    return false;
  }
  var point = {
    x: cx + r2 * Math.cos(angle3),
    y: cy + r2 * Math.sin(angle3)
  };
  return distance7(point.x, point.y, x4, y4) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/util/path.js
var transform8 = ext_exports.transform;
function hasArc(path) {
  var hasArc2 = false;
  var count = path.length;
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x4, y4, length6) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x4, y4)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x4, y4);
        break;
      case "Q":
        var qDistance = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x4, y4);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = cubic_default.pointDistance(
          prePoint[0],
          // 上一段结束位置, 即 C 的起始点
          prePoint[1],
          params[1],
          // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          x4,
          y4,
          length6
        );
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p2 = [x4, y4, 1];
        var r2 = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m3 = transform8(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3(p2, p2, m3);
        isHit = arc(0, 0, r2, startAngle, endAngle, lineWidth, p2[0], p2[1]);
        break;
      default:
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path) {
  var count = path.length;
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
var path_default3 = __assign2({
  hasArc,
  extractPolygons,
  isPointInStroke
}, path_exports);

// node_modules/@antv/g-canvas/esm/shape/path.js
function isInPolygons(polygons, x4, y4) {
  var isHit = false;
  for (var i2 = 0; i2 < polygons.length; i2++) {
    var points = polygons[i2];
    isHit = isInPolygon2(points, x4, y4);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path = (
  /** @class */
  function(_super) {
    __extends2(Path3, _super);
    function Path3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Path3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { startArrow: false, endArrow: false });
    };
    Path3.prototype.initAttrs = function(attrs) {
      this._setPathArr(attrs.path);
      this.setArrow();
    };
    Path3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "path") {
        this._setPathArr(value);
      }
      this.setArrow();
    };
    Path3.prototype._setPathArr = function(path) {
      this.attrs.path = pathToAbsolute2(path);
      var hasArc2 = path_default3.hasArc(path);
      this.set("hasArc", hasArc2);
      this.set("paramsCache", {});
      this.set("segments", null);
      this.set("curve", null);
      this.set("tCache", null);
      this.set("totalLength", null);
    };
    Path3.prototype.getSegments = function() {
      var segments = this.get("segements");
      if (!segments) {
        segments = getSegments(this.attr("path"));
        this.set("segments", segments);
      }
      return segments;
    };
    Path3.prototype.setArrow = function() {
      var attrs = this.attr();
      var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        var tangent = this.getStartTangent();
        addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
      if (endArrow) {
        var tangent = this.getEndTangent();
        addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
    };
    Path3.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      var segments = this.getSegments();
      var hasArc2 = this.get("hasArc");
      var isHit = false;
      if (isStroke) {
        var length_1 = this.getTotalLength();
        isHit = path_default3.isPointInStroke(segments, lineWidth, x4, y4, length_1);
      }
      if (!isHit && isFill) {
        if (hasArc2) {
          isHit = isPointInPath(this, x4, y4);
        } else {
          var path = this.attr("path");
          var extractResutl = path_default3.extractPolygons(path);
          isHit = isInPolygons(extractResutl.polygons, x4, y4) || isInPolygons(extractResutl.polylines, x4, y4);
        }
      }
      return isHit;
    };
    Path3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, attrs, paramsCache);
    };
    Path3.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Path3.prototype.getTotalLength = function() {
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this._calculateCurve();
      this._setTcache();
      return this.get("totalLength");
    };
    Path3.prototype.getPoint = function(ratio) {
      var tCache = this.get("tCache");
      if (!tCache) {
        this._calculateCurve();
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index2;
      var curve = this.get("curve");
      if (!tCache || tCache.length === 0) {
        if (curve) {
          return {
            x: curve[0][1],
            y: curve[0][2]
          };
        }
        return null;
      }
      each_default(tCache, function(v2, i2) {
        if (ratio >= v2[0] && ratio <= v2[1]) {
          subt = (ratio - v2[0]) / (v2[1] - v2[0]);
          index2 = i2;
        }
      });
      var seg = curve[index2];
      if (is_nil_default(seg) || is_nil_default(index2)) {
        return null;
      }
      var l2 = seg.length;
      var nextSeg = curve[index2 + 1];
      return cubic_default.pointAt(seg[l2 - 2], seg[l2 - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
    };
    Path3.prototype._calculateCurve = function() {
      var path = this.attr().path;
      this.set("curve", path_default3.pathToCurve(path));
    };
    Path3.prototype._setTcache = function() {
      var totalLength = 0;
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      var segmentN;
      var l2;
      var curve = this.get("curve");
      if (!curve) {
        return;
      }
      each_default(curve, function(segment, i2) {
        segmentN = curve[i2 + 1];
        l2 = segment.length;
        if (segmentN) {
          totalLength += cubic_default.length(segment[l2 - 2], segment[l2 - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
        }
      });
      this.set("totalLength", totalLength);
      if (totalLength === 0) {
        this.set("tCache", []);
        return;
      }
      each_default(curve, function(segment, i2) {
        segmentN = curve[i2 + 1];
        l2 = segment.length;
        if (segmentN) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = cubic_default.length(segment[l2 - 2], segment[l2 - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
          tempLength += segmentL || 0;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Path3.prototype.getStartTangent = function() {
      var segments = this.getSegments();
      var result;
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    };
    Path3.prototype.getEndTangent = function() {
      var segments = this.getSegments();
      var length6 = segments.length;
      var result;
      if (length6 > 1) {
        var startPoint = segments[length6 - 2].currentPoint;
        var endPoint = segments[length6 - 1].currentPoint;
        var tangent = segments[length6 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    };
    return Path3;
  }(base_default2)
);
var path_default2 = Path;

// node_modules/@antv/g-canvas/esm/shape/polygon.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
function inPolyline(points, lineWidth, x4, y4, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i2 = 0; i2 < count - 1; i2++) {
    var x1 = points[i2][0];
    var y1 = points[i2][1];
    var x22 = points[i2 + 1][0];
    var y22 = points[i2 + 1][1];
    if (inLine(x1, y1, x22, y22, lineWidth, x4, y4)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last3 = points[count - 1];
    if (inLine(first[0], first[1], last3[0], last3[1], lineWidth, x4, y4)) {
      return true;
    }
  }
  return false;
}

// node_modules/@antv/g-canvas/esm/shape/polygon.js
var Polygon = (
  /** @class */
  function(_super) {
    __extends2(Polygon3, _super);
    function Polygon3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Polygon3.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      var points = this.attr().points;
      var isHit = false;
      if (isStroke) {
        isHit = inPolyline(points, lineWidth, x4, y4, true);
      }
      if (!isHit && isFill) {
        isHit = isInPolygon2(points, x4, y4);
      }
      return isHit;
    };
    Polygon3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var points = attrs.points;
      if (points.length < 2) {
        return;
      }
      context.beginPath();
      for (var i2 = 0; i2 < points.length; i2++) {
        var point = points[i2];
        if (i2 === 0) {
          context.moveTo(point[0], point[1]);
        } else {
          context.lineTo(point[0], point[1]);
        }
      }
      context.closePath();
    };
    return Polygon3;
  }(base_default2)
);
var polygon_default3 = Polygon;

// node_modules/@antv/g-canvas/esm/shape/polyline.js
init_tslib_es6();
init_esm();
var PolyLine = (
  /** @class */
  function(_super) {
    __extends2(PolyLine2, _super);
    function PolyLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolyLine2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { startArrow: false, endArrow: false });
    };
    PolyLine2.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    PolyLine2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    PolyLine2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    PolyLine2.prototype.setArrow = function() {
      var attrs = this.attr();
      var _a2 = this.attrs, points = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
      var length6 = points.length;
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x22 = points[length6 - 1][0];
      var y22 = points[length6 - 1][1];
      if (startArrow) {
        addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, points[length6 - 2][0], points[length6 - 2][1], x22, y22);
      }
    };
    PolyLine2.prototype.isFill = function() {
      return false;
    };
    PolyLine2.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var points = this.attr().points;
      return inPolyline(points, lineWidth, x4, y4, false);
    };
    PolyLine2.prototype.isStroke = function() {
      return true;
    };
    PolyLine2.prototype.createPath = function(context) {
      var _a2 = this.attr(), points = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
      var length6 = points.length;
      if (points.length < 2) {
        return;
      }
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x22 = points[length6 - 1][0];
      var y22 = points[length6 - 1][1];
      if (startArrow && startArrow.d) {
        var distance11 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
        x1 += distance11.dx;
        y1 += distance11.dy;
      }
      if (endArrow && endArrow.d) {
        var distance11 = getShortenOffset(points[length6 - 2][0], points[length6 - 2][1], x22, y22, endArrow.d);
        x22 -= distance11.dx;
        y22 -= distance11.dy;
      }
      context.beginPath();
      context.moveTo(x1, y1);
      for (var i2 = 0; i2 < length6 - 1; i2++) {
        var point = points[i2];
        context.lineTo(point[0], point[1]);
      }
      context.lineTo(x22, y22);
    };
    PolyLine2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    PolyLine2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    PolyLine2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index2;
      each_default(tCache, function(v2, i2) {
        if (ratio >= v2[0] && ratio <= v2[1]) {
          subt = (ratio - v2[0]) / (v2[1] - v2[0]);
          index2 = i2;
        }
      });
      return line_default.pointAt(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt);
    };
    PolyLine2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p2, i2) {
        if (points[i2 + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p2[0], p2[1], points[i2 + 1][0], points[i2 + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    PolyLine2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    PolyLine2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l2 = points.length - 1;
      var result = [];
      result.push([points[l2 - 1][0], points[l2 - 1][1]]);
      result.push([points[l2][0], points[l2][1]]);
      return result;
    };
    return PolyLine2;
  }(base_default2)
);
var polyline_default3 = PolyLine;

// node_modules/@antv/g-canvas/esm/shape/rect.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
function inRect(minX, minY, width, height, lineWidth, x4, y4) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x4, y4) || // 上边
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x4, y4) || // 右边
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x4, y4) || // 下边
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x4, y4);
}

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x4, y4) {
  var halfWidth = lineWidth / 2;
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x4, y4) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x4, y4) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x4, y4) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x4, y4) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x4, y4) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x4, y4) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x4, y4) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x4, y4);
}

// node_modules/@antv/g-canvas/esm/shape/rect.js
var Rect = (
  /** @class */
  function(_super) {
    __extends2(Rect3, _super);
    function Rect3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect3.prototype.isInStrokeOrPath = function(x4, y4, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var minX = attrs.x;
      var minY = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        var halfWidth = lineWidth / 2;
        if (isFill && isStroke) {
          return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x4, y4);
        }
        if (isFill) {
          return inBox(minX, minY, width, height, x4, y4);
        }
        if (isStroke) {
          return inRect(minX, minY, width, height, lineWidth, x4, y4);
        }
      } else {
        var isHit = false;
        if (isStroke) {
          isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x4, y4);
        }
        if (!isHit && isFill) {
          isHit = isPointInPath(this, x4, y4);
        }
        return isHit;
      }
    };
    Rect3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x4 = attrs.x;
      var y4 = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      context.beginPath();
      if (radius === 0) {
        context.rect(x4, y4, width, height);
      } else {
        var _a2 = parseRadius2(radius), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
        context.moveTo(x4 + r1, y4);
        context.lineTo(x4 + width - r2, y4);
        r2 !== 0 && context.arc(x4 + width - r2, y4 + r2, r2, -Math.PI / 2, 0);
        context.lineTo(x4 + width, y4 + height - r3);
        r3 !== 0 && context.arc(x4 + width - r3, y4 + height - r3, r3, 0, Math.PI / 2);
        context.lineTo(x4 + r4, y4 + height);
        r4 !== 0 && context.arc(x4 + r4, y4 + height - r4, r4, Math.PI / 2, Math.PI);
        context.lineTo(x4, y4 + r1);
        r1 !== 0 && context.arc(x4 + r1, y4 + r1, r1, Math.PI, Math.PI * 1.5);
        context.closePath();
      }
    };
    return Rect3;
  }(base_default2)
);
var rect_default2 = Rect;

// node_modules/@antv/g-canvas/esm/shape/text.js
init_tslib_es6();
var Text = (
  /** @class */
  function(_super) {
    __extends2(Text3, _super);
    function Text3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Text3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Text3.prototype.initAttrs = function(attrs) {
      this._assembleFont();
      if (attrs.text) {
        this._setText(attrs.text);
      }
    };
    Text3.prototype._assembleFont = function() {
      var attrs = this.attrs;
      attrs.font = assembleFont(attrs);
    };
    Text3.prototype._setText = function(text) {
      var textArr = null;
      if (is_string_default(text) && text.indexOf("\n") !== -1) {
        textArr = text.split("\n");
      }
      this.set("textArr", textArr);
    };
    Text3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name.startsWith("font")) {
        this._assembleFont();
      }
      if (name === "text") {
        this._setText(value);
      }
    };
    Text3.prototype._getSpaceingY = function() {
      var attrs = this.attrs;
      var lineHeight = attrs.lineHeight;
      var fontSize = attrs.fontSize * 1;
      return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    Text3.prototype._drawTextArr = function(context, textArr, isFill) {
      var attrs = this.attrs;
      var textBaseline = attrs.textBaseline;
      var x4 = attrs.x;
      var y4 = attrs.y;
      var fontSize = attrs.fontSize * 1;
      var spaceingY = this._getSpaceingY();
      var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
      var subY;
      each_default(textArr, function(subText, index2) {
        subY = y4 + index2 * (spaceingY + fontSize) - height + fontSize;
        if (textBaseline === "middle")
          subY += height - fontSize - (height - fontSize) / 2;
        if (textBaseline === "top")
          subY += height - fontSize;
        if (!is_nil_default(subText)) {
          if (isFill) {
            context.fillText(subText, x4, subY);
          } else {
            context.strokeText(subText, x4, subY);
          }
        }
      });
    };
    Text3.prototype._drawText = function(context, isFill) {
      var attrs = this.attr();
      var x4 = attrs.x;
      var y4 = attrs.y;
      var textArr = this.get("textArr");
      if (textArr) {
        this._drawTextArr(context, textArr, isFill);
      } else {
        var text = attrs.text;
        if (!is_nil_default(text)) {
          if (isFill) {
            context.fillText(text, x4, y4);
          } else {
            context.strokeText(text, x4, y4);
          }
        }
      }
    };
    Text3.prototype.strokeAndFill = function(context) {
      var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = opacity;
          }
          this.stroke(context);
        }
      }
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      this.afterDrawPath(context);
    };
    Text3.prototype.fill = function(context) {
      this._drawText(context, true);
    };
    Text3.prototype.stroke = function(context) {
      this._drawText(context, false);
    };
    return Text3;
  }(base_default2)
);
var text_default2 = Text;

// node_modules/@antv/g-canvas/esm/canvas.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/hit.js
function invertFromMatrix(v2, matrix) {
  if (matrix) {
    var invertMatrix3 = invert7(matrix);
    return multiplyVec2(invertMatrix3, v2);
  }
  return v2;
}
function getRefXY(element, x4, y4) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a2 = invertFromMatrix([x4, y4, 1], totalMatrix), refX = _a2[0], refY = _a2[1];
    return [refX, refY];
  }
  return [x4, y4];
}
function preTest(element, x4, y4) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a2 = getRefXY(element, x4, y4), refX = _a2[0], refY = _a2[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x4 >= bbox.minX && x4 <= bbox.maxX && y4 >= bbox.minY && y4 <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape2(container, x4, y4) {
  if (!preTest(container, x4, y4)) {
    return null;
  }
  var shape = null;
  var children = container.getChildren();
  var count = children.length;
  for (var i2 = count - 1; i2 >= 0; i2--) {
    var child = children[i2];
    if (child.isGroup()) {
      shape = getShape2(child, x4, y4);
    } else if (preTest(child, x4, y4)) {
      var curShape = child;
      var _a2 = getRefXY(child, x4, y4), refX = _a2[0], refY = _a2[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}

// node_modules/@antv/g-canvas/esm/canvas.js
var Canvas2 = (
  /** @class */
  function(_super) {
    __extends2(Canvas4, _super);
    function Canvas4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Canvas4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["renderer"] = "canvas";
      cfg["autoDraw"] = true;
      cfg["localRefresh"] = true;
      cfg["refreshElements"] = [];
      cfg["clipView"] = true;
      cfg["quickHit"] = false;
      return cfg;
    };
    Canvas4.prototype.onCanvasChange = function(changeType) {
      if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
        this.set("refreshElements", [this]);
        this.draw();
      }
    };
    Canvas4.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Canvas4.prototype.getGroupBase = function() {
      return group_default3;
    };
    Canvas4.prototype.getPixelRatio = function() {
      var pixelRatio = this.get("pixelRatio") || getPixelRatio();
      return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
    };
    Canvas4.prototype.getViewRange = function() {
      return {
        minX: 0,
        minY: 0,
        maxX: this.cfg.width,
        maxY: this.cfg.height
      };
    };
    Canvas4.prototype.createDom = function() {
      var element = document.createElement("canvas");
      var context = element.getContext("2d");
      this.set("context", context);
      return element;
    };
    Canvas4.prototype.setDOMSize = function(width, height) {
      _super.prototype.setDOMSize.call(this, width, height);
      var context = this.get("context");
      var el = this.get("el");
      var pixelRatio = this.getPixelRatio();
      el.width = pixelRatio * width;
      el.height = pixelRatio * height;
      if (pixelRatio > 1) {
        context.scale(pixelRatio, pixelRatio);
      }
    };
    Canvas4.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this._clearFrame();
      var context = this.get("context");
      var element = this.get("el");
      context.clearRect(0, 0, element.width, element.height);
    };
    Canvas4.prototype.getShape = function(x4, y4) {
      var shape;
      if (this.get("quickHit")) {
        shape = getShape2(this, x4, y4);
      } else {
        shape = _super.prototype.getShape.call(this, x4, y4, null);
      }
      return shape;
    };
    Canvas4.prototype._getRefreshRegion = function() {
      var elements = this.get("refreshElements");
      var viewRegion = this.getViewRange();
      var region;
      if (elements.length && elements[0] === this) {
        region = viewRegion;
      } else {
        region = getMergedRegion(elements);
        if (region) {
          region.minX = Math.floor(region.minX);
          region.minY = Math.floor(region.minY);
          region.maxX = Math.ceil(region.maxX);
          region.maxY = Math.ceil(region.maxY);
          region.maxY += 1;
          var clipView = this.get("clipView");
          if (clipView) {
            region = mergeView(region, viewRegion);
          }
        }
      }
      return region;
    };
    Canvas4.prototype.refreshElement = function(element) {
      var refreshElements = this.get("refreshElements");
      refreshElements.push(element);
    };
    Canvas4.prototype._clearFrame = function() {
      var drawFrame = this.get("drawFrame");
      if (drawFrame) {
        cancelAnimationFrame2(drawFrame);
        this.set("drawFrame", null);
        this.set("refreshElements", []);
      }
    };
    Canvas4.prototype.draw = function() {
      var drawFrame = this.get("drawFrame");
      if (this.get("autoDraw") && drawFrame) {
        return;
      }
      this._startDraw();
    };
    Canvas4.prototype._drawAll = function() {
      var context = this.get("context");
      var element = this.get("el");
      var children = this.getChildren();
      context.clearRect(0, 0, element.width, element.height);
      applyAttrsToContext(context, this);
      drawChildren(context, children);
      this.set("refreshElements", []);
    };
    Canvas4.prototype._drawRegion = function() {
      var context = this.get("context");
      var refreshElements = this.get("refreshElements");
      var children = this.getChildren();
      var region = this._getRefreshRegion();
      if (region) {
        context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.save();
        context.beginPath();
        context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.clip();
        applyAttrsToContext(context, this);
        checkRefresh(this, children, region);
        drawChildren(context, children, region);
        context.restore();
      } else if (refreshElements.length) {
        clearChanged(refreshElements);
      }
      each_default(refreshElements, function(element) {
        if (element.get("hasChanged")) {
          element.set("hasChanged", false);
        }
      });
      this.set("refreshElements", []);
    };
    Canvas4.prototype._startDraw = function() {
      var _this = this;
      var drawFrame = this.get("drawFrame");
      var drawFrameCallback = this.get("drawFrameCallback");
      if (!drawFrame) {
        drawFrame = requestAnimationFrame2(function() {
          if (_this.get("localRefresh")) {
            _this._drawRegion();
          } else {
            _this._drawAll();
          }
          _this.set("drawFrame", null);
          if (drawFrameCallback) {
            drawFrameCallback();
          }
        });
        this.set("drawFrame", drawFrame);
      }
    };
    Canvas4.prototype.skipDraw = function() {
    };
    Canvas4.prototype.removeDom = function() {
      var el = this.get("el");
      el.width = 0;
      el.height = 0;
      el.parentNode.removeChild(el);
    };
    return Canvas4;
  }(canvas_default)
);
var canvas_default2 = Canvas2;

// node_modules/@antv/g-svg/esm/shape/index.js
var shape_exports2 = {};
__export(shape_exports2, {
  Base: () => base_default3,
  Circle: () => circle_default3,
  Dom: () => dom_default,
  Ellipse: () => ellipse_default4,
  Image: () => image_default2,
  Line: () => line_default4,
  Marker: () => marker_default3,
  Path: () => path_default4,
  Polygon: () => polygon_default4,
  Polyline: () => polyline_default4,
  Rect: () => rect_default3,
  Text: () => text_default3
});

// node_modules/@antv/g-svg/esm/shape/base.js
init_tslib_es6();

// node_modules/@antv/g-svg/esm/util/dom.js
init_esm();

// node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};

// node_modules/@antv/g-svg/esm/util/dom.js
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = to_array_default(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(
    // 要求为元素节点，且不能为 defs 节点
    function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    }
  );
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

// node_modules/@antv/g-svg/esm/util/svg.js
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id = context.find("filter", cfg);
    if (!id) {
      id = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform16 = [];
    for (var i2 = 0; i2 < 9; i2 += 3) {
      transform16.push(matrix[i2] + "," + matrix[i2 + 1]);
    }
    transform16 = transform16.join(",");
    if (transform16.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform16 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id + ")");
  }
}

// node_modules/@antv/g-svg/esm/util/draw.js
function drawChildren2(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement2(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a3, b10) {
          return children_1.indexOf(a3) - children_1.indexOf(b10) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr") {
    } else if (changeType === "add") {
      element.draw(context);
    }
  }
}

// node_modules/@antv/g-svg/esm/group.js
init_tslib_es6();
init_esm();
var Group2 = (
  /** @class */
  function(_super) {
    __extends2(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.isEntityGroup = function() {
      return true;
    };
    Group3.prototype.createDom = function() {
      var element = createSVGElement("g");
      this.set("el", element);
      var parent = this.getParent();
      if (parent) {
        var parentNode = parent.get("el");
        if (parentNode) {
          parentNode.appendChild(element);
        } else {
          parentNode = parent.createDom();
          parent.set("el", parentNode);
          parentNode.appendChild(element);
        }
      }
      return element;
    };
    Group3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.createPath(context, targetAttrs);
      }
    };
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype.draw = function(context) {
      var children = this.getChildren();
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          this.createDom();
        }
        setClip(this, context);
        this.createPath(context);
        if (children.length) {
          drawChildren2(context, children);
        }
      }
    };
    Group3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      setTransform(this);
    };
    return Group3;
  }(group_default2)
);
var group_default4 = Group2;

// node_modules/@antv/g-svg/esm/shape/base.js
var ShapeBase2 = (
  /** @class */
  function(_super) {
    __extends2(ShapeBase3, _super);
    function ShapeBase3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "svg";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    ShapeBase3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.draw(context, targetAttrs);
      }
    };
    ShapeBase3.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    ShapeBase3.prototype.getGroupBase = function() {
      return group_default4;
    };
    ShapeBase3.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    ShapeBase3.prototype.calculateBBox = function() {
      var el = this.get("el");
      var bbox = null;
      if (el) {
        bbox = el.getBBox();
      } else {
        var bboxMethod = getMethod(this.get("type"));
        if (bboxMethod) {
          bbox = bboxMethod(this);
        }
      }
      if (bbox) {
        var x4 = bbox.x, y4 = bbox.y, width = bbox.width, height = bbox.height;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2;
        var minX = x4 - halfWidth;
        var minY = y4 - halfWidth;
        var maxX = x4 + width + halfWidth;
        var maxY = y4 + height + halfWidth;
        return {
          x: minX,
          y: minY,
          minX,
          minY,
          maxX,
          maxY,
          width: width + lineWidth,
          height: height + lineWidth
        };
      }
      return {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
    };
    ShapeBase3.prototype.isFill = function() {
      var _a2 = this.attr(), fill = _a2.fill, fillStyle = _a2.fillStyle;
      return (fill || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase3.prototype.isStroke = function() {
      var _a2 = this.attr(), stroke = _a2.stroke, strokeStyle = _a2.strokeStyle;
      return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase3.prototype.draw = function(context, targetAttrs) {
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          createDom(this);
        }
        setClip(this, context);
        this.createPath(context, targetAttrs);
        this.shadow(context, targetAttrs);
        this.strokeAndFill(context, targetAttrs);
        this.transform(targetAttrs);
      }
    };
    ShapeBase3.prototype.createPath = function(context, targetAttrs) {
    };
    ShapeBase3.prototype.strokeAndFill = function(context, targetAttrs) {
      var attrs = targetAttrs || this.attr();
      var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
      var el = this.get("el");
      if (this.canFill) {
        if (!targetAttrs) {
          this._setColor(context, "fill", fill || fillStyle);
        } else if ("fill" in attrs) {
          this._setColor(context, "fill", fill);
        } else if ("fillStyle" in attrs) {
          this._setColor(context, "fill", fillStyle);
        }
        if (fillOpacity) {
          el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
        }
      }
      if (this.canStroke && lineWidth > 0) {
        if (!targetAttrs) {
          this._setColor(context, "stroke", stroke || strokeStyle);
        } else if ("stroke" in attrs) {
          this._setColor(context, "stroke", stroke);
        } else if ("strokeStyle" in attrs) {
          this._setColor(context, "stroke", strokeStyle);
        }
        if (strokeOpacity) {
          el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
        }
        if (lineWidth) {
          el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
        }
      }
    };
    ShapeBase3.prototype._setColor = function(context, attr, value) {
      var el = this.get("el");
      if (!value) {
        el.setAttribute(SVG_ATTR_MAP[attr], "none");
        return;
      }
      value = value.trim();
      if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
        var id = context.find("gradient", value);
        if (!id) {
          id = context.addGradient(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
        var id = context.find("pattern", value);
        if (!id) {
          id = context.addPattern(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    };
    ShapeBase3.prototype.shadow = function(context, targetAttrs) {
      var attrs = this.attr();
      var _a2 = targetAttrs || attrs, shadowOffsetX = _a2.shadowOffsetX, shadowOffsetY = _a2.shadowOffsetY, shadowBlur = _a2.shadowBlur, shadowColor = _a2.shadowColor;
      if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
        setShadow(this, context);
      }
    };
    ShapeBase3.prototype.transform = function(targetAttrs) {
      var attrs = this.attr();
      var matrix = (targetAttrs || attrs).matrix;
      if (matrix) {
        setTransform(this);
      }
    };
    ShapeBase3.prototype.isInShape = function(refX, refY) {
      return this.isPointInPath(refX, refY);
    };
    ShapeBase3.prototype.isPointInPath = function(refX, refY) {
      var el = this.get("el");
      var canvas = this.get("canvas");
      var bbox = canvas.get("el").getBoundingClientRect();
      var clientX = refX + bbox.left;
      var clientY = refY + bbox.top;
      var element = document.elementFromPoint(clientX, clientY);
      if (element && element.isEqualNode(el)) {
        return true;
      }
      return false;
    };
    ShapeBase3.prototype.getHitLineWidth = function() {
      var _a2 = this.attrs, lineWidth = _a2.lineWidth, lineAppendWidth = _a2.lineAppendWidth;
      if (this.isStroke()) {
        return lineWidth + lineAppendWidth;
      }
      return 0;
    };
    return ShapeBase3;
  }(shape_default)
);
var base_default3 = ShapeBase2;

// node_modules/@antv/g-svg/esm/shape/circle.js
init_tslib_es6();
init_esm();
var Circle2 = (
  /** @class */
  function(_super) {
    __extends2(Circle3, _super);
    function Circle3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Circle3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Circle3;
  }(base_default3)
);
var circle_default3 = Circle2;

// node_modules/@antv/g-svg/esm/shape/dom.js
init_tslib_es6();
init_esm();
var Dom = (
  /** @class */
  function(_super) {
    __extends2(Dom2, _super);
    function Dom2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dom";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Dom2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      if (typeof attrs["html"] === "function") {
        var element = attrs["html"].call(this, attrs);
        if (element instanceof Element || element instanceof HTMLDocument) {
          var children = el.childNodes;
          for (var i2 = children.length - 1; i2 >= 0; i2--) {
            el.removeChild(children[i2]);
          }
          el.appendChild(element);
        } else {
          el.innerHTML = element;
        }
      } else {
        el.innerHTML = attrs["html"];
      }
    };
    return Dom2;
  }(base_default3)
);
var dom_default = Dom;

// node_modules/@antv/g-svg/esm/shape/ellipse.js
init_tslib_es6();
init_esm();
var Ellipse2 = (
  /** @class */
  function(_super) {
    __extends2(Ellipse3, _super);
    function Ellipse3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ellipse";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Ellipse3;
  }(base_default3)
);
var ellipse_default4 = Ellipse2;

// node_modules/@antv/g-svg/esm/shape/image.js
init_tslib_es6();
init_esm();
var Image2 = (
  /** @class */
  function(_super) {
    __extends2(Image3, _super);
    function Image3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "image";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Image3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "img") {
          _this._setImage(attrs.img);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Image3.prototype.setAttr = function(name, value) {
      this.attrs[name] = value;
      if (name === "img") {
        this._setImage(value);
      }
    };
    Image3.prototype._setImage = function(img) {
      var attrs = this.attr();
      var el = this.get("el");
      if (is_string_default(img)) {
        el.setAttribute("href", img);
      } else if (img instanceof window.Image) {
        if (!attrs.width) {
          el.setAttribute("width", img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", img.src);
      } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
        el.setAttribute("href", img.toDataURL());
      } else if (img instanceof ImageData) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", "" + img.width);
        canvas.setAttribute("height", "" + img.height);
        canvas.getContext("2d").putImageData(img, 0, 0);
        if (!attrs.width) {
          el.setAttribute("width", "" + img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", "" + img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", canvas.toDataURL());
      }
    };
    return Image3;
  }(base_default3)
);
var image_default2 = Image2;

// node_modules/@antv/g-svg/esm/shape/line.js
init_tslib_es6();
init_esm();
var Line3 = (
  /** @class */
  function(_super) {
    __extends2(Line4, _super);
    function Line4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      _this.canFill = false;
      _this.canStroke = true;
      return _this;
    }
    Line4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line4.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Line4.prototype.getTotalLength = function() {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      return line_default.length(x1, y1, x22, y22);
    };
    Line4.prototype.getPoint = function(ratio) {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      return line_default.pointAt(x1, y1, x22, y22, ratio);
    };
    return Line4;
  }(base_default3)
);
var line_default4 = Line3;

// node_modules/@antv/g-svg/esm/shape/marker/index.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var Symbols2 = {
  // 圆
  circle: function(x4, y4, r2) {
    return [
      ["M", x4, y4],
      ["m", -r2, 0],
      ["a", r2, r2, 0, 1, 0, r2 * 2, 0],
      ["a", r2, r2, 0, 1, 0, -r2 * 2, 0]
    ];
  },
  // 正方形
  square: function(x4, y4, r2) {
    return [["M", x4 - r2, y4 - r2], ["L", x4 + r2, y4 - r2], ["L", x4 + r2, y4 + r2], ["L", x4 - r2, y4 + r2], ["Z"]];
  },
  // 菱形
  diamond: function(x4, y4, r2) {
    return [["M", x4 - r2, y4], ["L", x4, y4 - r2], ["L", x4 + r2, y4], ["L", x4, y4 + r2], ["Z"]];
  },
  // 三角形
  triangle: function(x4, y4, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x4 - r2, y4 + diffY], ["L", x4, y4 - diffY], ["L", x4 + r2, y4 + diffY], ["z"]];
  },
  // 倒三角形
  triangleDown: function(x4, y4, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x4 - r2, y4 - diffY], ["L", x4 + r2, y4 - diffY], ["L", x4, y4 + diffY], ["Z"]];
  }
};
var symbols_default = {
  get: function(type) {
    return Symbols2[type];
  },
  register: function(type, func) {
    Symbols2[type] = func;
  },
  remove: function(type) {
    delete Symbols2[type];
  },
  getAll: function() {
    return Symbols2;
  }
};

// node_modules/@antv/g-svg/esm/shape/marker/index.js
var Marker2 = (
  /** @class */
  function(_super) {
    __extends2(Marker3, _super);
    function Marker3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "marker";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Marker3.prototype.createPath = function(context) {
      var el = this.get("el");
      el.setAttribute("d", this._assembleMarker());
    };
    Marker3.prototype._assembleMarker = function() {
      var d2 = this._getPath();
      if (is_array_default(d2)) {
        return d2.map(function(path) {
          return path.join(" ");
        }).join("");
      }
      return d2;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x4 = attrs.x, y4 = attrs.y;
      var r2 = attrs.r || attrs.radius;
      var symbol = attrs.symbol || "circle";
      var method;
      if (is_function_default(symbol)) {
        method = symbol;
      } else {
        method = symbols_default.get(symbol);
      }
      if (!method) {
        console.warn(method + " symbol is not exist.");
        return null;
      }
      return method(x4, y4, r2);
    };
    Marker3.symbolsFactory = symbols_default;
    return Marker3;
  }(base_default3)
);
var marker_default3 = Marker2;

// node_modules/@antv/g-svg/esm/shape/path.js
init_tslib_es6();
init_esm();
var Path2 = (
  /** @class */
  function(_super) {
    __extends2(Path3, _super);
    function Path3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "path";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Path3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { startArrow: false, endArrow: false });
    };
    Path3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "path" && is_array_default(value)) {
          el.setAttribute("d", _this._formatPath(value));
        } else if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Path3.prototype._formatPath = function(value) {
      var newValue = value.map(function(path) {
        return path.join(" ");
      }).join("");
      if (~newValue.indexOf("NaN")) {
        return "";
      }
      return newValue;
    };
    Path3.prototype.getTotalLength = function() {
      var el = this.get("el");
      return el ? el.getTotalLength() : null;
    };
    Path3.prototype.getPoint = function(ratio) {
      var el = this.get("el");
      var totalLength = this.getTotalLength();
      if (totalLength === 0) {
        return null;
      }
      var point = el ? el.getPointAtLength(ratio * totalLength) : null;
      return point ? {
        x: point.x,
        y: point.y
      } : null;
    };
    return Path3;
  }(base_default3)
);
var path_default4 = Path2;

// node_modules/@antv/g-svg/esm/shape/polygon.js
init_tslib_es6();
init_esm();
var Polygon2 = (
  /** @class */
  function(_super) {
    __extends2(Polygon3, _super);
    function Polygon3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polygon3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Polygon3;
  }(base_default3)
);
var polygon_default4 = Polygon2;

// node_modules/@antv/g-svg/esm/shape/polyline.js
init_tslib_es6();
init_esm();
var Polyline = (
  /** @class */
  function(_super) {
    __extends2(Polyline2, _super);
    function Polyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polyline";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polyline2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { startArrow: false, endArrow: false });
    };
    Polyline2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    Polyline2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    Polyline2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Polyline2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    Polyline2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index2;
      each_default(tCache, function(v2, i2) {
        if (ratio >= v2[0] && ratio <= v2[1]) {
          subt = (ratio - v2[0]) / (v2[1] - v2[0]);
          index2 = i2;
        }
      });
      return line_default.pointAt(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt);
    };
    Polyline2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p2, i2) {
        if (points[i2 + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p2[0], p2[1], points[i2 + 1][0], points[i2 + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l2 = points.length - 1;
      var result = [];
      result.push([points[l2 - 1][0], points[l2 - 1][1]]);
      result.push([points[l2][0], points[l2][1]]);
      return result;
    };
    return Polyline2;
  }(base_default3)
);
var polyline_default4 = Polyline;

// node_modules/@antv/g-svg/esm/shape/rect.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g-svg/esm/util/format.js
init_esm();
function parseRadius3(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}

// node_modules/@antv/g-svg/esm/shape/rect.js
var Rect2 = (
  /** @class */
  function(_super) {
    __extends2(Rect3, _super);
    function Rect3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rect";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Rect3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      var completed = false;
      var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
      each_default(targetAttrs || attrs, function(value, attr) {
        if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
          el.setAttribute("d", _this._assembleRect(attrs));
          completed = true;
        } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Rect3.prototype._assembleRect = function(attrs) {
      var x4 = attrs.x;
      var y4 = attrs.y;
      var w2 = attrs.width;
      var h2 = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        return "M " + x4 + "," + y4 + " l " + w2 + ",0 l 0," + h2 + " l" + -w2 + " 0 z";
      }
      var r2 = parseRadius3(radius);
      if (is_array_default(radius)) {
        if (radius.length === 1) {
          r2.r1 = r2.r2 = r2.r3 = r2.r4 = radius[0];
        } else if (radius.length === 2) {
          r2.r1 = r2.r3 = radius[0];
          r2.r2 = r2.r4 = radius[1];
        } else if (radius.length === 3) {
          r2.r1 = radius[0];
          r2.r2 = r2.r4 = radius[1];
          r2.r3 = radius[2];
        } else {
          r2.r1 = radius[0];
          r2.r2 = radius[1];
          r2.r3 = radius[2];
          r2.r4 = radius[3];
        }
      } else {
        r2.r1 = r2.r2 = r2.r3 = r2.r4 = radius;
      }
      var d2 = [
        ["M " + (x4 + r2.r1) + "," + y4],
        ["l " + (w2 - r2.r1 - r2.r2) + ",0"],
        ["a " + r2.r2 + "," + r2.r2 + ",0,0,1," + r2.r2 + "," + r2.r2],
        ["l 0," + (h2 - r2.r2 - r2.r3)],
        ["a " + r2.r3 + "," + r2.r3 + ",0,0,1," + -r2.r3 + "," + r2.r3],
        ["l " + (r2.r3 + r2.r4 - w2) + ",0"],
        ["a " + r2.r4 + "," + r2.r4 + ",0,0,1," + -r2.r4 + "," + -r2.r4],
        ["l 0," + (r2.r4 + r2.r1 - h2)],
        ["a " + r2.r1 + "," + r2.r1 + ",0,0,1," + r2.r1 + "," + -r2.r1],
        ["z"]
      ];
      return d2.join(" ");
    };
    return Rect3;
  }(base_default3)
);
var rect_default3 = Rect2;

// node_modules/@antv/g-svg/esm/shape/text.js
init_tslib_es6();
init_esm();
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text2 = (
  /** @class */
  function(_super) {
    __extends2(Text3, _super);
    function Text3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "text";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Text3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign2(__assign2({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      this._setFont();
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "text") {
          _this._setText("" + value);
        } else if (attr === "matrix" && value) {
          setTransform(_this);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      el.setAttribute("paint-order", "stroke");
      el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
    };
    Text3.prototype._setFont = function() {
      var el = this.get("el");
      var _a2 = this.attr(), textBaseline = _a2.textBaseline, textAlign = _a2.textAlign;
      var browser2 = detect();
      if (browser2 && browser2.name === "firefox") {
        el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
      } else {
        el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
      }
      el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
    };
    Text3.prototype._setText = function(text) {
      var el = this.get("el");
      var _a2 = this.attr(), x4 = _a2.x, _b = _a2.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
      if (!text) {
        el.innerHTML = "";
      } else if (~text.indexOf("\n")) {
        var textArr = text.split("\n");
        var textLen_1 = textArr.length - 1;
        var arr_1 = "";
        each_default(textArr, function(segment, i2) {
          if (i2 === 0) {
            if (baseline === "alphabetic") {
              arr_1 += '<tspan x="' + x4 + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
            } else if (baseline === "top") {
              arr_1 += '<tspan x="' + x4 + '" dy="0.9em">' + segment + "</tspan>";
            } else if (baseline === "middle") {
              arr_1 += '<tspan x="' + x4 + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
            } else if (baseline === "bottom") {
              arr_1 += '<tspan x="' + x4 + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
            } else if (baseline === "hanging") {
              arr_1 += '<tspan x="' + x4 + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
            }
          } else {
            arr_1 += '<tspan x="' + x4 + '" dy="1em">' + segment + "</tspan>";
          }
        });
        el.innerHTML = arr_1;
      } else {
        el.innerHTML = text;
      }
    };
    return Text3;
  }(base_default3)
);
var text_default3 = Text2;

// node_modules/@antv/g-svg/esm/canvas.js
init_tslib_es6();

// node_modules/@antv/g-svg/esm/defs/index.js
init_esm();

// node_modules/@antv/g-svg/esm/defs/gradient.js
init_esm();
var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop2 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop2(steps) {
  var arr = steps.match(regexColorStop2);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a3, b10) {
    a3 = a3.split(":");
    b10 = b10.split(":");
    return Number(a3[0]) - Number(b10[0]);
  });
  each_default(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient2(color3, el) {
  var arr = regexLG2.exec(color3);
  var angle3 = mod_default(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end2;
  if (angle3 >= 0 && angle3 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end2 = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle3 && angle3 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end2 = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle3 && angle3 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end2 = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end2 = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle3);
  var tanTheta2 = tanTheta * tanTheta;
  var x4 = (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y4 = tanTheta * (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x4);
  el.setAttribute("y2", y4);
  el.innerHTML = addStop2(steps);
}
function parseRadialGradient2(color3, self2) {
  var arr = regexRG2.exec(color3);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r2 = parseFloat(arr[3]);
  var steps = arr[4];
  self2.setAttribute("cx", cx);
  self2.setAttribute("cy", cy);
  self2.setAttribute("r", r2);
  self2.innerHTML = addStop2(steps);
}
var Gradient = (
  /** @class */
  function() {
    function Gradient2(cfg) {
      this.cfg = {};
      var el = null;
      var id = unique_id_default("gradient_");
      if (cfg.toLowerCase()[0] === "l") {
        el = createSVGElement("linearGradient");
        parseLineGradient2(cfg, el);
      } else {
        el = createSVGElement("radialGradient");
        parseRadialGradient2(cfg, el);
      }
      el.setAttribute("id", id);
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      return this;
    }
    Gradient2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Gradient2;
  }()
);
var gradient_default = Gradient;

// node_modules/@antv/g-svg/esm/defs/shadow.js
init_esm();
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = (
  /** @class */
  function() {
    function Shadow2(cfg) {
      this.type = "filter";
      this.cfg = {};
      this.type = "filter";
      var el = createSVGElement("filter");
      each_default(SHADOW_DIMENSION, function(v2, k2) {
        el.setAttribute(k2, v2);
      });
      this.el = el;
      this.id = unique_id_default("filter_");
      this.el.id = this.id;
      this.cfg = cfg;
      this._parseShadow(cfg, el);
      return this;
    }
    Shadow2.prototype.match = function(type, cfg) {
      if (this.type !== type) {
        return false;
      }
      var flag = true;
      var config = this.cfg;
      each_default(Object.keys(config), function(attr) {
        if (config[attr] !== cfg[attr]) {
          flag = false;
          return false;
        }
      });
      return flag;
    };
    Shadow2.prototype.update = function(name, value) {
      var config = this.cfg;
      config[ATTR_MAP[name]] = value;
      this._parseShadow(config, this.el);
      return this;
    };
    Shadow2.prototype._parseShadow = function(config, el) {
      var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
      el.innerHTML = child;
    };
    return Shadow2;
  }()
);
var shadow_default = Shadow;

// node_modules/@antv/g-svg/esm/defs/arrow.js
init_esm();
var Arrow = (
  /** @class */
  function() {
    function Arrow2(attrs, type) {
      this.cfg = {};
      var el = createSVGElement("marker");
      var id = unique_id_default("marker_");
      el.setAttribute("id", id);
      var shape = createSVGElement("path");
      shape.setAttribute("stroke", attrs.stroke || "none");
      shape.setAttribute("fill", attrs.fill || "none");
      el.appendChild(shape);
      el.setAttribute("overflow", "visible");
      el.setAttribute("orient", "auto-start-reverse");
      this.el = el;
      this.child = shape;
      this.id = id;
      var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
      this.stroke = attrs.stroke || "#000";
      if (cfg === true) {
        this._setDefaultPath(type, shape);
      } else {
        this.cfg = cfg;
        this._setMarker(attrs.lineWidth, shape);
      }
      return this;
    }
    Arrow2.prototype.match = function() {
      return false;
    };
    Arrow2.prototype._setDefaultPath = function(type, el) {
      var parent = this.el;
      el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
      parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
      parent.setAttribute("refY", "5");
    };
    Arrow2.prototype._setMarker = function(r2, el) {
      var parent = this.el;
      var path = this.cfg.path;
      var d2 = this.cfg.d;
      if (is_array_default(path)) {
        path = path.map(function(segment) {
          return segment.join(" ");
        }).join("");
      }
      el.setAttribute("d", path);
      parent.appendChild(el);
      if (d2) {
        parent.setAttribute("refX", "" + d2 / r2);
      }
    };
    Arrow2.prototype.update = function(fill) {
      var child = this.child;
      if (child.attr) {
        child.attr("fill", fill);
      } else {
        child.setAttribute("fill", fill);
      }
    };
    return Arrow2;
  }()
);
var arrow_default2 = Arrow;

// node_modules/@antv/g-svg/esm/defs/clip.js
init_esm();
var Clip = (
  /** @class */
  function() {
    function Clip2(cfg) {
      this.type = "clip";
      this.cfg = {};
      var el = createSVGElement("clipPath");
      this.el = el;
      this.id = unique_id_default("clip_");
      el.id = this.id;
      var shapeEl = cfg.cfg.el;
      el.appendChild(shapeEl);
      this.cfg = cfg;
      return this;
    }
    Clip2.prototype.match = function() {
      return false;
    };
    Clip2.prototype.remove = function() {
      var el = this.el;
      el.parentNode.removeChild(el);
    };
    return Clip2;
  }()
);
var clip_default = Clip;

// node_modules/@antv/g-svg/esm/defs/pattern.js
init_esm();
var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = (
  /** @class */
  function() {
    function Pattern2(cfg) {
      this.cfg = {};
      var el = createSVGElement("pattern");
      el.setAttribute("patternUnits", "userSpaceOnUse");
      var child = createSVGElement("image");
      el.appendChild(child);
      var id = unique_id_default("pattern_");
      el.id = id;
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      var arr = regexPR2.exec(cfg);
      var source = arr[2];
      child.setAttribute("href", source);
      var img = new Image();
      if (!source.match(/^data:/i)) {
        img.crossOrigin = "Anonymous";
      }
      img.src = source;
      function onload() {
        el.setAttribute("width", "" + img.width);
        el.setAttribute("height", "" + img.height);
      }
      if (img.complete) {
        onload();
      } else {
        img.onload = onload;
        img.src = img.src;
      }
      return this;
    }
    Pattern2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Pattern2;
  }()
);
var pattern_default = Pattern;

// node_modules/@antv/g-svg/esm/defs/index.js
var Defs = (
  /** @class */
  function() {
    function Defs2(canvas) {
      var el = createSVGElement("defs");
      var id = unique_id_default("defs_");
      el.id = id;
      canvas.appendChild(el);
      this.children = [];
      this.defaultArrow = {};
      this.el = el;
      this.canvas = canvas;
    }
    Defs2.prototype.find = function(type, attr) {
      var children = this.children;
      var result = null;
      for (var i2 = 0; i2 < children.length; i2++) {
        if (children[i2].match(type, attr)) {
          result = children[i2].id;
          break;
        }
      }
      return result;
    };
    Defs2.prototype.findById = function(id) {
      var children = this.children;
      var flag = null;
      for (var i2 = 0; i2 < children.length; i2++) {
        if (children[i2].id === id) {
          flag = children[i2];
          break;
        }
      }
      return flag;
    };
    Defs2.prototype.add = function(item) {
      this.children.push(item);
      item.canvas = this.canvas;
      item.parent = this;
    };
    Defs2.prototype.getDefaultArrow = function(attrs, name) {
      var stroke = attrs.stroke || attrs.strokeStyle;
      if (this.defaultArrow[stroke]) {
        return this.defaultArrow[stroke].id;
      }
      var arrow = new arrow_default2(attrs, name);
      this.defaultArrow[stroke] = arrow;
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addGradient = function(cfg) {
      var gradient2 = new gradient_default(cfg);
      this.el.appendChild(gradient2.el);
      this.add(gradient2);
      return gradient2.id;
    };
    Defs2.prototype.addArrow = function(attrs, name) {
      var arrow = new arrow_default2(attrs, name);
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addShadow = function(cfg) {
      var shadow = new shadow_default(cfg);
      this.el.appendChild(shadow.el);
      this.add(shadow);
      return shadow.id;
    };
    Defs2.prototype.addPattern = function(cfg) {
      var pattern = new pattern_default(cfg);
      this.el.appendChild(pattern.el);
      this.add(pattern);
      return pattern.id;
    };
    Defs2.prototype.addClip = function(cfg) {
      var clip = new clip_default(cfg);
      this.el.appendChild(clip.el);
      this.add(clip);
      return clip.id;
    };
    return Defs2;
  }()
);
var defs_default = Defs;

// node_modules/@antv/g-svg/esm/canvas.js
var Canvas3 = (
  /** @class */
  function(_super) {
    __extends2(Canvas4, _super);
    function Canvas4(cfg) {
      return _super.call(this, __assign2(__assign2({}, cfg), {
        autoDraw: true,
        // 设置渲染引擎为 canvas，只读属性
        renderer: "svg"
      })) || this;
    }
    Canvas4.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Canvas4.prototype.getGroupBase = function() {
      return group_default4;
    };
    Canvas4.prototype.getShape = function(x4, y4, ev) {
      var target = ev.target || ev.srcElement;
      if (!SHAPE_TO_TAGS[target.tagName]) {
        var parent_1 = target.parentNode;
        while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
          parent_1 = parent_1.parentNode;
        }
        target = parent_1;
      }
      return this.find(function(child) {
        return child.get("el") === target;
      });
    };
    Canvas4.prototype.createDom = function() {
      var element = createSVGElement("svg");
      var context = new defs_default(element);
      element.setAttribute("width", "" + this.get("width"));
      element.setAttribute("height", "" + this.get("height"));
      this.set("context", context);
      return element;
    };
    Canvas4.prototype.onCanvasChange = function(changeType) {
      var context = this.get("context");
      var el = this.get("el");
      if (changeType === "sort") {
        var children_1 = this.get("children");
        if (children_1 && children_1.length) {
          sortDom(this, function(a3, b10) {
            return children_1.indexOf(a3) - children_1.indexOf(b10) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
          var defsEl = context.el;
          defsEl.innerHTML = "";
          el.appendChild(defsEl);
        }
      } else if (changeType === "matrix") {
        setTransform(this);
      } else if (changeType === "clip") {
        setClip(this, context);
      } else if (changeType === "changeSize") {
        el.setAttribute("width", "" + this.get("width"));
        el.setAttribute("height", "" + this.get("height"));
      }
    };
    Canvas4.prototype.draw = function() {
      var context = this.get("context");
      var children = this.getChildren();
      setClip(this, context);
      if (children.length) {
        drawChildren2(context, children);
      }
    };
    return Canvas4;
  }(canvas_default)
);
var canvas_default3 = Canvas3;

// node_modules/@antv/g6-pc/es/graph/graph.js
init_esm();

// node_modules/@antv/dom-util/esm/add-event-listener.js
function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === "function") {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target.attachEvent === "function") {
      target.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}

// node_modules/@antv/dom-util/esm/create-dom.js
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom2(str10) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str10) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container = CONTAINERS[name];
  str10 = typeof str10 === "string" ? str10.replace(/(^\s*)|(\s*$)/g, "") : str10;
  container.innerHTML = "" + str10;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}

// node_modules/@antv/dom-util/esm/modify-css.js
function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
}

// node_modules/@antv/g6-pc/es/util/color.js
var color_exports2 = {};
__export(color_exports2, {
  getColorSetsBySubjectColors: () => getColorSetsBySubjectColors,
  getColorsWithSubjectColor: () => getColorsWithSubjectColor,
  mixColor: () => mixColor
});
var import_color11 = __toESM(require_color());

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color3, opts) {
  color3 = color3 ? color3 : "";
  opts = opts || {};
  if (color3 instanceof tinycolor) {
    return color3;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color3, opts);
  }
  var rgb2 = inputToRGB(color3);
  this._originalInput = color3, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb2.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb2.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb2 = this.toRgb();
    return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb2 = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R2, G2, B3;
    RsRGB = rgb2.r / 255;
    GsRGB = rgb2.g / 255;
    BsRGB = rgb2.b / 255;
    if (RsRGB <= 0.03928) R2 = RsRGB / 12.92;
    else R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G2 = GsRGB / 12.92;
    else G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B3 = BsRGB / 12.92;
    else B3 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B3;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h2 = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl3 = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl3.h * 360,
      s: hsl3.s,
      l: hsl3.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl3 = rgbToHsl(this._r, this._g, this._b);
    var h2 = Math.round(hsl3.h * 360), s2 = Math.round(hsl3.s * 100), l2 = Math.round(hsl3.l * 100);
    return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s2 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString3(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone11() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn2, args) {
    var color3 = fn2.apply(null, [this].concat([].slice.call(args)));
    this._r = color3._r;
    this._g = color3._g;
    this._b = color3._b;
    this.setAlpha(color3._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn2, args) {
    return fn2.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color3, opts) {
  if (_typeof3(color3) == "object") {
    var newColor = {};
    for (var i2 in color3) {
      if (color3.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color3[i2];
        } else {
          newColor[i2] = convertToPercentage(color3[i2]);
        }
      }
    }
    color3 = newColor;
  }
  return tinycolor(color3, opts);
};
function inputToRGB(color3) {
  var rgb2 = {
    r: 0,
    g: 0,
    b: 0
  };
  var a3 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color3 == "string") {
    color3 = stringInputToObject(color3);
  }
  if (_typeof3(color3) == "object") {
    if (isValidCSSUnit(color3.r) && isValidCSSUnit(color3.g) && isValidCSSUnit(color3.b)) {
      rgb2 = rgbToRgb(color3.r, color3.g, color3.b);
      ok = true;
      format2 = String(color3.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.v)) {
      s2 = convertToPercentage(color3.s);
      v2 = convertToPercentage(color3.v);
      rgb2 = hsvToRgb(color3.h, s2, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.l)) {
      s2 = convertToPercentage(color3.s);
      l2 = convertToPercentage(color3.l);
      rgb2 = hslToRgb(color3.h, s2, l2);
      ok = true;
      format2 = "hsl";
    }
    if (color3.hasOwnProperty("a")) {
      a3 = color3.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color3.format || format2,
    r: Math.min(255, Math.max(rgb2.r, 0)),
    g: Math.min(255, Math.max(rgb2.g, 0)),
    b: Math.min(255, Math.max(rgb2.b, 0)),
    a: a3
  };
}
function rgbToRgb(r2, g2, b10) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b10, 255) * 255
  };
}
function rgbToHsl(r2, g2, b10) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b10 = bound01(b10, 255);
  var max8 = Math.max(r2, g2, b10), min6 = Math.min(r2, g2, b10);
  var h2, s2, l2 = (max8 + min6) / 2;
  if (max8 == min6) {
    h2 = s2 = 0;
  } else {
    var d2 = max8 - min6;
    s2 = l2 > 0.5 ? d2 / (2 - max8 - min6) : d2 / (max8 + min6);
    switch (max8) {
      case r2:
        h2 = (g2 - b10) / d2 + (g2 < b10 ? 6 : 0);
        break;
      case g2:
        h2 = (b10 - r2) / d2 + 2;
        break;
      case b10:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    l: l2
  };
}
function hslToRgb(h2, s2, l2) {
  var r2, g2, b10;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  function hue2rgb(p3, q3, t4) {
    if (t4 < 0) t4 += 1;
    if (t4 > 1) t4 -= 1;
    if (t4 < 1 / 6) return p3 + (q3 - p3) * 6 * t4;
    if (t4 < 1 / 2) return q3;
    if (t4 < 2 / 3) return p3 + (q3 - p3) * (2 / 3 - t4) * 6;
    return p3;
  }
  if (s2 === 0) {
    r2 = g2 = b10 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b10 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b10 * 255
  };
}
function rgbToHsv(r2, g2, b10) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b10 = bound01(b10, 255);
  var max8 = Math.max(r2, g2, b10), min6 = Math.min(r2, g2, b10);
  var h2, s2, v2 = max8;
  var d2 = max8 - min6;
  s2 = max8 === 0 ? 0 : d2 / max8;
  if (max8 == min6) {
    h2 = 0;
  } else {
    switch (max8) {
      case r2:
        h2 = (g2 - b10) / d2 + (g2 < b10 ? 6 : 0);
        break;
      case g2:
        h2 = (b10 - r2) / d2 + 2;
        break;
      case b10:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    v: v2
  };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t4 = v2 * (1 - (1 - f2) * s2), mod4 = i2 % 6, r2 = [v2, q2, p2, p2, t4, v2][mod4], g2 = [t4, v2, v2, q2, p2, p2][mod4], b10 = [p2, p2, t4, v2, v2, q2][mod4];
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b10 * 255
  };
}
function rgbToHex(r2, g2, b10, allow3Char) {
  var hex2 = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b10).toString(16))];
  if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g2, b10, a3, allow4Char) {
  var hex2 = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b10).toString(16)), pad2(convertDecimalToHex(a3))];
  if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function rgbaToArgbHex(r2, g2, b10, a3) {
  var hex2 = [pad2(convertDecimalToHex(a3)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b10).toString(16))];
  return hex2.join("");
}
tinycolor.equals = function(color1, color22) {
  if (!color1 || !color22) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color22).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.s -= amount / 100;
  hsl3.s = clamp01(hsl3.s);
  return tinycolor(hsl3);
}
function _saturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.s += amount / 100;
  hsl3.s = clamp01(hsl3.s);
  return tinycolor(hsl3);
}
function _greyscale(color3) {
  return tinycolor(color3).desaturate(100);
}
function _lighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.l += amount / 100;
  hsl3.l = clamp01(hsl3.l);
  return tinycolor(hsl3);
}
function _brighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb2 = tinycolor(color3).toRgb();
  rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
  rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
  rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb2);
}
function _darken(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.l -= amount / 100;
  hsl3.l = clamp01(hsl3.l);
  return tinycolor(hsl3);
}
function _spin(color3, amount) {
  var hsl3 = tinycolor(color3).toHsl();
  var hue2 = (hsl3.h + amount) % 360;
  hsl3.h = hue2 < 0 ? 360 + hue2 : hue2;
  return tinycolor(hsl3);
}
function _complement(color3) {
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.h = (hsl3.h + 180) % 360;
  return tinycolor(hsl3);
}
function polyad(color3, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl3 = tinycolor(color3).toHsl();
  var result = [tinycolor(color3)];
  var step = 360 / number;
  for (var i2 = 1; i2 < number; i2++) {
    result.push(tinycolor({
      h: (hsl3.h + i2 * step) % 360,
      s: hsl3.s,
      l: hsl3.l
    }));
  }
  return result;
}
function _splitcomplement(color3) {
  var hsl3 = tinycolor(color3).toHsl();
  var h2 = hsl3.h;
  return [tinycolor(color3), tinycolor({
    h: (h2 + 72) % 360,
    s: hsl3.s,
    l: hsl3.l
  }), tinycolor({
    h: (h2 + 216) % 360,
    s: hsl3.s,
    l: hsl3.l
  })];
}
function _analogous(color3, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl3 = tinycolor(color3).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color3)];
  for (hsl3.h = (hsl3.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl3.h = (hsl3.h + part) % 360;
    ret.push(tinycolor(hsl3));
  }
  return ret;
}
function _monochromatic(color3, results) {
  results = results || 6;
  var hsv = tinycolor(color3).toHsv();
  var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h2,
      s: s2,
      v: v2
    }));
    v2 = (v2 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color22, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color22).toRgb();
  var p2 = amount / 100;
  var rgba2 = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p2 + rgb1.a
  };
  return tinycolor(rgba2);
};
tinycolor.readability = function(color1, color22) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color22);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color22, wcag2) {
  var readability = tinycolor.readability(color1, color22);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size3;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size3 = args.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size: size3
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o2) {
  var flipped = {};
  for (var i2 in o2) {
    if (o2.hasOwnProperty(i2)) {
      flipped[o2[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function bound01(n2, max8) {
  if (isOnePointZero(n2)) n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max8, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max8, 10) / 100;
  }
  if (Math.abs(n2 - max8) < 1e-6) {
    return 1;
  }
  return n2 % max8 / parseFloat(max8);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c3) {
  return c3.length == 1 ? "0" + c3 : "" + c3;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color3) {
  return !!matchers.CSS_UNIT.exec(color3);
}
function stringInputToObject(color3) {
  color3 = color3.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named2 = false;
  if (names[color3]) {
    color3 = names[color3];
    named2 = true;
  } else if (color3 == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named2 ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named2 ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size3;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size3 = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size3 !== "small" && size3 !== "large") {
    size3 = "small";
  }
  return {
    level,
    size: size3
  };
}

// node_modules/@ant-design/colors/dist/index.esm.js
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function getHue(hsv, i2, light) {
  var hue2;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue2 = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue2 = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue2 < 0) {
    hue2 += 360;
  } else if (hue2 >= 360) {
    hue2 -= 360;
  }
  return hue2;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate(color3) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = tinycolor(color3);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = pColor.toHsv();
    var colorString = tinycolor({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue(hsv, i2, true)
    }).toHexString();
    patterns.push(colorString);
  }
  patterns.push(pColor.toHexString());
  for (var _i2 = 1; _i2 <= darkColorCount; _i2 += 1) {
    var _hsv = pColor.toHsv();
    var _colorString = tinycolor({
      h: getHue(_hsv, _i2),
      s: getSaturation(_hsv, _i2),
      v: getValue(_hsv, _i2)
    }).toHexString();
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref) {
      var index2 = _ref.index, opacity = _ref.opacity;
      var darkColorString = tinycolor.mix(opts.backgroundColor || "#141414", patterns[index2], opacity * 100).toHexString();
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key) {
  presetPalettes[key] = generate(presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5];
  presetDarkPalettes[key] = generate(presetPrimaryColors[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});
var red = presetPalettes.red;
var volcano = presetPalettes.volcano;
var gold = presetPalettes.gold;
var orange = presetPalettes.orange;
var yellow = presetPalettes.yellow;
var lime = presetPalettes.lime;
var green = presetPalettes.green;
var cyan = presetPalettes.cyan;
var blue = presetPalettes.blue;
var geekblue = presetPalettes.geekblue;
var purple = presetPalettes.purple;
var magenta = presetPalettes.magenta;
var grey = presetPalettes.grey;

// node_modules/@antv/g6-pc/es/util/color.js
var mixColor = function mixColor2(backColor3, frontColor, frontAlpha) {
  var bc = (0, import_color11.default)(backColor3);
  var fc = (0, import_color11.default)(frontColor);
  return (0, import_color11.default)([(1 - frontAlpha) * bc.red() + frontAlpha * fc.red(), (1 - frontAlpha) * bc.green() + frontAlpha * fc.green(), (1 - frontAlpha) * bc.blue() + frontAlpha * fc.blue()]).rgb();
};
var getColorsWithDefaultTheme = function getColorsWithDefaultTheme2(subjectColor3, backColor3, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  var subjectColor005 = mixColor(backColor3, subjectColor3, 0.05).rgb().toString();
  var subjectColor01 = mixColor(backColor3, subjectColor3, 0.1).rgb().toString();
  var subjectColor02 = mixColor(backColor3, subjectColor3, 0.2).rgb().toString();
  var subjectColor04 = mixColor(backColor3, subjectColor3, 0.4).rgb().toString();
  var disableColor002 = mixColor(backColor3, disableColor, 0.02).rgb().toString();
  var disableColor005 = mixColor(backColor3, disableColor, 0.05).rgb().toString();
  var disableColor01 = mixColor(backColor3, disableColor, 0.1).rgb().toString();
  var disableColor02 = mixColor(backColor3, disableColor, 0.2).rgb().toString();
  var disableColor03 = mixColor(backColor3, disableColor, 0.3).rgb().toString();
  var paletteFromSubject = generate(subjectColor3, {
    theme: "default",
    backgroundColor: backColor3
  });
  var subjectHex = (0, import_color11.default)(subjectColor3).hex().toLowerCase();
  var subjectIdx = paletteFromSubject.indexOf(subjectHex);
  var deeperSubject = subjectColor3;
  if (subjectIdx !== -1) {
    deeperSubject = paletteFromSubject[subjectIdx + 1];
  }
  return {
    // for nodes
    mainStroke: subjectColor3,
    mainFill: subjectColor01,
    activeStroke: subjectColor3,
    activeFill: subjectColor005,
    inactiveStroke: subjectColor04,
    inactiveFill: subjectColor005,
    selectedStroke: subjectColor3,
    selectedFill: backColor3,
    highlightStroke: deeperSubject,
    highlightFill: subjectColor02,
    disableStroke: disableColor03,
    disableFill: disableColor005,
    // for edges
    edgeMainStroke: disableColor03,
    edgeActiveStroke: subjectColor3,
    edgeInactiveStroke: disableColor02,
    edgeSelectedStroke: subjectColor3,
    edgeHighlightStroke: subjectColor3,
    edgeDisableStroke: disableColor01,
    // for combos
    comboMainStroke: disableColor03,
    comboMainFill: disableColor002,
    comboActiveStroke: subjectColor3,
    comboActiveFill: subjectColor005,
    comboInactiveStroke: disableColor03,
    comboInactiveFill: disableColor002,
    comboSelectedStroke: subjectColor3,
    comboSelectedFill: disableColor002,
    comboHighlightStroke: deeperSubject,
    comboHighlightFill: disableColor002,
    comboDisableStroke: disableColor02,
    comboDisableFill: disableColor005
  };
};
var getColorsWithDarkTheme = function getColorsWithDarkTheme2(subjectColor3, backColor3, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (disableColor === void 0) {
    disableColor = "#777";
  }
  var subjectColor02 = mixColor(backColor3, subjectColor3, 0.2).rgb().toString();
  var subjectColor03 = mixColor(backColor3, subjectColor3, 0.3).rgb().toString();
  var subjectColor06 = mixColor(backColor3, subjectColor3, 0.6).rgb().toString();
  var subjectColor08 = mixColor(backColor3, subjectColor3, 0.8).rgb().toString();
  var disableColor02 = mixColor(backColor3, disableColor, 0.2).rgb().toString();
  var disableColor025 = mixColor(backColor3, disableColor, 0.25).rgb().toString();
  var disableColor03 = mixColor(backColor3, disableColor, 0.3).rgb().toString();
  var disableColor04 = mixColor(backColor3, disableColor, 0.4).rgb().toString();
  var disableColor05 = mixColor(backColor3, disableColor, 0.5).rgb().toString();
  var paletteFromSubject = generate(subjectColor3, {
    theme: "dark",
    backgroundColor: backColor3
  });
  var subjectHex = (0, import_color11.default)(subjectColor3).hex().toLowerCase();
  var subjectIdx = paletteFromSubject.indexOf(subjectHex);
  var deeperSubject = subjectColor3;
  if (subjectIdx !== -1) {
    deeperSubject = paletteFromSubject[subjectIdx + 1];
  }
  return {
    // for nodes
    mainStroke: subjectColor08,
    mainFill: subjectColor02,
    activeStroke: subjectColor3,
    activeFill: subjectColor03,
    inactiveStroke: subjectColor08,
    inactiveFill: subjectColor02,
    selectedStroke: subjectColor3,
    selectedFill: subjectColor02,
    highlightStroke: subjectColor3,
    highlightFill: subjectColor06,
    disableStroke: disableColor05,
    disableFill: disableColor025,
    // for edges
    edgeMainStroke: disableColor,
    edgeActiveStroke: subjectColor3,
    edgeInactiveStroke: disableColor,
    edgeSelectedStroke: subjectColor3,
    edgeHighlightStroke: subjectColor3,
    edgeDisableStroke: disableColor03,
    // for combos
    comboMainStroke: disableColor04,
    comboMainFill: disableColor025,
    comboActiveStroke: subjectColor3,
    comboActiveFill: disableColor02,
    comboInactiveStroke: disableColor04,
    comboInactiveFill: disableColor025,
    comboSelectedStroke: subjectColor3,
    comboSelectedFill: disableColor02,
    comboHighlightStroke: deeperSubject,
    comboHighlightFill: disableColor025,
    comboDisableStroke: disableColor04,
    comboDisableFill: disableColor02
  };
};
var getColorsWithSubjectColor = function getColorsWithSubjectColor2(subjectColor3, backColor3, theme, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (theme === void 0) {
    theme = "default";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  if (theme === "default") return getColorsWithDefaultTheme(subjectColor3, backColor3, "rgb(150, 150, 150)");
  return getColorsWithDarkTheme(subjectColor3, backColor3, "#777");
};
var getColorSetsBySubjectColors = function getColorSetsBySubjectColors2(subjectColors, backColor3, theme, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (theme === void 0) {
    theme = "default";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  var sets = [];
  subjectColors.forEach(function(sColor) {
    sets.push(getColorsWithSubjectColor(sColor, backColor3, theme, disableColor));
  });
  return sets;
};

// node_modules/@antv/g6-pc/es/global.js
var subjectColor2 = "rgb(95, 149, 255)";
var backColor2 = "rgb(255, 255, 255)";
var textColor2 = "rgb(0, 0, 0)";
var colorSet2 = getColorsWithSubjectColor(subjectColor2, backColor2);
var global_default2 = {
  version: "0.8.23",
  rootContainerClassName: "root-container",
  nodeContainerClassName: "node-container",
  edgeContainerClassName: "edge-container",
  comboContainerClassName: "combo-container",
  delegateContainerClassName: "delegate-container",
  defaultLoopPosition: "top",
  nodeLabel: {
    style: {
      fill: "#000",
      fontSize: 12,
      textAlign: "center",
      textBaseline: "middle"
    },
    offset: 4
    // 节点的默认文本不居中时的偏移量
  },
  defaultNode: {
    type: "circle",
    style: {
      lineWidth: 1,
      stroke: colorSet2.mainStroke,
      fill: colorSet2.mainFill
    },
    size: 20,
    color: colorSet2.mainStroke,
    linkPoints: {
      size: 8,
      lineWidth: 1,
      fill: colorSet2.activeFill,
      stroke: colorSet2.activeStroke
    }
  },
  // 节点应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  nodeStateStyles: {
    active: {
      fill: colorSet2.activeFill,
      stroke: colorSet2.activeStroke,
      lineWidth: 2,
      shadowColor: colorSet2.mainStroke,
      shadowBlur: 10
    },
    selected: {
      fill: colorSet2.selectedFill,
      stroke: colorSet2.selectedStroke,
      lineWidth: 4,
      shadowColor: colorSet2.selectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      fill: colorSet2.highlightFill,
      stroke: colorSet2.highlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      fill: colorSet2.inactiveFill,
      stroke: colorSet2.inactiveStroke,
      lineWidth: 1
    },
    disable: {
      fill: colorSet2.disableFill,
      stroke: colorSet2.disableStroke,
      lineWidth: 1
    }
  },
  edgeLabel: {
    style: {
      fill: textColor2,
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 12
    }
  },
  defaultEdge: {
    type: "line",
    size: 1,
    style: {
      stroke: colorSet2.edgeMainStroke,
      lineAppendWidth: 2
    },
    color: colorSet2.edgeMainStroke
  },
  // 边应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  edgeStateStyles: {
    active: {
      stroke: colorSet2.edgeActiveStroke,
      lineWidth: 1
    },
    selected: {
      stroke: colorSet2.edgeSelectedStroke,
      lineWidth: 2,
      shadowColor: colorSet2.edgeSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet2.edgeHighlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet2.edgeInactiveStroke,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet2.edgeDisableStroke,
      lineWidth: 1
    }
  },
  comboLabel: {
    style: {
      fill: textColor2,
      // textAlign: 'center',
      textBaseline: "middle",
      fontSize: 12
    },
    refY: 10,
    refX: 10
    // Combo 的默认文本不居中时的偏移量
  },
  defaultCombo: {
    type: "circle",
    style: {
      fill: colorSet2.comboMainFill,
      lineWidth: 1,
      stroke: colorSet2.comboMainStroke,
      r: 5,
      width: 20,
      height: 10
    },
    size: [20, 5],
    color: colorSet2.comboMainStroke,
    padding: [25, 20, 15, 20]
  },
  // combo 应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  comboStateStyles: {
    active: {
      stroke: colorSet2.comboActiveStroke,
      lineWidth: 1,
      fill: colorSet2.comboActiveFill
    },
    selected: {
      stroke: colorSet2.comboSelectedStroke,
      lineWidth: 2,
      fill: colorSet2.comboSelectedFill,
      shadowColor: colorSet2.comboSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet2.comboHighlightStroke,
      lineWidth: 2,
      fill: colorSet2.comboHighlightFill,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet2.comboInactiveStroke,
      fill: colorSet2.comboInactiveFill,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet2.comboDisableStroke,
      fill: colorSet2.comboDisableFill,
      lineWidth: 1
    }
  },
  delegateStyle: {
    fill: "#F3F9FF",
    fillOpacity: 0.5,
    stroke: "#1890FF",
    strokeOpacity: 0.9,
    lineDash: [5, 5]
  },
  // 文本水印默认配置
  textWaterMarkerConfig: {
    width: 150,
    height: 100,
    compatible: false,
    text: {
      x: 0,
      y: 60,
      lineHeight: 20,
      rotate: 20,
      fontSize: 14,
      fontFamily: "Microsoft YaHei",
      fill: "rgba(0, 0, 0, 0.1)",
      baseline: "Middle"
    }
  },
  imageWaterMarkerConfig: {
    width: 150,
    height: 130,
    compatible: false,
    image: {
      x: 0,
      y: 0,
      width: 30,
      height: 20,
      rotate: 0
    }
  },
  waterMarkerImage: "https://gw.alipayobjects.com/os/s/prod/antv/assets/image/logo-with-text-73b8a.svg"
};

// node_modules/@antv/g6-pc/es/util/image.js
var cloneGElement = function cloneGElement2(element) {
  var vElement = element.clone();
  applyCloneClip(element, vElement);
  return vElement;
};
var applyCloneClip = function applyCloneClip2(element, clonedElement) {
  var _a2;
  if (element.isGroup() && clonedElement.isGroup()) {
    (_a2 = element.get("children")) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child, i2) {
      var clonedChild = clonedElement.get("children")[i2];
      applyCloneClip2(child, clonedChild);
    });
  }
  var type = element.get("type");
  var clonedType = clonedElement.get("type");
  if (type !== "image" || clonedType !== "image") return;
  var clipShape = element.get("clipShape");
  if (clipShape) {
    clonedElement.setClip({
      type: clipShape.get("type"),
      attrs: clipShape.attr()
    });
  }
};

// node_modules/@antv/g6-pc/es/graph/controller/event.js
init_esm();
var cloneEvent3 = util_default.cloneEvent;
var isViewportChanged3 = util_default.isViewportChanged;
var EventController3 = (
  /** @class */
  function(_super) {
    __extends(EventController4, _super);
    function EventController4(graph) {
      var _this = _super.call(this, graph) || this;
      _this.extendEvents = [];
      _this.dragging = false;
      _this.mousedown = false;
      _this.preItem = null;
      _this.destroy();
      _this.graph = graph;
      _this.destroyed = false;
      _this.initEvents();
      return _this;
    }
    EventController4.prototype.initEvents = function() {
      var _a2 = this, graph = _a2.graph, _b = _a2.extendEvents, extendEvents = _b === void 0 ? [] : _b;
      var canvas = graph.get("canvas");
      var el = canvas.get("el");
      var canvasHandler = wrap_behavior_default(this, "onCanvasEvents");
      var originHandler = wrap_behavior_default(this, "onExtendEvents");
      var wheelHandler = wrap_behavior_default(this, "onWheelEvent");
      canvas.off("*").on("*", canvasHandler);
      this.canvasHandler = canvasHandler;
      extendEvents.push(addEventListener(el, "wheel", wheelHandler));
      if (typeof window !== "undefined") {
        extendEvents.push(addEventListener(window, "keydown", originHandler));
        extendEvents.push(addEventListener(window, "keyup", originHandler));
        extendEvents.push(addEventListener(window, "focus", originHandler));
      }
      if (this.resetHandler) graph.off("afterchangedata", this.resetHandler);
      this.resetHandler = wrap_behavior_default(this, "resetStatus");
      graph.on("afterchangedata", this.resetHandler);
    };
    EventController4.getItemRoot = function(shape) {
      while (shape && !shape.get("item")) {
        shape = shape.get("parent");
      }
      return shape;
    };
    EventController4.prototype.onCanvasEvents = function(evt) {
      var _this = this;
      var graph = this.graph;
      var canvas = graph.get("canvas");
      var target = evt.target;
      var eventType = evt.type;
      switch (eventType) {
        case "drag":
          this.onCanvasEvents(Object.assign({}, evt, {
            type: "mousemove"
          }));
          break;
        case "dragend":
          this.onCanvasEvents(Object.assign({}, evt, {
            type: "mouseup"
          }));
          break;
        case "mousedown":
          this.mousedown = true;
          break;
        case "mouseup":
          setTimeout(function() {
            return _this.mousedown = false;
          });
          break;
        case "click":
          if (!this.mousedown) return;
          break;
        default:
          break;
      }
      evt.canvasX = evt.x;
      evt.canvasY = evt.y;
      var point = {
        x: evt.canvasX,
        y: evt.canvasY
      };
      var group = graph.get("group");
      var matrix = group.getMatrix();
      if (!matrix) {
        matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      if (isViewportChanged3(matrix)) {
        point = graph.getPointByClient(evt.clientX, evt.clientY);
      }
      evt.x = point.x;
      evt.y = point.y;
      evt.currentTarget = graph;
      if (target === canvas) {
        if (eventType === "mousemove" || eventType === "mouseleave") {
          this.handleMouseMove(evt, "canvas");
        }
        evt.target = canvas;
        evt.item = null;
        graph.emit(eventType, evt);
        graph.emit("canvas:".concat(eventType), evt);
        return;
      }
      var itemShape = EventController4.getItemRoot(target);
      if (!itemShape) {
        graph.emit(eventType, evt);
        return;
      }
      var item = itemShape.get("item");
      if (item.destroyed) {
        return;
      }
      var type = item.getType();
      evt.target = target;
      evt.item = item;
      if (evt.canvasX === evt.x && evt.canvasY === evt.y) {
        var canvasPoint = graph.getCanvasByPoint(evt.x, evt.y);
        evt.canvasX = canvasPoint.x;
        evt.canvasY = canvasPoint.y;
      }
      if (evt.name && !evt.name.includes(":")) {
        graph.emit("".concat(type, ":").concat(eventType), evt);
        graph.emit(eventType, evt);
      } else if (evt.name) {
        graph.emit(evt.name, evt);
      }
      if (eventType === "dragstart") {
        this.dragging = true;
      }
      if (eventType === "dragend") {
        this.dragging = false;
      }
      if (eventType === "mousemove") {
        this.handleMouseMove(evt, type);
      }
    };
    EventController4.prototype.onExtendEvents = function(evt) {
      this.graph.emit(evt.type, evt);
    };
    EventController4.prototype.onWheelEvent = function(evt) {
      if (is_nil_default(evt.wheelDelta)) {
        evt.wheelDelta = -evt.detail;
      }
      this.graph.emit("wheel", evt);
    };
    EventController4.prototype.handleMouseMove = function(evt, type) {
      var _a2 = this, graph = _a2.graph, preItem = _a2.preItem;
      var canvas = graph.get("canvas");
      var item = evt.target === canvas ? null : evt.item;
      evt = cloneEvent3(evt);
      if (preItem && preItem !== item && !preItem.destroyed) {
        evt.item = preItem;
        this.emitCustomEvent(preItem.getType(), "mouseleave", evt);
        if (this.dragging) {
          this.emitCustomEvent(preItem.getType(), "dragleave", evt);
        }
      }
      if (item && preItem !== item) {
        evt.item = item;
        this.emitCustomEvent(type, "mouseenter", evt);
        if (this.dragging) {
          this.emitCustomEvent(type, "dragenter", evt);
        }
      }
      this.preItem = item;
    };
    EventController4.prototype.emitCustomEvent = function(itemType, eventType, evt) {
      evt.type = eventType;
      this.graph.emit("".concat(itemType, ":").concat(eventType), evt);
    };
    EventController4.prototype.resetStatus = function() {
      this.mousedown = false;
      this.dragging = false;
      this.preItem = null;
    };
    EventController4.prototype.destroy = function() {
      var _a2 = this, graph = _a2.graph, canvasHandler = _a2.canvasHandler, extendEvents = _a2.extendEvents;
      var canvas = graph.get("canvas");
      canvas.off("*", canvasHandler);
      each_default(extendEvents, function(event) {
        event.remove();
      });
      this.resetStatus();
      this.extendEvents.length = 0;
      this.canvasHandler = null;
      this.resetHandler = null;
      this.destroyed = true;
    };
    return EventController4;
  }(event_default)
);
var event_default2 = EventController3;

// node_modules/@antv/g6-pc/es/layout/index.js
var import_lib = __toESM(require_lib());

// node_modules/@antv/g6-pc/es/layout/tree-layout.js
var import_hierarchy = __toESM(require_lib2());

// node_modules/@antv/g6-pc/es/util/layout.js
var layout_exports2 = {};
__export(layout_exports2, {
  arrayToTextureData: () => arrayToTextureData,
  attributesToTextureData: () => attributesToTextureData,
  buildTextureData: () => buildTextureData,
  buildTextureDataWithOneEdgeAttr: () => buildTextureDataWithOneEdgeAttr,
  buildTextureDataWithTwoEdgeAttr: () => buildTextureDataWithTwoEdgeAttr,
  proccessToFunc: () => proccessToFunc,
  radialLayout: () => radialLayout
});
init_esm();
var traverseTree3 = util_default.traverseTree;
var proccessToFunc = function proccessToFunc2(value, defaultV) {
  var func;
  if (!value) {
    func = function func2(d2) {
      return defaultV || 1;
    };
  } else if (is_number_default(value)) {
    func = function func2(d2) {
      return value;
    };
  } else {
    func = value;
  }
  return func;
};
var buildTextureData = function buildTextureData2(nodes, edges) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len6 = dests.length;
    dataArray[i2 * 4 + 2] = offset;
    dataArray[i2 * 4 + 3] = dests.length;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);
    for (var j2 = 0; j2 < len6; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr2(nodes, edges, attrs) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.source]].push(attrs(e8));
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
    nodeDict[mapIdPos[e8.target]].push(attrs(e8));
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len6 = dests.length;
    dataArray[i2 * 4 + 2] = offset;
    dataArray[i2 * 4 + 3] = len6 / 2;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, len6 / 2);
    for (var j2 = 0; j2 < len6; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr2(nodes, edges, attrs1, attrs2) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.source]].push(attrs1(e8));
    nodeDict[mapIdPos[e8.source]].push(attrs2(e8));
    nodeDict[mapIdPos[e8.source]].push(0);
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
    nodeDict[mapIdPos[e8.target]].push(attrs1(e8));
    nodeDict[mapIdPos[e8.target]].push(attrs2(e8));
    nodeDict[mapIdPos[e8.target]].push(0);
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len6 = dests.length;
    dataArray[i2 * 4 + 2] = offset + 1048576 * len6 / 4;
    dataArray[i2 * 4 + 3] = 0;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, len6 / 4);
    for (var j2 = 0; j2 < len6; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var attributesToTextureData = function attributesToTextureData2(attributeNames, items) {
  var dataArray = [];
  var attributeNum = attributeNames.length;
  var attributeStringMap = {};
  items.forEach(function(item) {
    attributeNames.forEach(function(name, i2) {
      if (attributeStringMap[item[name]] === void 0) {
        attributeStringMap[item[name]] = Object.keys(attributeStringMap).length;
      }
      dataArray.push(attributeStringMap[item[name]]);
      if (i2 === attributeNum - 1) {
        while (dataArray.length % 4 !== 0) {
          dataArray.push(0);
        }
      }
    });
  });
  return {
    array: new Float32Array(dataArray),
    count: Object.keys(attributeStringMap).length
  };
};
var arrayToTextureData = function arrayToTextureData2(valueArrays) {
  var dataArray = [];
  var attributeNum = valueArrays.length;
  var itemNum = valueArrays[0].length;
  var _loop_1 = function _loop_12(j3) {
    valueArrays.forEach(function(valueArray, i2) {
      dataArray.push(valueArray[j3]);
      if (i2 === attributeNum - 1) {
        while (dataArray.length % 4 !== 0) {
          dataArray.push(0);
        }
      }
    });
  };
  for (var j2 = 0; j2 < itemNum; j2++) {
    _loop_1(j2);
  }
  return new Float32Array(dataArray);
};
var radialLayout = function radialLayout2(data, layout2) {
  var VERTICAL_LAYOUTS = ["V", "TB", "BT"];
  var min6 = {
    x: Infinity,
    y: Infinity
  };
  var max8 = {
    x: -Infinity,
    y: -Infinity
  };
  var rScale = "x";
  var radScale = "y";
  if (layout2 && VERTICAL_LAYOUTS.indexOf(layout2) >= 0) {
    radScale = "x";
    rScale = "y";
  }
  var count = 0;
  traverseTree3(data, function(node) {
    count++;
    if (node.x > max8.x) {
      max8.x = node.x;
    }
    if (node.x < min6.x) {
      min6.x = node.x;
    }
    if (node.y > max8.y) {
      max8.y = node.y;
    }
    if (node.y < min6.y) {
      min6.y = node.y;
    }
    return true;
  });
  var avgRad = Math.PI * 2 / count;
  var radDiff = max8[radScale] - min6[radScale];
  if (radDiff === 0) {
    return data;
  }
  traverseTree3(data, function(node) {
    var radial = (node[radScale] - min6[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;
    var r2 = Math.abs(rScale === "x" ? node.x - data.x : node.y - data.y);
    node.x = r2 * Math.cos(radial);
    node.y = r2 * Math.sin(radial);
    return true;
  });
  return data;
};

// node_modules/@antv/g6-pc/es/util/gpu.js
var gpu_exports = {};
__export(gpu_exports, {
  gpuDetector: () => gpuDetector
});
var gpuDetector = function gpuDetector2() {
  if (typeof window === "undefined" || typeof document === "undefined") return {};
  return {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: function() {
      try {
        var canvas = document.createElement("canvas");
        return !!(window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
      } catch (e8) {
        return false;
      }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function getWebGLErrorMessage() {
      var element = document.createElement("div");
      element.id = "webgl-error-message";
      element.style.fontFamily = "monospace";
      element.style.fontSize = "13px";
      element.style.fontWeight = "normal";
      element.style.textAlign = "center";
      element.style.background = "#fff";
      element.style.color = "#000";
      element.style.padding = "1.5em";
      element.style.width = "400px";
      element.style.margin = "5em auto 0";
      if (!this.webgl) {
        element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join("\n");
      }
      return element;
    },
    addGetWebGLMessage: function addGetWebGLMessage(parameters) {
      parameters = parameters || {};
      var parent = parameters.parent !== void 0 ? parameters.parent : document.body;
      var id = parameters.id !== void 0 ? parameters.id : "oldie";
      var element = gpuDetector2().getWebGLErrorMessage();
      element.id = id;
      parent.appendChild(element);
    }
  };
};

// node_modules/@antv/g6-pc/es/util/browser.js
var browser_exports = {};
__export(browser_exports, {
  getBrowserName: () => getBrowserName
});
var getBrowserName = function getBrowserName2() {
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.indexOf("firefox") > -1) return "firefox";
  if (userAgent.indexOf("safari") > -1) return "safari";
  if (userAgent.indexOf("opr") > -1) return "opera";
  if (userAgent.indexOf("chrome") > -1) return "chrome";
  if (userAgent.indexOf("trident") > -1) return "ie 11";
  if (userAgent.indexOf("ie") > -1) return "ie";
  return "unknown";
};

// node_modules/@antv/g6-pc/es/util/index.js
var G6Util = __assign(__assign(__assign(__assign(__assign({}, util_default), color_exports2), layout_exports2), gpu_exports), browser_exports);
var util_default2 = G6Util;

// node_modules/@antv/g6-pc/es/layout/tree-layout.js
var radialLayout3 = util_default2.radialLayout;
var TreeLayout = (
  /** @class */
  function() {
    function TreeLayout2(cfg) {
      this.type = cfg.type;
      this.radial = cfg.radial;
      this.config = cfg;
    }
    TreeLayout2.prototype.init = function(data) {
      var _this = this;
      this.data = data;
      if (this.radial) {
        this.layoutMethod = function(data2) {
          var layoutData = import_hierarchy.default[_this.type](data2, _this.config);
          radialLayout3(layoutData);
          return layoutData;
        };
        return;
      }
      this.layoutMethod = function(data2) {
        return import_hierarchy.default[_this.type](data2, _this.config);
      };
    };
    TreeLayout2.prototype.execute = function() {
      return this.layoutMethod(this.data, this.config);
    };
    TreeLayout2.prototype.layout = function(data) {
      this.init(data);
      return this.execute();
    };
    return TreeLayout2;
  }()
);
var tree_layout_default = TreeLayout;

// node_modules/@antv/g6-pc/es/layout/index.js
(0, import_lib.registerLayout)("grid", import_lib.GridLayout);
(0, import_lib.registerLayout)("random", import_lib.RandomLayout);
(0, import_lib.registerLayout)("force", import_lib.ForceLayout);
(0, import_lib.registerLayout)("circular", import_lib.CircularLayout);
(0, import_lib.registerLayout)("dagre", import_lib.DagreLayout);
(0, import_lib.registerLayout)("dagreCompound", import_lib.DagreCompoundLayout);
(0, import_lib.registerLayout)("radial", import_lib.RadialLayout);
(0, import_lib.registerLayout)("concentric", import_lib.ConcentricLayout);
(0, import_lib.registerLayout)("mds", import_lib.MDSLayout);
(0, import_lib.registerLayout)("fruchterman", import_lib.FruchtermanLayout);
(0, import_lib.registerLayout)("fruchterman-gpu", import_lib.FruchtermanGPULayout);
(0, import_lib.registerLayout)("gForce", import_lib.GForceLayout);
(0, import_lib.registerLayout)("force2", import_lib.Force2Layout);
(0, import_lib.registerLayout)("gForce-gpu", import_lib.GForceGPULayout);
(0, import_lib.registerLayout)("comboForce", import_lib.ComboForceLayout);
(0, import_lib.registerLayout)("comboCombined", import_lib.ComboCombinedLayout);
(0, import_lib.registerLayout)("forceAtlas2", import_lib.ForceAtlas2Layout);
var registerLayout = function registerLayout2(name, layoutOverride) {
  layoutOverride.isCustomLayout = true;
  import_lib.Layouts[name] = (0, import_lib.registerLayout)(name, layoutOverride);
};

// node_modules/@antv/g6-pc/es/layout/worker/work.js
var WebWorker = (
  /** @class */
  /* @__PURE__ */ function() {
    function WebWorker2(worker, workerScirptURL) {
      var code = worker.toString();
      var blob = new Blob(["importScripts('".concat(workerScirptURL, "');(").concat(code, ")()")], {
        type: "text/javascript"
      });
      return new Worker(URL.createObjectURL(blob));
    }
    return WebWorker2;
  }()
);
var work_default = WebWorker;

// node_modules/@antv/g6-pc/es/layout/worker/layout.js
var LayoutWorker = function LayoutWorker2(workerScriptURL) {
  if (workerScriptURL === void 0) {
    workerScriptURL = "https://unpkg.com/@antv/layout@0.3.23/dist/layout.min.js";
  }
  function workerCode() {
    var LAYOUT_MESSAGE2 = {
      // run layout
      RUN: "LAYOUT_RUN",
      // layout ended with success
      END: "LAYOUT_END",
      // layout error
      ERROR: "LAYOUT_ERROR",
      // layout tick, used in force directed layout
      TICK: "LAYOUT_TICK",
      GPURUN: "GPU_LAYOUT_RUN",
      GPUEND: "GPU_LAYOUT_END"
    };
    layout.registerLayout("grid", layout.GridLayout);
    layout.registerLayout("random", layout.RandomLayout);
    layout.registerLayout("force", layout.ForceLayout);
    layout.registerLayout("force2", layout.Force2Layout);
    layout.registerLayout("circular", layout.CircularLayout);
    layout.registerLayout("dagre", layout.DagreLayout);
    layout.registerLayout("dagreCompound", layout.DagreCompoundLayout);
    layout.registerLayout("radial", layout.RadialLayout);
    layout.registerLayout("concentric", layout.ConcentricLayout);
    layout.registerLayout("mds", layout.MDSLayout);
    layout.registerLayout("fruchterman", layout.FruchtermanLayout);
    layout.registerLayout("fruchterman-gpu", layout.FruchtermanGPULayout);
    layout.registerLayout("gForce", layout.GForceLayout);
    layout.registerLayout("gForce-gpu", layout.GForceGPULayout);
    layout.registerLayout("comboForce", layout.ComboForceLayout);
    layout.registerLayout("comboCombined", layout.ComboCombinedLayout);
    layout.registerLayout("forceAtlas2", layout.ForceAtlas2Layout);
    function isLayoutMessage(event) {
      var type = event.data.type;
      return type === LAYOUT_MESSAGE2.RUN || type === LAYOUT_MESSAGE2.GPURUN;
    }
    function handleLayoutMessage(event) {
      var _this = this;
      var type = event.data.type;
      switch (type) {
        case LAYOUT_MESSAGE2.RUN: {
          var _a2 = event.data, nodes_1 = _a2.nodes, edges = _a2.edges, _b = _a2.layoutCfg, layoutCfg = _b === void 0 ? {} : _b;
          var layoutType = layoutCfg.type;
          var LayoutClass = layout.getLayoutByName(layoutType);
          if (!LayoutClass) {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " not found")
            });
            break;
          }
          var layoutMethod_1;
          layoutCfg.onLayoutEnd = function() {
            _this.postMessage({
              type: LAYOUT_MESSAGE2.END,
              nodes: nodes_1
            });
            layoutMethod_1 === null || layoutMethod_1 === void 0 ? void 0 : layoutMethod_1.destroy();
          };
          layoutMethod_1 = new LayoutClass(layoutCfg);
          layoutMethod_1.init({
            nodes: nodes_1,
            edges
          });
          layoutMethod_1.execute();
          break;
        }
        case LAYOUT_MESSAGE2.GPURUN: {
          var _c = event.data, nodes = _c.nodes, edges = _c.edges, _d = _c.layoutCfg, layoutCfg = _d === void 0 ? {} : _d, canvas = _c.canvas;
          var layoutType = layoutCfg.type;
          var LayoutClass = layout.getLayoutByName(layoutType);
          if (!LayoutClass) {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " not found")
            });
            break;
          }
          if (layoutType.split("-")[1] !== "gpu") {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " does not support GPU")
            });
            break;
          }
          var layoutMethod = new LayoutClass(layoutCfg);
          layoutMethod.init({
            nodes,
            edges
          });
          layoutMethod.executeWithWorker(canvas, this);
          break;
        }
        default:
          break;
      }
    }
    onmessage = function onmessage2(event) {
      if (isLayoutMessage(event)) {
        handleLayoutMessage(event);
      }
    };
  }
  var layoutWorker = new work_default(workerCode, workerScriptURL);
  return layoutWorker;
};

// node_modules/@antv/g6-pc/es/layout/worker/layoutConst.js
var LAYOUT_MESSAGE = {
  // run layout
  RUN: "LAYOUT_RUN",
  // layout ended with success
  END: "LAYOUT_END",
  // layout error
  ERROR: "LAYOUT_ERROR",
  // layout tick, used in force directed layout
  TICK: "LAYOUT_TICK",
  GPURUN: "GPU_LAYOUT_RUN",
  GPUEND: "GPU_LAYOUT_END"
};

// node_modules/@antv/g6-pc/es/graph/controller/layout.js
init_esm();
function _typeof7(o2) {
  "@babel/helpers - typeof";
  return _typeof7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof7(o2);
}
var mockRaf = function mockRaf2(cb) {
  return setTimeout(cb, 16);
};
var mockCaf = function mockCaf2(reqId) {
  return clearTimeout(reqId);
};
var helper = {
  // pollyfill
  requestAnimationFrame: function requestAnimationFrame4(callback) {
    var fn2 = typeof window !== "undefined" ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || mockRaf : mockRaf;
    return fn2(callback);
  },
  cancelAnimationFrame: function cancelAnimationFrame4(requestId) {
    var fn2 = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || mockCaf : mockCaf;
    return fn2(requestId);
  }
};
var GPU_LAYOUT_NAMES = ["fruchterman", "gForce"];
var LAYOUT_PIPES_ADJUST_NAMES = ["force", "grid", "circular"];
var LayoutController2 = (
  /** @class */
  function(_super) {
    __extends(LayoutController3, _super);
    function LayoutController3(graph) {
      var _this = _super.call(this, graph) || this;
      _this.graph = graph;
      _this.layoutCfg = graph.get("layout") || {};
      _this.layoutType = _this.getLayoutType();
      _this.worker = null;
      _this.workerData = {};
      _this.initLayout();
      return _this;
    }
    LayoutController3.prototype.initLayout = function() {
    };
    LayoutController3.prototype.getWorker = function() {
      if (this.worker) {
        return this.worker;
      }
      if (typeof Worker === "undefined") {
        console.warn("Web worker is not supported in current browser.");
        this.worker = null;
      } else {
        this.worker = LayoutWorker(this.layoutCfg.workerScriptURL);
      }
      return this.worker;
    };
    LayoutController3.prototype.stopWorker = function() {
      var workerData = this.workerData;
      if (!this.worker) {
        return;
      }
      this.worker.terminate();
      this.worker = null;
      if (workerData.requestId) {
        helper.cancelAnimationFrame(workerData.requestId);
        workerData.requestId = null;
      }
      if (workerData.requestId2) {
        helper.cancelAnimationFrame(workerData.requestId2);
        workerData.requestId2 = null;
      }
    };
    LayoutController3.prototype.execLayoutMethod = function(layoutCfg, order) {
      var _this = this;
      return new Promise(function(reslove, reject) {
        return __awaiter(_this, void 0, void 0, function() {
          var graph, layoutType, onTick_1, animate_1, isDefaultAnimateLayout_1, tick, enableTick, layoutMethod, onTick_2, tick, layoutData;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                graph = this.graph;
                if (!graph || graph.get("destroyed")) return [
                  2
                  /*return*/
                ];
                layoutType = layoutCfg.type;
                layoutCfg.onLayoutEnd = function() {
                  graph.emit("aftersublayout", {
                    type: layoutType
                  });
                  reslove();
                };
                if (layoutType && this.isGPU) {
                  if (!hasGPUVersion(layoutType)) {
                    console.warn("The '".concat(layoutType, "' layout does not support GPU calculation for now, it will run in CPU."));
                  } else {
                    layoutType = "".concat(layoutType, "-gpu");
                  }
                }
                if (util_default.isForce(layoutType)) {
                  onTick_1 = layoutCfg.onTick, animate_1 = layoutCfg.animate;
                  isDefaultAnimateLayout_1 = animate_1 === void 0 && (layoutType === "force" || layoutType === "force2");
                  tick = function tick2() {
                    if (onTick_1) {
                      onTick_1();
                    }
                    if (animate_1 || isDefaultAnimateLayout_1) graph.refreshPositions();
                  };
                  layoutCfg.tick = tick;
                } else if (layoutType === "comboForce" || layoutType === "comboCombined") {
                  layoutCfg.comboTrees = graph.get("comboTrees");
                }
                enableTick = false;
                try {
                  layoutMethod = new import_lib.Layouts[layoutType](layoutCfg);
                  if (this.layoutMethods[order]) {
                    this.layoutMethods[order].destroy();
                  }
                  this.layoutMethods[order] = layoutMethod;
                } catch (e8) {
                  console.warn("The layout method: '".concat(layoutType, "' does not exist! Please specify it first."));
                  reject();
                }
                enableTick = layoutMethod.enableTick;
                if (enableTick) {
                  onTick_2 = layoutCfg.onTick;
                  tick = function tick2() {
                    if (onTick_2) {
                      onTick_2();
                    }
                    graph.refreshPositions();
                  };
                  layoutMethod.tick = tick;
                }
                layoutData = this.filterLayoutData(this.data, layoutCfg);
                addLayoutOrder(layoutData, order);
                layoutMethod.init(layoutData);
                graph.emit("beforesublayout", {
                  type: layoutType
                });
                return [4, layoutMethod.execute()];
              case 1:
                _a2.sent();
                if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd) layoutCfg.onLayoutEnd();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    LayoutController3.prototype.updateLayoutMethod = function(layoutMethod, layoutCfg) {
      var _this = this;
      return new Promise(function(reslove, reject) {
        return __awaiter(_this, void 0, void 0, function() {
          var graph, layoutType, onTick_3, animate_2, isDefaultAnimateLayout_2, tick, layoutData;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                graph = this.graph;
                layoutType = layoutCfg === null || layoutCfg === void 0 ? void 0 : layoutCfg.type;
                layoutCfg.onLayoutEnd = function() {
                  graph.emit("aftersublayout", {
                    type: layoutType
                  });
                  reslove();
                };
                if (util_default.isForce(layoutType)) {
                  onTick_3 = layoutCfg.onTick, animate_2 = layoutCfg.animate;
                  isDefaultAnimateLayout_2 = animate_2 === void 0 && (layoutType === "force" || layoutType === "force2");
                  tick = function tick2() {
                    onTick_3 === null || onTick_3 === void 0 ? void 0 : onTick_3();
                    if (animate_2 || isDefaultAnimateLayout_2) graph.refreshPositions();
                  };
                  layoutCfg.tick = tick;
                }
                layoutData = this.filterLayoutData(this.data, layoutCfg);
                layoutMethod.init(layoutData);
                layoutMethod.updateCfg(layoutCfg);
                graph.emit("beforesublayout", {
                  type: layoutType
                });
                return [4, layoutMethod.execute()];
              case 1:
                _a2.sent();
                if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd) layoutCfg.onLayoutEnd();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    LayoutController3.prototype.layout = function(success) {
      var _this = this;
      var _a2;
      var graph = this.graph;
      if (!graph || graph.get("destroyed")) return;
      this.data = this.setDataFromGraph();
      var _b = this.data, nodes = _b.nodes, hiddenNodes = _b.hiddenNodes;
      if (!nodes) {
        return false;
      }
      var width = graph.get("width");
      var height = graph.get("height");
      var layoutCfg = {};
      Object.assign(layoutCfg, {
        width,
        height,
        center: [width / 2, height / 2]
      }, this.layoutCfg);
      this.layoutCfg = layoutCfg;
      var layoutType = layoutCfg.type;
      var prevHasNodes = false;
      (_a2 = this.layoutMethods) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(method) {
        var _a3;
        return prevHasNodes = !!((_a3 = method.nodes) === null || _a3 === void 0 ? void 0 : _a3.length) || prevHasNodes;
      });
      var preLayoutTypes = this.destoryLayoutMethods();
      graph.emit("beforelayout");
      var start = Promise.resolve();
      if (prevHasNodes && layoutType && (preLayoutTypes === null || preLayoutTypes === void 0 ? void 0 : preLayoutTypes.length) === 1 && preLayoutTypes[0] === layoutType) {
        this.tweakInit();
      } else {
        start = this.initPositions(layoutCfg.center, nodes);
      }
      var initHiddenPromise = this.initPositions(layoutCfg.center, hiddenNodes);
      initHiddenPromise.then();
      this.isGPU = getGPUEnabled(layoutCfg, layoutType);
      var onLayoutEnd = layoutCfg.onLayoutEnd, layoutEndFormatted = layoutCfg.layoutEndFormatted, adjust = layoutCfg.adjust;
      if (!layoutEndFormatted) {
        layoutCfg.layoutEndFormatted = true;
        layoutCfg.onAllLayoutEnd = function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  if (onLayoutEnd) {
                    onLayoutEnd(nodes);
                  }
                  this.refreshLayout();
                  if (!(adjust && layoutCfg.pipes)) return [3, 2];
                  return [4, this.adjustPipesBox(this.data, adjust)];
                case 1:
                  _a3.sent();
                  this.refreshLayout();
                  _a3.label = 2;
                case 2:
                  graph.emit("afterlayout");
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
      }
      this.stopWorker();
      if (layoutCfg.workerEnabled && this.layoutWithWorker(this.data, success)) {
        return true;
      }
      var hasLayout = false;
      if (layoutCfg.type) {
        hasLayout = true;
        start = start.then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.execLayoutMethod(layoutCfg, 0)];
                case 1:
                  return [2, _a3.sent()];
              }
            });
          });
        });
      } else if (layoutCfg.pipes) {
        hasLayout = true;
        layoutCfg.pipes.forEach(function(cfg, index2) {
          start = start.then(function() {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    return [4, this.execLayoutMethod(cfg, index2)];
                  case 1:
                    return [2, _a3.sent()];
                }
              });
            });
          });
        });
      }
      if (hasLayout) {
        start.then(function() {
          if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd();
          if (success) success();
        }).catch(function(error) {
          console.warn("graph layout failed,", error);
        });
      } else {
        graph.refreshPositions();
        success === null || success === void 0 ? void 0 : success();
      }
      return false;
    };
    LayoutController3.prototype.tweakInit = function() {
      var _a2 = this, data = _a2.data, graph = _a2.graph;
      var nodes = data.nodes, edges = data.edges;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) return;
      var positionMap = {};
      nodes.forEach(function(node) {
        var x4 = node.x, y4 = node.y;
        if (!isNaN(x4) && !isNaN(y4)) {
          positionMap[node.id] = {
            x: x4,
            y: y4
          };
          node.mass = node.mass || 2;
        }
      });
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var sourcePosition = positionMap[source];
        var targetPosition = positionMap[target];
        if (!sourcePosition && targetPosition) {
          positionMap[source] = {
            x: targetPosition.x + (Math.random() - 0.5) * 80,
            y: targetPosition.y + (Math.random() - 0.5) * 80
          };
        } else if (!targetPosition && sourcePosition) {
          positionMap[target] = {
            x: sourcePosition.x + (Math.random() - 0.5) * 80,
            y: sourcePosition.y + (Math.random() - 0.5) * 80
          };
        }
      });
      var width = graph.get("width");
      var height = graph.get("height");
      nodes.forEach(function(node) {
        var position = positionMap[node.id] || {
          x: width / 2 + (Math.random() - 0.5) * 20,
          y: height / 2 + (Math.random() - 0.5) * 20
        };
        node.x = position.x;
        node.y = position.y;
      });
    };
    LayoutController3.prototype.initWithPreset = function(hasPresetCallback, noPresetCallback) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        return __awaiter(_this, void 0, void 0, function() {
          var _a2, layoutCfg, data, preset, isGPU, layoutType, presetLayout;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this, layoutCfg = _a2.layoutCfg, data = _a2.data;
                preset = layoutCfg.preset;
                if (!(preset === null || preset === void 0 ? void 0 : preset.type) || !import_lib.Layouts[preset === null || preset === void 0 ? void 0 : preset.type]) {
                  noPresetCallback === null || noPresetCallback === void 0 ? void 0 : noPresetCallback();
                  resolve();
                  return [2, false];
                }
                isGPU = getGPUEnabled(preset, preset.type);
                layoutType = isGPU ? "".concat(preset.type, "-gpu") : preset.type;
                presetLayout = new import_lib.Layouts[layoutType](preset);
                delete layoutCfg.preset;
                presetLayout.init(data);
                return [4, presetLayout.execute()];
              case 1:
                _b.sent();
                hasPresetCallback === null || hasPresetCallback === void 0 ? void 0 : hasPresetCallback();
                resolve();
                return [2, true];
            }
          });
        });
      });
    };
    LayoutController3.prototype.layoutWithWorker = function(data, success) {
      var _this = this;
      var _a2 = this, layoutCfg = _a2.layoutCfg, graph = _a2.graph;
      var worker = this.getWorker();
      var workerData = this.workerData;
      if (!worker) {
        return false;
      }
      workerData.requestId = null;
      workerData.requestId2 = null;
      workerData.currentTick = null;
      workerData.currentTickData = null;
      graph.emit("beforelayout");
      var start = Promise.resolve();
      var hasLayout = false;
      if (layoutCfg.type) {
        hasLayout = true;
        start = start.then(function() {
          return _this.runWebworker(worker, data, layoutCfg);
        });
      } else if (layoutCfg.pipes) {
        hasLayout = true;
        var _loop_1 = function _loop_12(cfg2) {
          start = start.then(function() {
            return _this.runWebworker(worker, data, cfg2);
          });
        };
        for (var _i2 = 0, _b = layoutCfg.pipes; _i2 < _b.length; _i2++) {
          var cfg = _b[_i2];
          _loop_1(cfg);
        }
      }
      if (hasLayout) {
        start.then(function() {
          if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd();
          success === null || success === void 0 ? void 0 : success();
        }).catch(function(error) {
          console.error("layout failed", error);
        });
      }
      return true;
    };
    LayoutController3.prototype.runWebworker = function(worker, allData, layoutCfg) {
      var _this = this;
      var isGPU = this.isGPU;
      var data = this.filterLayoutData(allData, layoutCfg);
      var nodes = data.nodes, edges = data.edges;
      var offScreenCanvas = document.createElement("canvas");
      var gpuWorkerAbility = isGPU && typeof window !== "undefined" && // eslint-disable-next-line @typescript-eslint/dot-notation
      window.navigator && !navigator["gpu"] && // WebGPU 还不支持 OffscreenCanvas
      "OffscreenCanvas" in window && "transferControlToOffscreen" in offScreenCanvas;
      var filteredLayoutCfg = filterObject(layoutCfg, function(value) {
        return typeof value !== "function";
      });
      if (!gpuWorkerAbility) {
        worker.postMessage({
          type: LAYOUT_MESSAGE.RUN,
          nodes,
          edges,
          layoutCfg: filteredLayoutCfg
        });
      } else {
        var offscreen = offScreenCanvas.transferControlToOffscreen();
        filteredLayoutCfg.type = "".concat(filteredLayoutCfg.type, "-gpu");
        worker.postMessage({
          type: LAYOUT_MESSAGE.GPURUN,
          nodes,
          edges,
          layoutCfg: filteredLayoutCfg,
          canvas: offscreen
        }, [offscreen]);
      }
      return new Promise(function(reslove, reject) {
        worker.onmessage = function(event) {
          _this.handleWorkerMessage(reslove, reject, event, data, layoutCfg);
        };
      });
    };
    LayoutController3.prototype.handleWorkerMessage = function(reslove, reject, event, data, layoutCfg) {
      var _a2 = this, graph = _a2.graph, workerData = _a2.workerData;
      var eventData = event.data;
      var type = eventData.type;
      var onTick = function onTick2() {
        if (layoutCfg.onTick) {
          layoutCfg.onTick();
        }
      };
      switch (type) {
        case LAYOUT_MESSAGE.TICK:
          workerData.currentTick = eventData.currentTick;
          workerData.currentTickData = eventData;
          if (!workerData.requestId) {
            workerData.requestId = helper.requestAnimationFrame(function requestId() {
              updateLayoutPosition(data, eventData);
              graph.refreshPositions();
              onTick();
              if (eventData.currentTick === eventData.totalTicks) {
                reslove();
              } else if (workerData.currentTick === eventData.totalTicks) {
                workerData.requestId2 = helper.requestAnimationFrame(function requestId2() {
                  updateLayoutPosition(data, workerData.currentTickData);
                  graph.refreshPositions();
                  workerData.requestId2 = null;
                  onTick();
                  reslove();
                });
              }
              workerData.requestId = null;
            });
          }
          break;
        case LAYOUT_MESSAGE.END:
          if (workerData.currentTick == null) {
            updateLayoutPosition(data, eventData);
            reslove();
          }
          break;
        case LAYOUT_MESSAGE.GPUEND:
          if (workerData.currentTick == null) {
            updateGPUWorkerLayoutPosition(data, eventData);
            reslove();
          }
          break;
        case LAYOUT_MESSAGE.ERROR:
          console.warn("Web-Worker layout error!", eventData.message);
          reject();
          break;
        default:
          reject();
          break;
      }
    };
    LayoutController3.prototype.updateLayoutCfg = function(cfg) {
      var _this = this;
      var _a2 = this, graph = _a2.graph, layoutMethods = _a2.layoutMethods;
      if (!graph || graph.get("destroyed")) return;
      var disableTriggerLayout = cfg.disableTriggerLayout, otherCfg = __rest(cfg, ["disableTriggerLayout"]);
      var layoutCfg = mix({}, this.layoutCfg, otherCfg);
      this.layoutCfg = layoutCfg;
      if (disableTriggerLayout) {
        return;
      }
      if (!(layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length)) {
        this.layout();
        return;
      }
      this.data = this.setDataFromGraph();
      this.stopWorker();
      if (otherCfg.workerEnabled && this.layoutWithWorker(this.data, null)) {
        return;
      }
      graph.emit("beforelayout");
      var start = Promise.resolve();
      var hasLayout = false;
      if ((layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length) === 1) {
        hasLayout = true;
        start = start.then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.updateLayoutMethod(layoutMethods[0], layoutCfg)];
                case 1:
                  return [2, _a3.sent()];
              }
            });
          });
        });
      } else if (layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length) {
        hasLayout = true;
        layoutMethods.forEach(function(layoutMethod, index2) {
          var currentCfg = layoutCfg.pipes[index2];
          start = start.then(function() {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    return [4, this.updateLayoutMethod(layoutMethod, currentCfg)];
                  case 1:
                    return [2, _a3.sent()];
                }
              });
            });
          });
        });
      }
      if (hasLayout) {
        start.then(function() {
          if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd();
        }).catch(function(error) {
          console.warn("layout failed", error);
        });
      }
    };
    LayoutController3.prototype.adjustPipesBox = function(data, adjust) {
      var _this = this;
      return new Promise(function(resolve) {
        var nodes = data.nodes;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
          resolve();
        }
        if (!LAYOUT_PIPES_ADJUST_NAMES.includes(adjust)) {
          console.warn("The adjust type ".concat(adjust, " is not supported yet, please assign it with 'force', 'grid', or 'circular'."));
          resolve();
        }
        var layoutCfg = {
          center: _this.layoutCfg.center,
          nodeSize: function nodeSize(d2) {
            return Math.max(d2.height, d2.width);
          },
          preventOverlap: true,
          onLayoutEnd: function onLayoutEnd() {
          }
        };
        var _a2 = _this.getLayoutBBox(nodes), groupNodes = _a2.groupNodes, layoutNodes = _a2.layoutNodes;
        var preNodes = clone_default(layoutNodes);
        layoutCfg.onLayoutEnd = function() {
          layoutNodes === null || layoutNodes === void 0 ? void 0 : layoutNodes.forEach(function(ele, index2) {
            var _a3, _b, _c;
            var dx = ele.x - ((_a3 = preNodes[index2]) === null || _a3 === void 0 ? void 0 : _a3.x);
            var dy = ele.y - ((_b = preNodes[index2]) === null || _b === void 0 ? void 0 : _b.y);
            (_c = groupNodes[index2]) === null || _c === void 0 ? void 0 : _c.forEach(function(n2) {
              n2.x += dx;
              n2.y += dy;
            });
          });
          resolve();
        };
        var layoutMethod = new import_lib.Layouts[adjust](layoutCfg);
        layoutMethod.layout({
          nodes: layoutNodes
        });
      });
    };
    LayoutController3.prototype.destroy = function() {
      this.destoryLayoutMethods();
      var worker = this.worker;
      if (worker) {
        worker.terminate();
        this.worker = null;
      }
      this.destroyed = true;
      this.graph.set("layout", void 0);
      this.layoutCfg = void 0;
      this.layoutType = void 0;
      this.layoutMethods = void 0;
      this.graph = null;
    };
    return LayoutController3;
  }(layout_default)
);
var layout_default2 = LayoutController2;
function updateLayoutPosition(data, layoutData) {
  var nodes = data.nodes;
  var layoutNodes = layoutData.nodes;
  var nodeLength = nodes.length;
  for (var i2 = 0; i2 < nodeLength; i2++) {
    var node = nodes[i2];
    node.x = layoutNodes[i2].x;
    node.y = layoutNodes[i2].y;
  }
}
function filterObject(collection, callback) {
  var result = {};
  if (collection && _typeof7(collection) === "object") {
    Object.keys(collection).forEach(function(key) {
      if (collection.hasOwnProperty(key) && callback(collection[key])) {
        result[key] = collection[key];
      }
    });
    return result;
  }
  return collection;
}
function updateGPUWorkerLayoutPosition(data, layoutData) {
  var nodes = data.nodes;
  var vertexEdgeData = layoutData.vertexEdgeData;
  var nodeLength = nodes.length;
  for (var i2 = 0; i2 < nodeLength; i2++) {
    var node = nodes[i2];
    var x4 = vertexEdgeData[4 * i2];
    var y4 = vertexEdgeData[4 * i2 + 1];
    node.x = x4;
    node.y = y4;
  }
}
function addLayoutOrder(data, order) {
  var _a2;
  if (!((_a2 = data === null || data === void 0 ? void 0 : data.nodes) === null || _a2 === void 0 ? void 0 : _a2.length)) {
    return;
  }
  var nodes = data.nodes;
  nodes.forEach(function(node) {
    node.layoutOrder = order;
  });
}
function hasGPUVersion(layoutName) {
  return GPU_LAYOUT_NAMES.includes(layoutName);
}
function getGPUEnabled(layoutCfg, layoutType) {
  var type = layoutType;
  if (layoutType && layoutType.split("-")[1] === "gpu") {
    type = layoutType.split("-")[0];
    layoutCfg.gpuEnabled = true;
  }
  var enableGPU = false;
  if (layoutCfg.gpuEnabled) {
    enableGPU = true;
    if (!gpuDetector().webgl) {
      console.warn("Your browser does not support webGL or GPGPU. The layout will run in CPU.");
      enableGPU = false;
    }
  }
  if (enableGPU && !hasGPUVersion(type)) {
    console.warn("The '".concat(type, "' layout does not support GPU calculation for now, it will run in CPU."));
    enableGPU = false;
  }
  return enableGPU;
}

// node_modules/@antv/g6-pc/es/graph/graph.js
var transform10 = ext_exports.transform;
var SVG = "svg";
var Graph3 = (
  /** @class */
  function(_super) {
    __extends(Graph4, _super);
    function Graph4(cfg) {
      var _this = _super.call(this, cfg) || this;
      var defaultNode = _this.get("defaultNode");
      if (!defaultNode) {
        _this.set("defaultNode", {
          type: "circle"
        });
      }
      if (!defaultNode.type) {
        defaultNode.type = "circle";
        _this.set("defaultNode", defaultNode);
      }
      _this.destroyed = false;
      return _this;
    }
    Graph4.prototype.initLayoutController = function() {
      var layoutController = new layout_default2(this);
      this.set({
        layoutController
      });
    };
    Graph4.prototype.initEventController = function() {
      var eventController = new event_default2(this);
      this.set({
        eventController
      });
    };
    Graph4.prototype.initCanvas = function() {
      var container = this.get("container");
      if (typeof container === "string") {
        container = document.getElementById(container);
        this.set("container", container);
      }
      if (!container) {
        throw new Error("invalid container");
      }
      var clientWidth = container.clientWidth, clientHeight = container.clientHeight;
      var width = this.get("width") || clientWidth;
      var height = this.get("height") || clientHeight;
      if (!this.get("width") && !this.get("height")) {
        this.set("width", clientWidth);
        this.set("height", clientHeight);
      }
      var renderer = this.get("renderer");
      var canvas;
      if (renderer === SVG) {
        canvas = new canvas_default3({
          container,
          width,
          height
        });
      } else {
        var canvasCfg = {
          container,
          width,
          height
        };
        var pixelRatio = this.get("pixelRatio");
        if (pixelRatio) {
          canvasCfg.pixelRatio = pixelRatio;
          window.devicePixelRatio = pixelRatio;
        }
        canvas = new canvas_default2(canvasCfg);
      }
      this.set("canvas", canvas);
    };
    Graph4.prototype.initPlugins = function() {
      var self2 = this;
      each_default(self2.get("plugins"), function(plugin) {
        if (!plugin.destroyed && plugin.initPlugin) {
          plugin.initPlugin(self2);
        }
      });
    };
    Graph4.prototype.downloadImageWatermark = function(watermarker, context, width, height) {
      return __awaiter(this, void 0, void 0, function() {
        var watermarkStr, watermarkbase64, img;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              watermarkStr = watermarker.style.backgroundImage;
              watermarkbase64 = watermarkStr.slice(5, watermarkStr.length - 2);
              img = new Image();
              img.src = watermarkbase64;
              return [4, new Promise(function(resolve) {
                img.onload = function() {
                  var pat = context.createPattern(img, "repeat");
                  context.rect(0, 0, width, height);
                  context.fillStyle = pat;
                  context.fill();
                  resolve("");
                };
              })];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Graph4.prototype.asyncToDataUrl = function(type, backgroundColor, callback, widths, heights, vCanvasEl) {
      var _this = this;
      var watermarker = document.querySelector(".g6-graph-watermarker");
      var canvas = this.get("canvas");
      var renderer = canvas.getRenderer();
      var canvasDom = vCanvasEl || canvas.get("el");
      var dataURL = "";
      if (!type) type = "image/png";
      setTimeout(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var cloneNode, svgDocType, svgDoc, svgData, imageData, context, width, height, compositeOperation, pixelRatio;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!(renderer === "svg")) return [3, 1];
                cloneNode = canvasDom.cloneNode(true);
                svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
                svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
                svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
                svgData = new XMLSerializer().serializeToString(svgDoc);
                dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
                return [3, 4];
              case 1:
                imageData = void 0;
                context = canvasDom.getContext("2d");
                width = widths || this.get("width");
                height = heights || this.get("height");
                compositeOperation = void 0;
                if (!watermarker) return [3, 3];
                return [4, this.downloadImageWatermark(watermarker, context, width, height)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (backgroundColor) {
                  pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio : 1;
                  try {
                    imageData = context.getImageData(0, 0, width * pixelRatio, height * pixelRatio);
                    compositeOperation = context.globalCompositeOperation;
                    context.globalCompositeOperation = "destination-over";
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, width, height);
                  } catch (error) {
                    console.error("Download image failed. Out of memory at ImageData creation");
                  }
                }
                dataURL = canvasDom.toDataURL(type);
                if (backgroundColor) {
                  context.clearRect(0, 0, width, height);
                  context.putImageData(imageData, 0, 0);
                  context.globalCompositeOperation = compositeOperation;
                }
                _a2.label = 4;
              case 4:
                if (callback) callback(dataURL);
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, 16);
    };
    Graph4.prototype.toDataURL = function(type, backgroundColor) {
      var canvas = this.get("canvas");
      var renderer = canvas.getRenderer();
      var canvasDom = canvas.get("el");
      if (!type) type = "image/png";
      var dataURL = "";
      if (renderer === "svg") {
        var cloneNode = canvasDom.cloneNode(true);
        var svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
        var svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
        svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
        var svgData = new XMLSerializer().serializeToString(svgDoc);
        dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
      } else {
        var imageData = void 0;
        var context = canvasDom.getContext("2d");
        var width = Math.max(this.get("width"), 500);
        var height = Math.max(this.get("height"), 500);
        var compositeOperation = void 0;
        if (backgroundColor) {
          var pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
          try {
            imageData = context.getImageData(0, 0, width * pixelRatio, height * pixelRatio);
            compositeOperation = context.globalCompositeOperation;
            context.globalCompositeOperation = "destination-over";
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, width, height);
          } catch (error) {
            console.error("Download image failed. Out of memory at ImageData creation");
          }
        }
        dataURL = canvasDom.toDataURL(type);
        if (backgroundColor) {
          context.clearRect(0, 0, width, height);
          context.putImageData(imageData, 0, 0);
          context.globalCompositeOperation = compositeOperation;
        }
      }
      return dataURL;
    };
    Graph4.prototype.toFullDataURL = function(callback, type, imageConfig) {
      var bbox = this.get("group").getCanvasBBox();
      var height = bbox.height;
      var width = bbox.width;
      var renderer = this.get("renderer");
      var vContainerDOM = createDom2('<div id="virtual-image"></div>');
      var backgroundColor = imageConfig ? imageConfig.backgroundColor : void 0;
      var padding = imageConfig ? imageConfig.padding : void 0;
      if (!padding) padding = [0, 0, 0, 0];
      else if (is_number_default(padding)) padding = [padding, padding, padding, padding];
      var vHeight = height + padding[0] + padding[2];
      var vWidth = width + padding[1] + padding[3];
      var canvasOptions = {
        container: vContainerDOM,
        height: vHeight,
        width: vWidth,
        quickHit: true
      };
      var vCanvas = renderer === "svg" ? new canvas_default3(canvasOptions) : new canvas_default2(canvasOptions);
      var group = this.get("group");
      var vGroup = group.clone();
      var matrix = clone_default(vGroup.getMatrix());
      if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var centerX = (bbox.maxX + bbox.minX) / 2;
      var centerY = (bbox.maxY + bbox.minY) / 2;
      matrix = transform10(matrix, [["t", -centerX, -centerY], ["t", width / 2 + padding[3], height / 2 + padding[0]]]);
      vGroup.resetMatrix();
      vGroup.setMatrix(matrix);
      vCanvas.add(vGroup);
      var vCanvasEl = vCanvas.get("el");
      var dataURL = "";
      if (!type) type = "image/png";
      setTimeout(function() {
        if (renderer === "svg") {
          var cloneNode = vCanvasEl.cloneNode(true);
          var svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
          var svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
          svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
          var svgData = new XMLSerializer().serializeToString(svgDoc);
          dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
        } else {
          var imageData = void 0;
          var context = vCanvasEl.getContext("2d");
          var compositeOperation = void 0;
          if (backgroundColor) {
            var pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio : 1;
            try {
              imageData = context.getImageData(0, 0, vWidth * pixelRatio, vHeight * pixelRatio);
              compositeOperation = context.globalCompositeOperation;
              context.globalCompositeOperation = "destination-over";
              context.fillStyle = backgroundColor;
              context.fillRect(0, 0, vWidth, vHeight);
            } catch (error) {
              console.error("Download image failed. Out of memory at ImageData creation");
            }
          }
          dataURL = vCanvasEl.toDataURL(type);
          if (backgroundColor) {
            context.clearRect(0, 0, vWidth, vHeight);
            context.putImageData(imageData, 0, 0);
            context.globalCompositeOperation = compositeOperation;
          }
        }
        if (callback) callback(dataURL);
      }, 16);
    };
    Graph4.prototype.downloadFullImage = function(name, type, imageConfig) {
      var _this = this;
      var bbox = this.get("group").getCanvasBBox();
      var height = bbox.height;
      var width = bbox.width;
      var renderer = this.get("renderer");
      var vContainerDOM = createDom2('<div id="virtual-image"></div>');
      var watermarker = document.querySelector(".g6-graph-watermarker");
      var backgroundColor = imageConfig ? imageConfig.backgroundColor : void 0;
      var padding = imageConfig ? imageConfig.padding : void 0;
      if (!padding) padding = [0, 0, 0, 0];
      else if (is_number_default(padding)) padding = [padding, padding, padding, padding];
      var vHeight = height + padding[0] + padding[2];
      var vWidth = width + padding[1] + padding[3];
      if (watermarker) {
        var _a2 = this.get("graphWaterMarker").cfg || {}, wmWidth = _a2.width, wmHeight = _a2.height;
        vHeight = Math.ceil(vHeight / wmHeight) * wmHeight;
        vWidth = Math.ceil(vWidth / wmWidth) * wmWidth;
      }
      var canvasOptions = {
        container: vContainerDOM,
        height: vHeight,
        width: vWidth
      };
      var vCanvas = renderer === "svg" ? new canvas_default3(canvasOptions) : new canvas_default2(canvasOptions);
      var group = this.get("group");
      var vGroup = cloneGElement(group);
      var matrix = clone_default(vGroup.getMatrix());
      if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var centerX = (bbox.maxX + bbox.minX) / 2;
      var centerY = (bbox.maxY + bbox.minY) / 2;
      matrix = transform10(matrix, [["t", -centerX, -centerY], ["t", width / 2 + padding[3], height / 2 + padding[0]]]);
      vGroup.resetMatrix();
      vGroup.setMatrix(matrix);
      vCanvas.add(vGroup);
      var vCanvasEl = vCanvas.get("el");
      if (!type) type = "image/png";
      this.asyncToDataUrl(type, backgroundColor, function(dataURL) {
        var link = document.createElement("a");
        var fileName = (name || "graph") + (renderer === "svg" ? ".svg" : ".".concat(type.split("/")[1]));
        _this.dataURLToImage(dataURL, renderer, link, fileName);
        var e8 = document.createEvent("MouseEvents");
        e8.initEvent("click", false, false);
        link.dispatchEvent(e8);
      }, vWidth, vHeight, vCanvasEl);
    };
    Graph4.prototype.downloadImage = function(name, type, backgroundColor) {
      var _this = this;
      var self2 = this;
      self2.stopAnimate();
      var canvas = self2.get("canvas");
      var renderer = canvas.getRenderer();
      if (!type) type = "image/png";
      var fileName = (name || "graph") + (renderer === "svg" ? ".svg" : ".".concat(type.split("/")[1]));
      var link = document.createElement("a");
      self2.asyncToDataUrl(type, backgroundColor, function(dataURL) {
        _this.dataURLToImage(dataURL, renderer, link, fileName);
        var e8 = document.createEvent("MouseEvents");
        e8.initEvent("click", false, false);
        link.dispatchEvent(e8);
      });
    };
    Graph4.prototype.dataURLToImage = function(dataURL, renderer, link, fileName) {
      if (!dataURL || dataURL === "data:") {
        console.error("Download image failed. The graph is too large or there is invalid attribute values in graph items");
        return;
      }
      if (typeof window !== "undefined") {
        if (window.Blob && window.URL && renderer !== "svg") {
          var arr = dataURL.split(",");
          var mime = "";
          if (arr && arr.length > 0) {
            var match = arr[0].match(/:(.*?);/);
            if (match && match.length >= 2) mime = match[1];
          }
          var bstr = atob(arr[1]);
          var n2 = bstr.length;
          var u8arr = new Uint8Array(n2);
          while (n2--) {
            u8arr[n2] = bstr.charCodeAt(n2);
          }
          var blobObj_1 = new Blob([u8arr], {
            type: mime
          });
          if (window.navigator.msSaveBlob) {
            window.navigator.msSaveBlob(blobObj_1, fileName);
          } else {
            link.addEventListener("click", function() {
              link.download = fileName;
              link.href = window.URL.createObjectURL(blobObj_1);
            });
          }
        } else {
          link.addEventListener("click", function() {
            link.download = fileName;
            link.href = dataURL;
          });
        }
      }
    };
    Graph4.prototype.addPlugin = function(plugin) {
      var self2 = this;
      if (plugin.destroyed) {
        return;
      }
      self2.get("plugins").push(plugin);
      plugin.initPlugin(self2);
    };
    Graph4.prototype.removePlugin = function(plugin) {
      var plugins = this.get("plugins");
      var index2 = plugins.indexOf(plugin);
      if (index2 >= 0) {
        plugin.destroyPlugin();
        plugins.splice(index2, 1);
      }
    };
    Graph4.prototype.setImageWaterMarker = function(imgURL, config) {
      if (imgURL === void 0) {
        imgURL = global_default2.waterMarkerImage;
      }
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      if (!container.style.position) {
        container.style.position = "relative";
      }
      var canvas = this.get("graphWaterMarker");
      var waterMarkerConfig = deep_mix_default({}, global_default2.imageWaterMarkerConfig, config);
      var width = waterMarkerConfig.width, height = waterMarkerConfig.height, compatible = waterMarkerConfig.compatible, image = waterMarkerConfig.image;
      if (!imgURL) {
        var dom = compatible ? container : document.querySelector(".g6-graph-watermarker");
        if (dom) dom.style.cssText = void 0;
        if (canvas) canvas.clear();
        return;
      }
      if (!canvas) {
        var canvasCfg = {
          container,
          width,
          height,
          capture: false
        };
        var pixelRatio = this.get("pixelRatio");
        if (pixelRatio) {
          canvasCfg.pixelRatio = pixelRatio;
          window.devicePixelRatio = pixelRatio;
        }
        canvas = new canvas_default2(canvasCfg);
        this.set("graphWaterMarker", canvas);
      } else {
        canvas.clear();
      }
      canvas.get("el").style.display = "none";
      var ctx2 = canvas.get("context");
      var rotate9 = image.rotate, x4 = image.x, y4 = image.y;
      ctx2.rotate(-rotate9 * Math.PI / 180);
      var img = new Image();
      img.crossOrigin = "anonymous";
      img.src = imgURL;
      img.onload = function() {
        ctx2.drawImage(img, x4, y4, image.width, image.height);
        ctx2.rotate(rotate9 * Math.PI / 180);
        if (!compatible) {
          var box2 = document.querySelector(".g6-graph-watermarker");
          if (!box2) {
            box2 = document.createElement("div");
            box2.className = "g6-graph-watermarker";
          }
          box2.className = "g6-graph-watermarker";
          if (!canvas.destroyed) {
            box2.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;z-index:-1;");
            container.appendChild(box2);
          }
        } else {
          container.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;");
        }
      };
    };
    Graph4.prototype.setTextWaterMarker = function(texts, config) {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      if (!container.style.position) {
        container.style.position = "relative";
      }
      var canvas = this.get("graphWaterMarker");
      var waterMarkerConfig = deep_mix_default({}, global_default2.textWaterMarkerConfig, config);
      var width = waterMarkerConfig.width, height = waterMarkerConfig.height, compatible = waterMarkerConfig.compatible, text = waterMarkerConfig.text;
      if (!(texts === null || texts === void 0 ? void 0 : texts.length)) {
        var dom = compatible ? container : document.querySelector(".g6-graph-watermarker");
        if (dom) dom.style.cssText = void 0;
        if (canvas) canvas.clear();
        return;
      }
      if (!canvas) {
        var canvasCfg = {
          container,
          width,
          height,
          capture: false
        };
        var pixelRatio = this.get("pixelRatio");
        if (pixelRatio) {
          canvasCfg.pixelRatio = pixelRatio;
          window.devicePixelRatio = pixelRatio;
        }
        canvas = new canvas_default2(canvasCfg);
        this.set("graphWaterMarker", canvas);
      } else {
        canvas.clear();
      }
      canvas.get("el").style.display = "none";
      var ctx2 = canvas.get("context");
      var rotate9 = text.rotate, fill = text.fill, fontFamily = text.fontFamily, fontSize = text.fontSize, baseline = text.baseline, x4 = text.x, y4 = text.y, lineHeight = text.lineHeight;
      ctx2.rotate(-rotate9 * Math.PI / 180);
      ctx2.font = "".concat(fontSize, "px ").concat(fontFamily);
      ctx2.fillStyle = fill;
      ctx2.textBaseline = baseline;
      var displayTexts = is_string_default(texts) ? [texts] : texts;
      for (var i2 = displayTexts.length - 1; i2 >= 0; i2--) {
        ctx2.fillText(displayTexts[i2], x4, y4 + i2 * lineHeight);
      }
      ctx2.rotate(rotate9 * Math.PI / 180);
      if (!compatible) {
        var box2 = document.querySelector(".g6-graph-watermarker");
        if (!box2) {
          box2 = document.createElement("div");
          box2.className = "g6-graph-watermarker";
        }
        box2.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;z-index:99;");
        container.appendChild(box2);
      } else {
        container.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;");
      }
    };
    Graph4.prototype.destroy = function() {
      var _a2, _b, _c, _d;
      each_default(this.get("plugins"), function(plugin) {
        plugin.destroyPlugin();
      });
      var tooltipDOMs = this.get("tooltips");
      if (tooltipDOMs) {
        for (var i2 = 0; i2 < tooltipDOMs.length; i2++) {
          var container = tooltipDOMs[i2];
          if (!container) continue;
          var parent_1 = container.parentElement;
          if (!parent_1) continue;
          parent_1.removeChild(container);
        }
      }
      (_a2 = this.get("eventController")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.get("layoutController")) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.get("graphWaterMarker")) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = document.querySelector(".g6-graph-watermarker")) === null || _d === void 0 ? void 0 : _d.remove();
      _super.prototype.destroy.call(this);
    };
    return Graph4;
  }(graph_default)
);
var graph_default2 = Graph3;

// node_modules/@antv/g6-pc/es/graph/tree-graph.js
var import_hierarchy2 = __toESM(require_lib2());
init_esm();

// node_modules/@antv/g6-pc/es/util/deepClone.js
function _typeof8(o2) {
  "@babel/helpers - typeof";
  return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof8(o2);
}
function traverseClone(obj, hash) {
  if (hash === void 0) {
    hash = /* @__PURE__ */ new WeakMap();
  }
  if (obj === null) return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if (_typeof8(obj) !== "object") return obj;
  if (hash.get(obj)) return hash.get(obj);
  var cloneObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloneObj);
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && obj[key] !== void 0) {
      cloneObj[key] = traverseClone(obj[key], hash);
    }
  }
  return cloneObj;
}
function deepClone(data) {
  try {
    return structuredClone(data);
  } catch (err) {
    return traverseClone(data);
  }
}

// node_modules/@antv/g6-pc/es/graph/tree-graph.js
var radialLayout4 = util_default2.radialLayout;
var traverseTree4 = util_default2.traverseTree;
var TreeGraph = (
  /** @class */
  function(_super) {
    __extends(TreeGraph2, _super);
    function TreeGraph2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.layoutAnimating = false;
      _this.set("removeList", []);
      _this.set("layoutMethod", _this.getLayout());
      return _this;
    }
    TreeGraph2.prototype.getLayout = function() {
      var layout2 = this.get("layout");
      if (!layout2) {
        return null;
      }
      if (typeof layout2 === "function") {
        return layout2;
      }
      if (!layout2.type) {
        layout2.type = "dendrogram";
      }
      if (!layout2.direction) {
        layout2.direction = layout2.type === "indented" ? "LR" : "TB";
      }
      if (layout2.radial) {
        return function(data) {
          var layoutData = import_hierarchy2.default[layout2.type](data, layout2);
          radialLayout4(layoutData);
          return layoutData;
        };
      }
      return function(data) {
        return import_hierarchy2.default[layout2.type](data, layout2);
      };
    };
    TreeGraph2.indexOfChild = function(children, id) {
      var index2 = -1;
      each_default(children, function(former, i2) {
        if (id === former.id) {
          index2 = i2;
          return false;
        }
      });
      return index2;
    };
    TreeGraph2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg.animate = true;
      return cfg;
    };
    TreeGraph2.prototype.innerAddChild = function(treeData, parent, animate) {
      var self2 = this;
      var model = treeData.data;
      if (model) {
        model.x = treeData.x;
        model.y = treeData.y;
        model.depth = treeData.depth;
      }
      var node = self2.addItem("node", model, false);
      if (parent) {
        node.set("parent", parent);
        if (animate) {
          var origin_1 = parent.get("originAttrs");
          if (origin_1) {
            node.set("originAttrs", origin_1);
          } else {
            var parentModel = parent.getModel();
            node.set("originAttrs", {
              x: parentModel.x,
              y: parentModel.y
            });
          }
        }
        var childrenList = parent.get("children");
        if (!childrenList) {
          parent.set("children", [node]);
        } else {
          childrenList.push(node);
        }
        self2.addItem("edge", {
          source: parent.get("id"),
          target: node.get("id"),
          id: "".concat(parent.get("id"), ":").concat(node.get("id"))
        }, false);
      }
      each_default(treeData.children || [], function(child) {
        self2.innerAddChild(child, node, animate);
      });
      self2.emit("afteraddchild", {
        item: node,
        parent
      });
      return node;
    };
    TreeGraph2.prototype.innerUpdateChild = function(data, parent, animate) {
      var self2 = this;
      var current = self2.findById(data.id);
      if (!current) {
        self2.innerAddChild(data, parent, animate);
        return;
      }
      each_default(data.children || [], function(child2) {
        self2.innerUpdateChild(child2, current, animate);
      });
      var children = current.get("children");
      if (children) {
        var len6 = children.length;
        if (len6 > 0) {
          for (var i2 = children.length - 1; i2 >= 0; i2--) {
            var child = children[i2].getModel();
            if (TreeGraph2.indexOfChild(data.children || [], child.id) === -1) {
              self2.innerRemoveChild(child.id, {
                x: data.x,
                y: data.y
              }, animate);
              children.splice(i2, 1);
            }
          }
        }
      }
      var oriX;
      var oriY;
      if (current.get("originAttrs")) {
        oriX = current.get("originAttrs").x;
        oriY = current.get("originAttrs").y;
      }
      var model = current.getModel();
      if (animate) {
        current.set("originAttrs", {
          x: model.x,
          y: model.y
        });
      }
      current.set("model", Object.assign(model, data.data));
      if (oriX !== data.x || oriY !== data.y) {
        current.updatePosition({
          x: data.x,
          y: data.y
        });
      }
    };
    TreeGraph2.prototype.innerRemoveChild = function(id, to2, animate) {
      var self2 = this;
      var node = self2.findById(id);
      if (!node) {
        return;
      }
      each_default(node.get("children"), function(child) {
        self2.innerRemoveChild(child.getModel().id, to2, animate);
      });
      if (animate) {
        var model = node.getModel();
        node.set("to", to2);
        node.set("originAttrs", {
          x: model.x,
          y: model.y
        });
        self2.get("removeList").push(node);
      } else {
        self2.removeItem(node, false);
      }
    };
    TreeGraph2.prototype.changeData = function(data, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      this.getNodes().map(function(node) {
        return self2.clearItemStates(node);
      });
      this.getEdges().map(function(edge) {
        return self2.clearItemStates(edge);
      });
      if (stack && this.get("enabledStack")) {
        this.pushStack("changedata", {
          before: self2.get("originData"),
          after: data || self2.get("data")
        });
      }
      if (data) {
        self2.data(data);
        self2.render(false);
      } else {
        self2.layout(this.get("fitView"));
      }
    };
    TreeGraph2.prototype.changeLayout = function(layout2) {
      console.warn("Please call updateLayout instead of changeLayout. changeLayout will be discarded soon");
      var self2 = this;
      self2.updateLayout(layout2);
    };
    TreeGraph2.prototype.updateLayout = function(layout2, align, alignPoint, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      if (!layout2) {
        console.warn("layout cannot be null");
        return;
      }
      if (stack && this.get("enabledStack")) {
        this.pushStack("layout", {
          before: self2.get("layout"),
          after: layout2
        });
      }
      self2.set("layout", layout2);
      self2.set("layoutMethod", self2.getLayout());
      self2.layout();
      if (align) {
        var toPoint = alignPoint;
        if (!toPoint) {
          if (align === "begin") toPoint = {
            x: 0,
            y: 0
          };
          else toPoint = {
            x: this.getWidth() / 2,
            y: this.getHeight() / 2
          };
        }
        toPoint = this.getPointByCanvas(toPoint.x, toPoint.y);
        var matrix = this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        toPoint.x = toPoint.x * matrix[0] + matrix[6];
        toPoint.y = toPoint.y * matrix[0] + matrix[7];
        var _a2 = this.getGroup().getCanvasBBox(), minX = _a2.minX, maxX = _a2.maxX, minY = _a2.minY, maxY = _a2.maxY;
        var bboxPoint = {
          x: (minX + maxX) / 2,
          y: (minY + maxY) / 2
        };
        if (align === "begin") {
          bboxPoint.x = minX;
          bboxPoint.y = minY;
        }
        this.translate(toPoint.x - bboxPoint.x, toPoint.y - bboxPoint.y);
      }
    };
    TreeGraph2.prototype.refreshLayout = function(fitView) {
      console.warn("Please call layout instead of refreshLayout. refreshLayout will be discarded soon");
      var self2 = this;
      self2.layout(fitView);
    };
    TreeGraph2.prototype.layout = function(fitView) {
      var _this = this;
      var self2 = this;
      var data = self2.get("data");
      var layoutMethod = self2.get("layoutMethod");
      var layoutConfig = self2.get("layout");
      var layoutData = data;
      if (layoutConfig === null || layoutConfig === void 0 ? void 0 : layoutConfig.excludeInvisibles) {
        data = clone_default(self2.get("data"));
        var cacheChidMap_1 = {};
        traverseTree4(data, function(subTree) {
          var siblings = subTree.children;
          if (!(siblings === null || siblings === void 0 ? void 0 : siblings.length)) return true;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            var node = _this.findById(siblings[i2].id);
            var isHidden = node ? !node.isVisible() : siblings[i2].visible === false;
            if (isHidden) {
              cacheChidMap_1[subTree.id] = cacheChidMap_1[subTree.id] || [];
              cacheChidMap_1[subTree.id].push({
                idx: i2,
                child: siblings.splice(i2, 1)[0]
              });
            }
          }
        });
        layoutData = layoutMethod ? layoutMethod(data, self2.get("layout")) : data;
        traverseTree4(layoutData, function(subTree) {
          var cachedItems = cacheChidMap_1[subTree.id];
          if (cachedItems === null || cachedItems === void 0 ? void 0 : cachedItems.length) {
            for (var i2 = cachedItems.length - 1; i2 >= 0; i2--) {
              var _a2 = cachedItems[i2], idx = _a2.idx, child = _a2.child;
              subTree.children.splice(idx, 0, child);
            }
          }
        });
      } else {
        layoutData = layoutMethod ? layoutMethod(data, self2.get("layout")) : data;
      }
      var animate = self2.get("animate");
      self2.emit("beforerefreshlayout", {
        data,
        layoutData
      });
      self2.emit("beforelayout");
      self2.innerUpdateChild(layoutData, void 0, animate);
      if (fitView) {
        var viewController = self2.get("viewController");
        viewController.fitView();
      }
      if (!animate) {
        self2.refresh();
        self2.paint();
      } else {
        self2.layoutAnimate(layoutData);
      }
      self2.emit("afterrefreshlayout", {
        data,
        layoutData
      });
      self2.emit("afterlayout");
    };
    TreeGraph2.prototype.addChild = function(data, parent, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      self2.emit("beforeaddchild", {
        model: data,
        parent
      });
      if (!is_string_default(parent)) {
        parent = parent.get("id");
      }
      var parentData = self2.findDataById(parent);
      if (parentData) {
        if (!parentData.children) {
          parentData.children = [];
        }
        parentData.children.push(data);
        var parentItem = self2.findById(parent);
        parentItem.refresh();
        self2.changeData(void 0, stack);
      }
    };
    TreeGraph2.prototype.updateChildren = function(data, parentId, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var parentItem = self2.findById(parentId);
      if (!parentId || !parentItem) {
        console.warn("Update children failed! There is no node with id '".concat(parentId, "'"));
        return;
      }
      var parentModel = self2.findDataById(parentId);
      parentModel.children = data;
      parentItem.refresh();
      self2.changeData(void 0, stack);
    };
    TreeGraph2.prototype.updateChild = function(data, parentId, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      if (!parentId || !self2.findById(parentId)) {
        self2.changeData(data, stack);
        return;
      }
      var parentModel = self2.findDataById(parentId);
      var current = self2.findById(data.id);
      if (!parentModel.children) {
        parentModel.children = [];
      }
      if (!current) {
        parentModel.children.push(data);
      } else {
        var index2 = TreeGraph2.indexOfChild(parentModel.children, data.id);
        if (index2 > -1) parentModel.children[index2] = data;
      }
      var parentItem = self2.findById(parentId);
      parentItem === null || parentItem === void 0 ? void 0 : parentItem.refresh();
      self2.changeData(void 0, stack);
    };
    TreeGraph2.prototype.removeChild = function(id, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var node = self2.findById(id);
      var parent;
      if (!node) {
        parent = self2.getNodes().find(function(node2) {
          var children = node2.getModel().children || [];
          return !!children.find(function(child) {
            return child.id === id;
          });
        });
      } else {
        parent = node === null || node === void 0 ? void 0 : node.get("parent");
      }
      if (parent && !parent.destroyed) {
        var parentId = parent.get("id");
        var parentNode = self2.findDataById(parentId);
        var siblings = parentNode && parentNode.children || [];
        var index2 = TreeGraph2.indexOfChild(siblings, id);
        siblings.splice(index2, 1);
        parent.refresh();
      }
      self2.changeData(void 0, stack);
    };
    TreeGraph2.prototype.findDataById = function(id, parent) {
      var self2 = this;
      if (!parent) {
        parent = self2.get("data");
      }
      if (id === parent.id) {
        return parent;
      }
      var result = null;
      each_default(parent.children || [], function(child) {
        if (child.id === id) {
          result = child;
          return false;
        }
        result = self2.findDataById(id, child);
        if (result) {
          return false;
        }
      });
      return result;
    };
    TreeGraph2.prototype.layoutAnimate = function(data, onFrame) {
      var self2 = this;
      var animateCfg = this.get("animateCfg");
      self2.emit("beforeanimate", {
        data
      });
      self2.getEdges().forEach(function(edge) {
        var model = edge.get("model");
        if (!model.sourceAnchor) {
          model.sourceAnchor = edge.get("sourceAnchorIndex");
        }
      });
      this.get("canvas").animate(function(ratio) {
        traverseTree4(data, function(child) {
          var node = self2.findById(child.id);
          if (node) {
            var origin_2 = node.get("originAttrs");
            var model = node.get("model");
            if (!origin_2) {
              origin_2 = {
                x: model.x,
                y: model.y
              };
              node.set("originAttrs", origin_2);
            }
            if (onFrame) {
              var attrs = onFrame(node, ratio, origin_2, data);
              node.set("model", Object.assign(model, attrs));
            } else {
              model.x = origin_2.x + (child.x - origin_2.x) * ratio;
              model.y = origin_2.y + (child.y - origin_2.y) * ratio;
            }
          }
          return true;
        });
        each_default(self2.get("removeList"), function(node) {
          var model = node.getModel();
          var from = node.get("originAttrs");
          var to2 = node.get("to");
          model.x = from.x + (to2.x - from.x) * ratio;
          model.y = from.y + (to2.y - from.y) * ratio;
        });
        self2.refreshPositions();
      }, {
        duration: animateCfg.duration,
        easing: animateCfg.ease,
        callback: function callback() {
          each_default(self2.getNodes(), function(node) {
            node.set("originAttrs", null);
          });
          each_default(self2.get("removeList"), function(node) {
            self2.removeItem(node, false);
          });
          self2.set("removeList", []);
          if (animateCfg.callback) {
            animateCfg.callback();
          }
          self2.emit("afteranimate", {
            data
          });
        },
        delay: animateCfg.delay
      });
    };
    TreeGraph2.prototype.stopLayoutAnimate = function() {
      this.get("canvas").stopAnimate();
      this.emit("layoutanimateend", {
        data: this.get("data")
      });
      this.layoutAnimating = false;
    };
    TreeGraph2.prototype.isLayoutAnimating = function() {
      return this.layoutAnimating;
    };
    TreeGraph2.prototype.render = function(clearStack) {
      if (clearStack === void 0) {
        clearStack = true;
      }
      var self2 = this;
      var data = self2.get("data");
      if (!data || !is_object_default(data) || !Object.keys(data).length) {
        throw new Error("data must be defined first");
      }
      self2.clear();
      if (clearStack && this.get("enabledStack")) {
        this.clearStack();
      }
      self2.emit("beforerender");
      self2.layout(this.get("fitView"));
      self2.emit("afterrender");
    };
    TreeGraph2.prototype.save = function() {
      return this.get("data");
    };
    TreeGraph2.prototype.data = function(data) {
      _super.prototype.data.call(this, data);
      this.set("originData", deepClone(data));
    };
    return TreeGraph2;
  }(graph_default2)
);
var tree_graph_default = TreeGraph;

// node_modules/@antv/g6-plugin/es/base.js
init_esm();
var PluginBase = (
  /** @class */
  function() {
    function PluginBase2(cfgs) {
      this._cfgs = deep_mix_default(this.getDefaultCfgs(), cfgs);
      this._events = {};
      this.destroyed = false;
    }
    PluginBase2.prototype.getDefaultCfgs = function() {
      return {};
    };
    PluginBase2.prototype.initPlugin = function(graph) {
      var self2 = this;
      self2.set("graph", graph);
      var events = self2.getEvents();
      var bindEvents = {};
      each_default(events, function(v2, k2) {
        var event = wrap_behavior_default(self2, v2);
        bindEvents[k2] = event;
        graph.on(k2, event);
      });
      this._events = bindEvents;
      this.init();
    };
    PluginBase2.prototype.getEvents = function() {
      return {};
    };
    PluginBase2.prototype.get = function(key) {
      var _a2;
      return (_a2 = this._cfgs) === null || _a2 === void 0 ? void 0 : _a2[key];
    };
    PluginBase2.prototype.set = function(key, val) {
      this._cfgs[key] = val;
    };
    PluginBase2.prototype.destroy = function() {
    };
    PluginBase2.prototype.destroyPlugin = function() {
      this.destroy();
      var graph = this.get("graph");
      var events = this._events;
      each_default(events, function(v2, k2) {
        graph.off(k2, v2);
      });
      this._events = null;
      this._cfgs = null;
      this.destroyed = true;
    };
    return PluginBase2;
  }()
);
var base_default4 = PluginBase;

// node_modules/@antv/g6-plugin/es/grid/index.js
var __extends4 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var GRID_PNG = "url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHBhdHRlcm4gaWQ9ImdyaWQiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGggZD0iTSAwIDEwIEwgNDAgMTAgTSAxMCAwIEwgMTAgNDAgTSAwIDIwIEwgNDAgMjAgTSAyMCAwIEwgMjAgNDAgTSAwIDMwIEwgNDAgMzAgTSAzMCAwIEwgMzAgNDAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2UwZTBlMCIgb3BhY2l0eT0iMC4yIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNIDQwIDAgTCAwIDAgMCA0MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZTBlMGUwIiBzdHJva2Utd2lkdGg9IjEiLz48L3BhdHRlcm4+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JpZCkiLz48L3N2Zz4=)";
var Grid = (
  /** @class */
  function(_super) {
    __extends4(Grid3, _super);
    function Grid3(config) {
      return _super.call(this, config) || this;
    }
    Grid3.prototype.getDefaultCfgs = function() {
      return {
        img: GRID_PNG,
        follow: true
      };
    };
    Grid3.prototype.init = function() {
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var canvas = graph.get("canvas").get("el");
      var img = this.get("img") || GRID_PNG;
      if (!img.includes("url(")) {
        img = 'url("'.concat(img, '")');
      }
      var container = createDom2(`<div class='g6-grid-container' style="position:absolute;overflow:hidden;z-index: -1;"></div>`);
      var gridContainer = createDom2("<div\n        class='g6-grid'\n        style='position:absolute;\n        background-image: ".concat(img, ";\n        user-select: none\n        '></div>"));
      this.set("container", container);
      this.set("gridContainer", gridContainer);
      this.positionInit();
      container.appendChild(gridContainer);
      graphContainer.insertBefore(container, canvas);
    };
    Grid3.prototype.positionInit = function() {
      var graph = this.get("graph");
      var minZoom = graph.get("minZoom");
      var width = graph.get("width");
      var height = graph.get("height");
      modifyCSS(this.get("container"), {
        width: "".concat(width, "px"),
        height: "".concat(height, "px")
      });
      var gridContainerWidth = width * 80 / minZoom;
      var gridContainerHeight = height * 80 / minZoom;
      modifyCSS(this.get("gridContainer"), {
        width: "".concat(gridContainerWidth, "px"),
        height: "".concat(gridContainerHeight, "px"),
        left: "-".concat(gridContainerWidth / 2, "px"),
        top: "-".concat(gridContainerHeight / 2, "px")
      });
    };
    Grid3.prototype.getEvents = function() {
      return {
        viewportchange: "updateGrid"
      };
    };
    Grid3.prototype.updateGrid = function(param) {
      var gridContainer = this.get("gridContainer");
      var matrix = param.matrix;
      if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var isFollow = this.get("follow");
      var transform16 = "matrix(".concat(matrix[0], ", ").concat(matrix[1], ", ").concat(matrix[3], ", ").concat(matrix[4], ", ").concat(isFollow ? matrix[6] : "0", ", ").concat(isFollow ? matrix[7] : "0", ")");
      modifyCSS(gridContainer, {
        transform: transform16
      });
    };
    Grid3.prototype.getContainer = function() {
      return this.get("container");
    };
    Grid3.prototype.destroy = function() {
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var container = this.get("container");
      graphContainer.removeChild(container);
    };
    return Grid3;
  }(base_default4)
);
var grid_default = Grid;

// node_modules/@antv/g6-plugin/es/menu/index.js
init_esm();
var import_insert_css = __toESM(require_insert_css());
var __extends5 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
typeof document !== "undefined" && (0, import_insert_css.default)("\n  .g6-component-contextmenu {\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    background-color: rgba(255, 255, 255, 0.9);\n    padding: 10px 8px;\n    box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n  }\n  .g6-contextmenu-ul {\n    padding: 0;\n    margin: 0;\n    list-style: none;\n  }\n\n");
var Menu = (
  /** @class */
  function(_super) {
    __extends5(Menu3, _super);
    function Menu3(config) {
      return _super.call(this, config) || this;
    }
    Menu3.prototype.getDefaultCfgs = function() {
      return {
        offsetX: 6,
        offsetY: 6,
        handleMenuClick: void 0,
        // 指定菜单内容，function(e) {...}
        getContent: function getContent(e8) {
          return "\n          <ul class='g6-contextmenu-ul'>\n            <li>菜单项1</li>\n            <li>菜单项2</li>\n          </ul>\n        ";
        },
        shouldBegin: function shouldBegin2(e8) {
          return true;
        },
        // 菜单隐藏事件
        onHide: function onHide() {
          return true;
        },
        itemTypes: ["node", "edge", "combo"],
        trigger: "contextmenu"
      };
    };
    Menu3.prototype.getEvents = function() {
      if (this.get("trigger") === "click") {
        return {
          click: "onMenuShow",
          touchend: "onMenuShow"
        };
      }
      return {
        contextmenu: "onMenuShow"
      };
    };
    Menu3.prototype.init = function() {
      var className = this.get("className");
      var menu = createDom2("<div class=".concat(className || "g6-component-contextmenu", "></div>"));
      modifyCSS(menu, {
        top: "0px",
        position: "absolute",
        visibility: "hidden"
      });
      var container = this.get("container");
      if (!container) {
        container = this.get("graph").get("container");
      }
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      container.appendChild(menu);
      this.set("menu", menu);
    };
    Menu3.prototype.onMenuShow = function(e8) {
      var self2 = this;
      e8.preventDefault();
      var itemTypes = this.get("itemTypes");
      if (!e8.item) {
        if (itemTypes.indexOf("canvas") === -1) {
          self2.onMenuHide();
          return;
        }
      } else {
        if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1) {
          self2.onMenuHide();
          return;
        }
      }
      var shouldBegin2 = this.get("shouldBegin");
      if (!shouldBegin2(e8)) return;
      var menuDom = this.get("menu");
      var getContent = this.get("getContent");
      var graph = this.get("graph");
      var menu = getContent(e8, graph);
      if (is_string_default(menu)) {
        menuDom.innerHTML = menu;
      } else {
        menuDom.innerHTML = menu.outerHTML;
      }
      this.removeMenuEventListener();
      var handleMenuClick = this.get("handleMenuClick");
      if (handleMenuClick) {
        var handleMenuClickWrapper = function handleMenuClickWrapper2(evt) {
          handleMenuClick(evt.target, e8.item, graph);
        };
        this.set("handleMenuClickWrapper", handleMenuClickWrapper);
        menuDom.addEventListener("click", handleMenuClickWrapper);
      }
      var width = graph.get("width");
      var height = graph.get("height");
      var bbox = menuDom.getBoundingClientRect();
      var offsetX = this.get("offsetX") || 0;
      var offsetY = this.get("offsetY") || 0;
      var graphTop = graph.getContainer().offsetTop;
      var graphLeft = graph.getContainer().offsetLeft;
      var x4 = e8.canvasX + graphLeft + offsetX;
      var y4 = e8.canvasY + graphTop + offsetY;
      if (x4 + bbox.width > width) {
        x4 = e8.canvasX - bbox.width - offsetX + graphLeft;
      }
      if (y4 + bbox.height > height) {
        y4 = e8.canvasY - bbox.height - offsetY + graphTop;
      }
      if (y4 < 0) {
        y4 = 0;
      }
      modifyCSS(menuDom, {
        top: "".concat(y4, "px"),
        left: "".concat(x4, "px"),
        visibility: "visible"
      });
      var triggeredByFirstClick = this.get("trigger") === "click";
      var handler = function handler2(evt) {
        if (triggeredByFirstClick) {
          triggeredByFirstClick = false;
          return;
        }
        self2.onMenuHide();
      };
      document.body.addEventListener("click", handler);
      this.set("handler", handler);
    };
    Menu3.prototype.removeMenuEventListener = function() {
      var handleMenuClickWrapper = this.get("handleMenuClickWrapper");
      var handler = this.get("handler");
      if (handleMenuClickWrapper) {
        var menuDom = this.get("menu");
        menuDom.removeEventListener("click", handleMenuClickWrapper);
        this.set("handleMenuClickWrapper", null);
      }
      if (handler) {
        document.body.removeEventListener("click", handler);
      }
    };
    Menu3.prototype.onMenuHide = function() {
      var menuDom = this.get("menu");
      if (menuDom) {
        modifyCSS(menuDom, {
          visibility: "hidden"
        });
      }
      this.removeMenuEventListener();
    };
    Menu3.prototype.destroy = function() {
      var menu = this.get("menu");
      this.removeMenuEventListener();
      if (menu) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        container.removeChild(menu);
      }
    };
    return Menu3;
  }(base_default4)
);
var menu_default = Menu;

// node_modules/@antv/g6-plugin/es/minimap/index.js
init_esm();
var __extends6 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign5 = function() {
  __assign5 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign5.apply(this, arguments);
};
var max6 = Math.max;
var transform11 = ext_exports.transform;
var DEFAULT_MODE = "default";
var KEYSHAPE_MODE = "keyShape";
var DELEGATE_MODE = "delegate";
var SVG2 = "svg";
var MiniMap = (
  /** @class */
  function(_super) {
    __extends6(MiniMap2, _super);
    function MiniMap2(config) {
      var _this = _super.call(this, config) || this;
      _this.handleUpdateCanvas = debounce_default(function(event) {
        var self2 = _this;
        if (self2.destroyed) return;
        self2.updateCanvas();
      }, 100, false);
      return _this;
    }
    MiniMap2.prototype.getDefaultCfgs = function() {
      return {
        container: null,
        className: "g6-minimap",
        viewportClassName: "g6-minimap-viewport",
        // Minimap 中默认展示和主图一样的内容，KeyShape 只展示节点和边的 key shape 部分，delegate表示展示自定义的rect，用户可自定义样式
        type: "default",
        padding: 50,
        size: [200, 120],
        delegateStyle: {
          fill: "#40a9ff",
          stroke: "#096dd9"
        },
        refresh: true,
        hideEdge: false
      };
    };
    MiniMap2.prototype.getEvents = function() {
      return {
        beforepaint: "updateViewport",
        beforeanimate: "disableRefresh",
        afteranimate: "enableRefresh",
        viewportchange: "disableOneRefresh"
      };
    };
    MiniMap2.prototype.disableRefresh = function() {
      this.set("refresh", false);
    };
    MiniMap2.prototype.enableRefresh = function() {
      this.set("refresh", true);
      this.updateCanvas();
    };
    MiniMap2.prototype.disableOneRefresh = function() {
      this.set("viewportChange", true);
    };
    MiniMap2.prototype.initViewport = function() {
      var _this = this;
      var cfgs = this._cfgs;
      var size3 = cfgs.size, graph = cfgs.graph;
      if (this.destroyed) return;
      var canvas = this.get("canvas");
      var containerDOM = canvas.get("container");
      var isFireFox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
      var isSafari2 = navigator.userAgent.toLowerCase().indexOf("safari") > -1;
      var viewport = createDom2("\n      <div\n        class=".concat(cfgs.viewportClassName, "\n        style='position:absolute;\n          left:0;\n          top:0;\n          box-sizing:border-box;\n          outline: 2px solid #1980ff;\n          cursor:move'\n        draggable=").concat(isSafari2 || isFireFox ? false : true, "\n      </div>"));
      var x4 = 0;
      var y4 = 0;
      var dragging = false;
      var left = 0;
      var top = 0;
      var width = 0;
      var height = 0;
      var ratio = 0;
      var zoom = 0;
      var dragstartevent = isSafari2 || isFireFox ? "mousedown" : "dragstart";
      viewport.addEventListener(dragstartevent, function(e8) {
        var _a2, _b;
        if (e8.dataTransfer) {
          var img = new Image();
          img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' %3E%3Cpath /%3E%3C/svg%3E";
          (_b = (_a2 = e8.dataTransfer).setDragImage) === null || _b === void 0 ? void 0 : _b.call(_a2, img, 0, 0);
          try {
            e8.dataTransfer.setData("text/html", "view-port-minimap");
          } catch (_c) {
            e8.dataTransfer.setData("text", "view-port-minimap");
          }
        }
        cfgs.refresh = false;
        if (e8.target !== viewport) {
          return;
        }
        var style = viewport.style;
        left = parseInt(style.left, 10);
        top = parseInt(style.top, 10);
        width = parseInt(style.width, 10);
        height = parseInt(style.height, 10);
        if (width > size3[0] || height > size3[1]) {
          return;
        }
        zoom = graph.getZoom();
        ratio = _this.get("ratio");
        dragging = true;
        x4 = e8.clientX;
        y4 = e8.clientY;
      }, false);
      var dragListener = function dragListener2(e8) {
        if (!dragging || is_nil_default(e8.clientX) || is_nil_default(e8.clientY)) {
          return;
        }
        var dx = x4 - e8.clientX;
        var dy = y4 - e8.clientY;
        if (left - dx < 0 || left - dx + width >= size3[0]) {
          dx = 0;
        }
        if (top - dy < 0 || top - dy + height >= size3[1]) {
          dy = 0;
        }
        left -= dx;
        top -= dy;
        modifyCSS(viewport, {
          left: "".concat(left, "px"),
          top: "".concat(top, "px")
        });
        graph.translate(dx * zoom / ratio, dy * zoom / ratio);
        x4 = e8.clientX;
        y4 = e8.clientY;
      };
      if (!isSafari2 && !isFireFox) {
        viewport.addEventListener("drag", dragListener, false);
      }
      var dragendListener = function dragendListener2() {
        dragging = false;
        cfgs.refresh = true;
      };
      var dragendevent = isSafari2 || isFireFox ? "mouseup" : "dragend";
      viewport.addEventListener(dragendevent, dragendListener, false);
      containerDOM.addEventListener("mouseleave", dragendListener);
      containerDOM.addEventListener("mouseup", dragendListener);
      if (isSafari2 || isFireFox) {
        containerDOM.addEventListener("mousemove", dragListener, false);
      }
      this.set("viewport", viewport);
      containerDOM.appendChild(viewport);
    };
    MiniMap2.prototype.updateViewport = function() {
      if (this.destroyed) return;
      var ratio = this.get("ratio");
      var totaldx = this.get("totaldx");
      var totaldy = this.get("totaldy");
      var graph = this.get("graph");
      var size3 = this.get("size");
      var graphCanvasEl = graph.get("canvas").get("el");
      var graphWidth = graph.get("width") || graphCanvasEl.scrollWidth || 500;
      var graphHeight = graph.get("height") || graphCanvasEl.scrollHeight || 500;
      var topLeft = graph.getPointByCanvas(0, 0);
      var bottomRight = graph.getPointByCanvas(graphWidth, graphHeight);
      var viewport = this.get("viewport");
      if (!viewport) {
        this.initViewport();
      }
      var width = (bottomRight.x - topLeft.x) * ratio;
      var height = (bottomRight.y - topLeft.y) * ratio;
      var left = topLeft.x * ratio + totaldx;
      var top = topLeft.y * ratio + totaldy;
      var right = left + width;
      var bottom = top + height;
      if (left < 0) {
        width += left;
        left = 0;
      }
      if (right > size3[0]) {
        width = width - (right - size3[0]);
      }
      if (top < 0) {
        height += top;
        top = 0;
      }
      if (bottom > size3[1]) {
        height = height - (bottom - size3[1]);
      }
      this.set("ratio", ratio);
      var correctLeft = "".concat(left, "px");
      var correctTop = "".concat(top, "px");
      modifyCSS(viewport, {
        left: correctLeft,
        top: correctTop,
        width: "".concat(width, "px"),
        height: "".concat(height, "px")
      });
    };
    MiniMap2.prototype.updateGraphShapes = function() {
      var graph = this._cfgs.graph;
      var canvas = this.get("canvas");
      var graphGroup = graph.get("group");
      if (graphGroup.destroyed) return;
      canvas.clear();
      var clonedGroup;
      if (this.get("hideEdge")) {
        clonedGroup = canvas.addGroup();
        graphGroup.get("children").forEach(function(group) {
          if (group.get("id").includes("-edge")) return;
          clonedGroup.add(group.clone());
        });
      } else {
        clonedGroup = graphGroup.clone();
        clonedGroup.resetMatrix();
        canvas.add(clonedGroup);
      }
      var renderer = graph.get("renderer");
      if (renderer === SVG2) {
        this.updateVisible(clonedGroup);
      }
    };
    MiniMap2.prototype.updateVisible = function(ele) {
      var _this = this;
      if (!ele.isGroup() && !ele.get("visible")) {
        ele.hide();
      } else {
        var children = ele.get("children");
        if (!children || !children.length) return;
        children.forEach(function(child) {
          if (!child.get("visible")) child.hide();
          _this.updateVisible(child);
        });
      }
    };
    MiniMap2.prototype.updateKeyShapes = function() {
      var _this = this;
      var graph = this._cfgs.graph;
      var canvas = this.get("canvas");
      var group = canvas.get("children")[0] || canvas.addGroup();
      if (!this.get("hideEdge")) {
        each_default(graph.getEdges(), function(edge) {
          _this.updateOneEdgeKeyShape(edge, group);
        });
      }
      each_default(graph.getNodes(), function(node) {
        _this.updateOneNodeKeyShape(node, group);
      });
      var combos = graph.getCombos();
      if (combos && combos.length) {
        var comboGroup_1 = group.find(function(e8) {
          return e8.get("name") === "comboGroup";
        }) || group.addGroup({
          name: "comboGroup"
        });
        setTimeout(function() {
          if (_this.destroyed) return;
          each_default(combos, function(combo) {
            _this.updateOneComboKeyShape(combo, comboGroup_1);
          });
          comboGroup_1 === null || comboGroup_1 === void 0 ? void 0 : comboGroup_1.sort();
          comboGroup_1 === null || comboGroup_1 === void 0 ? void 0 : comboGroup_1.toBack();
          _this.updateCanvas();
        }, 250);
      }
      this.clearDestroyedShapes();
    };
    MiniMap2.prototype.updateOneComboKeyShape = function(item, comboGroup) {
      if (this.destroyed) return;
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      var bbox = item.getBBox();
      var cKeyShape = item.get("keyShape").clone();
      var keyShapeStyle = cKeyShape.attr();
      var attrs = {
        x: bbox.centerX,
        y: bbox.centerY
      };
      if (!mappedItem) {
        mappedItem = cKeyShape;
        comboGroup.add(mappedItem);
      } else {
        attrs = Object.assign(keyShapeStyle, attrs);
      }
      var shapeType = mappedItem.get("type");
      if (shapeType === "rect" || shapeType === "image") {
        attrs.x = bbox.minX;
        attrs.y = bbox.minY;
      }
      mappedItem.attr(attrs);
      if (!item.isVisible()) mappedItem.hide();
      else mappedItem.show();
      mappedItem.exist = true;
      var zIndex = item.getModel().depth;
      if (!isNaN(zIndex)) mappedItem.set("zIndex", zIndex);
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.updateOneNodeKeyShape = function(item, group) {
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      var bbox = item.getBBox();
      var cKeyShape = item.get("keyShape").clone();
      var keyShapeStyle = cKeyShape.attr();
      var attrs = {
        x: bbox.centerX,
        y: bbox.centerY
      };
      if (!mappedItem) {
        mappedItem = cKeyShape;
        group.add(mappedItem);
      } else {
        attrs = Object.assign(keyShapeStyle, attrs);
        mappedItem.toFront();
      }
      var shapeType = mappedItem.get("type");
      if (shapeType === "rect" || shapeType === "image") {
        attrs.x = bbox.minX;
        attrs.y = bbox.minY;
      }
      mappedItem.attr(attrs);
      if (!item.isVisible()) mappedItem.hide();
      else mappedItem.show();
      mappedItem.exist = true;
      var zIndex = item.getModel().depth;
      if (!isNaN(zIndex)) mappedItem.set("zIndex", zIndex);
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.updateDelegateShapes = function() {
      var _this = this;
      var graph = this._cfgs.graph;
      var canvas = this.get("canvas");
      var group = canvas.get("children")[0] || canvas.addGroup();
      if (!this.get("hideEdge")) {
        each_default(graph.getEdges(), function(edge) {
          _this.updateOneEdgeKeyShape(edge, group);
        });
      }
      each_default(graph.getNodes(), function(node) {
        _this.updateOneNodeDelegateShape(node, group);
      });
      var combos = graph.getCombos();
      if (combos && combos.length) {
        var comboGroup_2 = group.find(function(e8) {
          return e8.get("name") === "comboGroup";
        }) || group.addGroup({
          name: "comboGroup"
        });
        setTimeout(function() {
          if (_this.destroyed) return;
          each_default(combos, function(combo) {
            _this.updateOneComboKeyShape(combo, comboGroup_2);
          });
          comboGroup_2 === null || comboGroup_2 === void 0 ? void 0 : comboGroup_2.sort();
          comboGroup_2 === null || comboGroup_2 === void 0 ? void 0 : comboGroup_2.toBack();
          _this.updateCanvas();
        }, 250);
      }
      this.clearDestroyedShapes();
    };
    MiniMap2.prototype.clearDestroyedShapes = function() {
      var itemMap = this.get("itemMap") || {};
      var keys3 = Object.keys(itemMap);
      if (!keys3 || keys3.length === 0) return;
      for (var i2 = keys3.length - 1; i2 >= 0; i2--) {
        var shape = itemMap[keys3[i2]];
        var exist = shape.exist;
        shape.exist = false;
        if (!exist) {
          shape.remove();
          delete itemMap[keys3[i2]];
        }
      }
    };
    MiniMap2.prototype.updateOneEdgeKeyShape = function(item, group) {
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      if (mappedItem) {
        var path = item.get("keyShape").attr("path");
        mappedItem.attr("path", path);
      } else {
        mappedItem = item.get("keyShape").clone();
        group.add(mappedItem);
      }
      if (!item.isVisible()) mappedItem.hide();
      else mappedItem.show();
      mappedItem.exist = true;
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.updateOneNodeDelegateShape = function(item, group) {
      var delegateStyle = this.get("delegateStyle");
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      var bbox = item.getBBox();
      if (mappedItem) {
        var attrs = {
          x: bbox.minX,
          y: bbox.minY,
          width: bbox.width,
          height: bbox.height
        };
        mappedItem.attr(attrs);
        mappedItem.toFront();
      } else {
        mappedItem = group.addShape("rect", {
          attrs: __assign5({
            x: bbox.minX,
            y: bbox.minY,
            width: bbox.width,
            height: bbox.height
          }, delegateStyle),
          name: "minimap-node-shape"
        });
      }
      if (!item.isVisible()) mappedItem.hide();
      else mappedItem.show();
      mappedItem.exist = true;
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.init = function() {
      this.initContainer();
      this.get("graph").on("afterupdateitem", this.handleUpdateCanvas);
      this.get("graph").on("afteritemstatechange", this.handleUpdateCanvas);
      this.get("graph").on("afteradditem", this.handleUpdateCanvas);
      this.get("graph").on("afterremoveitem", this.handleUpdateCanvas);
      this.get("graph").on("afterrender", this.handleUpdateCanvas);
      this.get("graph").on("afterlayout", this.handleUpdateCanvas);
    };
    MiniMap2.prototype.initContainer = function() {
      var self2 = this;
      var graph = self2.get("graph");
      var size3 = self2.get("size");
      var className = self2.get("className");
      var parentNode = self2.get("container");
      var container = createDom2("<div class='".concat(className, "' style='width: ").concat(size3[0], "px; height: ").concat(size3[1], "px; overflow: hidden'></div>"));
      if (is_string_default(parentNode)) {
        parentNode = document.getElementById(parentNode);
      }
      if (parentNode) {
        parentNode.appendChild(container);
      } else {
        graph.get("container").appendChild(container);
      }
      self2.set("container", container);
      var containerDOM = createDom2('<div class="g6-minimap-container" style="position: relative;"></div>');
      container.appendChild(containerDOM);
      containerDOM.addEventListener("dragenter", function(e8) {
        e8.preventDefault();
      });
      containerDOM.addEventListener("dragover", function(e8) {
        e8.preventDefault();
      });
      var canvas;
      var renderer = graph.get("renderer");
      if (renderer === SVG2) {
        canvas = new canvas_default3({
          container: containerDOM,
          width: size3[0],
          height: size3[1]
        });
      } else {
        canvas = new canvas_default2({
          container: containerDOM,
          width: size3[0],
          height: size3[1]
        });
      }
      self2.set("canvas", canvas);
      self2.updateCanvas();
    };
    MiniMap2.prototype.updateCanvas = function() {
      if (this.destroyed) return;
      var isRefresh = this.get("refresh");
      if (!isRefresh) {
        return;
      }
      var graph = this.get("graph");
      if (graph.get("destroyed")) {
        return;
      }
      if (this.get("viewportChange")) {
        this.set("viewportChange", false);
        this.updateViewport();
      }
      var size3 = this.get("size");
      var canvas = this.get("canvas");
      var type = this.get("type");
      var padding = this.get("padding");
      if (canvas.destroyed) {
        return;
      }
      switch (type) {
        case DEFAULT_MODE:
          this.updateGraphShapes();
          break;
        case KEYSHAPE_MODE:
          this.updateKeyShapes();
          break;
        case DELEGATE_MODE:
          this.updateDelegateShapes();
          break;
        default:
          break;
      }
      var group = canvas.get("children")[0];
      if (!group) return;
      group.resetMatrix();
      var bbox = group.getCanvasBBox();
      var graphBBox = graph.get("canvas").getCanvasBBox();
      var graphZoom = graph.getZoom() || 1;
      var width = graphBBox.width / graphZoom;
      var height = graphBBox.height / graphZoom;
      if (Number.isFinite(bbox.width)) {
        width = max6(bbox.width, width);
        height = max6(bbox.height, height);
      }
      width += 2 * padding;
      height += 2 * padding;
      var ratio = Math.min(size3[0] / width, size3[1] / height);
      var matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var minX = 0;
      var minY = 0;
      if (Number.isFinite(bbox.minX)) {
        minX = -bbox.minX;
      }
      if (Number.isFinite(bbox.minY)) {
        minY = -bbox.minY;
      }
      var dx = (size3[0] - (width - 2 * padding) * ratio) / 2;
      var dy = (size3[1] - (height - 2 * padding) * ratio) / 2;
      matrix = transform11(matrix, [
        ["t", minX, minY],
        ["s", ratio, ratio],
        ["t", dx, dy]
        // 移动到画布中心
      ]);
      group.setMatrix(matrix);
      this.set("ratio", ratio);
      this.set("totaldx", dx + minX * ratio);
      this.set("totaldy", dy + minY * ratio);
      this.set("dx", dx);
      this.set("dy", dy);
      this.updateViewport();
    };
    MiniMap2.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    MiniMap2.prototype.getViewport = function() {
      return this.get("viewport");
    };
    MiniMap2.prototype.getContainer = function() {
      return this.get("container");
    };
    MiniMap2.prototype.destroy = function() {
      var _a2;
      (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      var container = this.get("container");
      if (container === null || container === void 0 ? void 0 : container.parentNode) container.parentNode.removeChild(container);
    };
    return MiniMap2;
  }(base_default4)
);
var minimap_default = MiniMap;

// node_modules/@antv/g6-plugin/es/bundling/index.js
var __extends7 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
function getEucliDis(pointA, pointB, eps2) {
  var vx = pointA.x - pointB.x;
  var vy = pointA.y - pointB.y;
  if (!eps2 || Math.abs(vx) > eps2 || Math.abs(vy) > eps2) {
    return Math.sqrt(vx * vx + vy * vy);
  }
  return eps2;
}
function getDotProduct(ei2, ej) {
  return ei2.x * ej.x + ei2.y * ej.y;
}
function projectPointToEdge(p2, e8) {
  var k2 = (e8.source.y - e8.target.y) / (e8.source.x - e8.target.x);
  var x4 = (k2 * k2 * e8.source.x + k2 * (p2.y - e8.source.y) + p2.x) / (k2 * k2 + 1);
  var y4 = k2 * (x4 - e8.source.x) + e8.source.y;
  return {
    x: x4,
    y: y4
  };
}
var Bundling = (
  /** @class */
  function(_super) {
    __extends7(Bundling3, _super);
    function Bundling3(config) {
      return _super.call(this, config) || this;
    }
    Bundling3.prototype.getDefaultCfgs = function() {
      return {
        edgeBundles: [],
        edgePoints: [],
        K: 0.1,
        lambda: 0.1,
        divisions: 1,
        divRate: 2,
        cycles: 6,
        iterations: 90,
        iterRate: 0.6666667,
        bundleThreshold: 0.6,
        eps: 1e-6,
        onLayoutEnd: function onLayoutEnd() {
        },
        onTick: function onTick() {
        }
      };
    };
    Bundling3.prototype.init = function() {
      var graph = this.get("graph");
      var onTick = this.get("onTick");
      var tick = function tick2() {
        if (onTick) {
          onTick();
        }
        graph.refreshPositions();
      };
      this.set("tick", tick);
    };
    Bundling3.prototype.bundling = function(data) {
      var self2 = this;
      self2.set("data", data);
      if (self2.isTicking()) {
        return;
      }
      var edges = data.edges || [];
      var nodes = data.nodes || [];
      var nodeIdMap = {};
      var error = false;
      nodes.forEach(function(node) {
        if (node.x === null || !node.y === null || node.x === void 0 || !node.y === void 0) {
          error = true;
        }
        nodeIdMap[node.id] = node;
      });
      if (error) throw new Error("please layout the graph or assign x and y for nodes first");
      self2.set("nodeIdMap", nodeIdMap);
      var divisions = self2.get("divisions");
      var divRate = self2.get("divRate");
      var edgePoints = self2.divideEdges(divisions);
      self2.set("edgePoints", edgePoints);
      var edgeBundles = self2.getEdgeBundles();
      self2.set("edgeBundles", edgeBundles);
      var C3 = self2.get("cycles");
      var iterations = self2.get("iterations");
      var iterRate = self2.get("iterRate");
      var lambda = self2.get("lambda");
      for (var i2 = 0; i2 < C3; i2++) {
        var _loop_1 = function _loop_12(j3) {
          var forces = [];
          edges.forEach(function(e8, k2) {
            if (e8.source === e8.target) return;
            var source = nodeIdMap[e8.source];
            var target = nodeIdMap[e8.target];
            forces[k2] = self2.getEdgeForces({
              source,
              target
            }, k2, divisions, lambda);
            for (var p2 = 0; p2 < divisions + 1; p2++) {
              edgePoints[k2][p2].x += forces[k2][p2].x;
              edgePoints[k2][p2].y += forces[k2][p2].y;
            }
          });
        };
        for (var j2 = 0; j2 < iterations; j2++) {
          _loop_1(j2);
        }
        lambda = lambda / 2;
        divisions *= divRate;
        iterations *= iterRate;
        edgePoints = self2.divideEdges(divisions);
        self2.set("edgePoints", edgePoints);
      }
      edges.forEach(function(e8, i3) {
        if (e8.source === e8.target) return;
        e8.type = "polyline";
        e8.controlPoints = edgePoints[i3].slice(1, edgePoints[i3].length - 1);
      });
      var graph = self2.get("graph");
      graph.refresh();
    };
    Bundling3.prototype.updateBundling = function(cfg) {
      var self2 = this;
      var data = cfg.data;
      if (data) {
        self2.set("data", data);
      }
      if (self2.get("ticking")) {
        self2.set("ticking", false);
      }
      Object.keys(cfg).forEach(function(key) {
        self2.set(key, cfg[key]);
      });
      if (cfg.onTick) {
        var graph_1 = this.get("graph");
        self2.set("tick", function() {
          cfg.onTick();
          graph_1.refresh();
        });
      }
      self2.bundling(data);
    };
    Bundling3.prototype.divideEdges = function(divisions) {
      var self2 = this;
      var edges = self2.get("data").edges;
      var nodeIdMap = self2.get("nodeIdMap");
      var edgePoints = self2.get("edgePoints");
      if (!edgePoints || edgePoints === void 0) edgePoints = [];
      edges.forEach(function(edge, i2) {
        var _a2;
        if (!edgePoints[i2] || edgePoints[i2] === void 0) {
          edgePoints[i2] = [];
        }
        var source = nodeIdMap[edge.source];
        var target = nodeIdMap[edge.target];
        if (divisions === 1) {
          edgePoints[i2].push({
            x: source.x,
            y: source.y
          });
          edgePoints[i2].push({
            x: 0.5 * (source.x + target.x),
            y: 0.5 * (source.y + target.y)
          });
          edgePoints[i2].push({
            x: target.x,
            y: target.y
          });
        } else {
          var edgeLength = 0;
          if (!((_a2 = edgePoints[i2]) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            edgeLength = getEucliDis({
              x: source.x,
              y: source.y
            }, {
              x: target.x,
              y: target.y
            });
          } else {
            edgeLength = self2.getEdgeLength(edgePoints[i2]);
          }
          var divisionLength_1 = edgeLength / (divisions + 1);
          var currentDivisonLength_1 = divisionLength_1;
          var newEdgePoints_1 = [{
            x: source.x,
            y: source.y
          }];
          edgePoints[i2].forEach(function(ep, j2) {
            if (j2 === 0) return;
            var oriDivisionLength = getEucliDis(ep, edgePoints[i2][j2 - 1]);
            while (oriDivisionLength > currentDivisonLength_1) {
              var ratio = currentDivisonLength_1 / oriDivisionLength;
              var edgePoint = {
                x: edgePoints[i2][j2 - 1].x,
                y: edgePoints[i2][j2 - 1].y
              };
              edgePoint.x += ratio * (ep.x - edgePoints[i2][j2 - 1].x);
              edgePoint.y += ratio * (ep.y - edgePoints[i2][j2 - 1].y);
              newEdgePoints_1.push(edgePoint);
              oriDivisionLength -= currentDivisonLength_1;
              currentDivisonLength_1 = divisionLength_1;
            }
            currentDivisonLength_1 -= oriDivisionLength;
          });
          newEdgePoints_1.push({
            x: target.x,
            y: target.y
          });
          edgePoints[i2] = newEdgePoints_1;
        }
      });
      return edgePoints;
    };
    Bundling3.prototype.getEdgeLength = function(points) {
      var length6 = 0;
      points.forEach(function(p2, i2) {
        if (i2 === 0) return;
        length6 += getEucliDis(p2, points[i2 - 1]);
      });
      return length6;
    };
    Bundling3.prototype.getEdgeBundles = function() {
      var self2 = this;
      var data = self2.get("data");
      var edges = data.edges || [];
      var bundleThreshold = self2.get("bundleThreshold");
      var nodeIdMap = self2.get("nodeIdMap");
      var edgeBundles = self2.get("edgeBundles");
      if (!edgeBundles) edgeBundles = [];
      edges.forEach(function(e8, i2) {
        if (!edgeBundles[i2] || edgeBundles[i2] === void 0) {
          edgeBundles[i2] = [];
        }
      });
      edges.forEach(function(ei2, i2) {
        var iSource = nodeIdMap[ei2.source];
        var iTarget = nodeIdMap[ei2.target];
        edges.forEach(function(ej, j2) {
          if (j2 <= i2) return;
          var jSource = nodeIdMap[ej.source];
          var jTarget = nodeIdMap[ej.target];
          var score = self2.getBundleScore({
            source: iSource,
            target: iTarget
          }, {
            source: jSource,
            target: jTarget
          });
          if (score >= bundleThreshold) {
            edgeBundles[i2].push(j2);
            edgeBundles[j2].push(i2);
          }
        });
      });
      return edgeBundles;
    };
    Bundling3.prototype.getBundleScore = function(ei2, ej) {
      var self2 = this;
      ei2.vx = ei2.target.x - ei2.source.x;
      ei2.vy = ei2.target.y - ei2.source.y;
      ej.vx = ej.target.x - ej.source.x;
      ej.vy = ej.target.y - ej.source.y;
      ei2.length = getEucliDis({
        x: ei2.source.x,
        y: ei2.source.y
      }, {
        x: ei2.target.x,
        y: ei2.target.y
      });
      ej.length = getEucliDis({
        x: ej.source.x,
        y: ej.source.y
      }, {
        x: ej.target.x,
        y: ej.target.y
      });
      var aScore = self2.getAngleScore(ei2, ej);
      var sScore = self2.getScaleScore(ei2, ej);
      var pScore = self2.getPositionScore(ei2, ej);
      var vScore = self2.getVisibilityScore(ei2, ej);
      return aScore * sScore * pScore * vScore;
    };
    Bundling3.prototype.getAngleScore = function(ei2, ej) {
      var dotProduct = getDotProduct({
        x: ei2.vx,
        y: ei2.vy
      }, {
        x: ej.vx,
        y: ej.vy
      });
      return dotProduct / (ei2.length * ej.length);
    };
    Bundling3.prototype.getScaleScore = function(ei2, ej) {
      var aLength = (ei2.length + ej.length) / 2;
      var score = 2 / (aLength / Math.min(ei2.length, ej.length) + Math.max(ei2.length, ej.length) / aLength);
      return score;
    };
    Bundling3.prototype.getPositionScore = function(ei2, ej) {
      var aLength = (ei2.length + ej.length) / 2;
      var iMid = {
        x: (ei2.source.x + ei2.target.x) / 2,
        y: (ei2.source.y + ei2.target.y) / 2
      };
      var jMid = {
        x: (ej.source.x + ej.target.x) / 2,
        y: (ej.source.y + ej.target.y) / 2
      };
      var distance11 = getEucliDis(iMid, jMid);
      return aLength / (aLength + distance11);
    };
    Bundling3.prototype.getVisibilityScore = function(ei2, ej) {
      var vij = this.getEdgeVisibility(ei2, ej);
      var vji = this.getEdgeVisibility(ej, ei2);
      return vij < vji ? vij : vji;
    };
    Bundling3.prototype.getEdgeVisibility = function(ei2, ej) {
      var ps = projectPointToEdge(ej.source, ei2);
      var pt2 = projectPointToEdge(ej.target, ei2);
      var pMid = {
        x: (ps.x + pt2.x) / 2,
        y: (ps.y + pt2.y) / 2
      };
      var iMid = {
        x: (ei2.source.x + ei2.target.x) / 2,
        y: (ei2.source.y + ei2.target.y) / 2
      };
      return Math.max(0, 1 - 2 * getEucliDis(pMid, iMid) / getEucliDis(ps, pt2));
    };
    Bundling3.prototype.getEdgeForces = function(e8, eidx, divisions, lambda) {
      var self2 = this;
      var edgePoints = self2.get("edgePoints");
      var K3 = self2.get("K");
      var kp = K3 / (getEucliDis(e8.source, e8.target) * (divisions + 1));
      var edgePointForces = [{
        x: 0,
        y: 0
      }];
      for (var i2 = 1; i2 < divisions; i2++) {
        var force = {
          x: 0,
          y: 0
        };
        var spring = self2.getSpringForce({
          pre: edgePoints[eidx][i2 - 1],
          cur: edgePoints[eidx][i2],
          next: edgePoints[eidx][i2 + 1]
        }, kp);
        var electrostatic = self2.getElectrostaticForce(i2, eidx);
        force.x = lambda * (spring.x + electrostatic.x);
        force.y = lambda * (spring.y + electrostatic.y);
        edgePointForces.push(force);
      }
      edgePointForces.push({
        x: 0,
        y: 0
      });
      return edgePointForces;
    };
    Bundling3.prototype.getSpringForce = function(divisions, kp) {
      var x4 = divisions.pre.x + divisions.next.x - 2 * divisions.cur.x;
      var y4 = divisions.pre.y + divisions.next.y - 2 * divisions.cur.y;
      x4 *= kp;
      y4 *= kp;
      return {
        x: x4,
        y: y4
      };
    };
    Bundling3.prototype.getElectrostaticForce = function(pidx, eidx) {
      var self2 = this;
      var eps2 = self2.get("eps");
      var edgeBundles = self2.get("edgeBundles");
      var edgePoints = self2.get("edgePoints");
      var edgeBundle = edgeBundles[eidx];
      var resForce = {
        x: 0,
        y: 0
      };
      edgeBundle.forEach(function(eb) {
        var force = {
          x: edgePoints[eb][pidx].x - edgePoints[eidx][pidx].x,
          y: edgePoints[eb][pidx].y - edgePoints[eidx][pidx].y
        };
        if (Math.abs(force.x) > eps2 || Math.abs(force.y) > eps2) {
          var length_1 = getEucliDis(edgePoints[eb][pidx], edgePoints[eidx][pidx]);
          var diff = 1 / length_1;
          resForce.x += force.x * diff;
          resForce.y += force.y * diff;
        }
      });
      return resForce;
    };
    Bundling3.prototype.isTicking = function() {
      return this.get("ticking");
    };
    Bundling3.prototype.getSimulation = function() {
      return this.get("forceSimulation");
    };
    Bundling3.prototype.destroy = function() {
      if (this.get("ticking")) {
        this.getSimulation().stop();
      }
      _super.prototype.destroy.call(this);
    };
    return Bundling3;
  }(base_default4)
);
var bundling_default = Bundling;

// node_modules/@antv/g6-plugin/es/fisheye/index.js
init_esm();
var __extends8 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign6 = function() {
  __assign6 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign6.apply(this, arguments);
};
var DELTA = 0.05;
var lensDelegateStyle = {
  stroke: "#000",
  strokeOpacity: 0.8,
  lineWidth: 2,
  fillOpacity: 0.1,
  fill: "#ccc"
};
var Fisheye = (
  /** @class */
  function(_super) {
    __extends8(Fisheye3, _super);
    function Fisheye3(config) {
      return _super.call(this, config) || this;
    }
    Fisheye3.prototype.getDefaultCfgs = function() {
      return {
        trigger: "mousemove",
        d: 1.5,
        r: 300,
        delegateStyle: clone_default(lensDelegateStyle),
        showLabel: false,
        maxD: 5,
        minD: 0,
        scaleRBy: "unset",
        scaleDBy: "unset",
        showDPercent: true
      };
    };
    Fisheye3.prototype.getEvents = function() {
      var events;
      switch (this.get("trigger")) {
        case "click":
          events = {
            click: "magnify"
          };
          break;
        case "drag":
          events = {
            click: "createDelegate"
          };
          break;
        default:
          events = {
            mousemove: "magnify"
          };
          break;
      }
      return events;
    };
    Fisheye3.prototype.init = function() {
      var self2 = this;
      var r2 = self2.get("r");
      self2.set("cachedMagnifiedModels", []);
      self2.set("cachedOriginPositions", {});
      self2.set("r2", r2 * r2);
      var d2 = self2.get("d");
      self2.set("molecularParam", (d2 + 1) * r2);
    };
    Fisheye3.prototype.createDelegate = function(e8) {
      var _this = this;
      var self2 = this;
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        self2.magnify(e8);
        lensDelegate = self2.get("delegate");
        lensDelegate.on("dragstart", function(evt) {
          self2.set("delegateCenterDiff", {
            x: lensDelegate.attr("x") - evt.x,
            y: lensDelegate.attr("y") - evt.y
          });
        });
        lensDelegate.on("drag", function(evt) {
          self2.magnify(evt);
        });
        if (this.get("scaleDBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            _this.scaleDByWheel(evt);
          });
        }
        if (this.get("scaleRBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            self2.scaleRByWheel(evt);
          });
        }
      }
    };
    Fisheye3.prototype.scaleRByWheel = function(e8) {
      var self2 = this;
      if (!e8 || !e8.originalEvent) return;
      if (e8.preventDefault) e8.preventDefault();
      var graph = self2.get("graph");
      var ratio;
      var lensDelegate = self2.get("delegate");
      var lensCenter = lensDelegate ? {
        x: lensDelegate.attr("x"),
        y: lensDelegate.attr("y")
      } : void 0;
      var mousePos = lensCenter || graph.getPointByClient(e8.clientX, e8.clientY);
      if (e8.originalEvent.wheelDelta < 0) {
        ratio = 1 - DELTA;
      } else {
        ratio = 1 / (1 - DELTA);
      }
      var maxR = self2.get("maxR");
      var minR = self2.get("minR");
      var r2 = self2.get("r");
      if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
        ratio = 1;
      }
      r2 *= ratio;
      self2.set("r", r2);
      self2.set("r2", r2 * r2);
      var d2 = self2.get("d");
      self2.set("molecularParam", (d2 + 1) * r2);
      self2.set("delegateCenterDiff", void 0);
      self2.magnify(e8, mousePos);
    };
    Fisheye3.prototype.scaleRByDrag = function(e8) {
      var self2 = this;
      if (!e8) return;
      var dragPrePos = self2.get("dragPrePos");
      var graph = self2.get("graph");
      var ratio;
      var mousePos = graph.getPointByClient(e8.clientX, e8.clientY);
      if (e8.x - dragPrePos.x < 0) {
        ratio = 1 - DELTA;
      } else {
        ratio = 1 / (1 - DELTA);
      }
      var maxR = self2.get("maxR");
      var minR = self2.get("minR");
      var r2 = self2.get("r");
      if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
        ratio = 1;
      }
      r2 *= ratio;
      self2.set("r", r2);
      self2.set("r2", r2 * r2);
      var d2 = self2.get("d");
      self2.set("molecularParam", (d2 + 1) * r2);
      self2.magnify(e8, mousePos);
      self2.set("dragPrePos", {
        x: e8.x,
        y: e8.y
      });
    };
    Fisheye3.prototype.scaleDByWheel = function(evt) {
      var self2 = this;
      if (!evt && !evt.originalEvent) return;
      if (evt.preventDefault) evt.preventDefault();
      var delta = 0;
      if (evt.originalEvent.wheelDelta < 0) {
        delta = -0.1;
      } else {
        delta = 0.1;
      }
      var d2 = self2.get("d");
      var newD = d2 + delta;
      var maxD = self2.get("maxD");
      var minD = self2.get("minD");
      if (newD < maxD && newD > minD) {
        self2.set("d", newD);
        var r2 = self2.get("r");
        self2.set("molecularParam", (newD + 1) * r2);
        var lensDelegate = self2.get("delegate");
        var lensCenter = lensDelegate ? {
          x: lensDelegate.attr("x"),
          y: lensDelegate.attr("y")
        } : void 0;
        self2.set("delegateCenterDiff", void 0);
        self2.magnify(evt, lensCenter);
      }
    };
    Fisheye3.prototype.scaleDByDrag = function(e8) {
      var self2 = this;
      var dragPrePos = self2.get("dragPrePos");
      var delta = e8.x - dragPrePos.x > 0 ? 0.1 : -0.1;
      var d2 = self2.get("d");
      var newD = d2 + delta;
      var maxD = self2.get("maxD");
      var minD = self2.get("minD");
      if (newD < maxD && newD > minD) {
        self2.set("d", newD);
        var r2 = self2.get("r");
        self2.set("molecularParam", (newD + 1) * r2);
        self2.magnify(e8);
      }
      self2.set("dragPrePos", {
        x: e8.x,
        y: e8.y
      });
    };
    Fisheye3.prototype.magnify = function(e8, mousePos) {
      var self2 = this;
      self2.restoreCache();
      var graph = self2.get("graph");
      var cachedMagnifiedModels = self2.get("cachedMagnifiedModels");
      var cachedOriginPositions = self2.get("cachedOriginPositions");
      var showLabel = self2.get("showLabel");
      var r2 = self2.get("r");
      var r22 = self2.get("r2");
      var d2 = self2.get("d");
      var molecularParam = self2.get("molecularParam");
      var nodes = graph.getNodes();
      var nodeLength = nodes.length;
      var mCenter = mousePos ? {
        x: mousePos.x,
        y: mousePos.y
      } : {
        x: e8.x,
        y: e8.y
      };
      if (self2.get("dragging") && (self2.get("trigger") === "mousemove" || self2.get("trigger") === "click")) {
        mCenter = self2.get("cacheCenter");
      }
      var delegateCenterDiff = self2.get("delegateCenterDiff");
      if (delegateCenterDiff) {
        mCenter.x += delegateCenterDiff.x;
        mCenter.y += delegateCenterDiff.y;
      }
      self2.updateDelegate(mCenter, r2);
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var model = nodes[i2].getModel();
        var x4 = model.x, y4 = model.y;
        if (isNaN(x4) || isNaN(y4)) continue;
        var dist22 = (x4 - mCenter.x) * (x4 - mCenter.x) + (y4 - mCenter.y) * (y4 - mCenter.y);
        if (!isNaN(dist22) && dist22 < r22 && dist22 !== 0) {
          var dist4 = Math.sqrt(dist22);
          var magnifiedDist = molecularParam * dist4 / (d2 * dist4 + r2);
          var cos3 = (x4 - mCenter.x) / dist4;
          var sin3 = (y4 - mCenter.y) / dist4;
          model.x = cos3 * magnifiedDist + mCenter.x;
          model.y = sin3 * magnifiedDist + mCenter.y;
          if (!cachedOriginPositions[model.id]) {
            cachedOriginPositions[model.id] = {
              x: x4,
              y: y4,
              texts: []
            };
          }
          cachedMagnifiedModels.push(model);
          if (showLabel && 2 * dist4 < r2) {
            var node = nodes[i2];
            var nodeGroup = node.getContainer();
            var shapes = nodeGroup.getChildren();
            var shapeLength = shapes.length;
            for (var j2 = 0; j2 < shapeLength; j2++) {
              var shape = shapes[j2];
              if (shape.get("type") === "text") {
                cachedOriginPositions[model.id].texts.push({
                  visible: shape.get("visible"),
                  shape
                });
                shape.set("visible", true);
              }
            }
          }
        }
      }
      graph.refreshPositions();
    };
    Fisheye3.prototype.restoreCache = function() {
      var self2 = this;
      var cachedMagnifiedModels = self2.get("cachedMagnifiedModels");
      var cachedOriginPositions = self2.get("cachedOriginPositions");
      var cacheLength = cachedMagnifiedModels.length;
      for (var i2 = 0; i2 < cacheLength; i2++) {
        var node = cachedMagnifiedModels[i2];
        var id = node.id;
        var ori = cachedOriginPositions[id];
        node.x = ori.x;
        node.y = ori.y;
        var textLength = ori.texts.length;
        for (var j2 = 0; j2 < textLength; j2++) {
          var text = ori.texts[j2];
          text.shape.set("visible", text.visible);
        }
      }
      self2.set("cachedMagnifiedModels", []);
      self2.set("cachedOriginPositions", {});
    };
    Fisheye3.prototype.updateParams = function(cfg) {
      var self2 = this;
      var r2 = cfg.r, d2 = cfg.d, trigger = cfg.trigger, minD = cfg.minD, maxD = cfg.maxD, minR = cfg.minR, maxR = cfg.maxR, scaleDBy = cfg.scaleDBy, scaleRBy = cfg.scaleRBy;
      if (!isNaN(cfg.r)) {
        self2.set("r", r2);
        self2.set("r2", r2 * r2);
      }
      if (!isNaN(d2)) {
        self2.set("d", d2);
      }
      if (!isNaN(maxD)) {
        self2.set("maxD", maxD);
      }
      if (!isNaN(minD)) {
        self2.set("minD", minD);
      }
      if (!isNaN(maxR)) {
        self2.set("maxR", maxR);
      }
      if (!isNaN(minR)) {
        self2.set("minR", minR);
      }
      var nd = self2.get("d");
      var nr2 = self2.get("r");
      self2.set("molecularParam", (nd + 1) * nr2);
      if (trigger === "mousemove" || trigger === "click" || trigger === "drag") {
        self2.set("trigger", trigger);
      }
      if (scaleDBy === "drag" || scaleDBy === "wheel" || scaleDBy === "unset") {
        self2.set("scaleDBy", scaleDBy);
        self2.get("delegate").remove();
        self2.get("delegate").destroy();
        var dPercentText = self2.get("dPercentText");
        if (dPercentText) {
          dPercentText.remove();
          dPercentText.destroy();
        }
      }
      if (scaleRBy === "drag" || scaleRBy === "wheel" || scaleRBy === "unset") {
        self2.set("scaleRBy", scaleRBy);
        self2.get("delegate").remove();
        self2.get("delegate").destroy();
        var dPercentText = self2.get("dPercentText");
        if (dPercentText) {
          dPercentText.remove();
          dPercentText.destroy();
        }
      }
    };
    Fisheye3.prototype.updateDelegate = function(mCenter, r2) {
      var _this = this;
      var self2 = this;
      var graph = self2.get("graph");
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        var parent_1 = graph.get("group");
        var attrs = self2.get("delegateStyle") || lensDelegateStyle;
        lensDelegate = parent_1.addShape("circle", {
          attrs: __assign6({
            r: r2 / 1.5,
            x: mCenter.x,
            y: mCenter.y
          }, attrs),
          name: "lens-shape",
          draggable: true
        });
        if (this.get("trigger") !== "drag") {
          if (this.get("scaleRBy") === "wheel") {
            lensDelegate.on("mousewheel", function(evt) {
              self2.scaleRByWheel(evt);
            });
          } else if (this.get("scaleRBy") === "drag") {
            lensDelegate.on("dragstart", function(e8) {
              self2.set("dragging", true);
              self2.set("cacheCenter", {
                x: e8.x,
                y: e8.y
              });
              self2.set("dragPrePos", {
                x: e8.x,
                y: e8.y
              });
            });
            lensDelegate.on("drag", function(evt) {
              self2.scaleRByDrag(evt);
            });
            lensDelegate.on("dragend", function(e8) {
              self2.set("dragging", false);
            });
          }
          if (this.get("scaleDBy") === "wheel") {
            lensDelegate.on("mousewheel", function(evt) {
              _this.scaleDByWheel(evt);
            });
          } else if (this.get("scaleDBy") === "drag") {
            lensDelegate.on("dragstart", function(evt) {
              self2.set("dragging", true);
              self2.set("cacheCenter", {
                x: evt.x,
                y: evt.y
              });
              self2.set("dragPrePos", {
                x: evt.x,
                y: evt.y
              });
            });
            lensDelegate.on("drag", function(evt) {
              _this.scaleDByDrag(evt);
            });
            lensDelegate.on("dragend", function(evt) {
              self2.set("dragging", false);
            });
          }
        }
      } else {
        lensDelegate.attr({
          x: mCenter.x,
          y: mCenter.y,
          r: r2 / 1.5
        });
      }
      if (self2.get("showDPercent")) {
        var percent = Math.round((self2.get("d") - self2.get("minD")) / (self2.get("maxD") - self2.get("minD")) * 100);
        var dPercentText = self2.get("dPercentText");
        var textY = mCenter.y + r2 / 1.5 + 16;
        if (!dPercentText || dPercentText.destroyed) {
          var parent_2 = graph.get("group");
          dPercentText = parent_2.addShape("text", {
            attrs: {
              text: "".concat(percent, "%"),
              x: mCenter.x,
              y: textY,
              fill: "#aaa",
              stroke: "#fff",
              lineWidth: 1,
              fontSize: 12
            }
          });
          self2.set("dPercentText", dPercentText);
        } else {
          dPercentText.attr({
            text: "".concat(percent, "%"),
            x: mCenter.x,
            y: textY
          });
        }
      }
      self2.set("delegate", lensDelegate);
    };
    Fisheye3.prototype.clear = function() {
      var graph = this.get("graph");
      this.restoreCache();
      graph.refreshPositions();
      var lensDelegate = this.get("delegate");
      if (lensDelegate && !lensDelegate.destroyed) {
        lensDelegate.remove();
        lensDelegate.destroy();
      }
      var dPercentText = this.get("dPercentText");
      if (dPercentText && !dPercentText.destroyed) {
        dPercentText.remove();
        dPercentText.destroy();
      }
    };
    Fisheye3.prototype.destroy = function() {
      this.clear();
    };
    return Fisheye3;
  }(base_default4)
);
var fisheye_default = Fisheye;

// node_modules/@antv/g6-plugin/es/toolBar/index.js
init_esm();
var import_insert_css2 = __toESM(require_insert_css());
var __extends9 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var DELTA2 = 0.05;
typeof document !== "undefined" && (0, import_insert_css2.default)("\n  .g6-component-toolbar {\n    position: absolute;\n    list-style-type: none;\n    padding: 6px;\n    left: 0px;\n    top: 0px;\n    background-color: rgba(255, 255, 255, 0.9);\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    margin: 0;\n  }\n  .g6-component-toolbar li {\n    float: left;\n    text-align: center;\n    width: 35px;\n    height: 24px;\n    cursor: pointer;\n		list-style-type:none;\n    list-style: none;\n    margin-left: 0px;\n  }\n  .g6-component-toolbar li .icon {\n    opacity: 0.7;\n  }\n  .g6-component-toolbar li .icon:hover {\n    opacity: 1;\n  }\n");
var getEventPath = function getEventPath2(evt) {
  if (!evt) {
    return [];
  }
  if (evt.composedPath) {
    return evt.composedPath();
  }
  var path = [];
  var el = evt.target;
  while (el) {
    path.push(el);
    if (el.tagName === "HTML") {
      path.push(document, window);
      return path;
    }
    el = el.parentElement;
  }
  return path;
};
var ToolBar = (
  /** @class */
  function(_super) {
    __extends9(ToolBar3, _super);
    function ToolBar3(config) {
      return _super.call(this, config) || this;
    }
    ToolBar3.prototype.getDefaultCfgs = function() {
      return {
        handleClick: void 0,
        // 指定菜单内容，function(e) {...}
        getContent: function getContent(graph) {
          return `
          <ul class='g6-component-toolbar'>
            <li code='redo'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M256 682.666667c0-102.741333 66.730667-213.333333 213.333333-213.333334 107.008 0 190.762667 56.576 230.570667 125.354667L611.968 682.666667H853.333333v-241.365334l-91.562666 91.562667C704.768 448.469333 601.130667 384 469.333333 384c-196.096 0-298.666667 150.229333-298.666666 298.666667h85.333333z" fill="" p-id="2041"></path>
              </svg>
            </li>
            <li code='undo'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M170.666667 682.666667h241.365333l-87.936-87.978667C363.904 525.909333 447.658667 469.333333 554.666667 469.333333c146.602667 0 213.333333 110.592 213.333333 213.333334h85.333333c0-148.437333-102.570667-298.666667-298.666666-298.666667-131.797333 0-235.392 64.469333-292.48 148.821333L170.666667 441.301333V682.666667z" fill="" p-id="2764"></path>
              </svg>
            </li>
            <li  code='zoomOut'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M658.432 428.736a33.216 33.216 0 0 1-33.152 33.152H525.824v99.456a33.216 33.216 0 0 1-66.304 0V461.888H360.064a33.152 33.152 0 0 1 0-66.304H459.52V296.128a33.152 33.152 0 0 1 66.304 0V395.52H625.28c18.24 0 33.152 14.848 33.152 33.152z m299.776 521.792a43.328 43.328 0 0 1-60.864-6.912l-189.248-220.992a362.368 362.368 0 0 1-215.36 70.848 364.8 364.8 0 1 1 364.8-364.736 363.072 363.072 0 0 1-86.912 235.968l192.384 224.64a43.392 43.392 0 0 1-4.8 61.184z m-465.536-223.36a298.816 298.816 0 0 0 298.432-298.432 298.816 298.816 0 0 0-298.432-298.432A298.816 298.816 0 0 0 194.24 428.8a298.816 298.816 0 0 0 298.432 298.432z"></path>
              </svg>
            </li>
            <li code='zoomIn'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M639.936 416a32 32 0 0 1-32 32h-256a32 32 0 0 1 0-64h256a32 32 0 0 1 32 32z m289.28 503.552a41.792 41.792 0 0 1-58.752-6.656l-182.656-213.248A349.76 349.76 0 0 1 480 768 352 352 0 1 1 832 416a350.4 350.4 0 0 1-83.84 227.712l185.664 216.768a41.856 41.856 0 0 1-4.608 59.072zM479.936 704c158.784 0 288-129.216 288-288S638.72 128 479.936 128a288.32 288.32 0 0 0-288 288c0 158.784 129.216 288 288 288z" p-id="3853"></path>
              </svg>
            </li>
            <li code='realZoom'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="24">
                <path d="M384 320v384H320V320h64z m256 0v384H576V320h64zM512 576v64H448V576h64z m0-192v64H448V384h64z m355.968 576H92.032A28.16 28.16 0 0 1 64 931.968V28.032C64 12.608 76.608 0 95.168 0h610.368L896 192v739.968a28.16 28.16 0 0 1-28.032 28.032zM704 64v128h128l-128-128z m128 192h-190.464V64H128v832h704V256z"></path>
              </svg>
            </li>
            <li code='autoZoom'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="24">
                <path d="M684.288 305.28l0.128-0.64-0.128-0.64V99.712c0-19.84 15.552-35.904 34.496-35.712a35.072 35.072 0 0 1 34.56 35.776v171.008h170.944c19.648 0 35.84 15.488 35.712 34.432a35.072 35.072 0 0 1-35.84 34.496h-204.16l-0.64-0.128a32.768 32.768 0 0 1-20.864-7.552c-1.344-1.024-2.816-1.664-3.968-2.816-0.384-0.32-0.512-0.768-0.832-1.088a33.472 33.472 0 0 1-9.408-22.848zM305.28 64a35.072 35.072 0 0 0-34.56 35.776v171.008H99.776A35.072 35.072 0 0 0 64 305.216c0 18.944 15.872 34.496 35.84 34.496h204.16l0.64-0.128a32.896 32.896 0 0 0 20.864-7.552c1.344-1.024 2.816-1.664 3.904-2.816 0.384-0.32 0.512-0.768 0.768-1.088a33.024 33.024 0 0 0 9.536-22.848l-0.128-0.64 0.128-0.704V99.712A35.008 35.008 0 0 0 305.216 64z m618.944 620.288h-204.16l-0.64 0.128-0.512-0.128c-7.808 0-14.72 3.2-20.48 7.68-1.28 1.024-2.752 1.664-3.84 2.752-0.384 0.32-0.512 0.768-0.832 1.088a33.664 33.664 0 0 0-9.408 22.912l0.128 0.64-0.128 0.704v204.288c0 19.712 15.552 35.904 34.496 35.712a35.072 35.072 0 0 0 34.56-35.776V753.28h170.944c19.648 0 35.84-15.488 35.712-34.432a35.072 35.072 0 0 0-35.84-34.496z m-593.92 11.52c-0.256-0.32-0.384-0.768-0.768-1.088-1.088-1.088-2.56-1.728-3.84-2.688a33.088 33.088 0 0 0-20.48-7.68l-0.512 0.064-0.64-0.128H99.84a35.072 35.072 0 0 0-35.84 34.496 35.072 35.072 0 0 0 35.712 34.432H270.72v171.008c0 19.84 15.552 35.84 34.56 35.776a35.008 35.008 0 0 0 34.432-35.712V720l-0.128-0.64 0.128-0.704a33.344 33.344 0 0 0-9.472-22.848zM512 374.144a137.92 137.92 0 1 0 0.128 275.84A137.92 137.92 0 0 0 512 374.08z"></path>
              </svg>
            </li>
          </ul>
        `;
        },
        zoomSensitivity: 2
      };
    };
    ToolBar3.prototype.init = function() {
      var _this = this;
      var graph = this.get("graph");
      var getContent = this.get("getContent");
      var toolBar = getContent(graph);
      var toolBarDOM = toolBar;
      if (is_string_default(toolBar)) {
        toolBarDOM = createDom2(toolBar);
      }
      var className = this.get("className");
      toolBarDOM.setAttribute("class", className || "g6-component-toolbar");
      var container = this.get("container");
      if (!container) {
        container = this.get("graph").get("container");
      }
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      container.appendChild(toolBarDOM);
      this.set("toolBar", toolBarDOM);
      var handleClick = this.get("handleClick");
      toolBarDOM.addEventListener("click", function(evt) {
        var current = getEventPath(evt).filter(function(p2) {
          return p2.nodeName === "LI";
        });
        if (current.length === 0) {
          return;
        }
        var code = current[0].getAttribute("code");
        if (!code) {
          return;
        }
        if (handleClick) {
          handleClick(code, graph);
        } else {
          _this.handleDefaultOperator(code);
        }
      });
      var pos = this.get("position");
      if (pos) {
        modifyCSS(toolBarDOM, {
          top: "".concat(pos.y, "px"),
          left: "".concat(pos.x, "px")
        });
      }
      this.bindUndoRedo();
    };
    ToolBar3.prototype.bindUndoRedo = function() {
      var graph = this.get("graph");
      var undoDom = document.querySelector('.g6-component-toolbar li[code="undo"]');
      var undoDomIcon = document.querySelector('.g6-component-toolbar li[code="undo"] svg');
      var redoDom = document.querySelector('.g6-component-toolbar li[code="redo"]');
      var redoDomIcon = document.querySelector('.g6-component-toolbar li[code="redo"] svg');
      if (!undoDom || !undoDomIcon || !redoDom || !redoDomIcon) {
        return;
      }
      undoDom.setAttribute("style", "cursor: not-allowed");
      undoDomIcon.setAttribute("style", "opacity: 0.4");
      redoDom.setAttribute("style", "cursor: not-allowed");
      redoDomIcon.setAttribute("style", "opacity: 0.4");
      graph.on("stackchange", function(evt) {
        var undoStack = evt.undoStack, redoStack = evt.redoStack;
        var undoStackLen = undoStack.length;
        var redoStackLen = redoStack.length;
        if (undoStackLen === 0) {
          undoDom.setAttribute("style", "cursor: not-allowed");
          undoDomIcon.setAttribute("style", "opacity: 0.4");
        } else {
          undoDom.removeAttribute("style");
          undoDomIcon.removeAttribute("style");
        }
        if (redoStackLen === 0) {
          redoDom.setAttribute("style", "cursor: not-allowed");
          redoDomIcon.setAttribute("style", "opacity: 0.4");
        } else {
          redoDom.removeAttribute("style");
          redoDomIcon.removeAttribute("style");
        }
      });
    };
    ToolBar3.prototype.undo = function() {
      var graph = this.get("graph");
      var undoStack = graph.getUndoStack();
      if (!undoStack || undoStack.length === 0) {
        return;
      }
      var currentData = undoStack.pop();
      if (currentData) {
        var action = currentData.action;
        graph.pushStack(action, clone_default(currentData.data), "redo");
        var data_1 = currentData.data.before;
        if (action === "add") {
          data_1 = currentData.data.after;
        }
        if (!data_1) return;
        switch (action) {
          case "visible": {
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array) return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                if (model.visible) {
                  graph.showItem(item, false);
                } else {
                  graph.hideItem(item, false);
                }
              });
            });
            break;
          }
          case "render":
          case "update":
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array) return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                delete model.id;
                graph.updateItem(item, model, false);
                if (item.getType() === "combo") graph.updateCombo(item);
              });
            });
            break;
          case "changedata":
            graph.changeData(data_1, false);
            break;
          case "delete": {
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array) return;
              array.forEach(function(model) {
                var itemType = model.itemType;
                delete model.itemType;
                graph.addItem(itemType, model, false);
              });
            });
            break;
          }
          case "add":
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array) return;
              array.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            });
            break;
          case "updateComboTree":
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array) return;
              array.forEach(function(model) {
                graph.updateComboTree(model.id, model.parentId, false);
              });
            });
            break;
          case "createCombo":
            var afterCombos = currentData.data.after.combos;
            var createdCombo = afterCombos[afterCombos.length - 1];
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array) return;
              array.forEach(function(model) {
                graph.updateComboTree(model.id, model.parentId, false);
              });
            });
            graph.removeItem(createdCombo.id, false);
            break;
          case "uncombo":
            var targetCombo_1 = data_1.combos[data_1.combos.length - 1];
            var childrenIds = data_1.nodes.concat(data_1.combos).map(function(child) {
              return child.id;
            }).filter(function(id) {
              return id !== targetCombo_1.id;
            });
            graph.createCombo(targetCombo_1, childrenIds, false);
            break;
          case "layout":
            graph.updateLayout(data_1, void 0, void 0, false);
            break;
          default:
        }
      }
    };
    ToolBar3.prototype.redo = function() {
      var graph = this.get("graph");
      var redoStack = graph.getRedoStack();
      if (!redoStack || redoStack.length === 0) {
        return;
      }
      var currentData = redoStack.pop();
      if (currentData) {
        var action = currentData.action;
        var data_2 = currentData.data.after;
        graph.pushStack(action, clone_default(currentData.data));
        if (action === "delete") {
          data_2 = currentData.data.before;
        }
        if (!data_2) return;
        switch (action) {
          case "visible": {
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array) return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                if (model.visible) {
                  graph.showItem(item, false);
                } else {
                  graph.hideItem(item, false);
                }
              });
            });
            break;
          }
          case "render":
          case "update":
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array) return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                delete model.id;
                graph.updateItem(item, model, false);
                if (item.getType() === "combo") graph.updateCombo(item);
              });
            });
            break;
          case "changedata":
            graph.changeData(data_2, false);
            break;
          case "delete":
            if (data_2.edges) {
              data_2.edges.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            }
            if (data_2.nodes) {
              data_2.nodes.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            }
            if (data_2.combos) {
              data_2.combos.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            }
            break;
          case "add": {
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array) return;
              array.forEach(function(model) {
                var itemType = model.itemType;
                delete model.itemType;
                graph.addItem(itemType, model, false);
              });
            });
            break;
          }
          case "updateComboTree":
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array) return;
              array.forEach(function(model) {
                graph.updateComboTree(model.id, model.parentId, false);
              });
            });
            break;
          case "createCombo":
            var createdCombo = data_2.combos[data_2.combos.length - 1];
            graph.createCombo(createdCombo, createdCombo.children.map(function(child) {
              return child.id;
            }), false);
            break;
          case "uncombo":
            var beforeCombos = currentData.data.before.combos;
            var targertCombo = beforeCombos[beforeCombos.length - 1];
            graph.uncombo(targertCombo.id, false);
            break;
          case "layout":
            graph.updateLayout(data_2, void 0, void 0, false);
            break;
          default:
        }
      }
    };
    ToolBar3.prototype.zoomOut = function() {
      var graph = this.get("graph");
      var currentZoom = graph.getZoom();
      var ratioOut = 1 / (1 - DELTA2 * this.get("zoomSensitivity"));
      var maxZoom = this.get("maxZoom") || graph.get("maxZoom");
      if (ratioOut * currentZoom > maxZoom) {
        return;
      }
      graph.zoomTo(currentZoom * ratioOut);
    };
    ToolBar3.prototype.zoomIn = function() {
      var graph = this.get("graph");
      var currentZoom = graph.getZoom();
      var ratioIn = 1 - DELTA2 * this.get("zoomSensitivity");
      var minZoom = this.get("minZoom") || graph.get("minZoom");
      if (ratioIn * currentZoom < minZoom) {
        return;
      }
      graph.zoomTo(currentZoom * ratioIn);
    };
    ToolBar3.prototype.realZoom = function() {
      var graph = this.get("graph");
      graph.zoomTo(1);
    };
    ToolBar3.prototype.autoZoom = function() {
      var graph = this.get("graph");
      graph.fitView([20, 20]);
    };
    ToolBar3.prototype.handleDefaultOperator = function(code) {
      switch (code) {
        case "redo":
          this.redo();
          break;
        case "undo":
          this.undo();
          break;
        case "zoomOut":
          this.zoomOut();
          break;
        case "zoomIn":
          this.zoomIn();
          break;
        case "realZoom":
          this.realZoom();
          break;
        case "autoZoom":
          this.autoZoom();
          break;
        default:
      }
    };
    ToolBar3.prototype.destroy = function() {
      var toolBar = this.get("toolBar");
      if (toolBar) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        container.removeChild(toolBar);
      }
      var handleClick = this.get("handleClick");
      if (handleClick) {
        toolBar.removeEventListener("click", handleClick);
      }
    };
    return ToolBar3;
  }(base_default4)
);
var toolBar_default = ToolBar;

// node_modules/@antv/g6-plugin/es/tooltip/index.js
init_esm();
var import_insert_css3 = __toESM(require_insert_css());
var __extends10 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
typeof document !== "undefined" && (0, import_insert_css3.default)("\n  .g6-component-tooltip {\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    background-color: rgba(255, 255, 255, 0.9);\n    padding: 10px 8px;\n    box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n  }\n  .tooltip-type {\n    padding: 0;\n    margin: 0;\n  }\n  .tooltip-id {\n    color: #531dab;\n  }\n");
var Tooltip = (
  /** @class */
  function(_super) {
    __extends10(Tooltip3, _super);
    function Tooltip3(config) {
      return _super.call(this, config) || this;
    }
    Tooltip3.prototype.getDefaultCfgs = function() {
      return {
        offsetX: 6,
        offsetY: 6,
        // 指定菜单内容，function(e) {...}
        getContent: function getContent(e8) {
          return "\n          <h4 class='tooltip-type'>类型：".concat(e8.item.getType(), "</h4>\n          <span class='tooltip-id'>ID：").concat(e8.item.getID(), "</span>\n        ");
        },
        shouldBegin: function shouldBegin2(e8) {
          return true;
        },
        itemTypes: ["node", "edge", "combo"],
        trigger: "mouseenter",
        fixToNode: void 0
      };
    };
    Tooltip3.prototype.getEvents = function() {
      if (this.get("trigger") === "click") {
        return {
          "node:click": "onClick",
          "edge:click": "onClick",
          "combo:click": "onClick",
          "canvas:click": "onMouseLeave",
          afterremoveitem: "onMouseLeave",
          contextmenu: "onMouseLeave",
          drag: "onMouseLeave"
        };
      }
      return {
        "node:mouseenter": "onMouseEnter",
        "node:mouseleave": "onMouseLeave",
        "node:mousemove": "onMouseMove",
        "edge:mouseenter": "onMouseEnter",
        "edge:mouseleave": "onMouseLeave",
        "edge:mousemove": "onMouseMove",
        "combo:mouseenter": "onMouseEnter",
        "combo:mouseleave": "onMouseLeave",
        "combo:mousemove": "onMouseMove",
        afterremoveitem: "onMouseLeave",
        contextmenu: "onMouseLeave",
        "node:drag": "onMouseLeave"
      };
    };
    Tooltip3.prototype.init = function() {
      var self2 = this;
      var className = self2.get("className") || "g6-component-tooltip";
      var tooltip = createDom2("<div class='".concat(className, "'></div>"));
      var container = self2.get("container");
      if (!container) {
        container = self2.get("graph").get("container");
      }
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      modifyCSS(tooltip, {
        position: "absolute",
        visibility: "hidden",
        display: "none"
      });
      container.appendChild(tooltip);
      if (self2.get("trigger") !== "click") {
        tooltip.addEventListener("mouseenter", function(e8) {
          modifyCSS(tooltip, {
            visibility: "visible",
            display: "unset"
          });
        });
        tooltip.addEventListener("mouseleave", function(e8) {
          self2.hideTooltip();
        });
      }
      self2.set("tooltip", tooltip);
    };
    Tooltip3.prototype.onClick = function(e8) {
      var itemTypes = this.get("itemTypes");
      if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1) return;
      var item = e8.item;
      var graph = this.get("graph");
      if (this.currentTarget === item) {
        this.currentTarget = null;
        this.hideTooltip();
        graph.emit("tooltipchange", {
          item: e8.item,
          action: "hide"
        });
      } else {
        this.currentTarget = item;
        this.showTooltip(e8);
        graph.emit("tooltipchange", {
          item: e8.item,
          action: "show"
        });
      }
    };
    Tooltip3.prototype.onMouseEnter = function(e8) {
      var itemTypes = this.get("itemTypes");
      if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1) return;
      var item = e8.item;
      var graph = this.get("graph");
      this.currentTarget = item;
      this.showTooltip(e8);
      graph.emit("tooltipchange", {
        item: e8.item,
        action: "show"
      });
    };
    Tooltip3.prototype.onMouseMove = function(e8) {
      var itemTypes = this.get("itemTypes");
      if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1) return;
      if (!this.currentTarget || e8.item !== this.currentTarget) {
        return;
      }
      this.showTooltip(e8);
    };
    Tooltip3.prototype.onMouseLeave = function() {
      this.hideTooltip();
      var graph = this.get("graph");
      graph.emit("tooltipchange", {
        item: this.currentTarget,
        action: "hide"
      });
      this.currentTarget = null;
    };
    Tooltip3.prototype.clearContainer = function() {
      var container = this.get("tooltip");
      if (container) {
        container.innerHTML = "";
      }
    };
    Tooltip3.prototype.showTooltip = function(e8) {
      if (!e8.item) {
        return;
      }
      var itemTypes = this.get("itemTypes");
      if (e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1) return;
      var container = this.get("tooltip");
      var getContent = this.get("getContent");
      var tooltip = getContent(e8);
      if (is_string_default(tooltip)) {
        container.innerHTML = tooltip;
      } else {
        this.clearContainer();
        container.appendChild(tooltip);
      }
      this.updatePosition(e8);
    };
    Tooltip3.prototype.hideTooltip = function() {
      var tooltip = this.get("tooltip");
      if (tooltip) {
        modifyCSS(tooltip, {
          visibility: "hidden",
          display: "none"
        });
      }
    };
    Tooltip3.prototype.updatePosition = function(e8) {
      var shouldBegin2 = this.get("shouldBegin");
      var tooltip = this.get("tooltip");
      if (!shouldBegin2(e8)) {
        modifyCSS(tooltip, {
          visibility: "hidden",
          display: "none"
        });
        return;
      }
      var graph = this.get("graph");
      var width = graph.get("width");
      var height = graph.get("height");
      var offsetX = this.get("offsetX") || 0;
      var offsetY = this.get("offsetY") || 0;
      var point = graph.getPointByClient(e8.clientX, e8.clientY);
      var fixToNode = this.get("fixToNode");
      var item = e8.item;
      if (item.getType && item.getType() === "node" && fixToNode && is_array_default(fixToNode) && fixToNode.length >= 2) {
        var itemBBox = item.getBBox();
        point = {
          x: itemBBox.minX + itemBBox.width * fixToNode[0],
          y: itemBBox.minY + itemBBox.height * fixToNode[1]
        };
      }
      var _a2 = graph.getCanvasByPoint(point.x, point.y), x4 = _a2.x, y4 = _a2.y;
      var graphContainer = graph.getContainer();
      var res = {
        x: x4 + graphContainer.offsetLeft + offsetX,
        y: y4 + graphContainer.offsetTop + offsetY
      };
      modifyCSS(tooltip, {
        visibility: "visible",
        display: "unset"
      });
      var bbox = tooltip.getBoundingClientRect();
      if (x4 + bbox.width + offsetX > width) {
        res.x -= bbox.width + offsetX;
      }
      if (y4 + bbox.height + offsetY > height) {
        res.y -= bbox.height + offsetY;
        if (res.y < 0) {
          res.y = 0;
        }
      }
      modifyCSS(tooltip, {
        left: "".concat(res.x, "px"),
        top: "".concat(res.y, "px")
      });
    };
    Tooltip3.prototype.hide = function() {
      this.onMouseLeave();
    };
    Tooltip3.prototype.destroy = function() {
      var tooltip = this.get("tooltip");
      if (tooltip) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        container.removeChild(tooltip);
      }
    };
    return Tooltip3;
  }(base_default4)
);
var tooltip_default = Tooltip;

// node_modules/@antv/g6-plugin/es/timeBar/index.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/constant.js
var TIMELINE_START = "timebarstartplay";
var TIMELINE_END = "timebarendplay";
var VALUE_CHANGE = "valuechange";
var TIMEBAR_CONFIG_CHANGE = "timebarConfigChanged";
var PLAY_PAUSE_BTN = "playPauseBtn";
var NEXT_STEP_BTN = "nextStepBtn";
var PRE_STEP_BTN = "preStepBtn";

// node_modules/@antv/g6-plugin/es/timeBar/timeBarSlice.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/timeBarTooltip.js
init_esm();
var TimeBarTooltip = (
  /** @class */
  function() {
    function TimeBarTooltip2(cfg) {
      var _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, container = cfg.container, text = cfg.text, _c = cfg.padding, padding = _c === void 0 ? [4, 4, 4, 4] : _c, _d = cfg.className, className = _d === void 0 ? "g6-component-timebar-tooltip" : _d, _e2 = cfg.backgroundColor, backgroundColor = _e2 === void 0 ? "#000" : _e2, _f = cfg.textColor, textColor3 = _f === void 0 ? "#fff" : _f, _g = cfg.opacity, opacity = _g === void 0 ? 0.8 : _g, _h = cfg.fontSize, fontSize = _h === void 0 ? 12 : _h;
      this.container = container;
      this.className = className;
      this.backgroundColor = backgroundColor;
      this.textColor = textColor3;
      this.x = x4;
      this.y = y4;
      this.text = text;
      this.padding = padding;
      this.opacity = opacity;
      this.fontSize = fontSize;
      this.render();
    }
    TimeBarTooltip2.prototype.render = function() {
      var self2 = this;
      var className = self2.className, x4 = self2.x, y4 = self2.y, backgroundColor = self2.backgroundColor, textColor3 = self2.textColor, text = self2.text, padding = self2.padding, opacity = self2.opacity, fontSize = self2.fontSize;
      var parentNode = self2.container;
      var container = createDom2("<div class='".concat(className, `' style="position: absolute; width: fit-content; height: fit-content; opacity: `).concat(opacity, '"></div>'));
      if (is_string_default(parentNode)) {
        parentNode = document.getElementById(parentNode);
      }
      parentNode.appendChild(container);
      self2.parentHeight = parentNode.offsetHeight;
      self2.parentWidth = parentNode.offsetWidth;
      modifyCSS(container, {
        visibility: "hidden",
        top: 0,
        left: 0
      });
      var background = createDom2("\n      <div style='position: absolute; white-space:nowrap; background-color: ".concat(backgroundColor, "; font-size: ").concat(fontSize, "px; border-radius: 4px; width: fit-content; height: fit-content; color: ").concat(textColor3, "; padding: ").concat(padding[0], "px ").concat(padding[1], "px ").concat(padding[2], "px ").concat(padding[3], "px'></div>"));
      background.innerHTML = text;
      container.appendChild(background);
      self2.backgroundDOM = background;
      var arrow = createDom2("<div style='position: absolute; width: 0px; height: 0px; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 10px solid ".concat(backgroundColor, "'></div>"));
      container.appendChild(arrow);
      self2.arrowDOM = arrow;
      self2.container = container;
    };
    TimeBarTooltip2.prototype.show = function(cfg) {
      var self2 = this;
      var text = cfg.text, x4 = cfg.x, y4 = cfg.y, clientX = cfg.clientX, clientY = cfg.clientY;
      self2.backgroundDOM.innerHTML = text;
      var backgroundWidth = self2.backgroundDOM.offsetWidth;
      var backgroundHeight = self2.backgroundDOM.offsetHeight;
      var arrowWidth = self2.arrowDOM.offsetWidth;
      var arrowHeight = self2.arrowDOM.offsetHeight;
      modifyCSS(self2.container, {
        top: "".concat(-backgroundHeight - arrowHeight, "px"),
        left: "".concat(x4, "px"),
        visibility: "visible"
      });
      modifyCSS(self2.backgroundDOM, {
        marginLeft: "".concat(-backgroundWidth / 2, "px")
      });
      modifyCSS(self2.arrowDOM, {
        marginLeft: "".concat(-arrowWidth / 2, "px"),
        top: "".concat(backgroundHeight, "px")
      });
      var left = x4 - backgroundWidth / 2;
      var right = x4 + backgroundWidth / 2;
      if (left < 0) {
        modifyCSS(self2.backgroundDOM, {
          marginLeft: "".concat(-backgroundWidth / 2 - left, "px")
        });
      } else if (right > self2.parentWidth) {
        modifyCSS(self2.backgroundDOM, {
          marginLeft: "".concat(-backgroundWidth / 2 - right + self2.parentWidth + 12, "px")
        });
      }
    };
    TimeBarTooltip2.prototype.hide = function() {
      modifyCSS(this.container, {
        top: 0,
        left: 0,
        visibility: "hidden"
      });
    };
    return TimeBarTooltip2;
  }()
);
var timeBarTooltip_default = TimeBarTooltip;

// node_modules/@antv/g6-plugin/es/timeBar/controllerBtn.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/timeButton.js
init_esm();
var __assign7 = function() {
  __assign7 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign7.apply(this, arguments);
};
var Button = (
  /** @class */
  function() {
    function Button2(cfg) {
      this.config = deep_mix_default({}, cfg);
      this.init();
    }
    Button2.prototype.update = function(cfg) {
      this.config = deep_mix_default({}, this.config, cfg);
      this.updateElement();
      this.renderMarker();
    };
    Button2.prototype.init = function() {
      this.initElement();
      this.renderMarker();
    };
    Button2.prototype.initElement = function() {
      var _a2 = this.config, group = _a2.group, style = _a2.style;
      var _b = style.scale, scale12 = _b === void 0 ? 1 : _b, _c = style.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = style.offsetY, offsetY = _d === void 0 ? 0 : _d;
      var x4 = this.config.x + offsetX;
      var y4 = this.config.y + offsetY;
      var buttonGroup = group.addGroup({
        name: PLAY_PAUSE_BTN
      });
      this.startMarkerGroup = buttonGroup.addGroup({
        name: PLAY_PAUSE_BTN
      });
      this.circle = group.addShape("circle", {
        attrs: __assign7({
          x: x4,
          y: y4,
          r: this.config.r * scale12
        }, style),
        name: PLAY_PAUSE_BTN
      });
      this.startMarker = this.startMarkerGroup.addShape("path", {
        attrs: {
          path: this.getStartMarkerPath(x4, y4, scale12),
          fill: style.stroke || "#aaa"
        },
        name: "start-marker"
      });
      this.pauseMarkerGroup = buttonGroup.addGroup({
        name: PLAY_PAUSE_BTN
      });
      var width = 0.25 * this.config.r * scale12;
      var height = 0.5 * this.config.r * Math.sqrt(3) * scale12;
      this.pauseLeftMarker = this.pauseMarkerGroup.addShape("rect", {
        attrs: {
          x: x4 - 0.375 * this.config.r * scale12,
          y: y4 - height / 2,
          width,
          height,
          fill: style.stroke || "#aaa",
          lineWidth: 0
        }
      });
      this.pauseRightMarker = this.pauseMarkerGroup.addShape("rect", {
        attrs: {
          x: x4 + 1 / 8 * this.config.r * scale12,
          y: y4 - height / 2,
          width,
          height,
          fill: style.stroke || "#aaa",
          lineWidth: 0
        }
      });
    };
    Button2.prototype.updateElement = function() {
      var _a2 = this.config.style, _b = _a2.scale, scale12 = _b === void 0 ? 1 : _b, _c = _a2.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _a2.offsetY, offsetY = _d === void 0 ? 0 : _d;
      var x4 = this.config.x + offsetX;
      var y4 = this.config.y + offsetY;
      this.circle.attr("x", x4);
      this.circle.attr("y", y4);
      this.circle.attr("r", this.config.r * scale12);
      this.startMarker.attr("path", this.getStartMarkerPath(x4, y4, scale12));
      var width = 0.25 * this.config.r * scale12;
      var height = 0.5 * this.config.r * Math.sqrt(3) * scale12;
      this.pauseLeftMarker.attr("x", x4 - (1 / 4 + 1 / 8) * this.config.r * scale12);
      this.pauseLeftMarker.attr("y", y4 - height / 2);
      this.pauseLeftMarker.attr("width", width);
      this.pauseLeftMarker.attr("height", height);
      this.pauseRightMarker.attr("x", x4 + 1 / 8 * this.config.r * scale12);
      this.pauseRightMarker.attr("y", y4 - height / 2);
      this.pauseRightMarker.attr("width", width);
      this.pauseRightMarker.attr("height", height);
    };
    Button2.prototype.renderMarker = function() {
      if (this.config.isPlay) {
        this.startMarkerGroup.hide();
        this.pauseMarkerGroup.show();
      } else {
        this.startMarkerGroup.show();
        this.pauseMarkerGroup.hide();
      }
    };
    Button2.prototype.getStartMarkerPath = function(x4, y4, scale12) {
      var sideLength = 0.5 * this.config.r * Math.sqrt(3) * scale12;
      return [["M", x4 - sideLength / Math.sqrt(3) / 2, y4 - sideLength / 2], ["L", x4 + sideLength / Math.sqrt(3), y4], ["L", x4 - sideLength / Math.sqrt(3) / 2, y4 + sideLength / 2]];
    };
    return Button2;
  }()
);
var timeButton_default = Button;

// node_modules/@antv/g6-plugin/es/timeBar/controllerBtn.js
var __assign8 = function() {
  __assign8 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign8.apply(this, arguments);
};
var transform12 = ext_exports.transform;
var DEFAULT_RECT_FILL = "#aaa";
var DEFAULT_RECT_STROKE = "green";
var DEFAULT_PLAYBTN_STYLE = {
  fill: "#aaa",
  fillOpacity: 0.35,
  stroke: "#aaa"
};
var DEFAULT_PREBTN_STYLE = {
  fill: "#fff"
};
var DEFAULT_NEXTBTN_STYLE = {
  fill: "green"
};
var DEFAULT_SPEED_CONTROLLER_STYLE = {
  pointer: {
    fill: "#aaa",
    lineWidth: 0
  },
  scroller: {
    stroke: "#aaa",
    fill: "#aaa",
    lineWidth: 1,
    lineAppendWidth: 5,
    cursor: "pointer"
  },
  text: {
    fill: "#aaa",
    textBaseline: "top"
  }
};
var DEFAULT_TIMETYPE_CONTROLLER_STYLE = {
  check: {
    stroke: "green",
    lineWidth: 3
  },
  box: {
    fill: "#fff",
    stroke: "#aaa",
    lineWidth: 2,
    radius: 3,
    width: 12,
    height: 12
  },
  text: {
    fill: "#aaa",
    fontSize: 12,
    textBaseline: "top"
  }
};
var DEFAULT_CONTROLLER_CONFIG = {
  speed: 1,
  loop: false,
  fill: "#fff",
  stroke: "#fff",
  hideTimeTypeController: false,
  preBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa"
  },
  nextBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa"
  },
  playBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa",
    fillOpacity: 0.05
  },
  speedControllerStyle: DEFAULT_SPEED_CONTROLLER_STYLE,
  timeTypeControllerStyle: DEFAULT_TIMETYPE_CONTROLLER_STYLE
};
var SPEED_CONTROLLER_OFFSET = 110;
var TOGGLE_MODEL_OFFSET = 50;
var TIME_TYPE = {
  SINGLE: "single",
  RANGE: "range"
};
var ControllerBtn = (
  /** @class */
  function() {
    function ControllerBtn2(cfg) {
      this.controllerCfg = deep_mix_default({}, DEFAULT_CONTROLLER_CONFIG, cfg);
      this.group = cfg.group;
      this.controllerGroup = this.group.addGroup({
        name: "controller-group"
      });
      this.speedAxisY = [];
      this.currentSpeed = this.controllerCfg.speed;
      this.currentType = this.controllerCfg.defaultTimeType || TIME_TYPE.RANGE;
      this.fontFamily = cfg.fontFamily || "Arial, sans-serif";
      this.init();
    }
    ControllerBtn2.prototype.init = function() {
      this.renderPlayButton();
    };
    ControllerBtn2.prototype.getNextMarkerPath = function(x4, y4, len6) {
      return [["M", x4, y4 - len6], ["L", x4 + len6, y4], ["L", x4, y4 + len6], ["Z", x4, y4 - len6], ["M", x4, y4], ["L", x4 - len6, y4 - len6], ["L", x4 - len6, y4 + len6], ["Z"]];
    };
    ControllerBtn2.prototype.getPreMarkerPath = function(x4, y4, len6) {
      return [["M", x4, y4 - len6], ["L", x4 - len6, y4], ["L", x4, y4 + len6], ["L", x4, y4 - len6], ["M", x4, y4], ["L", x4 + len6, y4 - len6], ["L", x4 + len6, y4 + len6], ["Z"]];
    };
    ControllerBtn2.prototype.renderPlayButton = function() {
      var controllerCfg = this.controllerCfg;
      var width = controllerCfg.width, height = controllerCfg.height, x4 = controllerCfg.x, y4 = controllerCfg.y, hideTimeTypeController = controllerCfg.hideTimeTypeController, _a2 = controllerCfg.fill, fill = _a2 === void 0 ? DEFAULT_RECT_FILL : _a2, _b = controllerCfg.stroke, stroke = _b === void 0 ? DEFAULT_RECT_STROKE : _b, _c = controllerCfg.containerStyle, containerStyle = _c === void 0 ? {} : _c;
      var playBtnStyle = __assign8(__assign8({}, DEFAULT_PLAYBTN_STYLE), controllerCfg.playBtnStyle || {});
      var preBtnStyle = __assign8(__assign8({}, DEFAULT_PREBTN_STYLE), controllerCfg.preBtnStyle || {});
      var nextBtnStyle = __assign8(__assign8({}, DEFAULT_NEXTBTN_STYLE), controllerCfg.nextBtnStyle || {});
      var r2 = height / 2 - 5;
      var realY = y4 + 10;
      var container = this.controllerGroup.addShape("rect", {
        attrs: __assign8({
          x: x4,
          y: realY,
          width,
          height,
          stroke,
          fill
        }, containerStyle),
        name: "container-rect"
      });
      if (this.playButton) {
        this.playButton.update({
          x: width / 2,
          y: realY,
          r: r2
        });
      } else {
        this.playButton = new timeButton_default({
          group: this.controllerGroup,
          x: width / 2,
          y: realY + r2 + 5,
          r: r2,
          isPlay: this.isPlay,
          style: playBtnStyle
        });
      }
      var prePaddingX = preBtnStyle.offsetX || 0;
      var prePaddingY = preBtnStyle.offsetY || 0;
      var preR = (preBtnStyle.scale || 1) * r2;
      this.controllerGroup.addShape("path", {
        attrs: __assign8({
          path: this.getPreMarkerPath(width / 2 - 5 * r2 + prePaddingX, realY + r2 + 5 + prePaddingY, preR * 0.5)
        }, preBtnStyle),
        name: PRE_STEP_BTN
      });
      var nxtPaddingX = nextBtnStyle.offsetX || 0;
      var nxtPaddingY = nextBtnStyle.offsetY || 0;
      var nxtR = (nextBtnStyle.scale || 1) * r2;
      this.controllerGroup.addShape("path", {
        attrs: __assign8({
          path: this.getNextMarkerPath(width / 2 + 5 * r2 + nxtPaddingX, realY + r2 + 5 + nxtPaddingY, nxtR * 0.5)
        }, nextBtnStyle),
        name: NEXT_STEP_BTN
      });
      container.toBack();
      this.renderSpeedBtn();
      if (!hideTimeTypeController) {
        this.renderToggleTime();
      }
      this.bindEvent();
      var _d = this.controllerCfg.scale, scale12 = _d === void 0 ? 1 : _d;
      var currentBBox = this.controllerGroup.getCanvasBBox();
      var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
      var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
      var matrix = transform12([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -centerX, -centerY], ["s", scale12, scale12], ["t", centerX, centerY]]);
      this.controllerGroup.setMatrix(matrix);
    };
    ControllerBtn2.prototype.renderSpeedBtn = function() {
      var _a2 = this.controllerCfg, y4 = _a2.y, width = _a2.width, hideTimeTypeController = _a2.hideTimeTypeController;
      var speedControllerStyle = __assign8(__assign8({}, DEFAULT_SPEED_CONTROLLER_STYLE), this.controllerCfg.speedControllerStyle || {});
      var _b = speedControllerStyle.scroller, scroller = _b === void 0 ? {} : _b, _c = speedControllerStyle.text, text = _c === void 0 ? {} : _c, _d = speedControllerStyle.pointer, pointer = _d === void 0 ? {} : _d, _e2 = speedControllerStyle.scale, scale12 = _e2 === void 0 ? 1 : _e2, _f = speedControllerStyle.offsetX, offsetX = _f === void 0 ? 0 : _f, _g = speedControllerStyle.offsetY, offsetY = _g === void 0 ? 0 : _g;
      var speedGroup = this.controllerGroup.addGroup({
        name: "speed-group"
      });
      this.speedGroup = speedGroup;
      var speedNum = [];
      var maxSpeed = 5;
      this.speedAxisY = [19, 22, 26, 32, 39];
      for (var i2 = 0; i2 < 5; i2++) {
        var axisY = y4 + this.speedAxisY[i2];
        var startX = width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET);
        speedGroup.addShape("line", {
          attrs: __assign8({
            x1: startX,
            x2: startX + 15,
            y1: axisY,
            y2: axisY
          }, scroller),
          speed: maxSpeed,
          name: "speed-rect"
        });
        this.speedAxisY[i2] = axisY;
        speedNum.push(maxSpeed);
        maxSpeed = maxSpeed - 1;
      }
      this.speedText = speedGroup.addShape("text", {
        attrs: __assign8({
          x: width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET) + 20,
          y: this.speedAxisY[0] + 4,
          text: "1.0X",
          fontFamily: this.fontFamily || "Arial, sans-serif"
        }, text),
        name: "speed-text"
      });
      this.speedPoint = speedGroup.addShape("path", {
        attrs: __assign8({
          path: this.getPointerPath(width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET), 0),
          matrix: [1, 0, 0, 0, 1, 0, 0, this.speedAxisY[4], 1]
        }, pointer),
        name: "speed-pointer"
      });
      var currentBBox = this.speedGroup.getCanvasBBox();
      var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
      var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
      var matrix = this.speedGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      matrix = transform12(matrix, [["t", -centerX, -centerY], ["s", scale12, scale12], ["t", centerX + offsetX * scale12, centerY + offsetY * scale12]]);
      this.speedGroup.setMatrix(matrix);
    };
    ControllerBtn2.prototype.getPointerPath = function(x4, y4) {
      return [["M", x4, y4], ["L", x4 - 10, y4 - 4], ["L", x4 - 10, y4 + 4], ["Z"]];
    };
    ControllerBtn2.prototype.renderToggleTime = function() {
      var _a2, _b;
      var _c = this.controllerCfg, width = _c.width, defaultTimeType = _c.defaultTimeType;
      var timeTypeControllerStyle = __assign8(__assign8({}, DEFAULT_TIMETYPE_CONTROLLER_STYLE), this.controllerCfg.timeTypeControllerStyle || {});
      var _d = timeTypeControllerStyle.scale, scale12 = _d === void 0 ? 1 : _d, _e2 = timeTypeControllerStyle.offsetX, offsetX = _e2 === void 0 ? 0 : _e2, _f = timeTypeControllerStyle.offsetY, offsetY = _f === void 0 ? 0 : _f, _g = timeTypeControllerStyle.box, box2 = _g === void 0 ? {} : _g, _h = timeTypeControllerStyle.check, check = _h === void 0 ? {} : _h, _j = timeTypeControllerStyle.text, text = _j === void 0 ? {} : _j;
      this.toggleGroup = this.controllerGroup.addGroup({
        name: "toggle-group"
      });
      var isChecked = defaultTimeType === TIME_TYPE.SINGLE;
      this.toggleGroup.addShape("rect", {
        attrs: __assign8({
          x: width - TOGGLE_MODEL_OFFSET,
          y: this.speedAxisY[0] + 3.5
        }, box2),
        isChecked,
        name: "toggle-model"
      });
      this.checkedIcon = this.toggleGroup.addShape("path", {
        attrs: __assign8({
          path: [["M", width - TOGGLE_MODEL_OFFSET + 3, this.speedAxisY[1] + 6], ["L", width - TOGGLE_MODEL_OFFSET + 7, this.speedAxisY[1] + 10], ["L", width - TOGGLE_MODEL_OFFSET + 12, this.speedAxisY[1] + 4]]
        }, check),
        capture: false,
        name: "check-icon"
      });
      if (!isChecked) this.checkedIcon.hide();
      this.checkedText = this.toggleGroup.addShape("text", {
        attrs: __assign8({
          text: isChecked ? ((_a2 = this.controllerCfg) === null || _a2 === void 0 ? void 0 : _a2.timeRangeControllerText) || "时间范围" : ((_b = this.controllerCfg) === null || _b === void 0 ? void 0 : _b.timePointControllerText) || "单一时间",
          x: width - TOGGLE_MODEL_OFFSET + 15,
          y: this.speedAxisY[0] + 4,
          fontFamily: typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif"
        }, text),
        name: "checked-text"
      });
      var currentBBox = this.toggleGroup.getCanvasBBox();
      var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
      var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
      var matrix = this.toggleGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      matrix = transform12(matrix, [["t", -centerX, -centerY], ["s", scale12, scale12], ["t", centerX + offsetX * scale12, centerY + offsetY * scale12]]);
      this.toggleGroup.setMatrix(matrix);
    };
    ControllerBtn2.prototype.bindEvent = function() {
      var _this = this;
      this.speedGroup.on("speed-rect:click", function(evt) {
        var currentPointerY = evt.target.attr("y1");
        var pointerMatrix = _this.speedPoint.attr("matrix");
        var currentYIdx = _this.speedAxisY.indexOf(pointerMatrix[7] || 0);
        var targetYIdx = _this.speedAxisY.indexOf(currentPointerY);
        var yDiff = _this.speedAxisY[targetYIdx] - _this.speedAxisY[currentYIdx];
        pointerMatrix = transform12(pointerMatrix, [["t", 0, yDiff]]);
        _this.speedPoint.setMatrix(pointerMatrix);
        _this.currentSpeed = _this.speedAxisY.length - targetYIdx;
        _this.speedText.attr("text", "".concat(_this.currentSpeed, ".0X"));
        _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
          speed: _this.currentSpeed,
          type: _this.currentType
        });
      });
      this.speedGroup.on("mousewheel", function(evt) {
        evt.preventDefault();
        var pointerMatrix = _this.speedPoint.attr("matrix") || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        var currentPointerY = pointerMatrix[7];
        var currentYIdx = _this.speedAxisY.indexOf(currentPointerY);
        if (currentYIdx === -1) {
          var minDist_1 = Infinity;
          _this.speedAxisY.forEach(function(y4, idx) {
            var dist4 = Math.abs(y4 - currentPointerY);
            if (minDist_1 > dist4) {
              minDist_1 = dist4;
              currentYIdx = idx;
            }
          });
        }
        if (evt.originalEvent.deltaY > 0) currentYIdx = Math.max(0, currentYIdx - 1);
        else currentYIdx = Math.min(_this.speedAxisY.length - 1, currentYIdx + 1);
        var yDiff = _this.speedAxisY[currentYIdx] - currentPointerY;
        pointerMatrix = transform12(pointerMatrix, [["t", 0, yDiff]]);
        _this.speedPoint.setMatrix(pointerMatrix);
        _this.currentSpeed = _this.speedAxisY.length - currentYIdx;
        _this.speedText.attr("text", "".concat(_this.currentSpeed, ".0X"));
        _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
          speed: _this.currentSpeed,
          type: _this.currentType
        });
      });
      if (this.toggleGroup) {
        this.toggleGroup.on("toggle-model:click", function(evt) {
          var _a2, _b;
          var isChecked = evt.target.get("isChecked");
          if (!isChecked) {
            _this.checkedIcon.show();
            _this.checkedText.attr("text", ((_a2 = _this.controllerCfg) === null || _a2 === void 0 ? void 0 : _a2.timeRangeControllerText) || "时间范围");
            _this.currentType = TIME_TYPE.SINGLE;
          } else {
            _this.checkedIcon.hide();
            _this.checkedText.attr("text", ((_b = _this.controllerCfg) === null || _b === void 0 ? void 0 : _b.timePointControllerText) || "单一时间");
            _this.currentType = TIME_TYPE.RANGE;
          }
          evt.target.set("isChecked", !isChecked);
          _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
            type: _this.currentType,
            speed: _this.currentSpeed
          });
        });
      }
    };
    ControllerBtn2.prototype.destroy = function() {
      this.speedGroup.off("speed-rect:click");
      if (this.toggleGroup) {
        this.toggleGroup.off("toggle-model:click");
        this.toggleGroup.destroy();
      }
      this.speedGroup.destroy();
    };
    return ControllerBtn2;
  }()
);
var controllerBtn_default = ControllerBtn;

// node_modules/@antv/g6-plugin/es/timeBar/timeBarSlice.js
var __assign9 = function() {
  __assign9 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign9.apply(this, arguments);
};
var transform13 = ext_exports.transform;
var DEFAULT_SELECTEDTICK_STYLE = {
  fill: "#5B8FF9"
};
var DEFAULT_UNSELECTEDTICK_STYLE = {
  fill: "#e6e8e9"
};
var TimeBarSlice = (
  /** @class */
  function() {
    function TimeBarSlice2(cfgs) {
      this.frameCount = 0;
      this.fontFamily = "Arial, sans-serif";
      var graph = cfgs.graph, canvas = cfgs.canvas, group = cfgs.group, width = cfgs.width, height = cfgs.height, padding = cfgs.padding, data = cfgs.data, start = cfgs.start, end2 = cfgs.end, _a2 = cfgs.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfgs.y, y4 = _b === void 0 ? 0 : _b, tickLabelFormatter = cfgs.tickLabelFormatter, _c = cfgs.selectedTickStyle, selectedTickStyle = _c === void 0 ? DEFAULT_SELECTEDTICK_STYLE : _c, _d = cfgs.unselectedTickStyle, unselectedTickStyle = _d === void 0 ? DEFAULT_UNSELECTEDTICK_STYLE : _d, tooltipBackgroundColor = cfgs.tooltipBackgroundColor, tooltipFomatter = cfgs.tooltipFomatter, tickLabelStyle = cfgs.tickLabelStyle, _e2 = cfgs.controllerCfg, controllerCfg = _e2 === void 0 ? {
        speed: 1
      } : _e2;
      this.graph = graph;
      this.group = group;
      this.sliceGroup = group.addGroup({
        name: "slice-group"
      });
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this.padding = padding;
      this.data = data;
      this.start = start;
      this.end = end2;
      this.tickLabelFormatter = tickLabelFormatter;
      this.tickLabelStyle = tickLabelStyle || {};
      this.selectedTickStyle = selectedTickStyle;
      this.unselectedTickStyle = unselectedTickStyle;
      this.controllerCfg = controllerCfg;
      this.currentSpeed = controllerCfg.speed || 1;
      this.x = x4;
      this.y = y4;
      this.tooltipBackgroundColor = tooltipBackgroundColor;
      this.tooltipFomatter = tooltipFomatter;
      this.fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
      this.renderSlices();
      this.initEvent();
    }
    TimeBarSlice2.prototype.renderSlices = function() {
      var _this = this;
      var _a2 = this, width = _a2.width, height = _a2.height, padding = _a2.padding, data = _a2.data, start = _a2.start, end2 = _a2.end, tickLabelFormatter = _a2.tickLabelFormatter, selectedTickStyle = _a2.selectedTickStyle, unselectedTickStyle = _a2.unselectedTickStyle, tickLabelStyle = _a2.tickLabelStyle;
      var realWidth = width - 2 * padding;
      var fontSize = 10;
      var labelLineHeight = 4;
      var labelAreaHeight = 3 * padding + labelLineHeight + fontSize;
      var ticksAreaHeight = height - labelAreaHeight - 2 * padding;
      var gap = 2;
      var ticksLength = data.length;
      var tickWidth = (realWidth - gap * (ticksLength - 1)) / ticksLength;
      this.tickWidth = tickWidth;
      var sliceGroup = this.sliceGroup;
      var tickRects = [];
      var labels = [];
      var startTickId = Math.round(ticksLength * start);
      var endTickId = Math.round(ticksLength * end2);
      this.startTickRectId = startTickId;
      this.endTickRectId = endTickId;
      var rotate9 = tickLabelStyle.rotate;
      delete tickLabelStyle.rotate;
      data.forEach(function(d2, i2) {
        var selected = i2 >= startTickId && i2 <= endTickId;
        var tickStyle = selected ? selectedTickStyle : unselectedTickStyle;
        var rect2 = sliceGroup.addShape("rect", {
          attrs: __assign9({
            x: padding + i2 * (tickWidth + gap),
            y: padding,
            width: tickWidth,
            height: ticksAreaHeight
          }, tickStyle),
          draggable: true,
          name: "tick-rect-".concat(i2)
        });
        var pickRect = sliceGroup.addShape("rect", {
          attrs: {
            x: padding + i2 * tickWidth + gap * (2 * i2 - 1) / 2,
            y: padding,
            width: i2 === 0 || i2 === ticksLength - 1 ? tickWidth + gap / 2 : tickWidth + gap,
            height: ticksAreaHeight,
            fill: "#fff",
            opacity: 0
          },
          draggable: true,
          name: "pick-rect-".concat(i2)
        });
        pickRect.toFront();
        var rectBBox = rect2.getBBox();
        var centerX = (rectBBox.minX + rectBBox.maxX) / 2;
        tickRects.push({
          rect: rect2,
          pickRect,
          value: d2.date,
          x: centerX,
          y: rectBBox.minY
        });
        var label;
        if (tickLabelFormatter) {
          label = tickLabelFormatter(d2);
          if (!is_string_default(label) && label) {
            label = d2.date;
          }
        } else if (i2 % Math.round(ticksLength / 10) === 0) {
          label = d2.date;
        }
        if (label) {
          labels.push(label);
          var lineStartY = rectBBox.maxY + padding * 2;
          sliceGroup.addShape("line", {
            attrs: {
              stroke: "#BFBFBF",
              x1: centerX,
              y1: lineStartY,
              x2: centerX,
              y2: lineStartY + labelLineHeight
            },
            name: "tick-line"
          });
          var labelStartY = lineStartY + labelLineHeight + padding;
          var text = sliceGroup.addShape("text", {
            attrs: __assign9({
              fill: "#8c8c8c",
              stroke: "#fff",
              lineWidth: 1,
              x: centerX,
              y: labelStartY,
              textAlign: "center",
              text: label,
              textBaseline: "top",
              fontSize: 10,
              fontFamily: _this.fontFamily || "Arial, sans-serif"
            }, tickLabelStyle),
            capture: false,
            name: "tick-label"
          });
          var textBBox = text.getBBox();
          if (textBBox.maxX > width) {
            text.attr("textAlign", "right");
          } else if (textBBox.minX < 0) {
            text.attr("textAlign", "left");
          }
          if (is_number_default(rotate9) && labels.length !== 10) {
            var matrix = transform13([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -centerX, -labelStartY], ["r", rotate9], ["t", centerX - 5, labelStartY + 2]]);
            text.attr({
              textAlign: "left",
              matrix
            });
          }
          if (labels.length === 1) {
            text.attr({
              textAlign: "left"
            });
          } else if (labels.length === 10) {
            text.attr({
              textAlign: "right"
            });
          }
        }
      });
      this.tickRects = tickRects;
      var group = this.group;
      this.currentSpeed = 1;
      this.controllerBtnGroup = new controllerBtn_default(__assign9({
        group,
        x: this.x,
        y: this.y + height + 5,
        width,
        height: 40,
        hideTimeTypeController: true,
        speed: this.currentSpeed,
        fontFamily: this.fontFamily || "Arial, sans-serif"
      }, this.controllerCfg));
    };
    TimeBarSlice2.prototype.initEvent = function() {
      var _this = this;
      var sliceGroup = this.sliceGroup;
      sliceGroup.on("click", function(e8) {
        var targetRect = e8.target;
        if (targetRect.get("type") !== "rect" || !targetRect.get("name")) return;
        var id = parseInt(targetRect.get("name").split("-")[2], 10);
        if (!isNaN(id)) {
          var tickRects_1 = _this.tickRects;
          var unselectedTickStyle_1 = _this.unselectedTickStyle;
          tickRects_1.forEach(function(tickRect) {
            tickRect.rect.attr(unselectedTickStyle_1);
          });
          var selectedTickStyle = _this.selectedTickStyle;
          tickRects_1[id].rect.attr(selectedTickStyle);
          _this.startTickRectId = id;
          _this.endTickRectId = id;
          var ticksLength = tickRects_1.length;
          var start = id / ticksLength;
          _this.graph.emit(VALUE_CHANGE, {
            value: [start, start]
          });
        }
      });
      sliceGroup.on("dragstart", function(e8) {
        var tickRects2 = _this.tickRects;
        var unselectedTickStyle = _this.unselectedTickStyle;
        tickRects2.forEach(function(tickRect) {
          tickRect.rect.attr(unselectedTickStyle);
        });
        var targetRect = e8.target;
        var id = parseInt(targetRect.get("name").split("-")[2], 10);
        var selectedTickStyle = _this.selectedTickStyle;
        tickRects2[id].rect.attr(selectedTickStyle);
        _this.startTickRectId = id;
        var ticksLength = tickRects2.length;
        var start = id / ticksLength;
        _this.graph.emit(VALUE_CHANGE, {
          value: [start, start]
        });
        _this.dragging = true;
      });
      sliceGroup.on("dragover", function(e8) {
        if (!_this.dragging) return;
        if (e8.target.get("type") !== "rect") return;
        var id = parseInt(e8.target.get("name").split("-")[2], 10);
        var startTickRectId = _this.startTickRectId;
        var tickRects2 = _this.tickRects;
        var selectedTickStyle = _this.selectedTickStyle;
        var unselectedTickStyle = _this.unselectedTickStyle;
        for (var i2 = 0; i2 < tickRects2.length; i2++) {
          var style = i2 >= startTickRectId && i2 <= id ? selectedTickStyle : unselectedTickStyle;
          tickRects2[i2].rect.attr(style);
        }
        var ticksLength = tickRects2.length;
        _this.endTickRectId = id;
        var start = startTickRectId / ticksLength;
        var end2 = id / ticksLength;
        _this.graph.emit(VALUE_CHANGE, {
          value: [start, end2]
        });
      });
      sliceGroup.on("drop", function(e8) {
        if (!_this.dragging) return;
        _this.dragging = false;
        if (e8.target.get("type") !== "rect") return;
        var startTickRectId = _this.startTickRectId;
        var id = parseInt(e8.target.get("name").split("-")[2], 10);
        if (id < startTickRectId) return;
        var selectedTickStyle = _this.selectedTickStyle;
        var tickRects2 = _this.tickRects;
        tickRects2[id].rect.attr(selectedTickStyle);
        _this.endTickRectId = id;
        var ticksLength = tickRects2.length;
        var start = startTickRectId / ticksLength;
        var end2 = id / ticksLength;
        _this.graph.emit(VALUE_CHANGE, {
          value: [start, end2]
        });
      });
      var _a2 = this, tooltipBackgroundColor = _a2.tooltipBackgroundColor, tooltipFomatter = _a2.tooltipFomatter, canvas = _a2.canvas;
      var tooltip = new timeBarTooltip_default({
        container: canvas.get("container"),
        backgroundColor: tooltipBackgroundColor
      });
      var tickRects = this.tickRects;
      tickRects.forEach(function(tickRect) {
        var pickRect = tickRect.pickRect;
        pickRect.on("mouseenter", function(e8) {
          var rect2 = e8.target;
          if (rect2.get("type") !== "rect") return;
          var id = parseInt(rect2.get("name").split("-")[2], 10);
          var clientPoint = canvas.getClientByPoint(tickRects[id].x, tickRects[id].y);
          tooltip.show({
            x: tickRects[id].x,
            y: tickRects[id].y,
            clientX: clientPoint.x,
            clientY: clientPoint.y,
            text: tooltipFomatter ? tooltipFomatter(tickRects[id].value) : tickRects[id].value
          });
        });
        pickRect.on("mouseleave", function(e8) {
          tooltip.hide();
        });
      });
      var group = this.group;
      group.on("".concat(PLAY_PAUSE_BTN, ":click"), function() {
        _this.isPlay = !_this.isPlay;
        _this.changePlayStatus();
      });
      group.on("".concat(NEXT_STEP_BTN, ":click"), function() {
        _this.updateStartEnd(1);
      });
      group.on("".concat(PRE_STEP_BTN, ":click"), function() {
        _this.updateStartEnd(-1);
      });
      group.on(TIMEBAR_CONFIG_CHANGE, function(_a3) {
        var type = _a3.type, speed = _a3.speed;
        _this.currentSpeed = speed;
      });
    };
    TimeBarSlice2.prototype.changePlayStatus = function(isSync) {
      if (isSync === void 0) {
        isSync = true;
      }
      this.controllerBtnGroup.playButton.update({
        isPlay: this.isPlay
      });
      if (this.isPlay) {
        this.playHandler = this.startPlay();
        this.graph.emit(TIMELINE_START, null);
      } else {
        if (this.playHandler) {
          if (typeof window !== "undefined") window.cancelAnimationFrame(this.playHandler);
          if (isSync) {
            this.graph.emit(TIMELINE_END, null);
          }
        }
      }
    };
    TimeBarSlice2.prototype.startPlay = function() {
      var _this = this;
      return typeof window !== "undefined" ? window.requestAnimationFrame(function() {
        var speed = _this.currentSpeed;
        if (_this.frameCount % (60 / speed) === 0) {
          _this.frameCount = 0;
          _this.updateStartEnd(1);
        }
        _this.frameCount++;
        if (_this.isPlay) {
          _this.playHandler = _this.startPlay();
        }
      }) : void 0;
    };
    TimeBarSlice2.prototype.updateStartEnd = function(sign) {
      var self2 = this;
      var tickRects = this.tickRects;
      var ticksLength = tickRects.length;
      var unselectedTickStyle = this.unselectedTickStyle;
      var selectedTickStyle = this.selectedTickStyle;
      var previousEndTickRectId = self2.endTickRectId;
      if (sign > 0) {
        self2.endTickRectId++;
      } else {
        tickRects[self2.endTickRectId].rect.attr(unselectedTickStyle);
        self2.endTickRectId--;
      }
      if (previousEndTickRectId !== self2.startTickRectId) {
        if (self2.endTickRectId < self2.startTickRectId) {
          self2.startTickRectId = self2.endTickRectId;
        }
      } else {
        for (var i2 = self2.startTickRectId; i2 <= self2.endTickRectId - 1; i2++) {
          tickRects[i2].rect.attr(unselectedTickStyle);
        }
        self2.startTickRectId = self2.endTickRectId;
      }
      if (tickRects[self2.endTickRectId]) {
        tickRects[self2.endTickRectId].rect.attr(selectedTickStyle);
        var start = self2.startTickRectId / ticksLength;
        var end2 = self2.endTickRectId / ticksLength;
        this.graph.emit(VALUE_CHANGE, {
          value: [start, end2]
        });
      }
    };
    TimeBarSlice2.prototype.destory = function() {
      var group = this.sliceGroup;
      group.off("click");
      group.off("dragstart");
      group.off("dragover");
      group.off("drop");
      this.tickRects.forEach(function(tickRect) {
        var pickRect = tickRect.pickRect;
        pickRect.off("mouseenter");
        pickRect.off("mouseleave");
      });
      this.tickRects.length = 0;
      group.off("".concat(PLAY_PAUSE_BTN, ":click"));
      group.off("".concat(NEXT_STEP_BTN, ":click"));
      group.off("".concat(PRE_STEP_BTN, ":click"));
      group.off(TIMEBAR_CONFIG_CHANGE);
      this.sliceGroup.destroy();
    };
    return TimeBarSlice2;
  }()
);
var timeBarSlice_default = TimeBarSlice;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
init_esm();

// node_modules/@antv/scale/esm/base.js
init_esm();

// node_modules/@antv/scale/esm/tick-method/register.js
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method) {
  methodCache[key] = method;
}

// node_modules/@antv/scale/esm/base.js
var Scale = (
  /** @class */
  function() {
    function Scale2(cfg) {
      this.type = "base";
      this.isCategory = false;
      this.isLinear = false;
      this.isContinuous = false;
      this.isIdentity = false;
      this.values = [];
      this.range = [0, 1];
      this.ticks = [];
      this.__cfg__ = cfg;
      this.initCfg();
      this.init();
    }
    Scale2.prototype.translate = function(v2) {
      return v2;
    };
    Scale2.prototype.change = function(cfg) {
      mix(this.__cfg__, cfg);
      this.init();
    };
    Scale2.prototype.clone = function() {
      return this.constructor(this.__cfg__);
    };
    Scale2.prototype.getTicks = function() {
      var _this = this;
      return map_default(this.ticks, function(tick, idx) {
        if (is_object_default(tick)) {
          return tick;
        }
        return {
          text: _this.getText(tick, idx),
          tickValue: tick,
          value: _this.scale(tick)
        };
      });
    };
    Scale2.prototype.getText = function(value, key) {
      var formatter = this.formatter;
      var res = formatter ? formatter(value, key) : value;
      if (is_nil_default(res) || !is_function_default(res.toString)) {
        return "";
      }
      return res.toString();
    };
    Scale2.prototype.getConfig = function(key) {
      return this.__cfg__[key];
    };
    Scale2.prototype.init = function() {
      mix(this, this.__cfg__);
      this.setDomain();
      if (is_empty_default(this.getConfig("ticks"))) {
        this.ticks = this.calculateTicks();
      }
    };
    Scale2.prototype.initCfg = function() {
    };
    Scale2.prototype.setDomain = function() {
    };
    Scale2.prototype.calculateTicks = function() {
      var tickMethod = this.tickMethod;
      var ticks = [];
      if (is_string_default(tickMethod)) {
        var method = getTickMethod(tickMethod);
        if (!method) {
          throw new Error("There is no method to to calculate ticks!");
        }
        ticks = method(this);
      } else if (is_function_default(tickMethod)) {
        ticks = tickMethod(this);
      }
      return ticks;
    };
    Scale2.prototype.rangeMin = function() {
      return this.range[0];
    };
    Scale2.prototype.rangeMax = function() {
      return this.range[1];
    };
    Scale2.prototype.calcPercent = function(value, min6, max8) {
      if (is_number_default(value)) {
        return (value - min6) / (max8 - min6);
      }
      return NaN;
    };
    Scale2.prototype.calcValue = function(percent, min6, max8) {
      return min6 + percent * (max8 - min6);
    };
    return Scale2;
  }()
);
var base_default5 = Scale;

// node_modules/@antv/scale/esm/category/base.js
init_tslib_es6();
init_esm();
var Category = (
  /** @class */
  function(_super) {
    __extends2(Category2, _super);
    function Category2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "cat";
      _this.isCategory = true;
      return _this;
    }
    Category2.prototype.buildIndexMap = function() {
      if (!this.translateIndexMap) {
        this.translateIndexMap = /* @__PURE__ */ new Map();
        for (var i2 = 0; i2 < this.values.length; i2++) {
          this.translateIndexMap.set(this.values[i2], i2);
        }
      }
    };
    Category2.prototype.translate = function(value) {
      this.buildIndexMap();
      var idx = this.translateIndexMap.get(value);
      if (idx === void 0) {
        idx = is_number_default(value) ? value : NaN;
      }
      return idx;
    };
    Category2.prototype.scale = function(value) {
      var order = this.translate(value);
      var percent = this.calcPercent(order, this.min, this.max);
      return this.calcValue(percent, this.rangeMin(), this.rangeMax());
    };
    Category2.prototype.invert = function(scaledValue) {
      var domainRange = this.max - this.min;
      var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
      var idx = Math.round(domainRange * percent) + this.min;
      if (idx < this.min || idx > this.max) {
        return NaN;
      }
      return this.values[idx];
    };
    Category2.prototype.getText = function(value) {
      var args = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        args[_i2 - 1] = arguments[_i2];
      }
      var v2 = value;
      if (is_number_default(value) && !this.values.includes(value)) {
        v2 = this.values[v2];
      }
      return _super.prototype.getText.apply(this, __spreadArrays([v2], args));
    };
    Category2.prototype.initCfg = function() {
      this.tickMethod = "cat";
    };
    Category2.prototype.setDomain = function() {
      if (is_nil_default(this.getConfig("min"))) {
        this.min = 0;
      }
      if (is_nil_default(this.getConfig("max"))) {
        var size3 = this.values.length;
        this.max = size3 > 1 ? size3 - 1 : size3;
      }
      if (this.translateIndexMap) {
        this.translateIndexMap = void 0;
      }
    };
    return Category2;
  }(base_default5)
);
var base_default6 = Category;

// node_modules/@antv/scale/esm/category/time.js
init_tslib_es6();
init_esm();

// node_modules/@antv/scale/esm/util/time.js
init_esm();

// node_modules/fecha/lib/fecha.js
var fecha_exports = {};
__export(fecha_exports, {
  assign: () => assign,
  default: () => fecha_default,
  defaultI18n: () => defaultI18n,
  format: () => format,
  parse: () => parse,
  setGlobalDateI18n: () => setGlobalDateI18n,
  setGlobalDateMasks: () => setGlobalDateMasks
});
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i2 = 0, len6 = arr.length; i2 < len6; i2++) {
    newArr.push(arr[i2].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v2, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v3) {
      return v3.toLowerCase();
    });
    var index2 = lowerCaseArr.indexOf(v2.toLowerCase());
    if (index2 > -1) {
      return index2;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    args[_i2 - 1] = arguments[_i2];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str10) {
  return str10.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len6) {
  if (len6 === void 0) {
    len6 = 2;
  }
  val = String(val);
  while (val.length < len6) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};
var monthParse = function(v2) {
  return +v2 - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v2, i18n) {
    var val = v2.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v2) {
    var parts = (v2 + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v2) {
    return parseInt(v2, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v2) {
      var now2 = /* @__PURE__ */ new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v2 > 68 ? cent - 1 : cent) + v2);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v2) {
    return +v2 * 100;
  }],
  SS: ["millisecond", twoDigits, function(v2) {
    return +v2 * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
  return assign(globalMasks, masks);
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = /* @__PURE__ */ new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field2 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " specified twice in format");
    }
    specifiedFields[field2] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field2) {
    if (!specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i2 = 1; i2 < matches.length; i2++) {
    var _a2 = parseInfo[i2 - 1], field = _a2[0], parser = _a2[2];
    var value = parser ? parser(matches[i2], combinedI18nSettings) : +matches[i2];
    if (value == null) {
      return null;
    }
    dateInfo[field] = value;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateTZ;
  if (dateInfo.timezoneOffset == null) {
    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i2 = 0, len6 = validateFields.length; i2 < len6; i2++) {
      if (specifiedFields[validateFields[i2][0]] && dateInfo[validateFields[i2][0]] !== dateTZ[validateFields[i2][1]]()) {
        return null;
      }
    }
  } else {
    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
      return null;
    }
  }
  return dateTZ;
}
var fecha = {
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
};
var fecha_default = fecha;

// node_modules/@antv/scale/esm/util/bisector.js
init_esm();
function bisector_default(getter) {
  return function(a3, x4, _lo, _hi) {
    var lo2 = is_nil_default(_lo) ? 0 : _lo;
    var hi2 = is_nil_default(_hi) ? a3.length : _hi;
    while (lo2 < hi2) {
      var mid = lo2 + hi2 >>> 1;
      if (getter(a3[mid]) > x4) {
        hi2 = mid;
      } else {
        lo2 = mid + 1;
      }
    }
    return lo2;
  };
}

// node_modules/@antv/scale/esm/util/time.js
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method = fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD];
  return method(time, mask);
}
function toTimeStamp(value) {
  if (is_string_default(value)) {
    if (value.indexOf("T") > 0) {
      value = new Date(value).getTime();
    } else {
      value = new Date(value.replace(/-/gi, "/")).getTime();
    }
  }
  if (is_date_default(value)) {
    value = value.getTime();
  }
  return value;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min6, max8, tickCount) {
  var target = (max8 - min6) / tickCount;
  var idx = bisector_default(function(o2) {
    return o2[1];
  })(intervals, target) - 1;
  var interval2 = intervals[idx];
  if (idx < 0) {
    interval2 = intervals[0];
  } else if (idx >= intervals.length) {
    interval2 = last(intervals);
  }
  return interval2;
}

// node_modules/@antv/scale/esm/category/time.js
var TimeCat = (
  /** @class */
  function(_super) {
    __extends2(TimeCat2, _super);
    function TimeCat2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "timeCat";
      return _this;
    }
    TimeCat2.prototype.translate = function(value) {
      value = toTimeStamp(value);
      var index2 = this.values.indexOf(value);
      if (index2 === -1) {
        if (is_number_default(value) && value < this.values.length) {
          index2 = value;
        } else {
          index2 = NaN;
        }
      }
      return index2;
    };
    TimeCat2.prototype.getText = function(value, tickIndex) {
      var index2 = this.translate(value);
      if (index2 > -1) {
        var result = this.values[index2];
        var formatter = this.formatter;
        result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
        return result;
      }
      return value;
    };
    TimeCat2.prototype.initCfg = function() {
      this.tickMethod = "time-cat";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
    };
    TimeCat2.prototype.setDomain = function() {
      var values3 = this.values;
      each_default(values3, function(v2, i2) {
        values3[i2] = toTimeStamp(v2);
      });
      values3.sort(function(v1, v2) {
        return v1 - v2;
      });
      _super.prototype.setDomain.call(this);
    };
    return TimeCat2;
  }(base_default6)
);
var time_default = TimeCat;

// node_modules/@antv/scale/esm/continuous/linear.js
init_tslib_es6();

// node_modules/@antv/scale/esm/continuous/base.js
init_tslib_es6();
init_esm();
var Continuous = (
  /** @class */
  function(_super) {
    __extends2(Continuous2, _super);
    function Continuous2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isContinuous = true;
      return _this;
    }
    Continuous2.prototype.scale = function(value) {
      if (is_nil_default(value)) {
        return NaN;
      }
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var max8 = this.max;
      var min6 = this.min;
      if (max8 === min6) {
        return rangeMin;
      }
      var percent = this.getScalePercent(value);
      return rangeMin + percent * (rangeMax - rangeMin);
    };
    Continuous2.prototype.init = function() {
      _super.prototype.init.call(this);
      var ticks = this.ticks;
      var firstTick = head(ticks);
      var lastTick = last(ticks);
      if (firstTick < this.min) {
        this.min = firstTick;
      }
      if (lastTick > this.max) {
        this.max = lastTick;
      }
      if (!is_nil_default(this.minLimit)) {
        this.min = firstTick;
      }
      if (!is_nil_default(this.maxLimit)) {
        this.max = lastTick;
      }
    };
    Continuous2.prototype.setDomain = function() {
      var _a2 = get_range_default(this.values), min6 = _a2.min, max8 = _a2.max;
      if (is_nil_default(this.min)) {
        this.min = min6;
      }
      if (is_nil_default(this.max)) {
        this.max = max8;
      }
      if (this.min > this.max) {
        this.min = min6;
        this.max = max8;
      }
    };
    Continuous2.prototype.calculateTicks = function() {
      var _this = this;
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        ticks = filter_default(ticks, function(tick) {
          return tick >= _this.min && tick <= _this.max;
        });
      }
      return ticks;
    };
    Continuous2.prototype.getScalePercent = function(value) {
      var max8 = this.max;
      var min6 = this.min;
      return (value - min6) / (max8 - min6);
    };
    Continuous2.prototype.getInvertPercent = function(value) {
      return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    };
    return Continuous2;
  }(base_default5)
);
var base_default7 = Continuous;

// node_modules/@antv/scale/esm/continuous/linear.js
var Linear = (
  /** @class */
  function(_super) {
    __extends2(Linear2, _super);
    function Linear2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "linear";
      _this.isLinear = true;
      return _this;
    }
    Linear2.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      return this.min + percent * (this.max - this.min);
    };
    Linear2.prototype.initCfg = function() {
      this.tickMethod = "wilkinson-extended";
      this.nice = false;
    };
    return Linear2;
  }(base_default7)
);
var linear_default = Linear;

// node_modules/@antv/scale/esm/continuous/log.js
init_tslib_es6();

// node_modules/@antv/scale/esm/util/math.js
init_esm();
function calBase(a3, b10) {
  var e8 = Math.E;
  var value;
  if (b10 >= 0) {
    value = Math.pow(e8, Math.log(b10) / a3);
  } else {
    value = Math.pow(e8, Math.log(-b10) / a3) * -1;
  }
  return value;
}
function log(a3, b10) {
  if (a3 === 1) {
    return 1;
  }
  return Math.log(b10) / Math.log(a3);
}
function getLogPositiveMin(values3, base, max8) {
  if (is_nil_default(max8)) {
    max8 = Math.max.apply(null, values3);
  }
  var positiveMin = max8;
  each_default(values3, function(value) {
    if (value > 0 && value < positiveMin) {
      positiveMin = value;
    }
  });
  if (positiveMin === max8) {
    positiveMin = max8 / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}

// node_modules/@antv/scale/esm/continuous/log.js
var Log = (
  /** @class */
  function(_super) {
    __extends2(Log2, _super);
    function Log2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "log";
      return _this;
    }
    Log2.prototype.invert = function(value) {
      var base = this.base;
      var max8 = log(base, this.max);
      var rangeMin = this.rangeMin();
      var range = this.rangeMax() - rangeMin;
      var min6;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        if (value === 0) {
          return 0;
        }
        min6 = log(base, positiveMin / base);
        var appendPercent = 1 / (max8 - min6) * range;
        if (value < appendPercent) {
          return value / appendPercent * positiveMin;
        }
      } else {
        min6 = log(base, this.min);
      }
      var percent = (value - rangeMin) / range;
      var tmp = percent * (max8 - min6) + min6;
      return Math.pow(base, tmp);
    };
    Log2.prototype.initCfg = function() {
      this.tickMethod = "log";
      this.base = 10;
      this.tickCount = 6;
      this.nice = true;
    };
    Log2.prototype.setDomain = function() {
      _super.prototype.setDomain.call(this);
      var min6 = this.min;
      if (min6 < 0) {
        throw new Error("When you use log scale, the minimum value must be greater than zero!");
      }
      if (min6 === 0) {
        this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
      }
    };
    Log2.prototype.getScalePercent = function(value) {
      var max8 = this.max;
      var min6 = this.min;
      if (max8 === min6) {
        return 0;
      }
      if (value <= 0) {
        return 0;
      }
      var base = this.base;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        min6 = positiveMin * 1 / base;
      }
      var percent;
      if (value < positiveMin) {
        percent = value / positiveMin / (log(base, max8) - log(base, min6));
      } else {
        percent = (log(base, value) - log(base, min6)) / (log(base, max8) - log(base, min6));
      }
      return percent;
    };
    return Log2;
  }(base_default7)
);
var log_default = Log;

// node_modules/@antv/scale/esm/continuous/pow.js
init_tslib_es6();
var Pow = (
  /** @class */
  function(_super) {
    __extends2(Pow2, _super);
    function Pow2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pow";
      return _this;
    }
    Pow2.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      var exponent2 = this.exponent;
      var max8 = calBase(exponent2, this.max);
      var min6 = calBase(exponent2, this.min);
      var tmp = percent * (max8 - min6) + min6;
      var factor = tmp >= 0 ? 1 : -1;
      return Math.pow(tmp, exponent2) * factor;
    };
    Pow2.prototype.initCfg = function() {
      this.tickMethod = "pow";
      this.exponent = 2;
      this.tickCount = 5;
      this.nice = true;
    };
    Pow2.prototype.getScalePercent = function(value) {
      var max8 = this.max;
      var min6 = this.min;
      if (max8 === min6) {
        return 0;
      }
      var exponent2 = this.exponent;
      var percent = (calBase(exponent2, value) - calBase(exponent2, min6)) / (calBase(exponent2, max8) - calBase(exponent2, min6));
      return percent;
    };
    return Pow2;
  }(base_default7)
);
var pow_default = Pow;

// node_modules/@antv/scale/esm/continuous/time.js
init_tslib_es6();
init_esm();
var Time = (
  /** @class */
  function(_super) {
    __extends2(Time2, _super);
    function Time2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "time";
      return _this;
    }
    Time2.prototype.getText = function(value, index2) {
      var numberValue = this.translate(value);
      var formatter = this.formatter;
      return formatter ? formatter(numberValue, index2) : timeFormat(numberValue, this.mask);
    };
    Time2.prototype.scale = function(value) {
      var v2 = value;
      if (is_string_default(v2) || is_date_default(v2)) {
        v2 = this.translate(v2);
      }
      return _super.prototype.scale.call(this, v2);
    };
    Time2.prototype.translate = function(v2) {
      return toTimeStamp(v2);
    };
    Time2.prototype.initCfg = function() {
      this.tickMethod = "time-pretty";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
      this.nice = false;
    };
    Time2.prototype.setDomain = function() {
      var values3 = this.values;
      var minConfig = this.getConfig("min");
      var maxConfig = this.getConfig("max");
      if (!is_nil_default(minConfig) || !is_number_default(minConfig)) {
        this.min = this.translate(this.min);
      }
      if (!is_nil_default(maxConfig) || !is_number_default(maxConfig)) {
        this.max = this.translate(this.max);
      }
      if (values3 && values3.length) {
        var timeStamps_1 = [];
        var min_1 = Infinity;
        var secondMin_1 = min_1;
        var max_1 = 0;
        each_default(values3, function(v2) {
          var timeStamp = toTimeStamp(v2);
          if (isNaN(timeStamp)) {
            throw new TypeError("Invalid Time: " + v2 + " in time scale!");
          }
          if (min_1 > timeStamp) {
            secondMin_1 = min_1;
            min_1 = timeStamp;
          } else if (secondMin_1 > timeStamp) {
            secondMin_1 = timeStamp;
          }
          if (max_1 < timeStamp) {
            max_1 = timeStamp;
          }
          timeStamps_1.push(timeStamp);
        });
        if (values3.length > 1) {
          this.minTickInterval = secondMin_1 - min_1;
        }
        if (is_nil_default(minConfig)) {
          this.min = min_1;
        }
        if (is_nil_default(maxConfig)) {
          this.max = max_1;
        }
      }
    };
    return Time2;
  }(linear_default)
);
var time_default2 = Time;

// node_modules/@antv/scale/esm/continuous/quantize.js
init_tslib_es6();
init_esm();
var Quantize = (
  /** @class */
  function(_super) {
    __extends2(Quantize2, _super);
    function Quantize2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantize";
      return _this;
    }
    Quantize2.prototype.invert = function(value) {
      var ticks = this.ticks;
      var length6 = ticks.length;
      var percent = this.getInvertPercent(value);
      var minIndex = Math.floor(percent * (length6 - 1));
      if (minIndex >= length6 - 1) {
        return last(ticks);
      }
      if (minIndex < 0) {
        return head(ticks);
      }
      var minTick = ticks[minIndex];
      var nextTick = ticks[minIndex + 1];
      var minIndexPercent = minIndex / (length6 - 1);
      var maxIndexPercent = (minIndex + 1) / (length6 - 1);
      return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
    };
    Quantize2.prototype.initCfg = function() {
      this.tickMethod = "r-pretty";
      this.tickCount = 5;
      this.nice = true;
    };
    Quantize2.prototype.calculateTicks = function() {
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        if (last(ticks) !== this.max) {
          ticks.push(this.max);
        }
        if (head(ticks) !== this.min) {
          ticks.unshift(this.min);
        }
      }
      return ticks;
    };
    Quantize2.prototype.getScalePercent = function(value) {
      var ticks = this.ticks;
      if (value < head(ticks)) {
        return 0;
      }
      if (value > last(ticks)) {
        return 1;
      }
      var minIndex = 0;
      each_default(ticks, function(tick, index2) {
        if (value >= tick) {
          minIndex = index2;
        } else {
          return false;
        }
      });
      return minIndex / (ticks.length - 1);
    };
    return Quantize2;
  }(base_default7)
);
var quantize_default2 = Quantize;

// node_modules/@antv/scale/esm/continuous/quantile.js
init_tslib_es6();
var Quantile = (
  /** @class */
  function(_super) {
    __extends2(Quantile2, _super);
    function Quantile2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantile";
      return _this;
    }
    Quantile2.prototype.initCfg = function() {
      this.tickMethod = "quantile";
      this.tickCount = 5;
      this.nice = true;
    };
    return Quantile2;
  }(quantize_default2)
);
var quantile_default = Quantile;

// node_modules/@antv/scale/esm/factory.js
var map5 = {};
function getClass(key) {
  return map5[key];
}
function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }
  map5[key] = cls;
}

// node_modules/@antv/scale/esm/identity/index.js
init_tslib_es6();
init_esm();
var Identity = (
  /** @class */
  function(_super) {
    __extends2(Identity2, _super);
    function Identity2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "identity";
      _this.isIdentity = true;
      return _this;
    }
    Identity2.prototype.calculateTicks = function() {
      return this.values;
    };
    Identity2.prototype.scale = function(value) {
      if (this.values[0] !== value && is_number_default(value)) {
        return value;
      }
      return this.range[0];
    };
    Identity2.prototype.invert = function(value) {
      var range = this.range;
      if (value < range[0] || value > range[1]) {
        return NaN;
      }
      return this.values[0];
    };
    return Identity2;
  }(base_default5)
);
var identity_default3 = Identity;

// node_modules/@antv/scale/esm/tick-method/cat.js
init_esm();
function calculateCatTicks(cfg) {
  var values3 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
  if (is_number_default(tickInterval)) {
    var ticks_1 = filter_default(values3, function(__, i3) {
      return i3 % tickInterval === 0;
    });
    var lastValue = last(values3);
    if (showLast && last(ticks_1) !== lastValue) {
      ticks_1.push(lastValue);
    }
    return ticks_1;
  }
  var len6 = values3.length;
  var min6 = cfg.min, max8 = cfg.max;
  if (is_nil_default(min6)) {
    min6 = 0;
  }
  if (is_nil_default(max8)) {
    max8 = values3.length - 1;
  }
  if (!is_number_default(tickCount) || tickCount >= len6)
    return values3.slice(min6, max8 + 1);
  if (tickCount <= 0 || max8 <= 0)
    return [];
  var interval2 = tickCount === 1 ? len6 : Math.floor(len6 / (tickCount - 1));
  var ticks = [];
  var idx = min6;
  for (var i2 = 0; i2 < tickCount; i2++) {
    if (idx >= max8)
      break;
    idx = Math.min(min6 + i2 * interval2, max8);
    if (i2 === tickCount - 1 && showLast)
      ticks.push(values3[max8]);
    else
      ticks.push(values3[idx]);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
init_esm();

// node_modules/@antv/scale/esm/util/d3-linear.js
function d3Linear(cfg) {
  var min6 = cfg.min, max8 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear4 = new D3Linear();
  linear4.domain([min6, max8]);
  if (nice) {
    linear4.nice(tickCount);
  }
  return linear4.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
var D3Linear = (
  /** @class */
  function() {
    function D3Linear2() {
      this._domain = [0, 1];
    }
    D3Linear2.prototype.domain = function(domain) {
      if (domain) {
        this._domain = Array.from(domain, Number);
        return this;
      }
      return this._domain.slice();
    };
    D3Linear2.prototype.nice = function(count) {
      var _a2, _b;
      if (count === void 0) {
        count = DEFAULT_COUNT;
      }
      var d2 = this._domain.slice();
      var i0 = 0;
      var i1 = this._domain.length - 1;
      var start = this._domain[i0];
      var stop = this._domain[i1];
      var step;
      if (stop < start) {
        _a2 = [stop, start], start = _a2[0], stop = _a2[1];
        _b = [i1, i0], i0 = _b[0], i1 = _b[1];
      }
      step = tickIncrement(start, stop, count);
      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count);
      }
      if (step > 0) {
        d2[i0] = Math.floor(start / step) * step;
        d2[i1] = Math.ceil(stop / step) * step;
        this.domain(d2);
      } else if (step < 0) {
        d2[i0] = Math.ceil(start * step) / step;
        d2[i1] = Math.floor(stop * step) / step;
        this.domain(d2);
      }
      return this;
    };
    D3Linear2.prototype.ticks = function(count) {
      if (count === void 0) {
        count = DEFAULT_COUNT;
      }
      return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
    };
    return D3Linear2;
  }()
);
function d3ArrayTicks(start, stop, count) {
  var reverse;
  var i2 = -1;
  var n2;
  var ticks;
  var step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) {
    return [start];
  }
  if (reverse = stop < start) {
    n2 = start, start = stop, stop = n2;
  }
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n2 = Math.ceil(stop - start + 1));
    while (++i2 < n2) {
      ticks[i2] = (start + i2) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n2 = Math.ceil(start - stop + 1));
    while (++i2 < n2) {
      ticks[i2] = (start - i2) / step;
    }
  }
  if (reverse) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count);
  var power = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1);
}

// node_modules/@antv/scale/esm/util/interval.js
init_esm();
function snapMultiple(v2, base, snapType) {
  var div4;
  if (snapType === "ceil") {
    div4 = Math.ceil(v2 / base);
  } else if (snapType === "floor") {
    div4 = Math.floor(v2 / base);
  } else {
    div4 = Math.round(v2 / base);
  }
  return div4 * base;
}
function intervalTicks(min6, max8, interval2) {
  var minTick = snapMultiple(min6, interval2, "floor");
  var maxTick = snapMultiple(max8, interval2, "ceil");
  minTick = fixed_base_default(minTick, interval2);
  maxTick = fixed_base_default(maxTick, interval2);
  var ticks = [];
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval2);
  for (var i2 = minTick; i2 <= maxTick; i2 = i2 + availableInterval) {
    var tickValue = fixed_base_default(i2, availableInterval);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}

// node_modules/@antv/scale/esm/util/strict-limit.js
init_esm();
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a2;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min6 = cfg.min, max8 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min6 : defaultMin : minLimit;
  var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max8 : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a2 = [tickMin, tickMax], tickMax = _a2[0], tickMin = _a2[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i2 = 0; i2 < tickCount; i2++) {
    ticks.push(tickMin + step * i2);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
function d3LinearTickMethod(cfg) {
  var min6 = cfg.min, max8 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min6, max8, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/linear.js
init_esm();

// node_modules/@antv/scale/esm/util/extended.js
init_esm();

// node_modules/@antv/scale/esm/util/pretty-number.js
function prettyNumber(n2) {
  return Math.abs(n2) < 1e-15 ? n2 : parseFloat(n2.toFixed(15));
}

// node_modules/@antv/scale/esm/util/extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod3(n2, m3) {
  return (n2 % m3 + m3) % m3;
}
function round5(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function simplicity(q2, Q2, j2, lmin, lmax, lstep) {
  var n2 = size(Q2);
  var i2 = index_of_default(Q2, q2);
  var v2 = 0;
  var m3 = mod3(lmin, lstep);
  if ((m3 < eps || lstep - m3 < eps) && lmin <= 0 && lmax >= 0) {
    v2 = 1;
  }
  return 1 - i2 / (n2 - 1) - j2 + v2;
}
function simplicityMax(q2, Q2, j2) {
  var n2 = size(Q2);
  var i2 = index_of_default(Q2, q2);
  var v2 = 1;
  return 1 - i2 / (n2 - 1) - j2 + v2;
}
function density(k2, m3, dMin, dMax, lMin, lMax) {
  var r2 = (k2 - 1) / (lMax - lMin);
  var rt2 = (m3 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r2 / rt2, rt2 / r2);
}
function densityMax(k2, m3) {
  if (k2 >= m3) {
    return 2 - (k2 - 1) / (m3 - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);
}
function coverageMax(dMin, dMax, span) {
  var range = dMax - dMin;
  if (span > range) {
    var half = (span - range) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n2, onlyLoose, Q2, w2) {
  if (n2 === void 0) {
    n2 = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q2 === void 0) {
    Q2 = DEFAULT_Q;
  }
  if (w2 === void 0) {
    w2 = [0.25, 0.2, 0.5, 0.05];
  }
  var m3 = n2 < 0 ? 0 : Math.round(n2);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m3) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m3 === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  if (dMax - dMin > 1e148) {
    var count = n2 || 5;
    var step_1 = (dMax - dMin) / count;
    return {
      min: dMin,
      max: dMax,
      ticks: Array(count).fill(null).map(function(_2, idx) {
        return prettyNumber(dMin + step_1 * idx);
      })
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j2 = 1;
  while (j2 < Infinity) {
    for (var i2 = 0; i2 < Q2.length; i2 += 1) {
      var q2 = Q2[i2];
      var sm = simplicityMax(q2, Q2, j2);
      if (w2[0] * sm + w2[1] + w2[2] + w2[3] < best.score) {
        j2 = Infinity;
        break;
      }
      var k2 = 2;
      while (k2 < Infinity) {
        var dm = densityMax(k2, m3);
        if (w2[0] * sm + w2[1] + w2[2] * dm + w2[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k2 + 1) / j2 / q2;
        var z2 = Math.ceil(Math.log10(delta));
        while (z2 < Infinity) {
          var step = j2 * q2 * Math.pow(10, z2);
          var cm = coverageMax(dMin, dMax, step * (k2 - 1));
          if (w2[0] * sm + w2[1] * cm + w2[2] * dm + w2[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j2 - (k2 - 1) * j2;
          var maxStart = Math.ceil(dMin / step) * j2;
          if (minStart <= maxStart) {
            var count = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j2);
              var lMax = lMin + step * (k2 - 1);
              var lStep = step;
              var s2 = simplicity(q2, Q2, j2, lMin, lMax, lStep);
              var c3 = coverage(dMin, dMax, lMin, lMax);
              var g2 = density(k2, m3, dMin, dMax, lMin, lMax);
              var l2 = legibility();
              var score = w2[0] * s2 + w2[1] * c3 + w2[2] * g2 + w2[3] * l2;
              if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score;
              }
            }
          }
          z2 += 1;
        }
        k2 += 1;
      }
    }
    j2 += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round5((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i2 = 1; i2 < tickCount; i2++) {
    ticks[i2] = prettyNumber(ticks[i2 - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/linear.js
function linear3(cfg) {
  var min6 = cfg.min, max8 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min6, max8, tickCount, nice).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min6, max8, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/log.js
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min6 = cfg.min, max8 = cfg.max, values3 = cfg.values;
  var minTick;
  var maxTick = log(base, max8);
  if (min6 > 0) {
    minTick = Math.floor(log(base, min6));
  } else {
    var positiveMin = getLogPositiveMin(values3, base, max8);
    minTick = Math.floor(log(base, positiveMin));
  }
  var count = maxTick - minTick;
  var avg = Math.ceil(count / tickCount);
  var ticks = [];
  for (var i2 = minTick; i2 < maxTick + avg; i2 = i2 + avg) {
    ticks.push(Math.pow(base, i2));
  }
  if (min6 <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/pretty.js
function pretty(min6, max8, m3) {
  if (m3 === void 0) {
    m3 = 5;
  }
  if (min6 === max8) {
    return {
      max: max8,
      min: min6,
      ticks: [min6]
    };
  }
  var n2 = m3 < 0 ? 0 : Math.round(m3);
  if (n2 === 0)
    return { max: max8, min: min6, ticks: [] };
  var h2 = 1.5;
  var h5 = 0.5 + 1.5 * h2;
  var d2 = max8 - min6;
  var c3 = d2 / n2;
  var base = Math.pow(10, Math.floor(Math.log10(c3)));
  var unit = base;
  if (2 * base - c3 < h2 * (c3 - unit)) {
    unit = 2 * base;
    if (5 * base - c3 < h5 * (c3 - unit)) {
      unit = 5 * base;
      if (10 * base - c3 < h2 * (c3 - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu2 = Math.ceil(max8 / unit);
  var ns = Math.floor(min6 / unit);
  var hi2 = Math.max(nu2 * unit, max8);
  var lo2 = Math.min(ns * unit, min6);
  var size3 = Math.floor((hi2 - lo2) / unit) + 1;
  var ticks = new Array(size3);
  for (var i2 = 0; i2 < size3; i2++) {
    ticks[i2] = prettyNumber(lo2 + i2 * unit);
  }
  return {
    min: lo2,
    max: hi2,
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/pow.js
function calculatePowTicks(cfg) {
  var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
  var max8 = Math.ceil(calBase(exponent2, cfg.max));
  var min6 = Math.floor(calBase(exponent2, cfg.min));
  var ticks = pretty(min6, max8, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent2) * factor;
  });
}

// node_modules/@antv/scale/esm/tick-method/quantile.js
function quantileSorted(x4, p2) {
  var idx = x4.length * p2;
  if (p2 === 1) {
    return x4[x4.length - 1];
  } else if (p2 === 0) {
    return x4[0];
  } else if (idx % 1 !== 0) {
    return x4[Math.ceil(idx) - 1];
  } else if (x4.length % 2 === 0) {
    return (x4[idx - 1] + x4[idx]) / 2;
  } else {
    return x4[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values3 = cfg.values;
  if (!values3 || !values3.length) {
    return [];
  }
  var sorted = values3.slice().sort(function(a3, b10) {
    return a3 - b10;
  });
  var ticks = [];
  for (var i2 = 0; i2 < tickCount; i2++) {
    var p2 = i2 / (tickCount - 1);
    ticks.push(quantileSorted(sorted, p2));
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/r-prettry.js
init_esm();
function linearPretty(cfg) {
  var min6 = cfg.min, max8 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min6, max8, tickCount).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min6, max8, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time.js
function calculateTimeTicks(cfg) {
  var min6 = cfg.min, max8 = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max8 - min6) / tickInterval);
  } else {
    tickInterval = getTickInterval(min6, max8, tickCount)[1];
    var count = (max8 - min6) / tickInterval;
    var ratio = count / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max8 - min6) / (Math.pow(2, 12) - 1)), tickInterval);
  var ticks = [];
  for (var i2 = min6; i2 < max8 + tickInterval; i2 += tickInterval) {
    ticks.push(i2);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-cat.js
init_tslib_es6();
function timeCat(cfg) {
  var ticks = calculateCatTicks(__assign2({ showLast: true }, cfg));
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-pretty.js
function getYear(date) {
  return new Date(date).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
  return new Date(date).getMonth();
}
function diffMonth(min6, max8) {
  var minYear = getYear(min6);
  var maxYear = getYear(max8);
  var minMonth = getMonth(min6);
  var maxMonth = getMonth(max8);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min6, max8) {
  return Math.ceil((max8 - min6) / DAY);
}
function diffHour(min6, max8) {
  return Math.ceil((max8 - min6) / HOUR);
}
function diffMinus(min6, max8) {
  return Math.ceil((max8 - min6) / (60 * 1e3));
}
function timePretty(cfg) {
  var min6 = cfg.min, max8 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max8 - min6) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max8 - min6) / (Math.pow(2, 12) - 1)), tickInterval);
  var minYear = getYear(min6);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max8);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i2 = minYear; i2 <= maxYear + yearInterval; i2 = i2 + yearInterval) {
      ticks.push(createYear(i2));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min6);
    var dMonths = diffMonth(min6, max8);
    for (var i2 = 0; i2 <= dMonths + monthInterval; i2 = i2 + monthInterval) {
      ticks.push(creatMonth(minYear, i2 + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date = new Date(min6);
    var year = date.getFullYear();
    var month = date.getMonth();
    var mday = date.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min6, max8);
    for (var i2 = 0; i2 < ddays + day; i2 = i2 + day) {
      ticks.push(new Date(year, month, mday + i2).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date = new Date(min6);
    var year = date.getFullYear();
    var month = date.getMonth();
    var day = date.getDate();
    var hour = date.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min6, max8);
    for (var i2 = 0; i2 <= dHours + hours; i2 = i2 + hours) {
      ticks.push(new Date(year, month, day, hour + i2).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min6, max8);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i2 = 0; i2 <= dMinus + minutes; i2 = i2 + minutes) {
      ticks.push(min6 + i2 * MINUTE);
    }
  } else {
    var interval2 = tickInterval;
    if (interval2 < SECOND) {
      interval2 = SECOND;
    }
    var minSecond = Math.floor(min6 / SECOND) * SECOND;
    var dSeconds = Math.ceil((max8 - min6) / SECOND);
    var seconds = Math.ceil(interval2 / SECOND);
    for (var i2 = 0; i2 < dSeconds + seconds; i2 = i2 + seconds) {
      ticks.push(minSecond + i2 * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/index.js
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", timeCat);
registerTickMethod("wilkinson-extended", linear3);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);

// node_modules/@antv/scale/esm/index.js
registerClass("cat", base_default6);
registerClass("category", base_default6);
registerClass("identity", identity_default3);
registerClass("linear", linear_default);
registerClass("log", log_default);
registerClass("pow", pow_default);
registerClass("time", time_default2);
registerClass("timeCat", time_default);
registerClass("quantize", quantize_default2);
registerClass("quantile", quantile_default);

// node_modules/@antv/g6-plugin/es/timeBar/path.js
init_esm();
var __spreadArray5 = function(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
    if (ar2 || !(i2 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
      ar2[i2] = from[i2];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
function pointsToPath(points) {
  return map_default(points, function(p2, idx) {
    var command = idx === 0 ? "M" : "L";
    var x4 = p2[0], y4 = p2[1];
    return [command, x4, y4];
  });
}
function getLinePath(points) {
  return pointsToPath(points);
}
function getSmoothLinePath(points) {
  if (points.length <= 2) {
    return getLinePath(points);
  }
  var data = [];
  each_default(points, function(p2) {
    if (!is_equal_default(p2, data.slice(data.length - 2))) {
      data.push(p2[0], p2[1]);
    }
  });
  var path = catmull_rom_2_bezier_default(data, false);
  var _a2 = head(points), x4 = _a2[0], y4 = _a2[1];
  path.unshift(["M", x4, y4]);
  return path;
}
function dataToPath(data, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y4 = new linear_default({
    values: data
  });
  var x4 = new base_default6({
    values: map_default(data, function(v2, idx) {
      return idx;
    })
  });
  var points = map_default(data, function(v2, idx) {
    return [x4.scale(idx) * width, height - y4.scale(v2) * height];
  });
  return smooth ? getSmoothLinePath(points) : getLinePath(points);
}
function dataToRectPath(data, width, height, barWidth) {
  if (barWidth === void 0) {
    barWidth = 5;
  }
  var y4 = new linear_default({
    values: data
  });
  var x4 = new base_default6({
    values: map_default(data, function(v2, idx) {
      return idx;
    })
  });
  var points = map_default(data, function(v2, idx) {
    return [x4.scale(idx) * width, height - y4.scale(v2) * height];
  });
  var rectPoints = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point = points[i2];
    var param = {
      x: point[0],
      y: point[1],
      y0: height,
      size: barWidth
    };
    var rectPoint = getRectPoints(param);
    rectPoints.push.apply(rectPoints, rectPoint);
  }
  return getRectPath(rectPoints);
}
function getAreaLineY(data, height) {
  var y4 = new linear_default({
    values: data
  });
  var lineY = Math.max(0, y4.min);
  return height - y4.scale(lineY) * height;
}
function linePathToAreaPath(path, width, height, data) {
  var areaPath = __spreadArray5([], path, true);
  var lineYPx = getAreaLineY(data, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}
function getRectPoints(pointInfo) {
  var x4 = pointInfo.x, y4 = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
  var yMin;
  var yMax;
  if (is_array_default(y4)) {
    yMin = y4[0], yMax = y4[1];
  } else {
    yMin = y0;
    yMax = y4;
  }
  var xMin;
  var xMax;
  if (is_array_default(x4)) {
    xMin = x4[0], xMax = x4[1];
  } else {
    xMin = x4 - size3 / 2;
    xMax = x4 + size3 / 2;
  }
  var points = [{
    x: xMin,
    y: yMin
  }, {
    x: xMin,
    y: yMax
  }];
  points.push({
    x: xMax,
    y: yMax
  }, {
    x: xMax,
    y: yMin
  });
  return points;
}
function getRectPath(points, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path = [];
  var firstPoint = points[0];
  path.push(["M", firstPoint.x, firstPoint.y]);
  for (var i2 = 1, len6 = points.length; i2 < len6; i2++) {
    path.push(["L", points[i2].x, points[i2].y]);
  }
  if (isClosed) {
    path.push(["L", firstPoint.x, firstPoint.y]);
    path.push(["z"]);
  }
  return path;
}

// node_modules/@antv/g6-plugin/es/timeBar/trend.js
var __assign10 = function() {
  __assign10 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign10.apply(this, arguments);
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};
var Trend = (
  /** @class */
  function() {
    function Trend2(cfg) {
      var _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 200 : _c, _d = cfg.height, height = _d === void 0 ? 26 : _d, _e2 = cfg.smooth, smooth = _e2 === void 0 ? true : _e2, _f = cfg.isArea, isArea = _f === void 0 ? false : _f, _g = cfg.data, data = _g === void 0 ? [] : _g, lineStyle = cfg.lineStyle, areaStyle = cfg.areaStyle, group = cfg.group, _h = cfg.interval, interval2 = _h === void 0 ? null : _h;
      this.group = group;
      this.x = x4;
      this.y = y4;
      this.width = width;
      this.height = height;
      this.data = data;
      this.smooth = smooth;
      this.isArea = isArea;
      this.lineStyle = Object.assign({}, LINE_STYLE, lineStyle);
      this.areaStyle = Object.assign({}, AREA_STYLE, areaStyle);
      this.intervalConfig = interval2;
      this.renderLine();
    }
    Trend2.prototype.renderLine = function() {
      var _a2 = this, x4 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height, barWidth = _a2.barWidth, data = _a2.data, smooth = _a2.smooth, isArea = _a2.isArea, lineStyle = _a2.lineStyle, areaStyle = _a2.areaStyle;
      var trendGroup = this.group.addGroup({
        name: "trend-group"
      });
      if (data) {
        var path = dataToPath(data, width, height, smooth);
        trendGroup.addShape("path", {
          attrs: __assign10({
            path
          }, lineStyle),
          name: "trend-line"
        });
        if (isArea) {
          var areaPath = linePathToAreaPath(path, width, height, data);
          trendGroup.addShape("path", {
            attrs: __assign10({
              path: areaPath
            }, areaStyle),
            name: "trend-area"
          });
        }
      }
      if (this.intervalConfig) {
        trendGroup.addShape("path", {
          attrs: __assign10({
            path: dataToRectPath(this.intervalConfig.data, width, height, this.intervalConfig.style.barWidth)
          }, this.intervalConfig.style),
          name: "trend-interval"
        });
      }
      trendGroup.move(x4, y4);
    };
    Trend2.prototype.destory = function() {
      this.group.destroy();
    };
    return Trend2;
  }()
);
var trend_default = Trend;

// node_modules/@antv/g6-plugin/es/timeBar/handler.js
init_esm();
var __assign11 = function() {
  __assign11 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign11.apply(this, arguments);
};
var DEFAULT_STYLE = {
  fill: "#1890ff",
  stroke: "#1890ff",
  type: "trend",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  // 高亮的颜色
  highLightFill: "#0050b3"
};
var SIMPLE_DEFAULT_STYLE = {
  fill: "#fff",
  stroke: "#1890ff",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  // 高亮的颜色
  highLightFill: "#0050b3"
};
var Handler = (
  /** @class */
  function() {
    function Handler2(cfg) {
      var group = cfg.group, name = cfg.name, type = cfg.type, _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 2 : _c, _d = cfg.height, height = _d === void 0 ? 24 : _d, _e2 = cfg.style, style = _e2 === void 0 ? {} : _e2;
      this.group = group;
      this.name = name;
      this.handleType = type;
      this.x = x4;
      this.y = y4;
      this.width = width;
      this.height = height;
      if (type === "trend") {
        this.style = __assign11(__assign11({}, DEFAULT_STYLE), style);
      } else if (type === "simple") {
        this.style = __assign11(__assign11({}, SIMPLE_DEFAULT_STYLE), style);
      }
      this.renderHandle();
    }
    Handler2.prototype.setX = function(x4) {
      this.setXY(x4, void 0);
    };
    Handler2.prototype.setY = function(y4) {
      this.setXY(void 0, y4);
    };
    Handler2.prototype.setXY = function(x4, y4) {
      if (is_number_default(x4)) {
        this.x = x4;
      }
      if (is_number_default(y4)) {
        this.y = y4;
      }
      this.updateXY();
    };
    Handler2.prototype.renderHandle = function() {
      var _a2 = this, width = _a2.width, height = _a2.height, style = _a2.style, name = _a2.name;
      var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
      this.handleGroup = this.group.addGroup();
      if (this.handleType === "trend") {
        this.verticalLine = this.handleGroup.addShape("rect", {
          attrs: {
            x: 0,
            y: 0,
            width,
            height,
            fill,
            stroke,
            radius,
            opacity,
            cursor
          },
          name: "".concat(name, "-handler")
        });
        this.topCircle = this.handleGroup.addShape("circle", {
          attrs: {
            x: width / 2,
            y: 0,
            r: 2 * width,
            fill,
            stroke,
            radius,
            opacity,
            cursor,
            lineAppendWidth: 12
          },
          name: "".concat(name, "-handler")
        });
        this.bottomCircle = this.handleGroup.addShape("circle", {
          attrs: {
            x: width / 2,
            y: height,
            r: 2 * width,
            fill,
            stroke,
            radius,
            opacity,
            cursor
          },
          name: "".concat(name, "-handler")
        });
      } else if (this.handleType === "simple") {
        this.topCircle = this.handleGroup.addShape("circle", {
          attrs: {
            x: width / 2,
            y: height / 2,
            r: 2 * width,
            fill,
            stroke,
            radius,
            opacity,
            cursor,
            lineWidth: 2
          },
          name: "".concat(name, "-handler")
        });
      }
      this.updateXY();
      if (this.handleType === "trend") {
        this.bindTrendEvents();
      } else if (this.handleType === "simple") {
        this.bindSimpleEvents();
      }
    };
    Handler2.prototype.bindSimpleEvents = function() {
      var _this = this;
      var name = this.name;
      this.handleGroup.on("".concat(name, "-handler:mouseenter"), function() {
        var highLightFill = _this.style.highLightFill;
        _this.topCircle.attr("fill", highLightFill);
      });
      this.handleGroup.on("".concat(name, "-handler:mouseleave"), function() {
        var fill = _this.style.fill;
        _this.topCircle.attr("fill", fill);
      });
    };
    Handler2.prototype.bindTrendEvents = function() {
      var _this = this;
      var name = this.name;
      this.handleGroup.on("".concat(name, "-handler:mouseenter"), function() {
        var highLightFill = _this.style.highLightFill;
        _this.verticalLine.attr("fill", highLightFill);
        _this.topCircle.attr("fill", highLightFill);
        _this.bottomCircle.attr("fill", highLightFill);
      });
      this.handleGroup.on("".concat(name, "-handler:mouseleave"), function() {
        var fill = _this.style.fill;
        _this.verticalLine.attr("fill", fill);
        _this.topCircle.attr("fill", fill);
        _this.bottomCircle.attr("fill", fill);
      });
    };
    Handler2.prototype.show = function() {
      this.handleGroup.show();
    };
    Handler2.prototype.hide = function() {
      this.handleGroup.hide();
    };
    Handler2.prototype.updateXY = function() {
      this.handleGroup.setMatrix([1, 0, 0, 0, 1, 0, this.x, this.y, 1]);
    };
    return Handler2;
  }()
);
var handler_default = Handler;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
init_esm();
var __assign12 = function() {
  __assign12 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign12.apply(this, arguments);
};
var transform14 = ext_exports.transform;
var BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.05
};
var SIMPLE_BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.15,
  radius: 5
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.3,
  cursor: "grab"
};
var DEFAULT_HANDLER_WIDTH = 2;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var TICK_LABEL_STYLE = {
  textAlign: "center",
  textBaseline: "top",
  fill: "#607889",
  opacity: 0.35
};
var TICK_LINE_STYLE = {
  lineWidth: 1,
  stroke: "#ccc"
};
var TrendTimeBar = (
  /** @class */
  function() {
    function TrendTimeBar2(cfg) {
      var _this = this;
      this.prevX = 0;
      this.onMouseDown = function(handler) {
        return function(e8) {
          _this.currentHandler = handler;
          var event = e8.originalEvent;
          event.stopPropagation();
          event.preventDefault();
          _this.prevX = get_default(event, "touches.0.pageX", event.pageX);
          var containerDOM = _this.canvas.get("container");
          containerDOM.addEventListener("mousemove", _this.onMouseMove);
          containerDOM.addEventListener("mouseup", _this.onMouseUp);
          containerDOM.addEventListener("mouseleave", _this.onMouseUp);
          containerDOM.addEventListener("touchmove", _this.onMouseMove);
          containerDOM.addEventListener("touchend", _this.onMouseUp);
          containerDOM.addEventListener("touchcancel", _this.onMouseUp);
        };
      };
      this.onMouseMove = function(e8) {
        e8.stopPropagation();
        e8.preventDefault();
        var x5 = get_default(e8, "touches.0.pageX", e8.pageX);
        var offsetX = x5 - _this.prevX;
        var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI();
        _this.prevX = x5;
      };
      this.onMouseUp = function() {
        if (_this.currentHandler) {
          _this.currentHandler = void 0;
        }
        var containerDOM = _this.canvas.get("container");
        if (containerDOM) {
          containerDOM.removeEventListener("mousemove", _this.onMouseMove);
          containerDOM.removeEventListener("mouseup", _this.onMouseUp);
          containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
          containerDOM.removeEventListener("touchmove", _this.onMouseMove);
          containerDOM.removeEventListener("touchend", _this.onMouseUp);
          containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
        }
      };
      var _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 100 : _c, height = cfg.height, _d = cfg.padding, padding = _d === void 0 ? 10 : _d, trendCfg = cfg.trendCfg, _e2 = cfg.controllerCfg, controllerCfg = _e2 === void 0 ? {
        speed: 1
      } : _e2, _f = cfg.backgroundStyle, backgroundStyle = _f === void 0 ? {} : _f, _g = cfg.foregroundStyle, foregroundStyle = _g === void 0 ? {} : _g, _h = cfg.handlerStyle, handlerStyle = _h === void 0 ? {} : _h, _j = cfg.textStyle, textStyle = _j === void 0 ? {} : _j, _k = cfg.start, start = _k === void 0 ? 0 : _k, _l = cfg.end, end2 = _l === void 0 ? 1 : _l, _m = cfg.minText, minText = _m === void 0 ? "" : _m, _o2 = cfg.maxText, maxText = _o2 === void 0 ? "" : _o2, group = cfg.group, graph = cfg.graph, canvas = cfg.canvas, _p = cfg.tick, tick = _p === void 0 ? {
        tickLabelStyle: {},
        tickLineStyle: {},
        tickLabelFormatter: function tickLabelFormatter(d2) {
          return d2;
        },
        ticks: []
      } : _p, type = cfg.type;
      this.graph = graph;
      this.canvas = canvas;
      this.group = group;
      this.timeBarType = type;
      this.x = x4;
      this.y = y4;
      this.width = width;
      this.height = height;
      this.padding = padding;
      this.ticks = tick.ticks;
      this.trendCfg = trendCfg;
      this.controllerCfg = controllerCfg;
      this.currentSpeed = controllerCfg.speed || 1;
      this.tickLabelFormatter = tick.tickLabelFormatter;
      if (type === "trend") {
        this.backgroundStyle = __assign12(__assign12({}, BACKGROUND_STYLE), backgroundStyle);
      } else if (type === "simple") {
        this.backgroundStyle = __assign12(__assign12({}, SIMPLE_BACKGROUND_STYLE), backgroundStyle);
      }
      this.foregroundStyle = __assign12(__assign12({}, FOREGROUND_STYLE), foregroundStyle);
      this.handlerStyle = __assign12(__assign12({}, HANDLER_STYLE), handlerStyle);
      this.textStyle = __assign12(__assign12({}, TEXT_STYLE), textStyle);
      this.tickLabelStyle = __assign12(__assign12({}, TICK_LABEL_STYLE), tick.tickLabelStyle);
      this.tickLineStyle = __assign12(__assign12({}, TICK_LINE_STYLE), tick.tickLineStyle);
      this.currentMode = controllerCfg.defaultTimeType || TIME_TYPE.RANGE;
      this.start = start;
      this.end = end2;
      this.minText = minText;
      this.maxText = maxText;
      this.fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
      this.renderSlider();
    }
    TrendTimeBar2.prototype.update = function(cfg) {
      var x4 = cfg.x, y4 = cfg.y, width = cfg.width, height = cfg.height, minText = cfg.minText, maxText = cfg.maxText, start = cfg.start, end2 = cfg.end;
      this.start = Math.min(1, Math.max(start, 0));
      this.end = Math.min(1, Math.max(end2, 0));
      mix(this, {
        x: x4,
        y: y4,
        width,
        height,
        minText,
        maxText
      });
      this.updateUI();
    };
    TrendTimeBar2.prototype.setText = function(minText, maxText) {
      this.minTextShape.attr("text", minText);
      this.maxTextShape.attr("text", maxText);
    };
    TrendTimeBar2.prototype.renderSlider = function() {
      var _this = this;
      var _a2 = this, width = _a2.width, height = _a2.height, timeBarType = _a2.timeBarType;
      if (timeBarType === "trend" && size(get_default(this.trendCfg, "data"))) {
        var trendComponent = new trend_default(__assign12(__assign12({
          x: this.x,
          y: this.y,
          width,
          height
        }, this.trendCfg), {
          group: this.group
        }));
        this.trendComponent = trendComponent;
      }
      var sliderGroup = this.group.addGroup({
        name: "slider-group"
      });
      sliderGroup.addShape("rect", {
        attrs: __assign12({
          x: 0,
          y: 0,
          width,
          height
        }, this.backgroundStyle),
        name: "background"
      });
      var textGroup = this.group.addGroup();
      if (timeBarType === "trend") {
        this.minTextShape = textGroup.addShape("text", {
          attrs: __assign12({
            x: 0,
            y: height / 2 + this.y,
            textAlign: "right",
            text: this.minText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "min-text-shape"
        });
        this.maxTextShape = textGroup.addShape("text", {
          attrs: __assign12({
            y: height / 2 + this.y,
            textAlign: "left",
            text: this.maxText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "max-text-shape"
        });
      } else {
        this.minTextShape = textGroup.addShape("text", {
          attrs: __assign12({
            x: 0,
            y: this.y - 10,
            textAlign: "center",
            text: this.minText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "min-text-shape"
        });
        this.maxTextShape = textGroup.addShape("text", {
          attrs: __assign12({
            y: this.y - 10,
            textAlign: "center",
            text: this.maxText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "max-text-shape"
        });
      }
      this.foregroundShape = this.group.addGroup().addShape("rect", {
        attrs: __assign12({
          x: 0,
          y: this.y,
          height
        }, this.foregroundStyle),
        name: "foreground-shape"
      });
      this.foregroundShape.on("mousedown", function(e8) {
        e8.target.attr("cursor", "grabbing");
      });
      this.foregroundShape.on("mouseup", function(e8) {
        e8.target.attr("cursor", _this.foregroundStyle.cursor || "grab");
      });
      var handlerWidth = get_default(this.handlerStyle, "width", 2);
      var handlerHeight = get_default(this.handlerStyle, "height", 24);
      var minHandleGroup = this.group.addGroup({
        name: "minHandlerShape"
      });
      this.minHandlerShape = new handler_default({
        name: "minHandlerShape",
        group: minHandleGroup,
        type: timeBarType,
        x: this.x,
        y: this.y,
        width: handlerWidth,
        height: handlerHeight,
        style: this.handlerStyle
      });
      var maxHandleGroup = this.group.addGroup({
        name: "maxHandlerShape"
      });
      this.maxHandlerShape = new handler_default({
        name: "maxHandlerShape",
        group: maxHandleGroup,
        type: timeBarType,
        x: this.x,
        y: this.y,
        width: handlerWidth,
        height: handlerHeight,
        style: this.handlerStyle
      });
      var tickData = this.ticks;
      var interval2 = width / (tickData.length - 1);
      this.tickPosList = [];
      if (this.textList && this.textList.length) {
        this.textList.forEach(function(text) {
          text.destroy();
        });
      }
      var lastX = -Infinity;
      var rotate9 = this.tickLabelStyle.rotate;
      delete this.tickLabelStyle.rotate;
      this.textList = tickData.map(function(data, index2) {
        _this.tickPosList.push(_this.x + index2 * interval2);
        var label;
        if (_this.tickLabelFormatter) {
          label = _this.tickLabelFormatter(data);
          if (!is_string_default(label) && label) {
            label = data.date;
          }
        } else {
          label = data.date;
        }
        var textX = _this.x + index2 * interval2, textY = _this.y + height + 5;
        var text = _this.group.addShape("text", {
          attrs: __assign12({
            x: textX,
            y: textY,
            text: label,
            fontFamily: _this.fontFamily || "Arial, sans-serif"
          }, _this.tickLabelStyle),
          name: "tick-label"
        });
        if (is_number_default(rotate9) && index2 !== tickData.length - 1) {
          var matrix = transform14([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -textX, -textY], ["r", rotate9], ["t", textX - 5, textY + 2]]);
          text.attr({
            textAlign: "left",
            matrix
          });
        }
        if (index2 === 0) {
          text.attr({
            textAlign: "left"
          });
        } else if (index2 !== tickData.length - 1) {
          text.attr({
            textAlign: "right"
          });
        }
        var line = _this.group.addShape("line", {
          attrs: __assign12({
            x1: _this.x + index2 * interval2,
            y1: _this.y + height + 2,
            x2: _this.x + index2 * interval2,
            y2: _this.y + height + 6
          }, _this.tickLineStyle),
          name: "tick-line"
        });
        line.toBack();
        var bbox = text.getBBox();
        if (bbox.minX > lastX) {
          text.show();
          line.show();
          lastX = bbox.minX + bbox.width + 10;
        } else {
          text.hide();
          line.hide();
        }
        return text;
      });
      this.controllerBtnGroup = new controllerBtn_default(__assign12({
        group: this.group,
        x: this.x,
        y: this.y + height + 25,
        width,
        height: 35
      }, this.controllerCfg));
      this.updateStartEnd(0);
      this.updateUI();
      sliderGroup.move(this.x, this.y);
      this.bindEvents();
      if (this.currentMode === TIME_TYPE.SINGLE) {
        this.minHandlerShape.hide();
        this.foregroundShape.hide();
        this.minTextShape.hide();
      }
    };
    TrendTimeBar2.prototype.bindEvents = function() {
      var _this = this;
      var minHandleShapeGroup = this.group.find(function(group) {
        return group.get("name") === "minHandlerShape";
      });
      if (minHandleShapeGroup) {
        minHandleShapeGroup.on("minHandlerShape-handler:mousedown", this.onMouseDown(this.minHandlerShape));
        minHandleShapeGroup.on("minHandlerShape-handler:touchstart", this.onMouseDown(this.minHandlerShape));
      }
      var maxHandleShapeGroup = this.group.find(function(group) {
        return group.get("name") === "maxHandlerShape";
      });
      if (maxHandleShapeGroup) {
        maxHandleShapeGroup.on("maxHandlerShape-handler:mousedown", this.onMouseDown(this.maxHandlerShape));
        maxHandleShapeGroup.on("maxHandlerShape-handler:touchstart", this.onMouseDown(this.maxHandlerShape));
      }
      this.foregroundShape.on("mousedown", this.onMouseDown(this.foregroundShape));
      this.foregroundShape.on("touchstart", this.onMouseDown(this.foregroundShape));
      this.group.on("".concat(PLAY_PAUSE_BTN, ":click"), function() {
        _this.isPlay = !_this.isPlay;
        _this.currentHandler = _this.maxHandlerShape;
        _this.changePlayStatus();
      });
      this.group.on("".concat(NEXT_STEP_BTN, ":click"), function() {
        _this.currentHandler = _this.maxHandlerShape;
        _this.updateStartEnd(0.01);
        _this.updateUI();
      });
      this.group.on("".concat(PRE_STEP_BTN, ":click"), function() {
        _this.currentHandler = _this.maxHandlerShape;
        _this.updateStartEnd(-0.01);
        _this.updateUI();
      });
      this.group.on(TIMEBAR_CONFIG_CHANGE, function(_a2) {
        var type = _a2.type, speed = _a2.speed;
        _this.currentSpeed = speed;
        _this.currentMode = type;
        if (type === TIME_TYPE.SINGLE) {
          _this.minHandlerShape.hide();
          _this.foregroundShape.hide();
          _this.minTextShape.hide();
        } else if (type === TIME_TYPE.RANGE) {
          _this.minHandlerShape.show();
          _this.foregroundShape.show();
          _this.minTextShape.show();
        }
      });
    };
    TrendTimeBar2.prototype.adjustTickIndex = function(timeSelectX) {
      for (var i2 = 0; i2 < this.tickPosList.length - 1; i2++) {
        if (this.tickPosList[i2] <= timeSelectX && timeSelectX <= this.tickPosList[i2 + 1]) {
          return Math.abs(this.tickPosList[i2] - timeSelectX) < Math.abs(timeSelectX - this.tickPosList[i2 + 1]) ? i2 : i2 + 1;
        }
      }
      return 0;
    };
    TrendTimeBar2.prototype.adjustOffsetRange = function(offsetRange) {
      switch (this.currentHandler) {
        case this.minHandlerShape: {
          var min6 = 0 - this.start;
          var max8 = 1 - this.start;
          return Math.min(max8, Math.max(min6, offsetRange));
        }
        case this.maxHandlerShape: {
          var min6 = 0 - this.end;
          var max8 = 1 - this.end;
          return Math.min(max8, Math.max(min6, offsetRange));
        }
        case this.foregroundShape: {
          var min6 = 0 - this.start;
          var max8 = 1 - this.end;
          return Math.min(max8, Math.max(min6, offsetRange));
        }
        default:
          return 0;
      }
    };
    TrendTimeBar2.prototype.updateStartEnd = function(offsetRange) {
      var minData = this.ticks[this.adjustTickIndex(this.start * this.width)];
      var maxData = this.ticks[this.adjustTickIndex(this.end * this.width)];
      if (!this.currentHandler) {
        this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData === null || minData === void 0 ? void 0 : minData.date;
        this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData === null || maxData === void 0 ? void 0 : maxData.date;
        return;
      }
      switch (this.currentHandler) {
        case this.minHandlerShape:
          this.maxText = this.maxTextShape.attr("text");
          this.start += offsetRange;
          this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;
          break;
        case this.maxHandlerShape:
          this.minText = this.minTextShape.attr("text");
          this.end += offsetRange;
          this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;
          break;
        case this.foregroundShape:
          this.start += offsetRange;
          this.end += offsetRange;
          this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;
          this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;
          break;
        default:
          break;
      }
    };
    TrendTimeBar2.prototype.updateUI = function() {
      var _this = this;
      if (this.start < 0) {
        this.start = 0;
      }
      if (this.start > 1) {
        this.start = 1;
      }
      if (this.end > 1) {
        this.end = 1;
      }
      if (this.end < 0) {
        this.end = 0;
      }
      var min6 = this.x + this.start * this.width;
      var max8 = this.x + this.end * this.width;
      this.foregroundShape.attr("x", min6);
      this.foregroundShape.attr("width", max8 - min6);
      var handlerWidth = get_default(this.handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      this.setText(this.minText, this.maxText);
      var _a2 = this.dodgeText([min6, max8]), minAttrs = _a2[0], maxAttrs = _a2[1];
      this.minHandlerShape.setX(min6 - handlerWidth / 2);
      each_default(minAttrs, function(v2, k2) {
        return _this.minTextShape.attr(k2, v2);
      });
      this.maxHandlerShape.setX(max8 - handlerWidth / 2);
      each_default(maxAttrs, function(v2, k2) {
        return _this.maxTextShape.attr(k2, v2);
      });
      if (this.currentMode === TIME_TYPE.RANGE) {
        this.graph.emit(VALUE_CHANGE, {
          value: [this.start, this.end].sort()
        });
      } else if (this.currentMode === TIME_TYPE.SINGLE) {
        this.graph.emit(VALUE_CHANGE, {
          value: [this.end, this.end]
        });
      }
    };
    TrendTimeBar2.prototype.dodgeText = function(range) {
      var _a2, _b;
      var TEXTPADDING = 2;
      var handlerWidth = get_default(this.handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var minTextShape = this.minTextShape;
      var maxTextShape = this.maxTextShape;
      var min6 = range[0], max8 = range[1];
      var sorted = false;
      if (min6 > max8) {
        _a2 = [max8, min6], min6 = _a2[0], max8 = _a2[1];
        _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
        sorted = true;
      }
      var minBBox = minTextShape.getBBox();
      var maxBBox = maxTextShape.getBBox();
      var minAttrs = null;
      var maxAttrs = null;
      if (this.timeBarType === "trend") {
        minAttrs = min6 - minBBox.width < this.x + TEXTPADDING ? {
          x: min6 + handlerWidth / 2 + TEXTPADDING,
          textAlign: "left"
        } : {
          x: min6 - handlerWidth / 2 - TEXTPADDING,
          textAlign: "right"
        };
        maxAttrs = max8 + maxBBox.width > this.x + this.width ? {
          x: max8 - handlerWidth / 2 - TEXTPADDING,
          textAlign: "right"
        } : {
          x: max8 + handlerWidth / 2 + TEXTPADDING,
          textAlign: "left"
        };
      } else if (this.timeBarType === "simple") {
        minAttrs = minTextShape.attr("x") > minBBox.width ? {
          x: min6,
          textAlign: "center"
        } : {
          x: min6,
          textAlign: "left"
        };
        maxAttrs = maxTextShape.attr("x") > this.width - maxBBox.width ? {
          x: max8,
          textAlign: "right"
        } : {
          x: max8,
          textAlign: "center"
        };
      }
      return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    TrendTimeBar2.prototype.startPlay = function() {
      var _this = this;
      return typeof window !== "undefined" ? window.requestAnimationFrame(function() {
        var _a2 = _this, ticks = _a2.ticks, width = _a2.width;
        var speed = _this.currentSpeed;
        var tickInterval = width / ticks.length;
        var offsetX = tickInterval / ((10 - speed) * 1e3 / 60);
        var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI();
        if (_this.isPlay) {
          _this.playHandler = _this.startPlay();
        }
      }) : void 0;
    };
    TrendTimeBar2.prototype.changePlayStatus = function(isSync) {
      if (isSync === void 0) {
        isSync = true;
      }
      this.controllerBtnGroup.playButton.update({
        isPlay: this.isPlay
      });
      if (this.isPlay) {
        this.playHandler = this.startPlay();
        this.graph.emit(TIMELINE_START, null);
      } else {
        if (this.playHandler) {
          if (typeof window !== "undefined") window.cancelAnimationFrame(this.playHandler);
          if (isSync) {
            this.graph.emit(TIMELINE_END, null);
          }
        }
      }
    };
    TrendTimeBar2.prototype.destory = function() {
      this.graph.off(VALUE_CHANGE, function() {
      });
      var group = this.group;
      var minHandleShapeGroup = group.find(function(g2) {
        return g2.get("name") === "minHandlerShape";
      });
      if (minHandleShapeGroup) {
        minHandleShapeGroup.off("minHandlerShape-handler:mousedown");
        minHandleShapeGroup.off("minHandlerShape-handler:touchstart");
        minHandleShapeGroup.destroy();
      }
      var maxHandleShapeGroup = group.find(function(g2) {
        return g2.get("name") === "maxHandlerShape";
      });
      if (maxHandleShapeGroup) {
        maxHandleShapeGroup.off("maxHandlerShape-handler:mousedown");
        maxHandleShapeGroup.off("maxHandlerShape-handler:touchstart");
        maxHandleShapeGroup.destroy();
      }
      this.foregroundShape.off("mousedown");
      this.foregroundShape.off("touchstart");
      this.foregroundShape.destroy();
      group.off("".concat(PLAY_PAUSE_BTN, ":click"));
      group.off("".concat(NEXT_STEP_BTN, ":click"));
      group.off("".concat(PRE_STEP_BTN, ":click"));
      group.off(TIMEBAR_CONFIG_CHANGE);
      group.destroy();
      if (this.trendComponent) {
        this.trendComponent.destory();
      }
    };
    return TrendTimeBar2;
  }()
);
var trendTimeBar_default = TrendTimeBar;

// node_modules/@antv/g6-plugin/es/timeBar/index.js
var __extends11 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign13 = function() {
  __assign13 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign13.apply(this, arguments);
};
var __rest4 = function(s2, e8) {
  var t4 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0) t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
    if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t4[p2[i2]] = s2[p2[i2]];
  }
  return t4;
};
var DEFAULT_SIMPLE_HEIGHT = 4;
var DEFAULT_TREND_HEIGHT = 26;
var TimeBar = (
  /** @class */
  function(_super) {
    __extends11(TimeBar3, _super);
    function TimeBar3(config) {
      var _this = _super.call(this, config) || this;
      _this.afterrenderListener = function(e8) {
        return _this.filterData({});
      };
      _this.valueChangeListener = throttle_default(
        function(e8) {
          return _this.filterData(e8);
        },
        // 不可简写，否则 filterData 中 this 指针不对
        200,
        {
          trailing: true,
          leading: true
        }
      );
      _this.changeData = function(e8) {
        var graph = _this.get("graph");
        _this.cacheGraphData = graph.get("data");
        _this.filterData({});
      };
      return _this;
    }
    TimeBar3.prototype.getDefaultCfgs = function() {
      return {
        container: null,
        className: "g6-component-timebar",
        padding: 10,
        type: "trend",
        trend: {
          data: [],
          isArea: false,
          smooth: true
        },
        controllerCfg: {
          speed: 1,
          loop: false
        },
        slider: {
          start: 0.1,
          end: 0.9,
          minText: "min",
          maxText: "max"
        },
        tick: {
          start: 0.1,
          end: 0.9,
          data: []
        },
        textStyle: {},
        filterEdge: false,
        filterItemTypes: ["node"],
        containerCSS: {},
        putInGraphContainer: true
      };
    };
    TimeBar3.prototype.initContainer = function() {
      var graph = this.get("graph");
      var _a2 = this._cfgs, width = _a2.width, height = _a2.height, putInGraphContainer = _a2.putInGraphContainer;
      var className = this.get("className") || "g6-component-timebar";
      var container = this.get("container");
      var timeBarContainer;
      if (!container) {
        timeBarContainer = createDom2("<div class='".concat(className, "'></div>"));
        modifyCSS(timeBarContainer, {
          position: "relative"
        });
      } else {
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        timeBarContainer = container;
      }
      if (putInGraphContainer) {
        var graphContainer = this.get("graph").get("container");
        graphContainer.appendChild(timeBarContainer);
      }
      this.set("timeBarContainer", timeBarContainer);
      var canvas;
      var renderer = graph.get("renderer");
      if (renderer === "SVG") {
        canvas = new canvas_default3({
          container: timeBarContainer,
          width,
          height
        });
      } else {
        canvas = new canvas_default2({
          container: timeBarContainer,
          width,
          height
        });
      }
      if (this.get("containerCSS")) modifyCSS(timeBarContainer, this.get("containerCSS"));
      this.set("canvas", canvas);
    };
    TimeBar3.prototype.init = function() {
      this.initContainer();
      var canvas = this.get("canvas");
      var timeBarGroup = canvas.addGroup({
        name: "timebar-group"
      });
      this.set("timeBarGroup", timeBarGroup);
      this.renderTrend();
      this.initEvent();
      var fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
      this.set("fontFamily", fontFamily);
    };
    TimeBar3.prototype.play = function() {
      this.togglePlay(true);
    };
    TimeBar3.prototype.pause = function() {
      this.togglePlay(false);
    };
    TimeBar3.prototype.togglePlay = function(play) {
      var timebar = this.get("timebar");
      if (!timebar) return;
      timebar.isPlay = !!play;
      timebar.changePlayStatus();
    };
    TimeBar3.prototype.renderTrend = function() {
      var _this = this;
      var _a2 = this._cfgs, width = _a2.width, x4 = _a2.x, y4 = _a2.y, padding = _a2.padding, type = _a2.type, trend = _a2.trend, slider = _a2.slider, controllerCfg = _a2.controllerCfg, textStyle = _a2.textStyle, tick = _a2.tick, backgroundStyle = _a2.backgroundStyle, foregroundStyle = _a2.foregroundStyle;
      var data = trend.data, other = __rest4(trend, ["data"]);
      var realWidth = width - 2 * padding;
      var defaultHeight = type === "trend" ? DEFAULT_TREND_HEIGHT : DEFAULT_SIMPLE_HEIGHT;
      var graph = this.get("graph");
      var group = this.get("timeBarGroup");
      var canvas = this.get("canvas");
      var timebar = null;
      if (type === "trend" || type === "simple") {
        var getValue_1 = this.get("getValue");
        timebar = new trendTimeBar_default(__assign13(__assign13({
          graph,
          canvas,
          group,
          type,
          x: x4 + padding,
          y: type === "trend" ? y4 + padding : y4 + padding + 15,
          width: realWidth,
          height: defaultHeight,
          padding,
          backgroundStyle,
          foregroundStyle,
          trendCfg: __assign13(__assign13({}, other), {
            data: data.map(function(d2) {
              return (getValue_1 === null || getValue_1 === void 0 ? void 0 : getValue_1(d2)) || d2.value;
            })
          })
        }, slider), {
          tick: {
            ticks: data,
            tickLabelFormatter: tick.tickLabelFormatter,
            tickLabelStyle: tick.tickLabelStyle,
            tickLineStyle: tick.tickLineStyle
          },
          handlerStyle: __assign13(__assign13({}, slider.handlerStyle), {
            height: slider.height || defaultHeight
          }),
          controllerCfg,
          textStyle
        }));
      } else if (type === "tick") {
        timebar = new timeBarSlice_default(__assign13({
          graph,
          canvas,
          group,
          x: x4 + padding,
          y: y4 + padding,
          width,
          height: 42,
          padding: 2,
          controllerCfg
        }, tick));
      }
      var handleMouseUp = function handleMouseUp2() {
        var timebarInstance = _this.get("timebar");
        timebarInstance.draggingHandler = false;
        if (timebarInstance.isPlay) {
          timebarInstance.isPlay = false;
          timebarInstance.currentHandler = timebarInstance.maxHandlerShape;
          timebarInstance.changePlayStatus();
        }
        document.removeEventListener("mouseup", handleMouseUp2);
      };
      canvas.on("mousedown", function(e8) {
        if (e8.target.get("name") === "maxHandlerShape-handler" || e8.target.get("name") === "minHandlerShape-handler" || e8.target === timebar.foregroundShape) {
          document.addEventListener("mouseup", handleMouseUp);
        }
      });
      this.set("timebar", timebar);
    };
    TimeBar3.prototype.filterData = function(evt) {
      var _a2;
      var value = evt.value;
      if (!value) {
        value = [];
        var type_1 = this._cfgs.type;
        if (!type_1 || type_1 === "trend" || type_1 === "simple") {
          value[0] = this._cfgs.slider.start;
          value[1] = this._cfgs.slider.end;
        } else if (type_1 === "tick") {
          value[0] = this._cfgs.tick.start;
          value[1] = this._cfgs.tick.end;
        }
      }
      var trendData = null;
      var type = this._cfgs.type;
      if (type === "trend" || type === "simple") {
        trendData = this._cfgs.trend.data;
      } else if (type === "tick") {
        trendData = this._cfgs.tick.data;
      }
      if (!trendData || trendData.length === 0) {
        console.warn("请配置 TimeBar 组件的数据");
        return;
      }
      var rangeChange = this.get("rangeChange");
      var graph = this.get("graph");
      var min6 = Math.round(trendData.length * value[0]);
      var max8 = Math.round(trendData.length * value[1]);
      max8 = max8 >= trendData.length ? trendData.length - 1 : max8;
      min6 = min6 >= trendData.length ? trendData.length - 1 : min6;
      var tickLabelFormatter = (_a2 = this._cfgs.tick) === null || _a2 === void 0 ? void 0 : _a2.tickLabelFormatter;
      var minText = tickLabelFormatter ? tickLabelFormatter(trendData[min6]) : trendData[min6].date;
      var maxText = tickLabelFormatter ? tickLabelFormatter(trendData[max8]) : trendData[max8].date;
      if (type !== "tick") {
        var timebar = this.get("timebar");
        timebar.setText(minText, maxText);
      }
      if (rangeChange) {
        rangeChange(graph, minText, maxText);
      } else {
        if (!this.cacheGraphData || this.cacheGraphData.nodes && this.cacheGraphData.nodes.length === 0) {
          this.cacheGraphData = graph.get("data");
        }
        var filterItemTypes = this.get("filterItemTypes");
        var changeData = this.get("changeData");
        var getDate_1 = this.get("getDate");
        var shouldIgnore_1 = this.get("shouldIgnore");
        var minDate_1 = trendData[min6].date, maxDate_1 = trendData[max8].date;
        if (changeData || changeData === void 0) {
          var originNodes = this.cacheGraphData.nodes;
          var originEdges = this.cacheGraphData.edges;
          var currentNodeExistMap_1 = {};
          var currentEdgeExistMap_1 = {};
          graph.getNodes().forEach(function(node) {
            return currentNodeExistMap_1[node.getID()] = true;
          });
          graph.getEdges().forEach(function(edge) {
            return currentEdgeExistMap_1[edge.getID()] = true;
          });
          if (filterItemTypes.includes("node")) {
            originNodes === null || originNodes === void 0 ? void 0 : originNodes.forEach(function(node) {
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(node)) || node.date);
              var hitRange = date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("node", node, {
                min: minDate_1,
                max: maxDate_1
              }));
              var exist = currentNodeExistMap_1[node.id];
              if (exist && !hitRange) {
                graph.removeItem(node.id);
                currentNodeExistMap_1[node.id] = false;
              } else if (!exist && hitRange) {
                graph.addItem("node", node);
                currentNodeExistMap_1[node.id] = true;
              }
            });
            originEdges === null || originEdges === void 0 ? void 0 : originEdges.forEach(function(edge) {
              var shouldShow = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target] || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", edge, {
                min: minDate_1,
                max: maxDate_1
              }));
              var exist = !!graph.findById(edge.id);
              if (exist && !shouldShow) {
                graph.removeItem(edge.id);
                currentEdgeExistMap_1[edge.id] = false;
              } else if (!exist && shouldShow) {
                graph.addItem("edge", edge);
                currentEdgeExistMap_1[edge.id] = true;
              } else if (!exist) {
                currentEdgeExistMap_1[edge.id] = false;
              }
            });
          }
          if (this.get("filterEdge") || filterItemTypes.includes("edge")) {
            originEdges === null || originEdges === void 0 ? void 0 : originEdges.filter(function(edge) {
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date);
              var hitRange = date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", edge, {
                min: minDate_1,
                max: maxDate_1
              }));
              var endsExist = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target];
              var shouldShow = hitRange && endsExist;
              var exist = currentEdgeExistMap_1[edge.id];
              if (exist && !shouldShow) {
                currentEdgeExistMap_1[edge.id] = false;
                graph.removeItem(edge.id);
              } else if (!exist && shouldShow) {
                currentEdgeExistMap_1[edge.id] = true;
                graph.addItem("edge", edge);
              }
            });
          }
        } else {
          if (filterItemTypes.includes("node")) {
            graph.getNodes().forEach(function(node) {
              var model = node.getModel();
              if (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("node", model, {
                min: minDate_1,
                max: maxDate_1
              })) return;
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(model)) || model.date);
              if (date < minDate_1 || date > maxDate_1) {
                graph.hideItem(node);
              } else {
                graph.showItem(node);
              }
            });
          }
          if (this.get("filterEdge") || filterItemTypes.includes("edge")) {
            graph.getEdges().forEach(function(edge) {
              var model = edge.getModel();
              if (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", model, {
                min: trendData[min6].date,
                max: trendData[max8].date
              })) return;
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(model)) || model.date);
              if (date < trendData[min6].date || date > trendData[max8].date) {
                graph.hideItem(edge);
              } else {
                var sourceVisible = edge.getSource().isVisible();
                var targetVisible = edge.getTarget().isVisible();
                if (sourceVisible && targetVisible) graph.showItem(edge);
              }
            });
          }
        }
      }
    };
    TimeBar3.prototype.initEvent = function() {
      var graph = this.get("graph");
      graph.on("afterchangedata", this.changeData);
      graph.on("afterrender", this.afterrenderListener);
      graph.on(VALUE_CHANGE, this.valueChangeListener);
    };
    TimeBar3.prototype.destroy = function() {
      var graph = this.get("graph");
      graph.off("afterchangedata", this.changeData);
      graph.off("afterrender", this.afterrenderListener);
      graph.off(VALUE_CHANGE, this.valueChangeListener);
      var timebar = this.get("timebar");
      if (timebar && timebar.destory) {
        timebar.destory();
      }
      _super.prototype.destroy.call(this);
      var timeBarContainer = this.get("timeBarContainer");
      if (timeBarContainer) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        if (container === timeBarContainer) {
          container = container.parentElement;
        }
        container.removeChild(timeBarContainer);
      }
    };
    return TimeBar3;
  }(base_default4)
);
var timeBar_default = TimeBar;

// node_modules/@antv/g6-plugin/es/imageMinimap/index.js
init_esm();
var __extends12 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var applyMatrix3 = util_default.applyMatrix;
function getImgNaturalDimension(img, callback) {
  var nWidth, nHeight;
  if (img.naturalWidth) {
    nWidth = img.naturalWidth;
    nHeight = img.naturalHeight;
  } else {
    var image_1 = new Image();
    image_1.src = img.src;
    image_1.onload = function() {
      if (callback) callback(image_1.width, image_1.height);
    };
  }
  return [nWidth, nHeight];
}
var ImageMiniMap = (
  /** @class */
  function(_super) {
    __extends12(ImageMiniMap2, _super);
    function ImageMiniMap2(config) {
      return _super.call(this, config) || this;
    }
    ImageMiniMap2.prototype.getDefaultCfgs = function() {
      return {
        container: null,
        className: "g6-minimap",
        viewportClassName: "g6-minimap-viewport",
        width: 200,
        delegateStyle: {
          fill: "#40a9ff",
          stroke: "#096dd9"
        },
        refresh: true
      };
    };
    ImageMiniMap2.prototype.getEvents = function() {
      return {
        beforepaint: "updateViewport",
        beforeanimate: "disableRefresh",
        afteranimate: "enableRefresh",
        viewportchange: "disableOneRefresh"
      };
    };
    ImageMiniMap2.prototype.disableRefresh = function() {
      this.set("refresh", false);
    };
    ImageMiniMap2.prototype.enableRefresh = function() {
      this.set("refresh", true);
      this.updateCanvas();
    };
    ImageMiniMap2.prototype.disableOneRefresh = function() {
      this.set("viewportChange", true);
    };
    ImageMiniMap2.prototype.initViewport = function() {
      var _this = this;
      var cfgs = this._cfgs;
      var graph = cfgs.graph;
      if (this.destroyed) return;
      var containerDOM = this.get("container");
      if (is_string_default(containerDOM)) {
        containerDOM = document.getElementById(containerDOM);
      }
      var viewport = createDom2("<div class=".concat(cfgs.viewportClassName, "\n      style='position:absolute;\n        left:0;\n        top:0;\n        box-sizing:border-box;\n        border: 2px solid #1980ff;\n        cursor:move'\n      </div>"));
      var x4 = 0;
      var y4 = 0;
      var dragging = false;
      var left = 0;
      var top = 0;
      var width = 0;
      var height = 0;
      var ratio = 0;
      var zoom = 0;
      containerDOM.addEventListener("mousedown", function(e8) {
        cfgs.refresh = false;
        if (e8.target !== viewport) {
          return;
        }
        var style = viewport.style;
        width = parseInt(style.width, 10);
        height = parseInt(style.height, 10);
        var cWidth = _this.get("width");
        var cHeight = _this.get("height");
        if (width > cWidth || height > cHeight) {
          return;
        }
        zoom = graph.getZoom();
        ratio = _this.get("ratio");
        dragging = true;
        x4 = e8.clientX;
        y4 = e8.clientY;
      }, false);
      containerDOM.addEventListener("mousemove", function(e8) {
        if (!dragging || is_nil_default(e8.clientX) || is_nil_default(e8.clientY)) {
          return;
        }
        var cWidth = _this.get("width");
        var cHeight = _this.get("height");
        var style = viewport.style;
        left = parseInt(style.left, 10);
        top = parseInt(style.top, 10);
        width = parseInt(style.width, 10);
        height = parseInt(style.height, 10);
        var dx = x4 - e8.clientX;
        var dy = y4 - e8.clientY;
        if (left - dx < 0) {
          dx = left;
        } else if (left - dx + width >= cWidth) {
          dx = 0;
        }
        if (top - dy < 0) {
          dy = top;
        } else if (top - dy + height >= cHeight) {
          dy = 0;
        }
        left -= dx;
        top -= dy;
        modifyCSS(viewport, {
          left: "".concat(left, "px"),
          top: "".concat(top, "px")
        });
        graph.translate(dx * zoom / ratio, dy * zoom / ratio);
        x4 = e8.clientX;
        y4 = e8.clientY;
      }, false);
      containerDOM.addEventListener("mouseleave", function() {
        dragging = false;
        cfgs.refresh = true;
      }, false);
      containerDOM.addEventListener("mouseup", function() {
        dragging = false;
        cfgs.refresh = true;
      }, false);
      this.set("viewport", viewport);
      containerDOM.appendChild(viewport);
    };
    ImageMiniMap2.prototype.updateViewport = function() {
      if (this.destroyed) return;
      var ratio = this.get("ratio");
      var cWidth = this.get("width");
      var cHeight = this.get("height");
      var graph = this.get("graph");
      var graphWidth = graph.get("width");
      var graphHeight = graph.get("height");
      var aspectRatio = graphWidth / graphHeight;
      var graphGroup = graph.getGroup();
      var graphCanvasBBox = graphGroup.getCanvasBBox();
      var graphCanvasBBoxMean = [(graphCanvasBBox.minX + graphCanvasBBox.maxX) / 2, (graphCanvasBBox.minY + graphCanvasBBox.maxY) / 2];
      var graphCanvasBBoxSize = [graphCanvasBBox.maxX - graphCanvasBBox.minX, graphCanvasBBox.maxY - graphCanvasBBox.minY];
      var expandedGraphCanvasBBox = {
        centerX: graphCanvasBBoxMean[0],
        centerY: graphCanvasBBoxMean[1],
        width: 0,
        height: 0,
        minX: 0,
        minY: 0
      };
      if (graphCanvasBBox[0] / graphCanvasBBox[1] > aspectRatio) {
        expandedGraphCanvasBBox.width = graphCanvasBBoxSize[0];
        expandedGraphCanvasBBox.height = expandedGraphCanvasBBox.width / aspectRatio;
      } else {
        expandedGraphCanvasBBox.height = graphCanvasBBoxSize[1];
        expandedGraphCanvasBBox.width = expandedGraphCanvasBBox.height * aspectRatio;
      }
      expandedGraphCanvasBBox.minX = graphCanvasBBoxMean[0] - expandedGraphCanvasBBox.width / 2;
      expandedGraphCanvasBBox.minY = graphCanvasBBoxMean[1] - expandedGraphCanvasBBox.height / 2;
      var graphMatrix = graphGroup.getMatrix();
      if (!graphMatrix) graphMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var invertGraphMatrix = mat3_exports.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], graphMatrix);
      var minXY = applyMatrix3({
        x: expandedGraphCanvasBBox.minX,
        y: expandedGraphCanvasBBox.minY
      }, invertGraphMatrix);
      var topLeft = graph.getCanvasByPoint(minXY.x, minXY.y);
      var viewport = this.get("viewport");
      if (!viewport) {
        this.initViewport();
      }
      var vpToMc = graphWidth / expandedGraphCanvasBBox.width;
      var width = vpToMc * cWidth;
      var height = vpToMc * cHeight;
      var left = cWidth * -topLeft.x / expandedGraphCanvasBBox.width;
      var top = cHeight * -topLeft.y / expandedGraphCanvasBBox.height;
      var right = left + width;
      var bottom = top + height;
      if (left < 0) {
        width += left;
        left = 0;
      }
      if (right > cWidth) {
        width = width - (right - cWidth);
      }
      if (top < 0) {
        height += top;
        top = 0;
      }
      if (bottom > cHeight) {
        height = height - (bottom - cHeight);
      }
      this.set("ratio", ratio);
      var correctLeft = "".concat(left, "px");
      var correctTop = "".concat(top, "px");
      modifyCSS(viewport, {
        left: correctLeft,
        top: correctTop,
        width: "".concat(width, "px"),
        height: "".concat(height, "px")
      });
    };
    ImageMiniMap2.prototype.init = function() {
      this.initContainer();
    };
    ImageMiniMap2.prototype.initContainer = function() {
      var self2 = this;
      var graph = self2.get("graph");
      var graphWidth = graph.get("width");
      var graphHeight = graph.get("height");
      var aspectRatio = graphHeight / graphWidth;
      var className = self2.get("className");
      var parentNode = self2.get("container");
      var cWidth = self2.get("width");
      var cHeight = self2.get("height");
      if (!cWidth && !cHeight) {
        cWidth = 200;
      }
      if (cWidth) {
        cHeight = aspectRatio * cWidth;
        self2.set("height", cHeight);
      } else {
        cWidth = 1 / aspectRatio * cHeight;
        self2.set("width", cWidth);
      }
      var container = createDom2("<div class='".concat(className, "' style='width: ").concat(cWidth, "px; height: ").concat(cHeight, "px; overflow: hidden; position: relative;'></div>"));
      if (is_string_default(parentNode)) {
        parentNode = document.getElementById(parentNode);
      }
      if (parentNode) {
        parentNode.appendChild(container);
      } else {
        graph.get("container").appendChild(container);
      }
      self2.set("container", container);
      var containerDOM = createDom2('<div class="g6-minimap-container" style="position: relative; width: 100%; height: 100%; text-align: center; display: table;"></div>');
      container.appendChild(containerDOM);
      var span = createDom2('<span style="display: table-cell; vertical-align: middle; "></span>');
      containerDOM.appendChild(span);
      self2.set("containerDOM", containerDOM);
      self2.set("containerSpan", span);
      var img = createDom2('<img alt="" src="'.concat(this.get("graphImg"), '" style="display: inline-block; user-select: none;" draggable="false" />'));
      self2.set("imgDOM", img);
      self2.updateImgSize();
      span.appendChild(img);
      self2.updateCanvas();
    };
    ImageMiniMap2.prototype.updateImgSize = function() {
      var self2 = this;
      var imgDOM = self2.get("imgDOM");
      var cWidth = self2.get("width");
      var cHeight = self2.get("height");
      imgDOM.onload = function() {
        var naturalSize = getImgNaturalDimension(imgDOM);
        if (naturalSize[0] > naturalSize[1]) {
          imgDOM.width = cWidth;
        } else {
          imgDOM.height = cHeight;
        }
      };
    };
    ImageMiniMap2.prototype.updateCanvas = function() {
      var isRefresh = this.get("refresh");
      if (!isRefresh) {
        return;
      }
      var graph = this.get("graph");
      if (graph.get("destroyed")) {
        return;
      }
      if (this.get("viewportChange")) {
        this.set("viewportChange", false);
        this.updateViewport();
      }
      var cWidth = this.get("width");
      var graphBBox = graph.get("canvas").getCanvasBBox();
      var width = graphBBox.width;
      var ratio = cWidth / width;
      this.set("ratio", ratio);
      this.updateViewport();
    };
    ImageMiniMap2.prototype.getViewport = function() {
      return this.get("viewport");
    };
    ImageMiniMap2.prototype.getContainer = function() {
      return this.get("container");
    };
    ImageMiniMap2.prototype.updateGraphImg = function(img) {
      var self2 = this;
      var oriImgDOM = self2.get("imgDOM");
      oriImgDOM.remove();
      self2.set("graphImg", img);
      var imgDOM = createDom2('<img alt="" src="'.concat(img, '" style="display: inline-block;" ondragstart="return false;" onselectstart="return false;"/>'));
      self2.set("imgDOM", imgDOM);
      imgDOM.src = img;
      self2.updateImgSize();
      var span = self2.get("containerSpan");
      span.appendChild(imgDOM);
      self2.updateCanvas();
    };
    ImageMiniMap2.prototype.destroy = function() {
      var container = this.get("container");
      container.parentNode.removeChild(container);
    };
    return ImageMiniMap2;
  }(base_default4)
);
var imageMinimap_default = ImageMiniMap;

// node_modules/@antv/g6-plugin/es/edgeFilterLens/index.js
init_esm();
var __extends13 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign14 = function() {
  __assign14 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign14.apply(this, arguments);
};
var distance8 = util_default.distance;
var DELTA3 = 0.05;
var lensDelegateStyle2 = {
  stroke: "#000",
  strokeOpacity: 0.8,
  lineWidth: 2,
  fillOpacity: 1,
  fill: "#fff"
};
var EdgeFilterLens = (
  /** @class */
  function(_super) {
    __extends13(EdgeFilterLens3, _super);
    function EdgeFilterLens3(config) {
      return _super.call(this, config) || this;
    }
    EdgeFilterLens3.prototype.getDefaultCfgs = function() {
      return {
        type: "both",
        trigger: "mousemove",
        r: 60,
        delegateStyle: clone_default(lensDelegateStyle2),
        showLabel: "edge",
        scaleRBy: "wheel"
      };
    };
    EdgeFilterLens3.prototype.getEvents = function() {
      var events;
      switch (this.get("trigger")) {
        case "click":
          events = {
            click: "filter"
          };
          break;
        case "drag":
          events = {
            click: "createDelegate"
          };
          break;
        default:
          events = {
            mousemove: "filter"
          };
          break;
      }
      return events;
    };
    EdgeFilterLens3.prototype.init = function() {
      var self2 = this;
      var showLabel = self2.get("showLabel");
      var showNodeLabel = showLabel === "node" || showLabel === "both";
      var showEdgeLabel = showLabel === "edge" || showLabel === "both";
      self2.set("showNodeLabel", showNodeLabel);
      self2.set("showEdgeLabel", showEdgeLabel);
      var shouldShow = self2.get("shouldShow");
      if (!shouldShow) self2.set("shouldShow", function() {
        return true;
      });
    };
    EdgeFilterLens3.prototype.createDelegate = function(e8) {
      var self2 = this;
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        self2.filter(e8);
        lensDelegate = self2.get("delegate");
        lensDelegate.on("dragstart", function(evt) {
        });
        lensDelegate.on("drag", function(evt) {
          self2.filter(evt);
        });
        if (this.get("scaleRBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            self2.scaleRByWheel(evt);
          });
        }
      }
    };
    EdgeFilterLens3.prototype.scaleRByWheel = function(e8) {
      var self2 = this;
      if (!e8 || !e8.originalEvent) return;
      if (e8.preventDefault) e8.preventDefault();
      var graph = self2.get("graph");
      var ratio;
      var lensDelegate = self2.get("delegate");
      var lensCenter = lensDelegate ? {
        x: lensDelegate.attr("x"),
        y: lensDelegate.attr("y")
      } : void 0;
      var mousePos = lensCenter || graph.getPointByClient(e8.clientX, e8.clientY);
      if (e8.originalEvent.wheelDelta < 0) {
        ratio = 1 - DELTA3;
      } else {
        ratio = 1 / (1 - DELTA3);
      }
      var maxR = self2.get("maxR");
      var minR = self2.get("minR");
      var r2 = self2.get("r");
      if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
        ratio = 1;
      }
      r2 *= ratio;
      self2.set("r", r2);
      self2.filter(e8);
    };
    EdgeFilterLens3.prototype.filter = function(e8) {
      var self2 = this;
      var graph = self2.get("graph");
      var nodes = graph.getNodes();
      var hitNodesMap = {};
      var r2 = self2.get("r");
      var type = self2.get("type");
      var fCenter = {
        x: e8.x,
        y: e8.y
      };
      self2.updateDelegate(fCenter, r2);
      var shouldShow = self2.get("shouldShow");
      var vShapes = self2.get("vShapes");
      if (vShapes) {
        vShapes.forEach(function(shape) {
          shape.remove();
          shape.destroy();
        });
      }
      vShapes = [];
      nodes.forEach(function(node) {
        var model = node.getModel();
        var x4 = model.x, y4 = model.y;
        if (distance8({
          x: x4,
          y: y4
        }, fCenter) < r2) {
          hitNodesMap[model.id] = node;
        }
      });
      var edges = graph.getEdges();
      var hitEdges = [];
      edges.forEach(function(edge) {
        var model = edge.getModel();
        var sourceId = model.source;
        var targetId = model.target;
        if (shouldShow(model)) {
          if (type === "only-source" || type === "one") {
            if (hitNodesMap[sourceId] && !hitNodesMap[targetId]) hitEdges.push(edge);
          } else if (type === "only-target" || type === "one") {
            if (hitNodesMap[targetId] && !hitNodesMap[sourceId]) hitEdges.push(edge);
          } else if (type === "both" && hitNodesMap[sourceId] && hitNodesMap[targetId]) {
            hitEdges.push(edge);
          }
        }
      });
      var showNodeLabel = self2.get("showNodeLabel");
      var showEdgeLabel = self2.get("showEdgelabel");
      var group = graph.get("group");
      hitEdges.forEach(function(edge) {
        var shapes = edge.get("group").get("children");
        shapes.forEach(function(shape) {
          var shapeType = shape.get("type");
          var vShape = group.addShape(shapeType, {
            attrs: shape.attr()
          });
          vShapes.push(vShape);
          if (showNodeLabel && shapeType === "text") {
            vShape.set("visible", true);
          }
        });
      });
      Object.keys(hitNodesMap).forEach(function(key) {
        var node = hitNodesMap[key];
        var clonedGroup = node.get("group").clone();
        group.add(clonedGroup);
        vShapes.push(clonedGroup);
        if (showEdgeLabel) {
          var shapes = clonedGroup.get("children");
          for (var j2 = 0; j2 < shapes.length; j2++) {
            var shape = shapes[j2];
            if (shape.get("type") === "text") {
              shape.set("visible", true);
            }
          }
        }
      });
      self2.set("vShapes", vShapes);
    };
    EdgeFilterLens3.prototype.updateParams = function(cfg) {
      var self2 = this;
      var r2 = cfg.r, trigger = cfg.trigger, minR = cfg.minR, maxR = cfg.maxR, scaleRBy = cfg.scaleRBy, showLabel = cfg.showLabel, shouldShow = cfg.shouldShow;
      if (!isNaN(cfg.r)) {
        self2.set("r", r2);
      }
      if (!isNaN(maxR)) {
        self2.set("maxR", maxR);
      }
      if (!isNaN(minR)) {
        self2.set("minR", minR);
      }
      if (trigger === "mousemove" || trigger === "click") {
        self2.set("trigger", trigger);
      }
      if (scaleRBy === "wheel" || scaleRBy === "unset") {
        self2.set("scaleRBy", scaleRBy);
        self2.get("delegate").remove();
        self2.get("delegate").destroy();
        var dPercentText = self2.get("dPercentText");
        if (dPercentText) {
          dPercentText.remove();
          dPercentText.destroy();
        }
      }
      if (showLabel === "node" || showLabel === "both") {
        self2.set("showNodeLabel", true);
      }
      if (showLabel === "edge" || showLabel === "both") {
        self2.set("showEdgeLabel", true);
      }
      if (shouldShow) {
        self2.set("shouldShow", shouldShow);
      }
    };
    EdgeFilterLens3.prototype.updateDelegate = function(mCenter, r2) {
      var self2 = this;
      var graph = self2.get("graph");
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        var parent_1 = graph.get("group");
        var attrs = self2.get("delegateStyle") || lensDelegateStyle2;
        lensDelegate = parent_1.addShape("circle", {
          attrs: __assign14({
            r: r2,
            x: mCenter.x,
            y: mCenter.y
          }, attrs),
          name: "lens-shape",
          draggable: true
        });
        if (this.get("trigger") !== "drag") {
          if (this.get("scaleRBy") === "wheel") {
            lensDelegate.on("mousewheel", function(evt) {
              self2.scaleRByWheel(evt);
            });
          }
        }
      } else {
        lensDelegate.attr({
          x: mCenter.x,
          y: mCenter.y,
          r: r2
        });
      }
      self2.set("delegate", lensDelegate);
    };
    EdgeFilterLens3.prototype.clear = function() {
      var self2 = this;
      var vShapes = self2.get("vShapes");
      if (vShapes) {
        vShapes.forEach(function(shape) {
          shape.remove();
          shape.destroy();
        });
      }
      vShapes = [];
      self2.set("vShapes", vShapes);
      var lensDelegate = self2.get("delegate");
      if (lensDelegate && !lensDelegate.destroyed) {
        lensDelegate.remove();
        lensDelegate.destroy();
      }
    };
    EdgeFilterLens3.prototype.destroy = function() {
      this.clear();
    };
    return EdgeFilterLens3;
  }(base_default4)
);
var edgeFilterLens_default = EdgeFilterLens;

// node_modules/@antv/g6-plugin/es/snapline/index.js
init_esm();
var __extends14 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var pointLineDistance3 = util_default.pointLineDistance;
var alignLineStyle = {
  stroke: "#FA8C16",
  lineWidth: 1
};
var SnapLine = (
  /** @class */
  function(_super) {
    __extends14(SnapLine3, _super);
    function SnapLine3(props) {
      return _super.call(this, props) || this;
    }
    SnapLine3.prototype.getDefaultCfgs = function() {
      return {
        line: alignLineStyle,
        /**
         * item align type
         * @type {String|True|False}
         */
        itemAlignType: "center",
        /**
         * tolerance to item force align
         * @type {String|True|False}
         */
        tolerance: 5,
        horizontalLines: {},
        verticalLines: {},
        alignLines: []
      };
    };
    SnapLine3.prototype.init = function() {
    };
    SnapLine3.prototype.getEvents = function() {
      return {
        "node:dragstart": "onDragStart",
        "node:drag": "onDrag",
        "node:dragend": "onDragEnd"
      };
    };
    SnapLine3.prototype.onDragStart = function() {
      this.initBoxLine();
    };
    SnapLine3.prototype.onDrag = function(e8) {
      var item = e8.item;
      var delegateShape = item.get("delegateShape") || item;
      var bbox = delegateShape.getBBox();
      var model = item.getModel();
      var dx = model.x - bbox.x;
      var dy = model.y - bbox.y;
      this.show({
        x: bbox.minX + dx,
        y: bbox.minY + dy
      }, {
        width: bbox.width,
        height: bbox.height
      });
    };
    SnapLine3.prototype.onDragEnd = function() {
      this.destory();
    };
    SnapLine3.prototype.initBoxLine = function() {
      var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines, itemAlignType = _a2.itemAlignType;
      var graph = this.get("graph");
      var nodes = graph.getNodes();
      nodes.forEach(function(item) {
        var bbox = item.getBBox();
        var nodeId = item.get("id");
        if (itemAlignType === true || itemAlignType === "horizontal") {
          horizontalLines["".concat(nodeId, "tltr")] = [bbox.minX, bbox.minY, bbox.maxX, bbox.minY, item];
          horizontalLines["".concat(nodeId, "lcrc")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];
          horizontalLines["".concat(nodeId, "blbr")] = [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY, item];
        } else if (itemAlignType === "center") {
          horizontalLines["".concat(nodeId, "lcrc")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];
        }
        if (itemAlignType === true || itemAlignType === "vertical") {
          verticalLines["".concat(nodeId, "tlbl")] = [bbox.minX, bbox.minY, bbox.minX, bbox.maxY, item];
          verticalLines["".concat(nodeId, "tcbc")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];
          verticalLines["".concat(nodeId, "trbr")] = [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY, item];
        } else if (itemAlignType === "center") {
          verticalLines["".concat(nodeId, "tcbc")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];
        }
      });
    };
    SnapLine3.prototype.show = function(point, bbox) {
      var originPoint = mix({}, point);
      this.itemAlign(point, bbox, originPoint);
      return point;
    };
    SnapLine3.prototype.itemAlign = function(point, bbox, originPoint) {
      var _this = this;
      var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines, tolerance3 = _a2.tolerance;
      var tc2 = {
        x: originPoint.x + bbox.width / 2,
        y: originPoint.y
      };
      var cc2 = {
        x: originPoint.x + bbox.width / 2,
        y: originPoint.y + bbox.height / 2
      };
      var bc = {
        x: originPoint.x + bbox.width / 2,
        y: originPoint.y + bbox.height
      };
      var lc = {
        x: originPoint.x,
        y: originPoint.y + bbox.height / 2
      };
      var rc2 = {
        x: originPoint.x + bbox.width,
        y: originPoint.y + bbox.height / 2
      };
      var horizontalDis = [];
      var verticalDis = [];
      var alignCfg = null;
      this.clearAlignLine();
      each_default(horizontalLines, function(line) {
        if (line[4].isVisible) {
          horizontalDis.push(_this.getLineDisObject(line, tc2));
          horizontalDis.push(_this.getLineDisObject(line, cc2));
          horizontalDis.push(_this.getLineDisObject(line, bc));
        }
      });
      each_default(verticalLines, function(line) {
        if (line[4].isVisible) {
          verticalDis.push(_this.getLineDisObject(line, lc));
          verticalDis.push(_this.getLineDisObject(line, cc2));
          verticalDis.push(_this.getLineDisObject(line, rc2));
        }
      });
      horizontalDis.sort(function(a3, b10) {
        return a3.dis - b10.dis;
      });
      verticalDis.sort(function(a3, b10) {
        return a3.dis - b10.dis;
      });
      if (horizontalDis.length !== 0 && horizontalDis[0].dis < tolerance3) {
        point.y = horizontalDis[0].line[1] - horizontalDis[0].point.y + originPoint.y;
        alignCfg = {
          type: "item",
          horizontals: [horizontalDis[0]]
        };
        for (var i2 = 1; i2 < 3; i2++) {
          if (horizontalDis[0].dis === horizontalDis[i2].dis) {
            alignCfg.horizontals.push(horizontalDis[i2]);
          }
        }
      }
      if (verticalDis.length !== 0 && verticalDis[0].dis < tolerance3) {
        point.x = verticalDis[0].line[0] - verticalDis[0].point.x + originPoint.x;
        if (!alignCfg) {
          alignCfg = {
            type: "item",
            verticals: [verticalDis[0]]
          };
        } else {
          alignCfg.verticals = [verticalDis[0]];
        }
        for (var i2 = 1; i2 < 3; i2++) {
          if (verticalDis[0].dis === verticalDis[i2].dis) {
            alignCfg.verticals.push(verticalDis[i2]);
          }
        }
      }
      if (alignCfg) {
        alignCfg.bbox = bbox;
        this.addAlignLine(alignCfg);
      }
    };
    SnapLine3.prototype.addAlignLine = function(cfg) {
      var bbox = cfg.bbox, type = cfg.type, horizontals = cfg.horizontals, verticals = cfg.verticals;
      var _a2 = this._cfgs, lineStyle = _a2.line, alignLines = _a2.alignLines;
      var graph = this.get("graph");
      var group = graph.get("group");
      if (type === "item") {
        if (horizontals) {
          each_default(horizontals, function(horizontal) {
            var refLine = horizontal.line, refPoint = horizontal.point;
            var lineCenterX = (refLine[0] + refLine[2]) / 2;
            var x1;
            var x22;
            if (refPoint.x < lineCenterX) {
              x1 = refPoint.x - bbox.width / 2;
              x22 = Math.max(refLine[0], refLine[2]);
            } else {
              x1 = refPoint.x + bbox.width / 2;
              x22 = Math.min(refLine[0], refLine[2]);
            }
            var lineAttrs = mix({
              x1,
              y1: refLine[1],
              x2: x22,
              y2: refLine[1]
            }, lineStyle);
            var line = group.addShape("line", {
              attrs: lineAttrs,
              capture: false
            });
            alignLines.push(line);
          });
        }
        if (verticals) {
          each_default(verticals, function(vertical3) {
            var refLine = vertical3.line, refPoint = vertical3.point;
            var lineCenterY = (refLine[1] + refLine[3]) / 2;
            var y1;
            var y22;
            if (refPoint.y < lineCenterY) {
              y1 = refPoint.y - bbox.height / 2;
              y22 = Math.max(refLine[1], refLine[3]);
            } else {
              y1 = refPoint.y + bbox.height / 2;
              y22 = Math.min(refLine[1], refLine[3]);
            }
            var lineAtts = mix({
              x1: refLine[0],
              y1,
              x2: refLine[0],
              y2: y22
            }, lineStyle);
            var line = group.addShape("line", {
              attrs: lineAtts,
              capture: false
            });
            alignLines.push(line);
          });
        }
      }
    };
    SnapLine3.prototype.getLineDisObject = function(line, point) {
      return {
        line,
        point,
        dis: pointLineDistance3(line, point)
      };
    };
    SnapLine3.prototype.getContainer = function() {
      return this.get("container");
    };
    SnapLine3.prototype.clearAlignLine = function() {
      var alignLines = this._cfgs.alignLines;
      each_default(alignLines, function(line) {
        line.remove();
      });
      alignLines.length = 0;
    };
    SnapLine3.prototype.destory = function() {
      var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines;
      var graph = this.get("graph");
      var nodes = graph.getNodes();
      nodes.forEach(function(node) {
        var itemId = node.get("id");
        delete horizontalLines["".concat(itemId, "tltr")];
        delete horizontalLines["".concat(itemId, "lcrc")];
        delete horizontalLines["".concat(itemId, "blbr")];
        delete verticalLines["".concat(itemId, "tlbl")];
        delete verticalLines["".concat(itemId, "tcbc")];
        delete verticalLines["".concat(itemId, "trbr")];
      });
      this.clearAlignLine();
    };
    return SnapLine3;
  }(base_default4)
);
var snapline_default = SnapLine;

// node_modules/@antv/g6-plugin/es/legend/index.js
init_esm();
var __extends15 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign15 = function() {
  __assign15 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign15.apply(this, arguments);
};
var ALLOW_EVENTS = ["click", "mouseenter"];
var Legend = (
  /** @class */
  function(_super) {
    __extends15(Legend3, _super);
    function Legend3(config) {
      return _super.call(this, config) || this;
    }
    Legend3.prototype.getDefaultCfgs = function() {
      return {
        data: {},
        position: "top",
        padding: 8,
        margin: 8,
        offsetX: 0,
        offsetY: 0,
        layout: "horizontal",
        flipPage: false,
        containerStyle: {},
        align: void 0,
        horiSep: 8,
        vertiSep: 8,
        filter: {
          enable: false,
          trigger: "click"
        }
      };
    };
    Legend3.prototype.init = function() {
      this.formatArray("padding");
      this.formatArray("margin");
      var filter3 = this.get("filter") || {};
      var multiple = filter3.multiple;
      if (multiple && filter3.trigger === "mouseenter") this.set("multiple", false);
      var align = this.get("align");
      if (!align) {
        var positions = this.get("position").split("-");
        if (positions.includes("left")) align = "left";
        if (positions.includes("right")) align = "right";
        else align = "center";
        this.set("align", align);
      }
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var container = createDom2(`<div class='g6-legend-container' style="position: absolute;"></div>`);
      graphContainer.appendChild(container);
      this.set("container", container);
      var size3 = this.render();
      modifyCSS(container, this.getContainerPos(size3));
      this.bindEvents();
    };
    Legend3.prototype.getContainerPos = function(size3) {
      if (size3 === void 0) {
        size3 = [0, 0];
      }
      var self2 = this;
      var graph = self2.get("graph");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      var margin = this.get("margin");
      var positions = this.get("position").split("-");
      var posIdxMap = {
        "top": 0,
        "right": 1,
        "bottom": 2,
        "left": 3
      };
      var x4 = 0, y4 = 0;
      var containerCSS = {
        left: (graph.getWidth() - size3[0]) / 2 + x4,
        top: (graph.getHeight() - size3[1]) / 2 + y4
      };
      positions.forEach(function(pos) {
        var marginValue = margin[posIdxMap[pos]];
        var key = pos;
        switch (pos) {
          case "top":
            marginValue += y4;
            break;
          case "left":
            marginValue += x4;
            break;
          case "bottom":
            marginValue = graph.getHeight() - size3[1] - marginValue + y4;
            key = "top";
            break;
          default:
            marginValue = graph.getWidth() - size3[0] - marginValue + x4;
            key = "left";
            break;
        }
        containerCSS[key] = marginValue;
      });
      containerCSS.top += offsetY + graph.getContainer().offsetTop;
      containerCSS.left += offsetX + graph.getContainer().offsetLeft;
      Object.keys(containerCSS).forEach(function(key) {
        containerCSS[key] = "".concat(containerCSS[key], "px");
      });
      return containerCSS;
    };
    Legend3.prototype.bindEvents = function() {
      var self2 = this;
      var filter3 = self2.get("filter");
      if (!filter3 || !filter3.enable) return;
      var trigger = filter3.trigger || "click";
      if (!ALLOW_EVENTS.includes(trigger)) {
        console.warn("Trigger for legend filterling must be 'click' or 'mouseenter', 'click' will take effect by default.");
        trigger = "click";
      }
      var lc = self2.get("legendCanvas");
      if (trigger === "mouseenter") {
        lc.on("node-container:mouseenter", function(e8) {
          return self2.filterData(e8);
        });
        lc.on("node-container:mouseleave", function(e8) {
          self2.clearFilter();
          self2.clearActiveLegend();
        });
      } else {
        lc.on("node-container:click", function(e8) {
          return self2.filterData(e8);
        });
        lc.on("click", function(e8) {
          if (e8.target && e8.target.isCanvas && e8.target.isCanvas()) {
            self2.clearFilter();
            self2.clearActiveLegend();
          }
        });
      }
    };
    Legend3.prototype.changeData = function(data) {
      this.set("data", data);
      var size3 = this.render();
      modifyCSS(this.get("container"), this.getContainerPos(size3));
    };
    Legend3.prototype.activateLegend = function(shape) {
      var filter3 = this.get("filter");
      var multiple = filter3 === null || filter3 === void 0 ? void 0 : filter3.multiple;
      if (!multiple) this.clearActiveLegend();
      var shapeGroup = shape.get("parent");
      if (shapeGroup.get("active")) {
        shapeGroup.set("active", false);
        if (this.findLegendItemsByState("active").length) shapeGroup.set("inactive", true);
      } else {
        shapeGroup.set("inactive", false);
        shapeGroup.set("active", true);
      }
      if (this.findLegendItemsByState("active").length) {
        this.findLegendItemsByState("active", "all", false).forEach(function(subGroup) {
          subGroup.set("inactive", true);
        });
      } else {
        this.clearActiveLegend();
      }
      var stateStyles = (filter3 === null || filter3 === void 0 ? void 0 : filter3.legendStateStyles) || {};
      var legendInactive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.inactive) || {
        opacity: 0.5,
        "text-shape": {
          opacity: 0.5
        }
      };
      var legendTextInactive = legendInactive["text-shape"] || {};
      this.findLegendItemsByState("inactive").forEach(function(subGroup) {
        var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
        keyShape.attr(__assign15(__assign15({}, keyShape.get("oriAttrs")), legendInactive));
        text.attr(__assign15(__assign15({}, text.get("oriAttrs")), legendTextInactive));
      });
      var legendActive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.active) || {
        stroke: "#000",
        lineWidth: 2,
        "text-shape": {
          fontWeight: "bold"
        }
      };
      var legendTextActive = legendActive["text-shape"] || {};
      this.findLegendItemsByState("active").forEach(function(subGroup) {
        var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
        keyShape.attr(__assign15(__assign15({}, keyShape.get("oriAttrs")), legendActive));
        text.attr(__assign15(__assign15({}, text.get("oriAttrs")), legendTextActive));
      });
    };
    Legend3.prototype.findLegendItemsByState = function(stateName, type, value) {
      if (type === void 0) {
        type = "all";
      }
      if (value === void 0) {
        value = true;
      }
      var group = this.get("legendCanvas").find(function(e8) {
        return e8.get("name") === "root";
      });
      var nodeGroup = group.find(function(e8) {
        return e8.get("name") === "node-group";
      });
      var edgeGroup = group.find(function(e8) {
        return e8.get("name") === "edge-group";
      });
      if (type === "node") return nodeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      });
      if (type === "edge") return edgeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      });
      return nodeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      }).concat(edgeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      }));
    };
    Legend3.prototype.clearActiveLegend = function() {
      var lg = this.get("legendCanvas");
      var group = lg.find(function(e8) {
        return e8.get("name") === "root";
      });
      var groups = [group.find(function(e8) {
        return e8.get("name") === "node-group";
      }), group.find(function(e8) {
        return e8.get("name") === "edge-group";
      })];
      groups.forEach(function(itemGroup) {
        itemGroup.get("children").forEach(function(subGroup) {
          subGroup.set("active", false);
          subGroup.set("inactive", false);
          var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
          keyShape.attr(keyShape.get("oriAttrs"));
          text.attr(text.get("oriAttrs"));
        });
      });
    };
    Legend3.prototype.filterData = function(e8) {
      var filter3 = this.get("filter");
      var filterFunctions = filter3 === null || filter3 === void 0 ? void 0 : filter3.filterFunctions;
      if (!filter3 || !filterFunctions) return;
      var lc = this.get("legendCanvas");
      var graph = this.get("graph");
      var activeState = filter3.graphActiveState || "active";
      var inactiveState = filter3.graphInactiveState || "inactive";
      var multiple = filter3.multiple;
      this.clearFilter();
      if (!multiple) this.clearActiveLegend();
      this.activateLegend(e8.target);
      var group = lc.find(function(e9) {
        return e9.get("name") === "root";
      });
      var nodeGroup = group.find(function(e9) {
        return e9.get("name") === "node-group";
      });
      var edgeGroup = group.find(function(e9) {
        return e9.get("name") === "edge-group";
      });
      var activeNodeLegend = nodeGroup.get("children").filter(function(e9) {
        return e9.get("active");
      });
      var activeEdgeLegend = edgeGroup.get("children").filter(function(e9) {
        return e9.get("active");
      });
      var activeCount = 0;
      var typeFuncs = ["getNodes", "getEdges"];
      typeFuncs.forEach(function(typeFunc) {
        graph[typeFunc]().forEach(function(graphItem) {
          var active = false;
          var activeLegend = typeFunc === "getNodes" ? activeNodeLegend : activeEdgeLegend;
          activeLegend.forEach(function(itemGroup) {
            var func = filterFunctions[itemGroup.get("id")];
            active = active || func(graphItem.getModel());
          });
          if (active) {
            graph.setItemState(graphItem, inactiveState, false);
            graph.setItemState(graphItem, activeState, true);
            activeCount++;
          } else {
            graph.setItemState(graphItem, activeState, false);
            graph.setItemState(graphItem, inactiveState, true);
          }
        });
      });
      if (!activeCount) typeFuncs.forEach(function(typeFunc) {
        graph[typeFunc]().forEach(function(graphItem) {
          graph.clearItemStates(graphItem, [inactiveState]);
        });
      });
    };
    Legend3.prototype.clearFilter = function() {
      var graph = this.get("graph");
      var filter3 = this.get("filter");
      if (!filter3) return;
      var activeState = filter3.graphActiveState || "active";
      var inactiveState = filter3.graphInactiveState || "inactive";
      graph.getNodes().forEach(function(node) {
        graph.clearItemStates(node, [activeState, inactiveState]);
      });
      graph.getEdges().forEach(function(edge) {
        graph.clearItemStates(edge, [activeState, inactiveState]);
      });
    };
    Legend3.prototype.render = function() {
      var _this = this;
      this.processData();
      var lc = this.get("legendCanvas");
      if (!lc) {
        lc = new canvas_default2({
          container: this.get("container"),
          width: 200,
          height: 200
        });
      } else {
        lc.clear();
      }
      var group = lc.addGroup({
        name: "root"
      });
      var nodeGroup = group.addGroup({
        name: "node-group"
      });
      var edgeGroup = group.addGroup({
        name: "edge-group"
      });
      this.set("legendCanvas", lc);
      var itemsData = this.get("itemsData");
      var itemTypes = ["nodes", "edges"];
      var itemGroup = [nodeGroup, edgeGroup];
      itemTypes.forEach(function(itemType, i2) {
        itemsData[itemType].forEach(function(data) {
          var _a2;
          var subGroup = itemGroup[i2].addGroup({
            id: data.id,
            name: "node-container"
          });
          var attrs;
          var shapeType = data.type;
          var _b = _this.getShapeSize(data), width = _b.width, height = _b.height, r2 = _b.r;
          var style2 = _this.getStyle(itemType.substr(0, 4), data);
          switch (data.type) {
            case "circle":
              attrs = {
                r: r2,
                x: 0,
                y: 0
              };
              break;
            case "rect":
              attrs = {
                width,
                height,
                x: -width / 2,
                y: -height / 2
              };
              break;
            case "ellipse":
              attrs = {
                rx: width,
                ry: height,
                x: 0,
                y: 0
              };
              shapeType = "ellipse";
              break;
            case "line":
              attrs = {
                x1: -width / 2,
                y1: 0,
                x2: width / 2,
                y2: 0
              };
              shapeType = "line";
              break;
            case "quadratic":
              attrs = {
                path: [["M", -width / 2, 0], ["Q", 0, width / 2, width / 2, 0]]
              };
              shapeType = "path";
              break;
            case "cubic":
              attrs = {
                path: [["M", -width / 2, 0], ["C", -width / 6, width / 2, width / 6, -width / 2, width / 2, 0]]
              };
              shapeType = "path";
              break;
            case "diamond":
              attrs = {
                path: [["M", 0, -height], ["L", width, 0], ["L", 0, height], ["L", -width, 0], ["Z"]]
              };
              shapeType = "path";
              break;
            case "triangle":
              attrs = {
                path: [["M", -width, height], ["L", 0, -height], ["L", width, height], ["Z"]]
              };
              shapeType = "path";
              break;
            case "star":
              attrs = {
                path: util_default.getStarPath(r2 * 3, r2 * 1.2)
              };
              shapeType = "path";
              break;
            default:
              attrs = {
                r: r2,
                x: 0,
                y: 0
              };
              break;
          }
          var keyShape = subGroup.addShape(shapeType, {
            attrs: __assign15(__assign15({}, attrs), style2),
            name: "".concat(data.type, "-node-keyShape"),
            oriAttrs: __assign15({
              opacity: 1
            }, style2)
          });
          if (data.label) {
            var keyShapeBBox = keyShape.getBBox();
            var labelStyle = ((_a2 = data.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
            var attrs_1 = __assign15({
              textAlign: "begin",
              fontSize: 12,
              textBaseline: "middle",
              fill: "#000",
              opacity: 1,
              fontWeight: "normal"
            }, labelStyle);
            subGroup.addShape("text", {
              attrs: __assign15({
                x: keyShapeBBox.maxX + 4,
                y: 0,
                text: data.label
              }, attrs_1),
              className: "legend-label",
              name: "".concat(data.type, "-node-text"),
              oriAttrs: attrs_1
            });
          }
        });
      });
      var padding = this.get("padding");
      var titleShape;
      var titleGroup = group.find(function(e8) {
        return e8.get("name") === "title-container";
      });
      var titleGroupBBox = {
        height: 0,
        maxY: 0,
        width: 0
      };
      if (this.get("title")) {
        if (!titleGroup) {
          titleGroup = group.addGroup({
            name: "title-container"
          });
        }
        var defaultTitleStyle = {
          fontSize: 20,
          fontFamily: "Arial",
          fontWeight: 300,
          textBaseline: "top",
          textAlign: "center",
          fill: "#000",
          x: 0,
          y: padding[0]
        };
        var titleConfig = this.get("titleConfig") || {};
        var style = Object.assign(defaultTitleStyle, titleConfig.style || {});
        titleShape = titleGroup.addShape("text", {
          attrs: __assign15({
            text: this.get("title")
          }, style)
        });
        titleGroupBBox = titleGroup.getCanvasBBox();
        titleGroup.setMatrix([1, 0, 0, 0, 1, 0, titleConfig.offsetX, titleConfig.offsetY, 1]);
      }
      this.layoutItems();
      var lcBBox = group.getCanvasBBox();
      var nodeGroupBBox = nodeGroup.getCanvasBBox();
      var nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];
      var nodeGroupBeginY = titleGroupBBox.maxY < nodeGroupBBox.minY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];
      var nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
      nodeGroup.setMatrix(nodeGroupMatrix);
      lcBBox = group.getCanvasBBox();
      var size3 = [lcBBox.minX + lcBBox.width + padding[1], lcBBox.minY + lcBBox.height + padding[2]];
      if (titleShape) {
        var titleConfig = __assign15({
          position: "center",
          offsetX: 0,
          offsetY: 0
        }, this.get("titleConfig"));
        titleGroupBBox = titleGroup.getCanvasBBox();
        var titleGroupMatrix = titleGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (titleConfig.position === "center") {
          titleGroupMatrix[6] = size3[0] / 2 + titleConfig.offsetX;
        } else if (titleConfig.position === "right") {
          titleGroupMatrix[6] = size3[0] - padding[3] + titleConfig.offsetX;
          titleShape.attr({
            textAlign: "right"
          });
        } else {
          titleGroupMatrix[6] = padding[3] + titleConfig.offsetX;
          titleShape.attr({
            textAlign: "left"
          });
        }
        titleGroup.setMatrix(titleGroupMatrix);
        titleGroupBBox = titleGroup.getCanvasBBox();
        nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];
        nodeGroupBeginY = nodeGroupBBox.minY < titleGroupBBox.maxY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];
        nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
        nodeGroup.setMatrix(nodeGroupMatrix);
        var edgeGroupMatrix_1 = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
        if (this.get("layout") === "vertical") edgeGroupMatrix_1[6] += nodeGroupBBox.maxX + this.get("horiSep");
        else edgeGroupMatrix_1[7] += nodeGroupBBox.maxY + this.get("vertiSep");
        edgeGroup.setMatrix(edgeGroupMatrix_1);
      } else {
        nodeGroupBBox = nodeGroup.getCanvasBBox();
        var edgeGroupMatrix_2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (this.get("layout") === "vertical") edgeGroupMatrix_2[6] += nodeGroupMatrix[6] + nodeGroupBBox.maxX + this.get("horiSep");
        else edgeGroupMatrix_2[7] += nodeGroupMatrix[7] + nodeGroupBBox.maxY + this.get("vertiSep");
        edgeGroup.setMatrix(edgeGroupMatrix_2);
      }
      lcBBox = group.getCanvasBBox();
      nodeGroupBBox = nodeGroup.getCanvasBBox();
      nodeGroupMatrix = nodeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var edgeGroupMatrix = edgeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var edgeGroupBBox = edgeGroup.getCanvasBBox();
      size3 = [Math.max(nodeGroupBBox.width + nodeGroupMatrix[6], edgeGroupBBox.width + edgeGroupMatrix[6]) + padding[1], Math.max(nodeGroupBBox.height + nodeGroupMatrix[7], edgeGroupBBox.height + edgeGroupMatrix[7]) + padding[2]];
      lc.changeSize(size3[0], size3[1]);
      var containerStyle = this.get("containerStyle");
      var viewportMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var beginPos = util_default.invertMatrix({
        x: 0,
        y: 0
      }, viewportMatrix);
      var backRect = group.addShape("rect", {
        attrs: __assign15({
          x: beginPos.x + (containerStyle.lineWidth || 1),
          y: beginPos.y + (containerStyle.lineWidth || 1),
          width: size3[0] - 2 * (containerStyle.lineWidth || 1),
          height: size3[1] - 2 * (containerStyle.lineWidth || 1),
          fill: "#f00",
          stroke: "#000",
          lineWidth: 1,
          opacity: 0.5
        }, containerStyle),
        name: "legend-back-rect",
        capture: false
      });
      backRect.toBack();
      return size3;
    };
    Legend3.prototype.layoutItems = function() {
      var lc = this.get("legendCanvas");
      var horiSep = this.get("horiSep");
      var vertiSep = this.get("vertiSep");
      var layout2 = this.get("layout");
      var align = this.get("align");
      var begin = [0, 0];
      var group = lc.find(function(e8) {
        return e8.get("name") === "root";
      });
      var nodeGroup = group.find(function(e8) {
        return e8.get("name") === "node-group";
      });
      var edgeGroup = group.find(function(e8) {
        return e8.get("name") === "edge-group";
      });
      var nodeLegendSize = {
        min: 0,
        max: -Infinity
      };
      var rowMaxY = -Infinity;
      nodeGroup.get("children").forEach(function(cNodeGroup, i2) {
        if (i2 === 0) nodeLegendSize.min = begin[0];
        var keyShape = cNodeGroup.get("children")[0];
        var bbox = cNodeGroup.getCanvasBBox();
        var _a2 = keyShape.getBBox(), keyShapeWidth = _a2.width, keyShapeHeight = _a2.height;
        var curHeight = 0, x4 = 0, y4 = 0;
        if (layout2 === "vertical") {
          x4 = begin[1];
          y4 = begin[0] + keyShapeWidth / 2;
          begin[0] = y4 + bbox.height + vertiSep;
          curHeight = bbox.maxX + x4 + keyShapeWidth / 2;
        } else {
          x4 = begin[0] + keyShapeWidth / 2;
          y4 = begin[1];
          begin[0] = x4 + bbox.width + horiSep;
          curHeight = bbox.maxY + y4 + keyShapeHeight / 2;
        }
        if (begin[0] > nodeLegendSize.max) nodeLegendSize.max = begin[0];
        if (curHeight > rowMaxY) rowMaxY = curHeight;
        cNodeGroup.setMatrix([1, 0, 0, 0, 1, 0, x4, y4, 1]);
      });
      var nw = nodeLegendSize.max - nodeLegendSize.min;
      var edgeLegendSize = {
        min: 0,
        max: -Infinity
      };
      var nodeGroupBBox = nodeGroup.getCanvasBBox();
      begin[0] = 0;
      begin[1] = layout2 === "vertical" ? nodeGroupBBox.maxX + horiSep : nodeGroupBBox.maxY + vertiSep;
      edgeGroup.get("children").forEach(function(subGroup, i2) {
        if (i2 === 0) edgeLegendSize.min = begin[0];
        var keyShape = subGroup.get("children")[0];
        var bbox = subGroup.getCanvasBBox();
        var _a2 = keyShape.getBBox(), keyShapeWidth = _a2.width, keyShapeHeight = _a2.height;
        var x4 = 0, y4 = 0;
        if (layout2 === "vertical") {
          x4 = begin[1];
          y4 = begin[0];
          begin[0] = y4 + bbox.height + vertiSep;
          subGroup.setMatrix([1, 0, 0, 0, 1, 0, 0, y4 + keyShapeHeight / 2, 1]);
        } else {
          x4 = begin[0];
          y4 = begin[1];
          begin[0] = x4 + bbox.width + horiSep;
          subGroup.setMatrix([1, 0, 0, 0, 1, 0, x4 + keyShapeWidth / 2, 0, 1]);
        }
        if (begin[0] > edgeLegendSize.max) edgeLegendSize.max = begin[0];
      });
      var ew = edgeLegendSize.max - edgeLegendSize.min;
      if (align && align !== "" && align !== "left") {
        var widthDiff = nw - ew;
        var movement_1 = align === "center" ? Math.abs(widthDiff) / 2 : Math.abs(widthDiff);
        var shouldAdjustGroup = widthDiff < 0 ? nodeGroup : edgeGroup;
        shouldAdjustGroup.get("children").forEach(function(subGroup) {
          var matrix = subGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (layout2 === "vertical") matrix[7] += movement_1;
          else matrix[6] += movement_1;
          subGroup.setMatrix(matrix);
        });
      }
    };
    Legend3.prototype.processData = function() {
      var data = this.get("data");
      var itemsData = {
        nodes: [],
        edges: []
      };
      if (data.nodes) {
        data.nodes.sort(function(a3, b10) {
          return a3.order - b10.order;
        });
        data.nodes.forEach(function(node) {
          var _a2, _b, _c, _d, _e2;
          var size3 = node.size || [((_a2 = node.style) === null || _a2 === void 0 ? void 0 : _a2.width) || ((_b = node.style) === null || _b === void 0 ? void 0 : _b.r) || 8, ((_c = node.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = node.style) === null || _d === void 0 ? void 0 : _d.r) || 8];
          var labelStyle = ((_e2 = node.labelCfg) === null || _e2 === void 0 ? void 0 : _e2.style) || {};
          itemsData.nodes.push({
            id: node.id || unique_id_default(),
            type: node.type || "circle",
            style: __assign15({}, node.style),
            order: node.order,
            label: node.label,
            itemType: "node",
            size: size3,
            labelCfg: {
              position: "right",
              style: __assign15({
                fontFamily: "Arial"
              }, labelStyle)
            }
          });
        });
      }
      if (data.edges) {
        data.edges.sort(function(a3, b10) {
          return a3.order - b10.order;
        });
        data.edges.forEach(function(edge) {
          var _a2, _b;
          var type = edge.type || "line";
          if (edge.type === "cubic-horizontal") type = "cubic";
          var labelStyle = ((_a2 = edge.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
          var size3 = edge.size || [((_b = edge.style) === null || _b === void 0 ? void 0 : _b.width) || 8, 1];
          itemsData.edges.push({
            id: edge.id || unique_id_default(),
            type,
            size: size3,
            style: __assign15({
              lineWidth: is_array_default(size3) ? size3[1] : 1
            }, edge.style),
            order: edge.order,
            label: edge.label,
            itemType: "edge",
            labelCfg: {
              position: "right",
              style: __assign15({
                fontFamily: "Arial"
              }, labelStyle)
            }
          });
        });
      }
      this.set("itemsData", itemsData);
    };
    Legend3.prototype.getContainer = function() {
      return this.get("container");
    };
    Legend3.prototype.formatArray = function(key) {
      var value = this.get(key);
      if (is_number_default(value)) this.set(key, [value, value, value, value]);
      else if (is_array_default(value)) {
        switch (value.length) {
          case 0:
            this.set(key, [0, 0, 0, 0]);
            break;
          case 1:
            this.set(key, [value[0], value[0], value[0], value[0]]);
            break;
          case 2:
            this.set(key, [value[0], value[1], value[0], value[1]]);
            break;
          case 3:
            this.set(key, [value[0], value[1], value[2], value[1]]);
            break;
          default:
            break;
        }
      }
      return this.get(key);
    };
    Legend3.prototype.getShapeSize = function(data) {
      var width, height, r2;
      if (data.size) {
        if (is_array_default(data.size)) {
          width = data.size[0];
          height = data.size[1] || data.size[0];
          r2 = data.size[0] / 2;
        } else if (is_number_default(data.size)) {
          width = data.size;
          height = data.size;
          r2 = data.size / 2;
        }
      }
      if (data.style) {
        if (data.style.width) width = data.style.width;
        if (data.style.height) height = data.style.height;
        if (data.style.r) r2 = data.style.r;
      }
      if (!r2) r2 = 5;
      if (!width) width = r2;
      if (!height) height = r2;
      return {
        width,
        height,
        r: r2
      };
    };
    Legend3.prototype.getStyle = function(type, data) {
      var defaultStyle = type === "node" ? {
        fill: "#ccc",
        lineWidth: 0
      } : {
        stroke: "#000",
        lineWidth: 1
      };
      return __assign15(__assign15({}, defaultStyle), data.style || {});
    };
    Legend3.prototype.destroy = function() {
      var lc = this.get("legendCanvas");
      lc === null || lc === void 0 ? void 0 : lc.destroy();
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var container = this.get("container");
      graphContainer.removeChild(container);
    };
    return Legend3;
  }(base_default4)
);
var legend_default = Legend;

// node_modules/@antv/g6-plugin/es/annotation/index.js
init_esm();
var import_insert_css4 = __toESM(require_insert_css());
var __extends16 = /* @__PURE__ */ function() {
  var _extendStatics = function extendStatics4(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) if (Object.prototype.hasOwnProperty.call(b11, p2)) d3[p2] = b11[p2];
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null) throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign16 = function() {
  __assign16 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign16.apply(this, arguments);
};
var __rest5 = function(s2, e8) {
  var t4 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0) t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
    if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t4[p2[i2]] = s2[p2[i2]];
  }
  return t4;
};
typeof document !== "undefined" && (0, import_insert_css4.default)("\n  .g6-annotation-container {\n    background-color: rgba(255, 255, 255, 0.3);\n    padding: 8px;\n  }\n  .g6-annotation-wrapper {\n    background-color: #fff;\n    box-shadow: 0 0 8px rgba(0, 0, 0, 0.85);\n  }\n  .g6-annotation-header-wapper {\n    height: fit-content;\n    width: 100%;\n    background-color: #5B8FF9;\n    display: inline-flex;\n    cursor: move;\n  }\n  .g6-annotation-title {\n    margin: 4px 40px 4px 8px;\n    cursor: text;\n    min-width: 32px;\n  }\n  .g6-annotation-collapse {\n    margin: 4px;\n    cursor: pointer;\n  }\n  .g6-annotation-expand {\n    margin: 4px;\n    cursor: pointer;\n  }\n  .g6-annotation-close {\n    margin: 4px 8px 4px 0;\n    cursor: pointer;\n  }\n  .g6-annotation-content {\n    padding: 8px;\n    width: fit-content;\n    cursor: text;\n    word-break: break-all;\n    min-width: 32px;\n  }\n  .g6-annotation-title-input-wrapper {\n    margin: 4px 40px 4px 8px;\n  }\n  .g6-annotation-content-input {\n    height: 100%;\n    word-break: break-all;\n  }\n  .g6-annotation-content-input-wrapper {\n    margin: 8px;\n    height: 100%;\n  }\n");
var CANVAS_ANNOTATION_ID = "canvas-annotation";
var Annotation = (
  /** @class */
  function(_super) {
    __extends16(Annotation3, _super);
    function Annotation3(config) {
      return _super.call(this, config) || this;
    }
    Annotation3.prototype.getDefaultCfgs = function() {
      return {
        trigger: "click",
        editable: true,
        itemHighlightState: "highlight",
        linkHighlightStyle: {
          shadowColor: "#5B8FF9",
          shadowBlur: 10
        },
        cardCfg: {
          minHeight: 60,
          width: "fit-content",
          height: "fit-content",
          collapseType: "minimize",
          closeType: "hide",
          borderRadius: 5,
          maxTitleLength: 20
        }
      };
    };
    Annotation3.prototype.getEvents = function() {
      var events = {
        "viewportchange": "updateLinks",
        "afterlayout": "updateLinks",
        "aftergraphrefreshposition": "updateLinks",
        "afterupdateitem": "updateLink",
        "afterchangedata": "onGraphDataChange",
        "afteritemvisibilitychange": "onGraphItemVisibilityChange"
      };
      switch (this.get("trigger")) {
        case "click":
          events = __assign16(__assign16({}, events), {
            "node:click": "showAnnotation",
            "edge:click": "showAnnotation"
          });
      }
      return events;
    };
    Annotation3.prototype.getDOMContent = function(cfg) {
      if (this.destroyed) return;
      var collapsed = cfg.collapsed, maxWidth = cfg.maxWidth, _a2 = cfg.title, title = _a2 === void 0 ? "" : _a2, _b = cfg.content, content = _b === void 0 ? "" : _b, _c = cfg.borderRadius, r2 = _c === void 0 ? 5 : _c;
      var collapseExpandDOM = collapsed ? "<p class='g6-annotation-expand'>+</p>" : "<p class='g6-annotation-collapse'>-</p>";
      var contentDOM = collapsed ? "" : " <p class='g6-annotation-content'>".concat(content, "</p>");
      var closeDOM = "<p class='g6-annotation-close'>x</p>";
      var borderRadius = collapsed ? "".concat(r2, "px") : "".concat(r2, "px ").concat(r2, "px 0 0");
      return '<div class="g6-annotation-wrapper" style="border-radius: '.concat(r2, "px; max-width: ").concat(maxWidth, 'px">\n        <div\n          class="g6-annotation-header-wapper"\n          style="border-radius: ').concat(borderRadius, `;"
        >
          <h4 class='g6-annotation-title'>`).concat(title, "</h4>\n          ").concat(collapseExpandDOM, "\n          ").concat(closeDOM, "\n        </div>\n        ").concat(contentDOM, "\n      </div>");
    };
    Annotation3.prototype.init = function() {
      var self2 = this;
      if (self2.destroyed) return;
      var graph = self2.get("graph");
      var graphCantainer = graph.getContainer();
      var container = self2.get("container");
      var containerCfg = this.get("containerCfg");
      if (containerCfg) {
        container = this.createContainer();
        graphCantainer.appendChild(container);
      } else {
        container = graphCantainer;
      }
      this.set("container", container);
      var graphContainerBBox = graphCantainer.getBoundingClientRect();
      var linkCanvas = new canvas_default2({
        container: graphCantainer,
        width: graphContainerBBox.right - graphContainerBBox.left,
        height: graphContainerBBox.bottom - graphContainerBBox.top
      });
      modifyCSS(linkCanvas.get("el"), {
        position: "absolute",
        top: 0,
        left: 0,
        pointerEvents: "none"
      });
      window.addEventListener("resize", debounce_default(function() {
        return self2.resizeCanvas(self2);
      }, 100));
      var linkGroup = linkCanvas.addGroup({
        id: "annotation-link-group"
      });
      self2.set("linkGroup", linkGroup);
      self2.set("canvas", linkCanvas);
      if (!self2.get("getTitle")) {
        self2.set("getTitle", function(item) {
          var _a2;
          var _b = ((_a2 = item === null || item === void 0 ? void 0 : item.getModel) === null || _a2 === void 0 ? void 0 : _a2.call(item)) || {}, label = _b.label, id = _b.id;
          return label || id || "-";
        });
      }
      if (!self2.get("getContent")) {
        self2.set("getContent", function(item) {
          var _a2, _b;
          if (!item) return "-";
          var _c = ((_a2 = item.getModel) === null || _a2 === void 0 ? void 0 : _a2.call(item)) || {}, label = _c.label, id = _c.id;
          var type = (_b = item.getType) === null || _b === void 0 ? void 0 : _b.call(item);
          var suffix = type ? "".concat(type, ": ") : "";
          return "".concat(suffix).concat(label || id || "");
        });
      }
      var defaultData = self2.get("defaultData");
      if (defaultData) this.readData(defaultData);
    };
    Annotation3.prototype.createContainer = function() {
      var _this = this;
      if (this.destroyed) return;
      var containerCfg = this.get("containerCfg");
      var graph = this.get("graph");
      var graphContainer = graph.getContainer();
      var _a2 = graphContainer.getBoundingClientRect(), gLeft = _a2.left, gRight = _a2.right, gTop = _a2.top, gBottom = _a2.bottom;
      var graphContainerHeight = gBottom - gTop;
      var graphContainerWidth = gRight - gLeft;
      var _b = containerCfg.position, position = _b === void 0 ? "top" : _b, _c = containerCfg.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = containerCfg.offsetY, offsetY = _d === void 0 ? 0 : _d, otherStyle = __rest5(containerCfg, ["position", "offsetX", "offsetY"]);
      var _e2 = containerCfg.height, height = _e2 === void 0 ? "fit-content" : _e2, _f = containerCfg.width, width = _f === void 0 ? graph.getWidth() : _f;
      if (height === "100%") height = graphContainerHeight;
      if (width === "100%") width = graphContainerWidth;
      var maxHeight = "unset", maxWidth = "unset";
      var containerPosition = {};
      switch (position) {
        case "right":
          maxHeight = "".concat(graphContainerHeight, "px");
          containerPosition = {
            top: 0,
            right: 0
          };
          containerPosition.right += gLeft + offsetX;
          containerPosition.top += gTop + offsetY;
          break;
        case "bottom":
          maxWidth = "".concat(graphContainerWidth, "px");
          containerPosition = {
            bottom: 0,
            left: 0
          };
          containerPosition.left += gLeft + offsetX;
          containerPosition.bottom += gTop + offsetY;
          break;
        case "top":
          maxWidth = "".concat(graphContainerWidth, "px");
        case "left":
          maxHeight = "".concat(graphContainerHeight, "px");
        default:
          containerPosition = {
            top: 0,
            left: 0
          };
          containerPosition.left += gLeft + offsetX;
          containerPosition.top += gTop + offsetY;
          break;
      }
      Object.keys(containerPosition).forEach(function(key) {
        containerPosition[key] = "".concat(containerPosition[key], "px");
      });
      var container = createDom2("<div class='".concat(containerCfg.className, " g6-annotation-container'></div>"));
      modifyCSS(container, __assign16(__assign16({
        position: "absolute",
        display: position === "top" || position === "bottom" ? "inline-flex" : "unset",
        width: is_number_default(width) ? "".concat(width, "px") : width,
        height: is_number_default(height) ? "".concat(height, "px") : height,
        maxHeight,
        maxWidth,
        overflow: "scroll"
      }, containerPosition), otherStyle));
      graphContainer.appendChild(container);
      container.addEventListener("scroll", function(e8) {
        _this.updateLinks();
      });
      return container;
    };
    Annotation3.prototype.resizeCanvas = function(self2) {
      clearTimeout(self2.resizeTimer);
      self2.resizeTimer = setTimeout(function() {
        if (!self2 || self2.destroyed) return;
        var cBBox = self2.get("container").getBoundingClientRect();
        var newWidth = cBBox.right - cBBox.left;
        var newHeight = cBBox.bottom - cBBox.top;
        self2.get("canvas").changeSize(newWidth, newHeight);
        self2.updateOutsideCards(self2);
      }, 250);
    };
    Annotation3.prototype.updateOutsideCards = function(selfObj) {
      var self2 = selfObj || this;
      var cardInfoMap = self2.get("cardInfoMap") || {};
      var graph = self2.get("graph");
      var graphLeftTopCanvas = graph.getPointByCanvas(0, 0);
      var graphRightBottomCanvas = graph.getPointByCanvas(graph.getWidth(), graph.getHeight());
      var _a2 = graph.getClientByPoint(graphLeftTopCanvas.x, graphLeftTopCanvas.y), graphLeft = _a2.x, graphTop = _a2.y;
      var _b = graph.getClientByPoint(graphRightBottomCanvas.x, graphRightBottomCanvas.y), graphRight = _b.x, graphBottom = _b.y;
      Object.values(cardInfoMap).forEach(function(cardInfo) {
        var card = cardInfo.card;
        if (!card) return;
        var style = card.style;
        var left = px2Num(style.left);
        var top = px2Num(style.top);
        var _a3 = card.getBoundingClientRect(), width = _a3.width, height = _a3.height;
        var newLeft = left;
        var newTop = top;
        if (left + width > graphRight - graphLeft) {
          newLeft = graphRight - graphLeft - width;
        }
        if (left < 0) {
          newLeft = 0;
        }
        if (top + height > graphBottom - graphTop) {
          newTop = graphBottom - graphTop - height;
        }
        if (top < 0) {
          newTop = 0;
        }
        modifyCSS(card, {
          left: "".concat(newLeft, "px"),
          top: "".concat(newTop, "px")
        });
      });
      self2.updateLinks();
    };
    Annotation3.prototype.showAnnotation = function(evt) {
      if (this.destroyed) return;
      var item = evt.item;
      this.toggleAnnotation(item);
    };
    Annotation3.prototype.hideCards = function() {
      var self2 = this;
      if (self2.destroyed) return;
      var cardInfoMap = self2.get("cardInfoMap") || {};
      Object.keys(cardInfoMap).forEach(function(itemId) {
        self2.hideCard(itemId);
      });
    };
    Annotation3.prototype.toggleAnnotation = function(item, cfg) {
      var _a2, _b;
      if (cfg === void 0) {
        cfg = {};
      }
      var self2 = this;
      if (self2.destroyed) return;
      var cardInfoMap = self2.get("cardInfoMap") || {};
      var graph = self2.get("graph");
      var container = self2.get("container");
      var containerCfg = self2.get("containerCfg");
      var _c = Object.assign({}, self2.get("cardCfg") || {}, cfg), minHeight = _c.minHeight, minWidth = _c.minWidth, width = _c.width, height = _c.height, _d = _c.collapsed, collapsed = _d === void 0 ? false : _d, propsX = _c.x, propsY = _c.y, propsTitle = _c.title, propsContent = _c.content, maxTitleLength = _c.maxTitleLength, defaultBegin = _c.defaultBegin, otherCardCfg = __rest5(_c, ["minHeight", "minWidth", "width", "height", "collapsed", "x", "y", "title", "content", "maxTitleLength", "defaultBegin"]);
      var linkGroup = self2.get("linkGroup");
      var rows = this.get("rows") || [[]];
      var isCanvas2 = (_a2 = item.isCanvas) === null || _a2 === void 0 ? void 0 : _a2.call(item);
      var itemId = isCanvas2 ? CANVAS_ANNOTATION_ID : item.getID();
      var _e2 = cardInfoMap[itemId] || {}, card = _e2.card, link = _e2.link, x4 = _e2.x, y4 = _e2.y, title = _e2.title, content = _e2.content;
      var getTitle = this.get("getTitle");
      var getContent = this.get("getContent");
      var getContentPlaceholder = this.get("getContentPlaceholder") || function() {
        return "";
      };
      var getTitlePlaceHolder = this.get("getTitlePlaceHolder") || function() {
        return "";
      };
      var contentPlaceholder = getContentPlaceholder(item);
      var titlePlaceholder = getTitlePlaceHolder(item);
      var newCard = createDom2(this.getDOMContent(__assign16({
        itemId,
        collapsed,
        title: ((_b = title || propsTitle || (getTitle === null || getTitle === void 0 ? void 0 : getTitle(item))) === null || _b === void 0 ? void 0 : _b.substr(0, maxTitleLength)) || titlePlaceholder,
        content: content || propsContent || (getContent === null || getContent === void 0 ? void 0 : getContent(item)) || contentPlaceholder
      }, otherCardCfg)));
      var minHeightPx = is_number_default(minHeight) ? "".concat(minHeight, "px") : minHeight;
      modifyCSS(newCard, {
        minHeight: collapsed ? "unset" : minHeightPx,
        minWidth: is_number_default(minWidth) ? "".concat(minWidth, "px") : minWidth,
        height,
        width
      });
      var exist = !!card;
      if (exist) {
        link === null || link === void 0 ? void 0 : link.remove(true);
        container.replaceChild(newCard, card);
      } else {
        container.appendChild(newCard);
      }
      var containerBBox;
      if (!containerCfg) {
        containerBBox = container.getBoundingClientRect() || {};
        if (propsX !== void 0 && propsY !== void 0) {
          x4 = propsX;
          y4 = propsY;
        } else if (!exist && !isCanvas2) {
          var containerTop = containerBBox.top;
          var _f = defaultBegin || {}, beginLeft = _f.left, _g = _f.right, propsBeginRight = _g === void 0 ? 16 : _g, _h = _f.top, propsBeginTop = _h === void 0 ? 8 : _h, beginBottom = _f.bottom;
          var beginRight = propsBeginRight;
          var beginTop = propsBeginTop;
          if (!isNaN(beginLeft)) {
            beginRight = container.scrollWidth - beginLeft;
          }
          if (!isNaN(beginBottom)) {
            beginTop = container.scrollHeight - beginBottom;
          }
          var cardWidth = is_number_default(minWidth) ? minWidth : 100;
          x4 = container.scrollWidth - newCard.scrollWidth - (rows.length - 1) * cardWidth - beginRight;
          var currentRow = rows[rows.length - 1];
          var lastCardBBox = (currentRow[currentRow.length - 1] || {}).bbox;
          y4 = (lastCardBBox === null || lastCardBBox === void 0 ? void 0 : lastCardBBox.bottom) - containerTop || beginTop;
        }
        modifyCSS(newCard, {
          position: "absolute",
          left: "".concat(x4, "px"),
          top: "".concat(y4, "px"),
          cusor: containerCfg ? "unset" : "move"
        });
      }
      this.bindListener(newCard, itemId);
      var cardBBox = newCard.getBoundingClientRect();
      if (!isCanvas2) {
        var path = getPathItem2Card(item, cardBBox, graph, this.get("canvas"));
        var linkStyle = this.get("linkStyle");
        link = linkGroup.addShape("path", {
          attrs: __assign16({
            lineWidth: 1,
            lineDash: [5, 5],
            stroke: "#ccc",
            path
          }, linkStyle)
        });
      }
      cardInfoMap[itemId] = __assign16(__assign16({}, cardInfoMap[itemId] || {}), {
        id: itemId,
        collapsed,
        card: newCard,
        link,
        x: x4,
        y: y4,
        cardBBox,
        content: content || propsContent,
        title: title || propsTitle,
        contentPlaceholder,
        titlePlaceholder,
        isCanvas: isCanvas2
      });
      self2.set("cardInfoMap", cardInfoMap);
      if (containerCfg) {
        this.updateCardPositionsInConatainer();
        this.updateLinks();
      } else {
        var hasPropsPosition = !isNaN(propsX) && !isNaN(propsY);
        if (!exist && !isCanvas2 && !hasPropsPosition) {
          var _j = containerBBox.bottom, containerBottom = _j === void 0 ? 0 : _j, containerTop = containerBBox.top;
          rows[rows.length - 1].push({
            id: itemId,
            bbox: cardBBox
          });
          if (cardBBox.top > containerBottom - containerTop - cardBBox.height - 16) rows.push([]);
          this.set("rows", rows);
        }
      }
      this.updateCardSize(itemId);
      var onAnnotationChange = this.get("onAnnotationChange");
      onAnnotationChange === null || onAnnotationChange === void 0 ? void 0 : onAnnotationChange(cardInfoMap[itemId], exist ? "update" : "create");
    };
    Annotation3.prototype.updateCardPositionsInConatainer = function() {
      if (this.destroyed) return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var container = this.get("container");
      var position = this.get("containerCfg").position;
      var containerWidth = container.getBoundingClientRect().width;
      var computeStyle = getComputedStyle(container);
      var sidePadding = px2Num(computeStyle["paddingLeft"]) + px2Num(computeStyle["paddingRight"]);
      containerWidth -= sidePadding;
      Object.values(cardInfoMap).forEach(function(_a2) {
        var card = _a2.card;
        var cardWidth = card.getBoundingClientRect().width;
        switch (position) {
          case "right":
            modifyCSS(card, {
              marginLeft: containerWidth ? "".concat(containerWidth - cardWidth, "px") : "0px"
            });
            break;
          case "top":
          case "bottom":
            modifyCSS(card, {
              marginLeft: "8px"
            });
          default:
            break;
        }
      });
    };
    Annotation3.prototype.handleExpandCollapseCard = function(id) {
      if (this.destroyed) return;
      var graph = this.get("graph");
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var collapsed = cardInfoMap[id].collapsed;
      var item = graph.findById(id);
      if (!item) return;
      var collapseType = this.get("cardCfg").collapseType;
      if (collapseType === "hide" && !collapsed) {
        this.hideCard(id);
      } else {
        this.toggleAnnotation(item, {
          collapsed: !collapsed
        });
      }
      cardInfoMap[id] = __assign16(__assign16({}, cardInfoMap[id]), {
        collapsed: !collapsed
      });
    };
    Annotation3.prototype.hideCard = function(id) {
      if (this.destroyed) return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap || !cardInfoMap[id]) return;
      var _a2 = cardInfoMap[id], card = _a2.card, link = _a2.link;
      modifyCSS(card, {
        display: "none"
      });
      link === null || link === void 0 ? void 0 : link.hide();
      var onAnnotationChange = this.get("onAnnotationChange");
      onAnnotationChange(cardInfoMap[id], "hide");
    };
    Annotation3.prototype.removeCard = function(id) {
      if (this.destroyed) return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var cardInfo = cardInfoMap[id];
      var card = cardInfo.card, link = cardInfo.link;
      var container = this.get("container");
      container.removeChild(card);
      link === null || link === void 0 ? void 0 : link.remove(true);
      delete cardInfoMap[id];
      var onAnnotationChange = this.get("onAnnotationChange");
      onAnnotationChange(cardInfo, "remove");
    };
    Annotation3.prototype.bindListener = function(card, itemId) {
      var _this = this;
      if (this.destroyed) return;
      card.addEventListener("mousemove", function(e8) {
        var iconType;
        if (e8.target.className === "g6-annotation-collapse") {
          iconType = "collapse";
        } else if (e8.target.className === "g6-annotation-expand") {
          iconType = "expand";
        } else if (e8.target.className === "g6-annotation-close") {
          iconType = "close";
        }
        if (iconType) {
          var _a2 = _this.get("cardCfg").onMouseEnterIcon, onMouseEnterIcon = _a2 === void 0 ? function() {
          } : _a2;
          onMouseEnterIcon(e8, itemId, iconType);
        }
      });
      card.addEventListener("mouseout", function(e8) {
        var iconType;
        if (e8.target.className === "g6-annotation-collapse") {
          iconType = "collapse";
        } else if (e8.target.className === "g6-annotation-expand") {
          iconType = "expand";
        } else if (e8.target.className === "g6-annotation-close") {
          iconType = "close";
        }
        if (iconType) {
          var _a2 = _this.get("cardCfg").onMouseLeaveIcon, onMouseLeaveIcon = _a2 === void 0 ? function() {
          } : _a2;
          onMouseLeaveIcon(e8, itemId, iconType);
        }
      });
      card.addEventListener("mouseenter", function(e8) {
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap) return;
        var graph = _this.get("graph");
        var item = graph.findById(itemId);
        if (item) {
          var itemHighlightState = _this.get("itemHighlightState");
          graph.setItemState(item, itemHighlightState, true);
        }
        var link = cardInfoMap[itemId].link;
        if (link) {
          var linkHighlightStyle = _this.get("linkHighlightStyle") || {};
          link.attr(linkHighlightStyle);
        }
      });
      card.addEventListener("mouseleave", function(e8) {
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap) return;
        var graph = _this.get("graph");
        var item = graph.findById(itemId);
        if (item) {
          var itemHighlightState = _this.get("itemHighlightState");
          graph.setItemState(item, itemHighlightState, false);
        }
        var link = cardInfoMap[itemId].link;
        if (link) {
          var linkHighlightStyle = _this.get("linkHighlightStyle") || {};
          Object.keys(linkHighlightStyle).forEach(function(key) {
            link.attr(key, void 0);
            link.attr(key, void 0);
          });
          var linkStyle = _this.get("linkStyle");
          link.attr(linkStyle);
        }
      });
      card.addEventListener("click", function(e8) {
        var onClickIcon = (_this.get("cardCfg") || {}).onClickIcon;
        if (e8.target.className === "g6-annotation-collapse" || e8.target.className === "g6-annotation-expand") {
          var collapseType = _this.get("cardCfg").collapseType;
          if (collapseType === "hide") {
            _this.hideCard(itemId);
          } else {
            _this.handleExpandCollapseCard(itemId);
          }
          onClickIcon === null || onClickIcon === void 0 ? void 0 : onClickIcon(e8, itemId, e8.target.className === "g6-annotation-collapse" ? "collapse" : "expand");
        } else if (e8.target.className === "g6-annotation-close") {
          var closeType = _this.get("cardCfg").closeType;
          if (closeType === "remove") {
            _this.removeCard(itemId);
          } else {
            _this.hideCard(itemId);
          }
          onClickIcon === null || onClickIcon === void 0 ? void 0 : onClickIcon(e8, itemId, "close");
        }
      });
      var editable = this.get("editable");
      if (editable) {
        card.addEventListener("dblclick", function(e8) {
          var cardInfoMap = _this.get("cardInfoMap");
          var _a2 = (_this.get("cardCfg") || {}).maxTitleLength, maxTitleLength = _a2 === void 0 ? 20 : _a2;
          if (!cardInfoMap) return;
          var target = e8.target;
          var targetClass = target.className;
          if (targetClass !== "g6-annotation-title" && targetClass !== "g6-annotation-content") return;
          var _b = targetClass === "g6-annotation-title" ? target.getBoundingClientRect() : target.parentNode.getBoundingClientRect(), width = _b.width, height = _b.height;
          var computeStyle = getComputedStyle(target);
          var inputTag = targetClass === "g6-annotation-title" ? "input" : "textarea";
          var input = createDom2("<".concat(inputTag, ' class="').concat(targetClass, '-input" type="textarea" style="width:').concat(width, "px; height: ").concat(height, 'px; min-width: 16px;"/>'));
          var inputWrapper = createDom2('<div class="'.concat(targetClass, '-input-wrapper" style="width: ').concat(width, "px; height: ").concat(height, "px; min-width: 16px; margin-right: ").concat(computeStyle["marginRight"], '" />'));
          inputWrapper.appendChild(input);
          target.parentNode.replaceChild(inputWrapper, target);
          var cardInfo = cardInfoMap[itemId];
          var contentPlaceholder = cardInfo.contentPlaceholder, titlePlaceholder = cardInfo.titlePlaceholder, content = cardInfo.content, title = cardInfo.title;
          var value = content;
          if (targetClass === "g6-annotation-title") {
            input.name = "title";
            input.maxLength = maxTitleLength;
            value = title;
          } else {
            input.name = "content";
          }
          if (value) {
            input.innerHTML = target.innerHTML;
            input.value = target.innerHTML;
          } else {
            input.placeholder = targetClass === "g6-annotation-title" ? titlePlaceholder : contentPlaceholder;
          }
          input.focus();
          input.addEventListener("blur", function(blurEvt) {
            if (input.value) {
              target.innerHTML = input.value;
              cardInfo[input.name || "title"] = input.value;
            }
            inputWrapper.parentNode.replaceChild(target, inputWrapper);
            _this.updateCardSize(itemId);
            var onAnnotationChange = _this.get("onAnnotationChange");
            onAnnotationChange === null || onAnnotationChange === void 0 ? void 0 : onAnnotationChange(cardInfo, "update");
          });
        });
      }
      var unmovableClasses = ["g6-annotation-title", "g6-annotation-content", "g6-annotation-title-input", "g6-annotation-content-input"];
      card.draggable = true;
      card.addEventListener("dragstart", function(e8) {
        var targetClass = e8.target.className;
        if (unmovableClasses.includes(targetClass)) return;
        var style = card.style;
        _this.set("dragging", {
          card,
          x: e8.clientX,
          y: e8.clientY,
          left: px2Num(style.left),
          top: px2Num(style.top)
        });
      });
      card.addEventListener("drag", function(e8) {
        e8.preventDefault();
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap) return;
        var clientX = e8.clientX, clientY = e8.clientY;
        var dragging = _this.get("dragging");
        if (isNaN(clientX) || isNaN(clientY) || !dragging) return;
        var x4 = dragging.x, y4 = dragging.y, left = dragging.left, top = dragging.top, draggingCard = dragging.card;
        var dx = clientX - x4;
        var dy = clientY - y4;
        left += dx;
        top += dy;
        var graph = _this.get("graph");
        var graphLeftTopCanvas = graph.getPointByCanvas(0, 0);
        var graphRightBottomCanvas = graph.getPointByCanvas(graph.getWidth(), graph.getHeight());
        var _a2 = graph.getClientByPoint(graphLeftTopCanvas.x, graphLeftTopCanvas.y), graphLeft = _a2.x, graphTop = _a2.y;
        var _b = graph.getClientByPoint(graphRightBottomCanvas.x, graphRightBottomCanvas.y), graphRight = _b.x, graphBottom = _b.y;
        var cardBBox = draggingCard.getBoundingClientRect();
        var cardWidth = cardBBox.right - cardBBox.left;
        var cardHeight = cardBBox.bottom - cardBBox.top;
        if (left > graphRight - graphLeft - cardWidth && dx > 0 || left < 0 && dx < 0) left -= dx;
        if (top > graphBottom - graphTop - cardHeight && dy > 0 || top < 0 && dy < 0) top -= dy;
        modifyCSS(draggingCard, {
          left: "".concat(left, "px"),
          top: "".concat(top, "px"),
          visibility: "hidden"
        });
        x4 = clientX;
        y4 = clientY;
        var link = (cardInfoMap[itemId] || {}).link;
        if (link) {
          var item = graph.findById(itemId);
          link.attr("path", getPathItem2Card(item, cardBBox, graph, _this.get("canvas")));
        }
        _this.set("dragging", {
          x: x4,
          y: y4,
          left,
          top,
          card: draggingCard
        });
      });
      var dragendListener = function dragendListener2(e8) {
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap) return;
        var dragging = _this.get("dragging");
        if (dragging) {
          var left = dragging.left, top_1 = dragging.top, draggingCard = dragging.card;
          cardInfoMap[itemId].x = left;
          cardInfoMap[itemId].y = top_1;
          modifyCSS(draggingCard, {
            visibility: "visible"
          });
          _this.set("dragging", false);
          var rows = _this.get("rows");
          rows === null || rows === void 0 ? void 0 : rows.forEach(function(rowItems) {
            for (var i2 = rowItems.length - 1; i2 >= 0; i2--) {
              if (rowItems[i2].id === itemId) rowItems.splice(i2, 1);
            }
          });
          var onAnnotationChange = _this.get("onAnnotationChange");
          onAnnotationChange === null || onAnnotationChange === void 0 ? void 0 : onAnnotationChange(cardInfoMap[itemId], "update");
        }
      };
      card.addEventListener("dragend", dragendListener);
    };
    Annotation3.prototype.updateCardSize = function(id) {
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var card = cardInfoMap[id].card;
      var width = card.getBoundingClientRect().width;
      var title = card.getElementsByClassName("g6-annotation-title")[0];
      if (title) {
        var computeStyle = getComputedStyle(title);
        var sideMargin = px2Num(computeStyle["marginLeft"]);
        var titleWidth = title.getBoundingClientRect().width;
        modifyCSS(title, {
          marginRight: "".concat(width - sideMargin - 24 - 16 - titleWidth, "px")
        });
      }
    };
    Annotation3.prototype.updateLink = function(_a2) {
      var item = _a2.item;
      if (!item) return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var canvas = this.get("canvas");
      var graph = this.get("graph");
      var id = item.getID();
      var _b = cardInfoMap[id] || {}, link = _b.link, card = _b.card;
      if (link) {
        var path = getPathItem2Card(item, card.getBoundingClientRect(), graph, canvas);
        link.attr("path", path);
      }
    };
    Annotation3.prototype.updateLinks = function() {
      var _this = this;
      if (this.destroyed) return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var graph = this.get("graph");
      Object.values(cardInfoMap).forEach(function(cardInfo) {
        var id = cardInfo.id;
        var item = graph.findById(id);
        _this.updateLink({
          item
        });
      });
    };
    Annotation3.prototype.onGraphDataChange = function() {
      var _this = this;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var graph = this.get("graph");
      Object.values(cardInfoMap).forEach(function(info) {
        var id = info.id, card = info.card, isCanvas2 = info.isCanvas;
        if (!card || isCanvas2 || card.style.display === "none") return;
        var item = graph.findById(id);
        if (item && item.isVisible()) {
          _this.toggleAnnotation(item);
        } else {
          _this.hideCard(id);
        }
      });
    };
    Annotation3.prototype.onGraphItemVisibilityChange = function(_a2) {
      var item = _a2.item, visible = _a2.visible;
      if (!item || item.destroyed) return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var id = item.getID();
      if (!cardInfoMap[id]) return;
      if (!visible) this.hideCard(id);
    };
    Annotation3.prototype.saveData = function(saveClosed) {
      if (saveClosed === void 0) {
        saveClosed = false;
      }
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var graph = this.get("graph");
      var getTitle = this.get("getTitle");
      var getContent = this.get("getContent");
      var data = [];
      Object.values(cardInfoMap).forEach(function(info) {
        var title = info.title, content = info.content, x4 = info.x, y4 = info.y, id = info.id, collapsed = info.collapsed, card = info.card;
        if (card && card.style.display === "none" && !saveClosed) return;
        var item = graph.findById(id) || graph.get("canvas");
        data.push({
          id,
          x: x4,
          y: y4,
          collapsed,
          title: title || (getTitle === null || getTitle === void 0 ? void 0 : getTitle(item)),
          content: content || (getContent === null || getContent === void 0 ? void 0 : getContent(item)),
          visible: card && card.style.display !== "none"
        });
      });
      return data;
    };
    Annotation3.prototype.readData = function(data) {
      var _this = this;
      var graph = this.get("graph");
      data.forEach(function(info) {
        var id = info.id, x4 = info.x, y4 = info.y, title = info.title, content = info.content, collapsed = info.collapsed, visible = info.visible;
        var item = graph.findById(id);
        if (!item && id === CANVAS_ANNOTATION_ID) {
          item = graph.get("canvas");
        }
        if (!item) {
          var cardInfoMap = _this.get("cardInfoMap") || {};
          cardInfoMap[id] = info;
          _this.set("cardInfoMap", cardInfoMap);
          return;
        }
        _this.toggleAnnotation(item, {
          x: x4,
          y: y4,
          title,
          content,
          collapsed
        });
        if (!visible) _this.hideCard(id);
      });
    };
    Annotation3.prototype.clear = function() {
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap) return;
      var container = this.get("container");
      Object.values(cardInfoMap).forEach(function(cardInfo) {
        var card = cardInfo.card, link = cardInfo.link;
        container.removeChild(card);
        link === null || link === void 0 ? void 0 : link.remove(true);
      });
      this.set("cardInfoMap", {});
    };
    Annotation3.prototype.destroy = function() {
      var _a2;
      this.clear();
      (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      var graph = this.get("graph");
      if (!graph || graph.destroyed) return;
      if (this.get("containerCfg")) {
        graph.getContainer().removeChild(this.get("container"));
      }
      this.destroyed = true;
    };
    return Annotation3;
  }(base_default4)
);
var annotation_default = Annotation;
var getPath6 = function getPath7(startPoints, endPoints) {
  var startPoint, endPoint, posKeys, distance11 = Infinity;
  Object.keys(startPoints).forEach(function(skey) {
    var spos = startPoints[skey];
    Object.keys(endPoints).forEach(function(ekey) {
      var epos = endPoints[ekey];
      var xdist = spos.x - epos.x;
      var ydist = spos.y - epos.y;
      var dist4 = xdist * xdist + ydist * ydist;
      if (distance11 > dist4) {
        distance11 = dist4;
        startPoint = spos;
        endPoint = epos;
        posKeys = [skey, ekey];
      }
    });
  });
  var curveOffset = 20;
  var controlPoint = util_default.getControlPoint(startPoint, endPoint, 0.5, curveOffset);
  return [["M", startPoint.x, startPoint.y], ["Q", controlPoint.x, controlPoint.y, endPoint.x, endPoint.y]];
};
var getPathItem2Card = function getPathItem2Card2(item, cardBBox, graph, annotationCanvas) {
  var _a2;
  var itemLinkPoints;
  var itemType = item.getType();
  if (itemType === "edge") {
    itemLinkPoints = [item.getKeyShape().getPoint(0.5)];
  } else {
    var _b = (_a2 = item.getKeyShape) === null || _a2 === void 0 ? void 0 : _a2.call(item).getBBox(), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
    var _c = item.getModel(), x4 = _c.x, y4 = _c.y;
    minX += x4;
    minY += y4;
    maxX += x4;
    maxY += y4;
    itemLinkPoints = {
      left: {
        x: minX,
        y: (minY + maxY) / 2
      },
      right: {
        x: maxX,
        y: (minY + maxY) / 2
      },
      top: {
        x: (minX + maxX) / 2,
        y: minY
      },
      bottom: {
        x: (minX + maxX) / 2,
        y: maxY
      }
    };
  }
  Object.keys(itemLinkPoints).forEach(function(key) {
    var _a3 = itemLinkPoints[key], x5 = _a3.x, y5 = _a3.y;
    var clientPos = graph.getClientByPoint(x5, y5);
    itemLinkPoints[key] = annotationCanvas.getPointByClient(clientPos.x, clientPos.y);
  });
  var _d = cardBBox.top, cardTop = _d === void 0 ? 0 : _d, _e2 = cardBBox.left, cardLeft = _e2 === void 0 ? 0 : _e2, _f = cardBBox.right, cardRight = _f === void 0 ? 0 : _f, _g = cardBBox.bottom, cardBottom = _g === void 0 ? 0 : _g;
  var cardLinkPoints = {
    left: annotationCanvas.getPointByClient(cardLeft, (cardTop + cardBottom) / 2),
    right: annotationCanvas.getPointByClient(cardRight, (cardTop + cardBottom) / 2),
    top: annotationCanvas.getPointByClient((cardLeft + cardRight) / 2, cardTop),
    bottom: annotationCanvas.getPointByClient((cardLeft + cardRight) / 2, cardBottom)
  };
  return getPath6(itemLinkPoints, cardLinkPoints);
};
var px2Num = function px2Num2(px) {
  return Number(px.replace(/\s+|px/gi, "")) || 0;
};

// node_modules/@antv/g6-plugin/es/index.js
var Plugin = {
  PluginBase: base_default4,
  Menu: menu_default,
  Grid: grid_default,
  Minimap: minimap_default,
  Bundling: bundling_default,
  ToolBar: toolBar_default,
  Tooltip: tooltip_default,
  Fisheye: fisheye_default,
  TimeBar: timeBar_default,
  ImageMinimap: imageMinimap_default,
  EdgeFilterLens: edgeFilterLens_default,
  SnapLine: snapline_default,
  Legend: legend_default,
  Annotation: annotation_default
};
var es_default3 = Plugin;

// node_modules/@antv/g6-pc/es/plugin/index.js
var plugin_default = es_default3;

// node_modules/@antv/g6-element/node_modules/tslib/tslib.es6.mjs
var __assign17 = function() {
  __assign17 = Object.assign || function __assign18(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign17.apply(this, arguments);
};
function __rest6(s2, e8) {
  var t4 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
    t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
}

// node_modules/@antv/g6-element/es/nodes/circle.js
init_esm();
registerNode("circle", {
  // 自定义节点时的配置
  options: {
    size: BaseGlobal.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign17({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "circle",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape11(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, defaultIcon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var icon = deep_mix_default({}, defaultIcon, cfg.icon);
    var name = "".concat(this.type, "-keyShape");
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: name,
      name,
      draggable: true
    });
    group["shapeMap"][name] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      var iconName = "".concat(this.type, "-icon");
      if (text) {
        group["shapeMap"][iconName] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: iconName,
          name: iconName,
          draggable: true
        });
      } else {
        group["shapeMap"][iconName] = group.addShape("image", {
          attrs: __assign17({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: iconName,
          name: iconName,
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints(cfg, group) {
    var linkPoints = (this.mergeStyle || this.getOptions(cfg)).linkPoints;
    if (!linkPoints) return;
    var _a2 = linkPoints || {}, top = _a2.top, left = _a2.left, right = _a2.right, bottom = _a2.bottom, markSize = _a2.size, markR = _a2.r, markStyle = __rest6(_a2, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var r2 = size3[0] / 2;
    if (left) {
      var name_1 = "link-point-left";
      group["shapeMap"][name_1] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: -r2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: name_1,
        name: name_1,
        isAnchorPoint: true
      });
    }
    if (right) {
      var name_2 = "link-point-right";
      group["shapeMap"][name_2] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: r2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: name_2,
        name: name_2,
        isAnchorPoint: true
      });
    }
    if (top) {
      var name_3 = "link-point-top";
      group["shapeMap"][name_3] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: -r2,
          r: markSize / 2 || markR || 5
        }),
        className: name_3,
        name: name_3,
        isAnchorPoint: true
      });
    }
    if (bottom) {
      var name_4 = "link-point-bottom";
      group["shapeMap"][name_4] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: r2,
          r: markSize / 2 || markR || 5
        }),
        className: name_4,
        name: name_4,
        isAnchorPoint: true
      });
    }
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle8(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = deep_mix_default({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var r2 = size3[0] / 2;
    var styles = __assign17({
      x: 0,
      y: 0,
      r: r2
    }, style);
    return styles;
  },
  update: function update7(cfg, item, updateType) {
    var group = item.getContainer();
    var size3 = this.getSize(cfg);
    var style = __assign17({}, cfg.style);
    if (cfg.style.stroke === void 0 && cfg.color) {
      style.stroke = cfg.color;
    }
    if (cfg.style.r === void 0 && !isNaN(size3[0])) {
      style.r = size3[0] / 2;
    }
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/rect.js
init_esm();
registerNode("rect", {
  // 自定义节点时的配置
  options: {
    size: [100, 30],
    style: {
      radius: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    // 连接点，默认为左右
    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign17({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "rect",
  labelPosition: "center",
  drawShape: function drawShape12(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints2(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest6(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle9(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var width = style.width || size3[0];
    var height = style.height || size3[1];
    var styles = __assign17({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update8(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var size3 = this.getSize(cfg);
    var keyShape = item.get("keyShape");
    if (!cfg.size) {
      size3[0] = keyShape.attr("width") || defaultStyle.width;
      size3[1] = keyShape.attr("height") || defaultStyle.height;
    }
    var strokeStyle = {
      stroke: cfg.color,
      x: -size3[0] / 2,
      y: -size3[1] / 2,
      width: size3[0],
      height: size3[1]
    };
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, false, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/ellipse.js
init_esm();
registerNode("ellipse", {
  // 自定义节点时的配置
  options: {
    size: [80, 40],
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign17({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "ellipse",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape13(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("ellipse", {
      attrs: style,
      className: "ellipse-keyShape",
      name: "ellipse-keyShape",
      draggable: true
    });
    group["shapeMap"]["ellipse-keyShape"] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign17({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints3(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest6(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var rx = size3[0] / 2;
    var ry = size3[1] / 2;
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: -rx,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: rx,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: -ry,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: ry,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle10(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var rx = size3[0] / 2;
    var ry = size3[1] / 2;
    var styles = __assign17({
      x: 0,
      y: 0,
      rx,
      ry
    }, style);
    return styles;
  },
  update: function update9(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var size3 = this.getSize(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      rx: size3[0] / 2,
      ry: size3[1] / 2
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/diamond.js
init_esm();
registerNode("diamond", {
  // 自定义节点时的配置
  options: {
    size: [80, 80],
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign17({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "diamond",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape14(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign17({
            x: -w2 / 2,
            y: -h2 / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints4(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest6(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  getPath: function getPath8(cfg) {
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var path = [
      ["M", 0, -height / 2],
      ["L", width / 2, 0],
      ["L", 0, height / 2],
      ["L", -width / 2, 0],
      ["Z"]
      // 封闭
    ];
    return path;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle11(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign17({
      path
    }, style);
    return styles;
  },
  update: function update10(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/triangle.js
init_esm();
registerNode("triangle", {
  // 自定义节点时的配置
  options: {
    size: 40,
    direction: "up",
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize
      },
      offset: 15
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20,
      offset: 6
    },
    stateStyles: __assign17({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "triangle",
  // 文本位置
  labelPosition: "bottom",
  drawShape: function drawShape15(cfg, group) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.icon, icon = _b === void 0 ? {} : _b, defaultDirection = _a2.direction;
    var style = this.getShapeStyle(cfg);
    var direction3 = cfg.direction || defaultDirection;
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, offset = icon.offset, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        var iconW = -w2 / 2;
        var iconH = -h2 / 2;
        if (direction3 === "up" || direction3 === "down") {
          iconH += offset;
        }
        if (direction3 === "left" || direction3 === "right") {
          iconW += offset;
        }
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign17({
            x: iconW,
            y: iconH
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints5(cfg, group) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.linkPoints, linkPoints = _b === void 0 ? {} : _b, defaultDirection = _a2.direction;
    var direction3 = cfg.direction || defaultDirection;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest6(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var len6 = size3[0];
    if (left) {
      var leftPos = null;
      var diffY = len6 * Math.sin(1 / 3 * Math.PI);
      var r2 = len6 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "up") {
        leftPos = [-r2, diffY];
      } else if (direction3 === "down") {
        leftPos = [-r2, -diffY];
      } else if (direction3 === "left") {
        leftPos = [-r2, r2 - diffY];
      }
      if (leftPos) {
        group["shapeMap"]["link-point-left"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, markStyle), {
            x: leftPos[0],
            y: leftPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-left",
          name: "link-point-left"
        });
      }
    }
    if (right) {
      var rightPos = null;
      var diffY = len6 * Math.sin(1 / 3 * Math.PI);
      var r2 = len6 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "up") {
        rightPos = [r2, diffY];
      } else if (direction3 === "down") {
        rightPos = [r2, -diffY];
      } else if (direction3 === "right") {
        rightPos = [r2, r2 - diffY];
      }
      if (rightPos) {
        group["shapeMap"]["link-point-right"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, markStyle), {
            x: rightPos[0],
            y: rightPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-right",
          name: "link-point-right"
        });
      }
    }
    if (top) {
      var topPos = null;
      var diffY = len6 * Math.sin(1 / 3 * Math.PI);
      var r2 = len6 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "up") {
        topPos = [r2 - diffY, -diffY];
      } else if (direction3 === "left") {
        topPos = [r2, -diffY];
      } else if (direction3 === "right") {
        topPos = [-r2, -diffY];
      }
      if (topPos) {
        group["shapeMap"]["link-point-top"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, markStyle), {
            x: topPos[0],
            y: topPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-top",
          name: "link-point-top"
        });
      }
    }
    if (bottom) {
      var bottomPos = null;
      var diffY = len6 * Math.sin(1 / 3 * Math.PI);
      var r2 = len6 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "down") {
        bottomPos = [-r2 + diffY, diffY];
      } else if (direction3 === "left") {
        bottomPos = [r2, diffY];
      } else if (direction3 === "right") {
        bottomPos = [-r2, diffY];
      }
      if (bottomPos) {
        group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, markStyle), {
            x: bottomPos[0],
            y: bottomPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-bottom",
          name: "link-point-bottom"
        });
      }
    }
  },
  getPath: function getPath9(cfg) {
    var defaultDirection = (this.mergeStyle || this.getOptions(cfg)).direction;
    var direction3 = cfg.direction || defaultDirection;
    var size3 = this.getSize(cfg);
    var len6 = size3[0];
    var diffY = len6 * Math.sin(1 / 3 * Math.PI);
    var r2 = len6 * Math.sin(1 / 3 * Math.PI);
    var path = [
      ["M", -r2, diffY],
      ["L", 0, -diffY],
      ["L", r2, diffY],
      ["Z"]
      // 封闭
    ];
    if (direction3 === "down") {
      path = [
        ["M", -r2, -diffY],
        ["L", r2, -diffY],
        ["L", 0, diffY],
        ["Z"]
        // 封闭
      ];
    } else if (direction3 === "left") {
      path = [
        ["M", -r2, r2 - diffY],
        ["L", r2, -r2],
        ["L", r2, r2],
        ["Z"]
        // 封闭
      ];
    } else if (direction3 === "right") {
      path = [
        ["M", r2, r2 - diffY],
        ["L", -r2, r2],
        ["L", -r2, -r2],
        ["Z"]
        // 封闭
      ];
    }
    return path;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle12(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign17({
      path
    }, style);
    return styles;
  },
  update: function update11(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  },
  /**
   * 更新linkPoints
   * @param {Object} cfg 节点数据配置项
   * @param {Group} group Item所在的group
   */
  updateLinkPoints: function updateLinkPoints2(cfg, group) {
    var _a2 = this.getOptions({}), defaultLinkPoints = _a2.linkPoints, defaultDirection = _a2.direction;
    var direction3 = cfg.direction || defaultDirection;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markBottom = group["shapeMap"]["link-point-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-bottom";
    });
    var currentLinkPoints = defaultLinkPoints;
    var existLinkPoint = markLeft || markRight || markTop || markBottom;
    if (existLinkPoint) {
      currentLinkPoints = existLinkPoint.attr();
    }
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize) markSize = linkPoints.r;
    var _b = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }, left = _b.left, right = _b.right, top = _b.top, bottom = _b.bottom;
    var size3 = this.getSize(cfg);
    var len6 = size3[0];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    var leftPos = null;
    var diffY = len6 * Math.sin(1 / 3 * Math.PI);
    var r2 = len6 * Math.sin(1 / 3 * Math.PI);
    if (direction3 === "up") {
      leftPos = [-r2, diffY];
    } else if (direction3 === "down") {
      leftPos = [-r2, -diffY];
    } else if (direction3 === "left") {
      leftPos = [-r2, r2 - diffY];
    }
    if (leftPos) {
      if (markLeft) {
        if (!left && left !== void 0) {
          markLeft.remove();
          delete group["shapeMap"]["link-point-left"];
        } else {
          markLeft.attr(__assign17(__assign17({}, styles), {
            x: leftPos[0],
            y: leftPos[1]
          }));
        }
      } else if (left) {
        group["shapeMap"]["link-point-left"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, styles), {
            x: leftPos[0],
            y: leftPos[1]
          }),
          className: "link-point-left",
          name: "link-point-left",
          isAnchorPoint: true
        });
      }
    }
    var rightPos = null;
    if (direction3 === "up") {
      rightPos = [r2, diffY];
    } else if (direction3 === "down") {
      rightPos = [r2, -diffY];
    } else if (direction3 === "right") {
      rightPos = [r2, r2 - diffY];
    }
    if (rightPos) {
      if (markRight) {
        if (!right && right !== void 0) {
          markRight.remove();
          delete group["shapeMap"]["link-point-right"];
        } else {
          markRight.attr(__assign17(__assign17({}, styles), {
            x: rightPos[0],
            y: rightPos[1]
          }));
        }
      } else if (right) {
        group["shapeMap"]["link-point-right"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, styles), {
            x: rightPos[0],
            y: rightPos[1]
          }),
          className: "link-point-right",
          name: "link-point-right",
          isAnchorPoint: true
        });
      }
    }
    var topPos = null;
    if (direction3 === "up") {
      topPos = [r2 - diffY, -diffY];
    } else if (direction3 === "left") {
      topPos = [r2, -diffY];
    } else if (direction3 === "right") {
      topPos = [-r2, -diffY];
    }
    if (topPos) {
      if (markTop) {
        if (!top && top !== void 0) {
          markTop.remove();
          delete group["shapeMap"]["link-point-top"];
        } else {
          markTop.attr(__assign17(__assign17({}, styles), {
            x: topPos[0],
            y: topPos[1]
          }));
        }
      } else if (top) {
        group["shapeMap"]["link-point-top"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, styles), {
            x: topPos[0],
            y: topPos[1]
          }),
          className: "link-point-top",
          name: "link-point-top",
          isAnchorPoint: true
        });
      }
    }
    var bottomPos = null;
    if (direction3 === "down") {
      bottomPos = [-r2 + diffY, diffY];
    } else if (direction3 === "left") {
      bottomPos = [r2, diffY];
    } else if (direction3 === "right") {
      bottomPos = [-r2, diffY];
    }
    if (bottomPos) {
      if (markBottom) {
        if (!bottom && bottom !== void 0) {
          markBottom.remove();
          delete group["shapeMap"]["link-point-bottom"];
        } else {
          markBottom.attr(__assign17(__assign17({}, styles), {
            x: bottomPos[0],
            y: bottomPos[1]
          }));
        }
      } else if (bottom) {
        group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
          attrs: __assign17(__assign17({}, styles), {
            x: bottomPos[0],
            y: bottomPos[1]
          }),
          className: "link-point-bottom",
          name: "link-point-bottom",
          isAnchorPoint: true
        });
      }
    }
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/modelRect.js
init_esm();
registerNode("modelRect", {
  // 自定义节点时的配置
  options: {
    size: [185, 70],
    style: {
      radius: 5,
      stroke: "#69c0ff",
      fill: "#ffffff",
      lineWidth: BaseGlobal.defaultNode.style.lineWidth,
      fillOpacity: 1
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: "#595959",
        fontSize: 14,
        fontFamily: BaseGlobal.windowFontFamily
      },
      offset: 30
      // 距离左侧的 offset，没有设置 y 轴上移动的配置
    },
    descriptionCfg: {
      style: {
        fontSize: 12,
        fill: "#bfbfbf",
        fontFamily: BaseGlobal.windowFontFamily
      },
      paddingTop: 0
    },
    preRect: {
      show: true,
      width: 4,
      fill: "#40a9ff",
      radius: 2
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: 10,
      lineWidth: 1,
      fill: "#72CC4A",
      stroke: "#72CC4A"
    },
    // 节点中icon配置
    logoIcon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: true,
      x: 0,
      y: 0,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/basement_prod/4f81893c-1806-4de4-aff3-9a6b266bc8a2.svg",
      width: 16,
      height: 16,
      // 用于调整图标的左右位置
      offset: 0
    },
    // 节点中表示状态的icon配置
    stateIcon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: true,
      x: 0,
      y: 0,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/basement_prod/300a2523-67e0-4cbf-9d4a-67c077b40395.svg",
      width: 16,
      height: 16,
      // 用于调整图标的左右位置
      offset: -5
    },
    // 连接点，默认为左右
    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]
    anchorPoints: [[0, 0.5], [1, 0.5]]
  },
  shapeType: "modelRect",
  drawShape: function drawShape16(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).preRect, preRect = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var preRectShow = preRect.show, preRectStyle = __rest6(preRect, ["show"]);
    if (preRectShow) {
      group["shapeMap"]["pre-rect"] = group.addShape("rect", {
        attrs: __assign17({
          x: -width / 2,
          y: -height / 2,
          height
        }, preRectStyle),
        className: "pre-rect",
        name: "pre-rect",
        draggable: true
      });
    }
    this.drawLogoIcon(cfg, group);
    this.drawStateIcon(cfg, group);
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制模型矩形左边的logo图标
   * @param {Object} cfg 数据配置项
   * @param {Group} group Group实例
   */
  drawLogoIcon: function drawLogoIcon(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).logoIcon, logoIcon = _a2 === void 0 ? {} : _a2;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    if (logoIcon.show) {
      var w2 = logoIcon.width, h2 = logoIcon.height, x4 = logoIcon.x, y4 = logoIcon.y, offset = logoIcon.offset, text = logoIcon.text, logoIconStyle = __rest6(logoIcon, ["width", "height", "x", "y", "offset", "text"]);
      if (text) {
        group["shapeMap"]["rect-logo-icon"] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, logoIconStyle),
          className: "rect-logo-icon",
          name: "rect-logo-icon",
          draggable: true
        });
      } else {
        group["shapeMap"]["rect-logo-icon"] = group.addShape("image", {
          attrs: __assign17(__assign17({}, logoIconStyle), {
            x: x4 || -width / 2 + w2 + offset,
            y: y4 || -h2 / 2,
            width: w2,
            height: h2
          }),
          className: "rect-logo-icon",
          name: "rect-logo-icon",
          draggable: true
        });
      }
    }
  },
  /**
   * 绘制模型矩形右边的状态图标
   * @param {Object} cfg 数据配置项
   * @param {Group} group Group实例
   */
  drawStateIcon: function drawStateIcon(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).stateIcon, stateIcon = _a2 === void 0 ? {} : _a2;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    if (stateIcon.show) {
      var w2 = stateIcon.width, h2 = stateIcon.height, x4 = stateIcon.x, y4 = stateIcon.y, offset = stateIcon.offset, text = stateIcon.text, iconStyle = __rest6(stateIcon, ["width", "height", "x", "y", "offset", "text"]);
      if (text) {
        group["shapeMap"]["rect-state-icon"] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, iconStyle),
          className: "rect-state-icon",
          name: "rect-state-icon",
          draggable: true
        });
      } else {
        group["shapeMap"]["rect-state-icon"] = group.addShape("image", {
          attrs: __assign17(__assign17({}, iconStyle), {
            x: x4 || width / 2 - w2 + offset,
            y: y4 || -h2 / 2,
            width: w2,
            height: h2
          }),
          className: "rect-state-icon",
          name: "rect-state-icon",
          draggable: true
        });
      }
    }
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints6(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest6(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  drawLabel: function drawLabel3(cfg, group) {
    var _a2 = this.getOptions(cfg), _b = _a2.labelCfg, labelCfg = _b === void 0 ? {} : _b, _c = _a2.logoIcon, logoIcon = _c === void 0 ? {} : _c, _d = _a2.descriptionCfg, descriptionCfg = _d === void 0 ? {} : _d;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var label = null;
    var show = logoIcon.show, w2 = logoIcon.width;
    var offsetX = -width / 2 + labelCfg.offset;
    if (show) {
      offsetX = -width / 2 + w2 + labelCfg.offset;
    }
    var fontStyle = labelCfg.style;
    var descriptionStyle = descriptionCfg.style, descriptionPaddingTop = descriptionCfg.paddingTop;
    if (is_string_default(cfg.description)) {
      label = group.addShape("text", {
        attrs: __assign17(__assign17({}, fontStyle), {
          x: offsetX,
          y: -5,
          text: cfg.label
        }),
        className: "text-shape",
        name: "text-shape",
        draggable: true,
        labelRelated: true
      });
      group["shapeMap"]["text-shape"] = label;
      group["shapeMap"]["rect-description"] = group.addShape("text", {
        attrs: __assign17(__assign17({}, descriptionStyle), {
          x: offsetX,
          y: 17 + (descriptionPaddingTop || 0),
          text: cfg.description
        }),
        className: "rect-description",
        name: "rect-description",
        draggable: true,
        labelRelated: true
      });
    } else {
      label = group.addShape("text", {
        attrs: __assign17(__assign17({}, fontStyle), {
          x: offsetX,
          y: 7,
          text: cfg.label
        }),
        className: "text-shape",
        name: "text-shape",
        draggable: true,
        labelRelated: true
      });
      group["shapeMap"]["text-shape"] = label;
    }
    return label;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle13(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var width = style.width || size3[0];
    var height = style.height || size3[1];
    var styles = __assign17({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update12(cfg, item) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.style, style = _b === void 0 ? {} : _b, _c = _a2.labelCfg, labelCfg = _c === void 0 ? {} : _c, _d = _a2.descriptionCfg, descriptionCfg = _d === void 0 ? {} : _d;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign17(__assign17({}, style), {
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }));
    var group = item.getContainer();
    var logoIconShape = group["shapeMap"]["rect-logo-icon"] || group.find(function(element) {
      return element.get("className") === "rect-logo-icon";
    });
    var currentLogoIconAttr = logoIconShape ? logoIconShape.attr() : {};
    var logoIcon = mix({}, currentLogoIconAttr, cfg.logoIcon);
    var w2 = logoIcon.width;
    if (w2 === void 0) {
      w2 = this.options.logoIcon.width;
    }
    var show = cfg.logoIcon ? cfg.logoIcon.show : void 0;
    var offset = labelCfg.offset;
    var offsetX = -width / 2 + w2 + offset;
    if (!show && show !== void 0) {
      offsetX = -width / 2 + offset;
    }
    var label = group["shapeMap"]["node-label"] || group.find(function(element) {
      return element.get("className") === "node-label";
    });
    var description = group["shapeMap"]["rect-description"] || group.find(function(element) {
      return element.get("className") === "rect-description";
    });
    if (cfg.label) {
      if (!label) {
        group["shapeMap"]["node-label"] = group.addShape("text", {
          attrs: __assign17(__assign17({}, labelCfg.style), {
            x: offsetX,
            y: cfg.description ? -5 : 7,
            text: cfg.label
          }),
          className: "node-label",
          name: "node-label",
          draggable: true,
          labelRelated: true
        });
      } else {
        var cfgStyle = cfg.labelCfg ? cfg.labelCfg.style : {};
        var labelStyle = mix({}, label.attr(), cfgStyle);
        if (cfg.label) labelStyle.text = cfg.label;
        labelStyle.x = offsetX;
        if (is_string_default(cfg.description)) labelStyle.y = -5;
        if (description) {
          description.resetMatrix();
          description.attr({
            x: offsetX
          });
        }
        label.resetMatrix();
        label.attr(labelStyle);
      }
    }
    if (is_string_default(cfg.description)) {
      var paddingTop = descriptionCfg.paddingTop;
      if (!description) {
        group["shapeMap"]["rect-description"] = group.addShape("text", {
          attrs: __assign17(__assign17({}, descriptionCfg.style), {
            x: offsetX,
            y: 17 + (paddingTop || 0),
            text: cfg.description
          }),
          className: "rect-description",
          name: "rect-description",
          draggable: true,
          labelRelated: true
        });
      } else {
        var cfgStyle = cfg.descriptionCfg ? cfg.descriptionCfg.style : {};
        var descriptionStyle = mix({}, description.attr(), cfgStyle);
        if (is_string_default(cfg.description)) descriptionStyle.text = cfg.description;
        descriptionStyle.x = offsetX;
        description.resetMatrix();
        description.attr(__assign17(__assign17({}, descriptionStyle), {
          y: 17 + (paddingTop || 0)
        }));
      }
    }
    var preRectShape = group["shapeMap"]["pre-rect"] || group.find(function(element) {
      return element.get("className") === "pre-rect";
    });
    if (preRectShape && !preRectShape.destroyed) {
      var preRect = mix({}, preRectShape.attr(), cfg.preRect);
      preRectShape.attr(__assign17(__assign17({}, preRect), {
        x: -width / 2,
        y: -height / 2,
        height
      }));
    }
    if (logoIconShape && !logoIconShape.destroyed) {
      if (!show && show !== void 0) {
        logoIconShape.remove();
        delete group["shapeMap"]["pre-rect"];
      } else {
        var logoW = logoIcon.width, h2 = logoIcon.height, x4 = logoIcon.x, y4 = logoIcon.y, logoOffset = logoIcon.offset, logoIconStyle = __rest6(logoIcon, ["width", "height", "x", "y", "offset"]);
        logoIconShape.attr(__assign17(__assign17({}, logoIconStyle), {
          x: x4 || -width / 2 + logoW + logoOffset,
          y: y4 || -h2 / 2,
          width: logoW,
          height: h2
        }));
      }
    } else if (show) {
      this.drawLogoIcon(cfg, group);
    }
    var stateIconShape = group["shapeMap"]["rect-state-icon"] || group.find(function(element) {
      return element.get("className") === "rect-state-icon";
    });
    var currentStateIconAttr = stateIconShape ? stateIconShape.attr() : {};
    var stateIcon = mix({}, currentStateIconAttr, cfg.stateIcon);
    if (stateIconShape) {
      if (!stateIcon.show && stateIcon.show !== void 0) {
        stateIconShape.remove();
        delete group["shapeMap"]["rect-state-icon"];
      }
      var stateW = stateIcon.width, h2 = stateIcon.height, x4 = stateIcon.x, y4 = stateIcon.y, stateOffset = stateIcon.offset, stateIconStyle = __rest6(stateIcon, ["width", "height", "x", "y", "offset"]);
      stateIconShape.attr(__assign17(__assign17({}, stateIconStyle), {
        x: x4 || width / 2 - stateW + stateOffset,
        y: y4 || -h2 / 2,
        width: stateW,
        height: h2
      }));
    } else if (stateIcon.show) {
      this.drawStateIcon(cfg, group);
    }
    this.updateLinkPoints(cfg, group);
  },
  getOptions: function getOptions2(cfg, updateType) {
    if (updateType === "move") return cfg;
    return deep_mix_default({}, this.options, this.getCustomConfig(cfg) || {}, cfg);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/star.js
init_esm();
registerNode("star", {
  // 自定义节点时的配置
  options: {
    size: 60,
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign17({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "star",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape17(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign17({
            x: -w2 / 2,
            y: -h2 / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints7(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, leftBottom = linkPoints.leftBottom, rightBottom = linkPoints.rightBottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest6(linkPoints, ["top", "left", "right", "leftBottom", "rightBottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var outerR = size3[0];
    if (right) {
      var x1 = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right"
      });
    }
    if (top) {
      var x1 = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top"
      });
    }
    if (left) {
      var x1 = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left"
      });
    }
    if (leftBottom) {
      var x1 = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left-bottom",
        name: "link-point-left-bottom"
      });
    }
    if (rightBottom) {
      var x1 = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-right-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right-bottom",
        name: "link-point-right-bottom"
      });
    }
  },
  getPath: function getPath10(cfg) {
    var size3 = this.getSize(cfg);
    var outerR = size3[0];
    var defaultInnerR = outerR * 3 / 8;
    var innerR = cfg.innerR || defaultInnerR;
    return util_default.getStarPath(outerR, innerR);
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle14(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign17({
      path
    }, style);
    return styles;
  },
  update: function update13(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  },
  /**
   * 更新linkPoints
   * @param {Object} cfg 节点数据配置项
   * @param {Group} group Item所在的group
   */
  updateLinkPoints: function updateLinkPoints3(cfg, group) {
    var defaultLinkPoints = this.getOptions({}).linkPoints;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markLeftBottom = group["shapeMap"]["link-point-left-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-left-bottom";
    });
    var markRightBottom = group["shapeMap"]["link-point-left-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-right-bottom";
    });
    var currentLinkPoints = defaultLinkPoints;
    var existLinkPoint = markLeft || markRight || markTop || markLeftBottom || markRightBottom;
    if (existLinkPoint) {
      currentLinkPoints = existLinkPoint.attr();
    }
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize) markSize = linkPoints.r;
    var _a2 = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      leftBottom: void 0,
      rightBottom: void 0
    }, left = _a2.left, right = _a2.right, top = _a2.top, leftBottom = _a2.leftBottom, rightBottom = _a2.rightBottom;
    var size3 = this.getSize(cfg);
    var outerR = size3[0];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    var x4 = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;
    var y4 = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;
    if (markRight) {
      if (!right && right !== void 0) {
        markRight.remove();
        delete group["shapeMap"]["link-point-right"];
      } else {
        markRight.attr(__assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR;
    if (markTop) {
      if (!top && top !== void 0) {
        markTop.remove();
        delete group["shapeMap"]["link-point-top"];
      } else {
        markTop.attr(__assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR;
    if (markLeft) {
      if (!left && left !== void 0) {
        markLeft.remove();
        delete group["shapeMap"]["link-point-left"];
      } else {
        markLeft.attr(__assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR;
    if (markLeftBottom) {
      if (!leftBottom && leftBottom !== void 0) {
        markLeftBottom.remove();
        delete group["shapeMap"]["link-point-left-bottom"];
      } else {
        markLeftBottom.attr(__assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (leftBottom) {
      group["shapeMap"]["link-point-left-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-left-bottom",
        name: "link-point-left-bottom",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR;
    if (markRightBottom) {
      if (!rightBottom && rightBottom !== void 0) {
        markRightBottom.remove();
        delete group["shapeMap"]["link-point-right-bottom"];
      } else {
        markRightBottom.attr(__assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (rightBottom) {
      group["shapeMap"]["link-point-right-bottom"] = group.addShape("circle", {
        attrs: __assign17(__assign17({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-right-bottom",
        name: "link-point-right-bottom",
        isAnchorPoint: true
      });
    }
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/donut.js
init_esm();
var defaultSubjectColors2 = util_default.defaultSubjectColors;
var FAN_NAME_PREFIX = "fan-shape-";
registerNode("donut", {
  // 自定义节点时的配置
  options: {
    size: BaseGlobal.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign17({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "circle",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape18(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, defaultIcon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var icon = deep_mix_default({}, defaultIcon, cfg.icon);
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      draggable: true,
      name: "".concat(this.type, "-keyShape")
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign17({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign17({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    drawFans(cfg, group, keyShape);
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  updateShape: function updateShape3(cfg, item, keyShapeStyle, hasIcon, updateType) {
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign17({}, keyShapeStyle));
    updateFans(cfg, item, keyShape);
    if (true) {
      this.updateLabel(cfg, item, updateType);
    }
    if (hasIcon) {
      this.updateIcon(cfg, item);
    }
  }
}, "circle");
var drawFans = function drawFans2(cfg, group, keyShape) {
  var _a2 = cfg.donutAttrs, donutAttrs = _a2 === void 0 ? {} : _a2, _b = cfg.donutColorMap, donutColorMap = _b === void 0 ? {} : _b;
  var attrNum = Object.keys(donutAttrs).length;
  if (donutAttrs && attrNum > 1) {
    var _c = getDonutConfig(donutAttrs, donutColorMap), configs = _c.configs, totalValue = _c.totalValue;
    if (totalValue) {
      var _d = getDonutSize(keyShape), lineWidth = _d.lineWidth, arcR = _d.arcR;
      var arcBegin = [arcR, 0];
      var beginAngle = 0;
      if (attrNum === 1) {
        drawFan(group, {
          arcR,
          arcBegin,
          beginAngle,
          config: configs[0],
          fanIndex: 0,
          lineWidth,
          totalValue,
          drawWhole: true
        });
        return;
      }
      for (var i2 = 0; i2 < configs.length; i2++) {
        var result = drawFan(group, {
          arcR,
          arcBegin,
          beginAngle,
          config: configs[i2],
          fanIndex: i2,
          lineWidth,
          totalValue
        });
        if (result.shouldEnd) return;
        arcBegin = result.arcBegin;
        beginAngle = result.beginAngle;
      }
    }
  }
};
var drawFan = function drawFan2(group, fanConfig) {
  var arcR = fanConfig.arcR, arcBegin = fanConfig.arcBegin, beginAngle = fanConfig.beginAngle, config = fanConfig.config, fanIndex = fanConfig.fanIndex, lineWidth = fanConfig.lineWidth, totalValue = fanConfig.totalValue, _a2 = fanConfig.drawWhole, drawWhole = _a2 === void 0 ? false : _a2, _b = fanConfig.updateShape, updateShape4 = _b === void 0 ? void 0 : _b;
  var percent = config.value / totalValue;
  if (percent < 1e-3) {
    return {
      beginAngle,
      arcBegin,
      shape: void 0,
      shouldEnd: false
    };
  }
  var arcEnd, endAngle, isBig;
  if (drawWhole || percent > 0.999) {
    arcEnd = [arcR, 1e-4];
    isBig = 1;
  } else {
    var angle3 = percent * Math.PI * 2;
    endAngle = beginAngle + angle3;
    arcEnd = [arcR * Math.cos(endAngle), -arcR * Math.sin(endAngle)];
    isBig = angle3 > Math.PI ? 1 : 0;
  }
  var style = {
    path: [["M", arcBegin[0], arcBegin[1]], ["A", arcR, arcR, 0, isBig, 0, arcEnd[0], arcEnd[1]]],
    stroke: config.color || (updateShape4 === null || updateShape4 === void 0 ? void 0 : updateShape4.attr("stroke")) || defaultSubjectColors2[fanIndex % defaultSubjectColors2.length],
    lineWidth
  };
  if (updateShape4) {
    updateShape4.attr(style);
  } else {
    group["shapeMap"]["".concat(FAN_NAME_PREFIX).concat(fanIndex)] = group.addShape("path", {
      attrs: style,
      name: "".concat(FAN_NAME_PREFIX).concat(fanIndex),
      draggable: true
    });
  }
  return {
    beginAngle: endAngle,
    arcBegin: arcEnd,
    shape: group["shapeMap"]["".concat(FAN_NAME_PREFIX).concat(fanIndex)],
    shouldEnd: drawWhole || percent > 0.999
  };
};
var updateFans = function updateFans2(cfg, item, keyShape) {
  var donutAttrs = cfg.donutAttrs, _a2 = cfg.donutColorMap, donutColorMap = _a2 === void 0 ? {} : _a2;
  var visitMap = {};
  var group = item.getContainer();
  if (donutAttrs) {
    var _b = getDonutConfig(donutAttrs, donutColorMap), configs = _b.configs, totalValue = _b.totalValue;
    if (totalValue) {
      var _c = getDonutSize(keyShape), lineWidth = _c.lineWidth, arcR = _c.arcR;
      var arcBegin = [arcR, 0];
      var beginAngle = 0;
      for (var i2 = 0; i2 < configs.length; i2++) {
        var shapeName = "".concat(FAN_NAME_PREFIX).concat(i2);
        var result = drawFan(group, {
          arcR,
          arcBegin,
          beginAngle,
          config: configs[i2],
          fanIndex: i2,
          lineWidth,
          totalValue,
          drawWhole: configs.length === 1,
          updateShape: group["shapeMap"][shapeName]
        });
        if (result.shape) visitMap[shapeName] = true;
        if (result.shouldEnd) break;
        arcBegin = result.arcBegin;
        beginAngle = result.beginAngle;
      }
    }
  }
  var fanKeys = Object.keys(group["shapeMap"]).filter(function(key) {
    return key.includes(FAN_NAME_PREFIX);
  });
  fanKeys.forEach(function(key) {
    if (!visitMap[key]) {
      group["shapeMap"][key].remove(true);
      delete group["shapeMap"][key];
    }
  });
};
var getDonutConfig = function getDonutConfig2(donutAttrs, donutColorMap) {
  var totalValue = 0;
  var configs = [];
  Object.keys(donutAttrs).forEach(function(name) {
    var value = +donutAttrs[name];
    if (isNaN(value)) return;
    configs.push({
      key: name,
      value,
      color: donutColorMap[name]
    });
    totalValue += value;
  });
  return {
    totalValue,
    configs
  };
};
var getDonutSize = function getDonutSize2(keyShape) {
  var keyShapeR = keyShape.attr("r");
  var innerR = 0.6 * keyShapeR;
  var arcR = (keyShapeR + innerR) / 2;
  var lineWidth = keyShapeR - innerR;
  return {
    lineWidth,
    arcR
  };
};

// node_modules/@antv/g6-element/es/edges/polyline.js
init_esm();

// node_modules/@antv/g6-element/es/edges/polyline-util.js
var getBBoxFromPoint = function getBBoxFromPoint2(point) {
  var x4 = point.x, y4 = point.y;
  return {
    x: x4,
    y: y4,
    centerX: x4,
    centerY: y4,
    minX: x4,
    minY: y4,
    maxX: x4,
    maxY: y4,
    height: 0,
    width: 0
  };
};
var getBBoxFromPoints = function getBBoxFromPoints2(points) {
  if (points === void 0) {
    points = [];
  }
  var xs = [];
  var ys = [];
  points.forEach(function(p2) {
    xs.push(p2.x);
    ys.push(p2.y);
  });
  var minX = Math.min.apply(Math, xs);
  var maxX = Math.max.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxY = Math.max.apply(Math, ys);
  return {
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    maxX,
    maxY,
    minX,
    minY,
    height: maxY - minY,
    width: maxX - minX
  };
};
var filterConnectPoints = function filterConnectPoints2(points) {
  var result = [];
  var map6 = {};
  var pointsLength = points.length;
  for (var i2 = pointsLength - 1; i2 >= 0; i2--) {
    var p2 = points[i2];
    p2.id = "".concat(p2.x, "|||").concat(p2.y);
    if (!map6[p2.id]) {
      map6[p2.id] = p2;
      result.push(p2);
    }
  }
  return result;
};
var simplifyPolyline = function simplifyPolyline2(points) {
  return filterConnectPoints(points);
};
var getExpandedBBox = function getExpandedBBox2(bbox, offset) {
  if (bbox.width || bbox.height) {
    return {
      centerX: bbox.centerX,
      centerY: bbox.centerY,
      minX: bbox.minX - offset,
      minY: bbox.minY - offset,
      maxX: bbox.maxX + offset,
      maxY: bbox.maxY + offset,
      height: bbox.height + 2 * offset,
      width: bbox.width + 2 * offset
    };
  }
  return bbox;
};
var isHorizontalPort = function isHorizontalPort2(port, bbox) {
  var dx = Math.abs(port.x - bbox.centerX);
  var dy = Math.abs(port.y - bbox.centerY);
  if (dx === 0 && dy === 0) return 0;
  return dx / bbox.width > dy / bbox.height;
};
var getExpandedBBoxPoint = function getExpandedBBoxPoint2(bbox, point, anotherPoint) {
  var isHorizontal = isHorizontalPort(point, bbox);
  if (isHorizontal === 0) {
    var x4 = bbox.centerX;
    var y4 = bbox.centerY;
    if (anotherPoint.y < point.y) {
      y4 = bbox.minY;
    } else if (anotherPoint.x > point.x) {
      x4 = bbox.maxX;
    } else if (anotherPoint.x < point.x) {
      x4 = bbox.minX;
    } else if (anotherPoint.x === point.x) {
      y4 = bbox.maxY;
    }
    return {
      x: x4,
      y: y4
    };
  }
  if (isHorizontal) {
    return {
      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,
      y: point.y
    };
  }
  return {
    x: point.x,
    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY
  };
};
var mergeBBox2 = function mergeBBox3(b12, b22) {
  var minX = Math.min(b12.minX, b22.minX);
  var minY = Math.min(b12.minY, b22.minY);
  var maxX = Math.max(b12.maxX, b22.maxX);
  var maxY = Math.max(b12.maxY, b22.maxY);
  return {
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    minX,
    minY,
    maxX,
    maxY,
    height: maxY - minY,
    width: maxX - minX
  };
};
var getPointsFromBBox = function getPointsFromBBox2(bbox) {
  return [{
    x: bbox.minX,
    y: bbox.minY
  }, {
    x: bbox.maxX,
    y: bbox.minY
  }, {
    x: bbox.maxX,
    y: bbox.maxY
  }, {
    x: bbox.minX,
    y: bbox.maxY
  }];
};
var isPointOutsideBBox = function isPointOutsideBBox2(point, bbox) {
  var x4 = point.x, y4 = point.y;
  return x4 < bbox.minX || x4 > bbox.maxX || y4 < bbox.minY || y4 > bbox.maxY;
};
var getBBoxXCrossPoints = function getBBoxXCrossPoints2(bbox, x4) {
  if (x4 < bbox.minX || x4 > bbox.maxX) {
    return [];
  }
  return [{
    x: x4,
    y: bbox.minY
  }, {
    x: x4,
    y: bbox.maxY
  }];
};
var getBBoxYCrossPoints = function getBBoxYCrossPoints2(bbox, y4) {
  if (y4 < bbox.minY || y4 > bbox.maxY) {
    return [];
  }
  return [{
    x: bbox.minX,
    y: y4
  }, {
    x: bbox.maxX,
    y: y4
  }];
};
var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint2(bbox, point) {
  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));
};
var distance9 = function distance10(p1, p2) {
  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
};
var _costByPoints = function _costByPoints2(p2, points) {
  var offset = -2;
  var result = 0;
  points.forEach(function(point) {
    if (point) {
      if (p2.x === point.x) {
        result += offset;
      }
      if (p2.y === point.y) {
        result += offset;
      }
    }
  });
  return result;
};
var heuristicCostEstimate = function heuristicCostEstimate2(p2, ps, pt2, source, target) {
  return distance9(p2, ps) + distance9(p2, pt2) + _costByPoints(p2, [ps, pt2, source, target]);
};
var reconstructPath = function reconstructPath2(pathPoints, pointById, cameFrom, currentId, iterator) {
  if (iterator === void 0) {
    iterator = 0;
  }
  pathPoints.unshift(pointById[currentId]);
  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {
    reconstructPath2(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);
  }
};
var isSegmentsIntersected = function isSegmentsIntersected2(p0, p1, p2, p3) {
  var v1x = p2.x - p0.x;
  var v1y = p2.y - p0.y;
  var v2x = p3.x - p0.x;
  var v2y = p3.y - p0.y;
  var v3x = p2.x - p1.x;
  var v3y = p2.y - p1.y;
  var v4x = p3.x - p1.x;
  var v4y = p3.y - p1.y;
  var pd1 = v1x * v2y - v1y * v2x;
  var pd2 = v3x * v4y - v3y * v4x;
  var pd3 = v1x * v3y - v1y * v3x;
  var pd4 = v2x * v4y - v2y * v4x;
  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;
};
var isSegmentCrossingBBox = function isSegmentCrossingBBox2(p1, p2, bbox) {
  if (bbox.width || bbox.height) {
    var _a2 = getPointsFromBBox(bbox), pa2 = _a2[0], pb = _a2[1], pc = _a2[2], pd = _a2[3];
    return isSegmentsIntersected(p1, p2, pa2, pb) || isSegmentsIntersected(p1, p2, pa2, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);
  }
  return false;
};
var getNeighborPoints = function getNeighborPoints2(points, point, bbox1, bbox2) {
  var neighbors = [];
  points.forEach(function(p2) {
    if (p2 === point) return;
    if (p2.x === point.x || p2.y === point.y) {
      if (isSegmentCrossingBBox(p2, point, bbox1) || isSegmentCrossingBBox(p2, point, bbox2)) return;
      neighbors.push(p2);
    }
  });
  return filterConnectPoints(neighbors);
};
var pathFinder = function pathFinder2(points, start, goal, sBBox, tBBox, os, ot2) {
  var _a2;
  var closedSet = [];
  var openSet = (_a2 = {}, _a2[start.id] = start, _a2);
  var cameFrom = {};
  var gScore = {};
  var fScore = {};
  gScore[start.id] = 0;
  fScore[start.id] = heuristicCostEstimate(start, goal, start);
  var sortedOpenSet = new SortedArray();
  sortedOpenSet.add({
    id: start.id,
    value: fScore[start.id]
  });
  var pointById = {};
  points.forEach(function(p2) {
    pointById[p2.id] = p2;
  });
  var current;
  while (Object.keys(openSet).length) {
    var minId = sortedOpenSet.minId(false);
    if (minId) {
      current = openSet[minId];
    } else {
      break;
    }
    if (current === goal) {
      var pathPoints = [];
      reconstructPath(pathPoints, pointById, cameFrom, goal.id);
      return pathPoints;
    }
    delete openSet[current.id];
    sortedOpenSet.remove(current.id);
    closedSet.push(current);
    var neighborPoints = getNeighborPoints(points, current, sBBox, tBBox);
    var iterateNeighbors = function iterateNeighbors2(items) {
      items.forEach(function(neighbor) {
        if (closedSet.indexOf(neighbor) !== -1) {
          return;
        }
        var neighborId = neighbor.id;
        if (!openSet[neighborId]) {
          openSet[neighborId] = neighbor;
        }
        var tentativeGScore = fScore[current.id] + distance9(current, neighbor);
        if (gScore[neighborId] && tentativeGScore >= gScore[neighborId]) {
          sortedOpenSet.add({
            id: neighborId,
            value: fScore[neighborId]
          });
          return;
        }
        cameFrom[neighborId] = current.id;
        gScore[neighborId] = tentativeGScore;
        fScore[neighborId] = gScore[neighborId] + heuristicCostEstimate(neighbor, goal, start, os, ot2);
        sortedOpenSet.add({
          id: neighborId,
          value: fScore[neighborId]
        });
      });
    };
    iterateNeighbors(neighborPoints);
  }
  return [start, goal];
};
var isBending = function isBending2(p0, p1, p2) {
  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);
};
var getBorderRadiusPoints = function getBorderRadiusPoints2(p0, p1, p2, r2) {
  var d0 = distance9(p0, p1);
  var d1 = distance9(p2, p1);
  if (d0 < r2) {
    r2 = d0;
  }
  if (d1 < r2) {
    r2 = d1;
  }
  var ps = {
    x: p1.x - r2 / d0 * (p1.x - p0.x),
    y: p1.y - r2 / d0 * (p1.y - p0.y)
  };
  var pt2 = {
    x: p1.x - r2 / d1 * (p1.x - p2.x),
    y: p1.y - r2 / d1 * (p1.y - p2.y)
  };
  return [ps, pt2];
};
var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline2(points, borderRadius) {
  var pathSegments = [];
  var startPoint = points[0];
  pathSegments.push("M".concat(startPoint.x, " ").concat(startPoint.y));
  points.forEach(function(p2, i2) {
    var p1 = points[i2 + 1];
    var p22 = points[i2 + 2];
    if (p1 && p22) {
      if (isBending(p2, p1, p22)) {
        var _a2 = getBorderRadiusPoints(p2, p1, p22, borderRadius), ps = _a2[0], pt2 = _a2[1];
        pathSegments.push("L".concat(ps.x, " ").concat(ps.y));
        pathSegments.push("Q".concat(p1.x, " ").concat(p1.y, " ").concat(pt2.x, " ").concat(pt2.y));
        pathSegments.push("L".concat(pt2.x, " ").concat(pt2.y));
      } else {
        pathSegments.push("L".concat(p1.x, " ").concat(p1.y));
      }
    } else if (p1) {
      pathSegments.push("L".concat(p1.x, " ").concat(p1.y));
    }
  });
  return pathSegments.join("");
};
var getPolylinePoints = function getPolylinePoints2(start, end2, sNode, tNode, offset) {
  var sBBox, tBBox;
  if (!sNode || !sNode.getType()) {
    sBBox = getBBoxFromPoint(start);
  } else if (sNode.getType() === "combo") {
    var sKeyShapeBBox = sNode.getKeyShape().getBBox();
    if (sKeyShapeBBox) {
      var _a2 = sNode.getModel(), sx = _a2.x, sy = _a2.y;
      sBBox = {
        x: sx,
        y: sy,
        width: sKeyShapeBBox.width,
        height: sKeyShapeBBox.height,
        minX: sKeyShapeBBox.minX + sx,
        maxX: sKeyShapeBBox.maxX + sx,
        minY: sKeyShapeBBox.minY + sy,
        maxY: sKeyShapeBBox.maxY + sy
      };
      sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;
      sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;
    } else {
      sBBox = getBBoxFromPoint(start);
    }
  } else {
    sBBox = sNode && sNode.getBBox();
  }
  if (!tNode || !tNode.getType()) {
    tBBox = getBBoxFromPoint(end2);
  } else if (tNode.getType() === "combo") {
    var tKeyShapeBBox = tNode.getKeyShape().getBBox();
    if (tKeyShapeBBox) {
      var _b = tNode.getModel(), tx = _b.x, ty = _b.y;
      tBBox = {
        x: tx,
        y: ty,
        width: tKeyShapeBBox.width,
        height: tKeyShapeBBox.height,
        minX: tKeyShapeBBox.minX + tx,
        maxX: tKeyShapeBBox.maxX + tx,
        minY: tKeyShapeBBox.minY + ty,
        maxY: tKeyShapeBBox.maxY + ty
      };
      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;
      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;
    } else {
      tBBox = getBBoxFromPoint(end2);
    }
  } else {
    tBBox = tNode && tNode.getBBox();
  }
  var sxBBox = getExpandedBBox(sBBox, offset);
  var txBBox = getExpandedBBox(tBBox, offset);
  var sPoint = getExpandedBBoxPoint(sxBBox, start, end2);
  var tPoint = getExpandedBBoxPoint(txBBox, end2, start);
  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);
  var sMixBBox = mergeBBox2(sxBBox, lineBBox);
  var tMixBBox = mergeBBox2(txBBox, lineBBox);
  var connectPoints = [];
  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));
  var centerPoint = {
    x: (start.x + end2.x) / 2,
    y: (start.y + end2.y) / 2
  };
  [lineBBox, sMixBBox, tMixBBox].forEach(function(bbox) {
    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function(p2) {
      return isPointOutsideBBox(p2, sxBBox) && isPointOutsideBBox(p2, txBBox);
    }));
  });
  [{
    x: sPoint.x,
    y: tPoint.y
  }, {
    x: tPoint.x,
    y: sPoint.y
  }].forEach(function(p2) {
    if (isPointOutsideBBox(p2, sxBBox) && isPointOutsideBBox(p2, txBBox)) {
      connectPoints.push(p2);
    }
  });
  connectPoints.unshift(sPoint);
  connectPoints.push(tPoint);
  connectPoints = filterConnectPoints(connectPoints);
  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end2);
  pathPoints.unshift(start);
  pathPoints.push(end2);
  return simplifyPolyline(pathPoints);
};
var removeRedundantPoint = function removeRedundantPoint2(points) {
  if (!(points === null || points === void 0 ? void 0 : points.length)) return points;
  var beginPoint = points[points.length - 1];
  var current = {
    x: beginPoint.x,
    y: beginPoint.y
  };
  var continueSameX = [beginPoint];
  var continueSameY = [beginPoint];
  for (var i2 = points.length - 2; i2 >= 0; i2--) {
    var point = points[i2];
    if (point.x === current.x) {
      continueSameX.push(point);
    } else {
      continueSameX = [point];
      current.x = point.x;
    }
    if (point.y === current.y) {
      continueSameY.push(point);
    } else {
      continueSameY = [point];
      current.y = point.y;
    }
    if (continueSameX.length > 2) {
      var removeIdx = points.indexOf(continueSameX[1]);
      if (removeIdx > -1) points.splice(removeIdx, 1);
      continue;
    }
    if (continueSameY.length > 2) {
      var removeIdx = points.indexOf(continueSameY[1]);
      if (removeIdx > -1) points.splice(removeIdx, 1);
    }
  }
  return points;
};
var SortedArray = (
  /** @class */
  function() {
    function SortedArray2() {
      this.arr = [];
      this.map = {};
      this.arr = [];
      this.map = {};
    }
    SortedArray2.prototype._innerAdd = function(item, length6) {
      var idxRange = [0, length6 - 1];
      while (idxRange[1] - idxRange[0] > 1) {
        var midIdx = Math.floor((idxRange[0] + idxRange[1]) / 2);
        if (this.arr[midIdx].value > item.value) {
          idxRange[1] = midIdx;
        } else if (this.arr[midIdx].value < item.value) {
          idxRange[0] = midIdx;
        } else {
          this.arr.splice(midIdx, 0, item);
          this.map[item.id] = true;
          return;
        }
      }
      this.arr.splice(idxRange[1], 0, item);
      this.map[item.id] = true;
    };
    SortedArray2.prototype.add = function(item) {
      delete this.map[item.id];
      var length6 = this.arr.length;
      if (!length6) {
        this.arr.push(item);
        this.map[item.id] = true;
        return;
      }
      if (this.arr[length6 - 1].value < item.value) {
        this.arr.push(item);
        this.map[item.id] = true;
        return;
      }
      this._innerAdd(item, length6);
    };
    SortedArray2.prototype.remove = function(id) {
      if (!this.map[id]) return;
      delete this.map[id];
    };
    SortedArray2.prototype._clearAndGetMinId = function() {
      var res;
      for (var i2 = this.arr.length - 1; i2 >= 0; i2--) {
        if (this.map[this.arr[i2].id]) res = this.arr[i2].id;
        else this.arr.splice(i2, 1);
      }
      return res;
    };
    SortedArray2.prototype._findFirstId = function() {
      while (this.arr.length) {
        var first = this.arr.shift();
        if (this.map[first.id]) return first.id;
      }
    };
    SortedArray2.prototype.minId = function(clear) {
      if (clear) {
        return this._clearAndGetMinId();
      } else {
        return this._findFirstId();
      }
    };
    return SortedArray2;
  }()
);

// node_modules/@antv/g6-element/es/edges/router.js
init_esm();
var manhattanDist = function manhattanDist2(p1, p2) {
  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
};
var eucliDist = function eucliDist2(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};
var straightPath = function straightPath2(start, end2) {
  return [start, end2];
};
var simplePolyline = function simplePolyline2(start, end2, startNode, endNode, cfg) {
  return simplifyPolyline(getPolylinePoints(start, end2, startNode, endNode, cfg.offset));
};
var defaultCfg = {
  offset: 20,
  maxAllowedDirectionChange: Math.PI / 2,
  maximumLoops: 2e3,
  gridSize: 10,
  directions: [
    {
      stepX: 1,
      stepY: 0
    },
    {
      stepX: -1,
      stepY: 0
    },
    {
      stepX: 0,
      stepY: 1
    },
    {
      stepX: 0,
      stepY: -1
    }
    // top
  ],
  get penalties() {
    return {
      0: 0,
      45: this.gridSize / 2,
      90: this.gridSize / 2
    };
  },
  distFunc: manhattanDist,
  fallbackRoute: simplePolyline
};
var octolinearCfg = {
  maxAllowedDirectionChange: Math.PI / 4,
  // 8 个方向: 上下左右 + 45度斜线方向
  directions: [{
    stepX: 1,
    stepY: 0
  }, {
    stepX: 1,
    stepY: 1
  }, {
    stepX: 0,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 0
  }, {
    stepX: -1,
    stepY: -1
  }, {
    stepX: 0,
    stepY: -1
  }, {
    stepX: 1,
    stepY: -1
  }],
  distFunc: eucliDist,
  fallbackRoute: straightPath
};
var pos2GridIx = function pos2GridIx2(pos, gridSize) {
  var gridIx = Math.round(Math.abs(pos / gridSize));
  var sign = pos < 0 ? -1 : 1;
  return gridIx < 0 ? 0 : sign * gridIx;
};
var getObstacleMap = function getObstacleMap2(items, gridSize, offset) {
  var map6 = {};
  items.forEach(function(item) {
    if (!item) return;
    var bbox = getExpandedBBox(item.getBBox(), offset);
    for (var x4 = pos2GridIx(bbox.minX, gridSize); x4 <= pos2GridIx(bbox.maxX, gridSize); x4 += 1) {
      for (var y4 = pos2GridIx(bbox.minY, gridSize); y4 <= pos2GridIx(bbox.maxY, gridSize); y4 += 1) {
        map6["".concat(x4, "|||").concat(y4)] = true;
      }
    }
  });
  return map6;
};
var getDirectionAngle = function getDirectionAngle2(p1, p2) {
  var deltaX = p2.x - p1.x;
  var deltaY = p2.y - p1.y;
  if (deltaX || deltaY) {
    return Math.atan2(deltaY, deltaX);
  }
  return 0;
};
var getAngleDiff = function getAngleDiff2(angle1, angle22) {
  var directionChange = Math.abs(angle1 - angle22);
  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;
};
var estimateCost = function estimateCost2(from, endPoints, distFunc) {
  var min6 = Infinity;
  for (var i2 = 0, len6 = endPoints.length; i2 < len6; i2++) {
    var cost = distFunc(from, endPoints[i2]);
    if (cost < min6) {
      min6 = cost;
    }
  }
  return min6;
};
var getBoxPoints = function getBoxPoints2(point, oriPoint, node, anotherPoint, cfg) {
  var points = [];
  if (!node) {
    return [point];
  }
  var directions = cfg.directions, offset = cfg.offset;
  var bbox = node.getBBox();
  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;
  var expandBBox = getExpandedBBox(bbox, offset);
  for (var i2 in expandBBox) {
    expandBBox[i2] = pos2GridIx(expandBBox[i2], cfg.gridSize);
  }
  if (isInside) {
    for (var _i2 = 0, directions_1 = directions; _i2 < directions_1.length; _i2++) {
      var dir = directions_1[_i2];
      var bounds = [[{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.minY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.minX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.maxX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.maxY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }]];
      for (var i2 = 0; i2 < 4; i2++) {
        var boundLine = bounds[i2];
        var insterctP_1 = util_default.getLineIntersect(point, {
          x: point.x + dir.stepX * expandBBox.width,
          y: point.y + dir.stepY * expandBBox.height
        }, boundLine[0], boundLine[1]);
        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {
          insterctP_1.id = "".concat(insterctP_1.x, "|||").concat(insterctP_1.y);
          points.push(insterctP_1);
        }
      }
    }
    return points;
  }
  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);
  insterctP.id = "".concat(insterctP.x, "|||").concat(insterctP.y);
  return [insterctP];
};
var getDirectionChange = function getDirectionChange2(current, neighbor, cameFrom, scaleStartPoint) {
  var directionAngle = getDirectionAngle(current, neighbor);
  var currentCameFrom = cameFrom[current.id];
  if (!currentCameFrom) {
    var startAngle = getDirectionAngle(scaleStartPoint, current);
    return getAngleDiff(startAngle, directionAngle);
  }
  var prevDirectionAngle = getDirectionAngle({
    x: currentCameFrom.x,
    y: currentCameFrom.y
  }, current);
  return getAngleDiff(prevDirectionAngle, directionAngle);
};
var getControlPoints12 = function getControlPoints13(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {
  var controlPoints = [endPoint];
  var pointZero = endPoint;
  var currentId = current.id;
  var currentX = current.x;
  var currentY = current.y;
  var lastPoint = {
    x: currentX,
    y: currentY,
    id: currentId
  };
  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {
    pointZero = {
      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,
      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize
    };
    controlPoints.unshift(pointZero);
  }
  var currentCameFrom = cameFrom[currentId];
  while (currentCameFrom && currentCameFrom.id !== currentId) {
    var point = {
      x: currentX,
      y: currentY,
      id: currentId
    };
    var prePoint = {
      x: currentCameFrom.x,
      y: currentCameFrom.y,
      id: currentCameFrom.id
    };
    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);
    if (directionChange) {
      pointZero = {
        x: prePoint.x === point.x ? pointZero.x : prePoint.x * gridSize,
        y: prePoint.y === point.y ? pointZero.y : prePoint.y * gridSize
      };
      controlPoints.unshift(pointZero);
    }
    currentId = prePoint.id;
    currentX = prePoint.x;
    currentY = prePoint.y;
    currentCameFrom = cameFrom[currentId];
  }
  controlPoints[0].x = currentX === scaleStartPoint.x ? startPoint.x : pointZero.x;
  controlPoints[0].y = currentY === scaleStartPoint.y ? startPoint.y : pointZero.y;
  controlPoints.unshift(startPoint);
  return controlPoints;
};
var pathFinder3 = function pathFinder4(startPoint, endPoint, startNode, endNode, routerCfg) {
  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];
  var cfg = deep_mix_default(defaultCfg, routerCfg);
  cfg.obstacles = cfg.obstacles || [];
  var penalties = cfg.penalties, gridSize = cfg.gridSize;
  var map6 = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);
  var scaleStartPoint = {
    x: pos2GridIx(startPoint.x, gridSize),
    y: pos2GridIx(startPoint.y, gridSize)
  };
  var scaleEndPoint = {
    x: pos2GridIx(endPoint.x, gridSize),
    y: pos2GridIx(endPoint.y, gridSize)
  };
  startPoint.id = "".concat(scaleStartPoint.x, "|||").concat(scaleStartPoint.y);
  endPoint.id = "".concat(scaleEndPoint.x, "|||").concat(scaleEndPoint.y);
  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);
  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);
  startPoints.forEach(function(point) {
    delete map6[point.id];
  });
  endPoints.forEach(function(point) {
    delete map6[point.id];
  });
  var openSet = {};
  var closedSet = {};
  var cameFrom = {};
  var gScore = {};
  var fScore = {};
  var sortedOpenSet = new SortedArray();
  for (var i2 = 0; i2 < startPoints.length; i2++) {
    var firstStep = startPoints[i2];
    openSet[firstStep.id] = firstStep;
    gScore[firstStep.id] = 0;
    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);
    sortedOpenSet.add({
      id: firstStep.id,
      value: fScore[firstStep.id]
    });
  }
  var remainLoops = cfg.maximumLoops;
  var current, direction3, neighbor, neighborCost, costFromStart, directionChange;
  var curCost = Infinity;
  var endPointMap = {};
  endPoints.forEach(function(point) {
    endPointMap["".concat(point.x, "|||").concat(point.y)] = true;
  });
  Object.keys(openSet).forEach(function(key) {
    var id = openSet[key].id;
    if (fScore[id] <= curCost) {
      curCost = fScore[id];
      current = openSet[id];
    }
  });
  while (Object.keys(openSet).length > 0 && remainLoops > 0) {
    var minId = sortedOpenSet.minId((remainLoops + 1) % 30 === 0);
    if (minId) {
      current = openSet[minId];
    } else {
      break;
    }
    if (endPointMap["".concat(current.x, "|||").concat(current.y)]) {
      return getControlPoints12(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);
    }
    delete openSet[current.id];
    sortedOpenSet.remove(current.id);
    closedSet[current.id] = true;
    for (var i2 = 0; i2 < cfg.directions.length; i2++) {
      direction3 = cfg.directions[i2];
      var neighborId = "".concat(Math.round(current.x) + direction3.stepX, "|||").concat(Math.round(current.y) + direction3.stepY);
      neighbor = {
        x: current.x + direction3.stepX,
        y: current.y + direction3.stepY,
        id: neighborId
      };
      if (closedSet[neighborId]) continue;
      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);
      if (directionChange > cfg.maxAllowedDirectionChange) continue;
      if (map6[neighborId]) continue;
      if (!openSet[neighborId]) {
        openSet[neighborId] = neighbor;
      }
      var directionPenalties = penalties[directionChange];
      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);
      costFromStart = gScore[current.id] + neighborCost;
      var neighborGScore = gScore[neighborId];
      if (neighborGScore && costFromStart >= neighborGScore) {
        continue;
      }
      cameFrom[neighborId] = current;
      gScore[neighborId] = costFromStart;
      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);
      sortedOpenSet.add({
        id: neighborId,
        value: fScore[neighborId]
      });
    }
    remainLoops -= 1;
  }
  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);
};

// node_modules/@antv/g6-element/es/edges/polyline.js
registerEdge("polyline", {
  options: {
    color: BaseGlobal.defaultEdge.color,
    size: BaseGlobal.defaultEdge.size,
    style: {
      radius: 0,
      offset: 15,
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultEdge.style.stroke,
      lineAppendWidth: BaseGlobal.defaultEdge.style.lineAppendWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.edgeLabel.style.fill,
        fontSize: BaseGlobal.edgeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    routeCfg: {
      obstacles: [],
      maxAllowedDirectionChange: Math.PI,
      maximumLoops: 500,
      gridSize: 10
      // 指定精度
    },
    stateStyles: __assign17({}, BaseGlobal.edgeStateStyles)
  },
  shapeType: "polyline",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape19(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    if (shapeStyle.radius === 0) delete shapeStyle.radius;
    var keyShape = group.addShape("path", {
      className: "edge-shape",
      name: "edge-shape",
      attrs: shapeStyle
    });
    group["shapeMap"]["edge-shape"] = keyShape;
    return keyShape;
  },
  getShapeStyle: function getShapeStyle15(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    cfg = this.getPathPoints(cfg);
    this.radius = style.radius;
    this.offset = style.offset;
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = style.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = mix({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = style.offset;
    var path = this.getPath(points, source, target, radius, routeCfg, !Boolean(controlPoints));
    if (is_array_default(path) && path.length <= 1 || is_string_default(path) && path.indexOf("L") === -1) {
      path = "M0 0, L0 0";
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = "M0 0, L0 0";
    }
    var attrs = mix({}, BaseGlobal.defaultEdge.style, style, {
      lineWidth: cfg.size,
      path
    });
    return attrs;
  },
  updateShapeStyle: function updateShapeStyle4(cfg, item) {
    var group = item.getContainer();
    if (!item.isVisible()) return;
    var strokeStyle = {
      stroke: cfg.color
    };
    var shape = group["shapeMap"]["edge-shape"] || group.find(function(element) {
      return element.get("className") === "edge-shape";
    }) || item.getKeyShape();
    var size3 = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var currentAttr = shape.attr();
    var previousStyle = mix({}, strokeStyle, currentAttr, cfg.style);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = previousStyle.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = mix({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = previousStyle.offset;
    var path = this.getPath(points, source, target, radius, routeCfg, !Boolean(controlPoints));
    if (is_array_default(path) && path.length <= 1 || is_string_default(path) && path.indexOf("L") === -1) {
      path = "M0 0, L0 0";
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = "M0 0, L0 0";
    }
    if (currentAttr.endArrow && previousStyle.endArrow === false) {
      cfg.style.endArrow = {
        path: ""
      };
    }
    if (currentAttr.startArrow && previousStyle.startArrow === false) {
      cfg.style.startArrow = {
        path: ""
      };
    }
    var style = mix(strokeStyle, shape.attr(), {
      lineWidth: size3,
      path
    }, cfg.style);
    if (shape) {
      shape.attr(style);
    }
  },
  getPath: function getPath11(points, source, target, radius, routeCfg, auto) {
    var offset = routeCfg.offset, obstacles = routeCfg.obstacles;
    var simple = routeCfg.simple;
    if (!offset || points.length > 2 || auto === false) {
      if (radius) {
        return getPathWithBorderRadiusByPolyline(points, radius);
      }
      var pathArray_1 = [];
      each_default(points, function(point, index2) {
        if (index2 === 0) {
          pathArray_1.push(["M", point.x, point.y]);
        } else {
          pathArray_1.push(["L", point.x, point.y]);
        }
      });
      return pathArray_1;
    }
    if (simple !== false && !(obstacles === null || obstacles === void 0 ? void 0 : obstacles.length)) simple = true;
    var polylinePoints = simple ? getPolylinePoints(points[points.length - 1], points[0], target, source, offset) : pathFinder3(points[0], points[points.length - 1], source, target, routeCfg);
    if (!polylinePoints || !polylinePoints.length) return "M0 0, L0 0";
    if (radius) {
      var res_1 = getPathWithBorderRadiusByPolyline(polylinePoints, radius);
      return res_1;
    }
    polylinePoints = removeRedundantPoint(polylinePoints);
    var res = util_default.pointsToPolygon(polylinePoints);
    return res;
  }
}, "single-edge");

// node_modules/@antv/g6-pc/es/behavior/index.js
init_esm();

// node_modules/@antv/g6-pc/es/behavior/drag-canvas.js
init_esm();
var cloneEvent4 = util_default2.cloneEvent;
var isNaN4 = util_default2.isNaN;
var abs = Math.abs;
var DRAG_OFFSET = 10;
var ALLOW_EVENTS2 = ["shift", "ctrl", "alt", "control"];
var drag_canvas_default = {
  getDefaultCfg: function getDefaultCfg2() {
    return {
      direction: "both",
      enableOptimize: false,
      // drag-canvas 可拖动的扩展范围，默认为 0，即最多可以拖动一屏的位置
      // 当设置的值大于 0 时，即拖动可以超过一屏
      // 当设置的值小于 0 时，相当于缩小了可拖动范围
      // 具体实例可参考：https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*IFfoS67_HssAAAAAAAAAAAAAARQnAQ
      scalableRange: 0,
      allowDragOnItem: false
    };
  },
  getEvents: function getEvents2() {
    return {
      "mousedown": "onMouseDown",
      "drag": "onDragMove",
      "dragend": "onMouseUp",
      "canvas:click": "onMouseUp",
      "keyup": "onKeyUp",
      "focus": "onKeyUp",
      "keydown": "onKeyDown",
      "touchstart": "onTouchStart",
      "touchmove": "onTouchMove",
      "touchend": "onMouseUp"
    };
  },
  updateViewport: function updateViewport(e8) {
    var origin = this.origin;
    var clientX = +e8.clientX;
    var clientY = +e8.clientY;
    if (isNaN4(clientX) || isNaN4(clientY)) {
      return;
    }
    var dx = clientX - origin.x;
    var dy = clientY - origin.y;
    if (this.get("direction") === "x") {
      dy = 0;
    } else if (this.get("direction") === "y") {
      dx = 0;
    }
    this.origin = {
      x: clientX,
      y: clientY
    };
    var width = this.graph.get("width");
    var height = this.graph.get("height");
    var graphCanvasBBox = this.graph.get("canvas").getCanvasBBox();
    var expandWidth = this.scalableRange;
    var expandHeight = this.scalableRange;
    if (expandWidth < 1 && expandWidth > -1) {
      expandWidth = width * expandWidth;
      expandHeight = height * expandHeight;
    }
    if (graphCanvasBBox.minX <= width + expandWidth && graphCanvasBBox.minX + dx > width + expandWidth || graphCanvasBBox.maxX + expandWidth >= 0 && graphCanvasBBox.maxX + expandWidth + dx < 0) {
      dx = 0;
    }
    if (graphCanvasBBox.minY <= height + expandHeight && graphCanvasBBox.minY + dy > height + expandHeight || graphCanvasBBox.maxY + expandHeight >= 0 && graphCanvasBBox.maxY + expandHeight + dy < 0) {
      dy = 0;
    }
    this.graph.translate(dx, dy);
  },
  onTouchStart: function onTouchStart(e8) {
    var self2 = this;
    var touches = e8.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (event1 && event2) {
      return;
    }
    e8.preventDefault();
    this.mousedown = true;
    self2.onDragStart(e8);
  },
  onMouseDown: function onMouseDown(e8) {
    this.mousedown = true;
  },
  onDragMove: function onDragMove(evt) {
    if (!this.mousedown) return;
    if (!this.dragstart) {
      this.dragstart = true;
      this.onDragStart(evt);
    } else {
      this.onDrag(evt);
    }
  },
  onDragStart: function onDragStart(e8) {
    var self2 = this;
    var event = e8.originalEvent;
    if (event && e8.name !== "touchstart" && event.button !== 0) {
      return;
    }
    if (e8.name !== "touchstart" && typeof window !== "undefined" && window.event && !window.event.buttons && !window.event.button) {
      return;
    }
    if (!this.shouldBegin(e8, this)) {
      return;
    }
    if (self2.keydown) return;
    if (!this.allowDrag(e8)) return;
    self2.origin = {
      x: e8.clientX,
      y: e8.clientY
    };
    self2.dragging = false;
    if (this.enableOptimize) {
      var graph = this.graph;
      var edges = graph.getEdges();
      for (var i2 = 0, len6 = edges.length; i2 < len6; i2++) {
        var shapes = edges[i2].get("group").get("children");
        if (!shapes) continue;
        shapes.forEach(function(shape) {
          shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
          shape.hide();
        });
      }
      var nodes = graph.getNodes();
      for (var j2 = 0, nodeLen = nodes.length; j2 < nodeLen; j2++) {
        var container = nodes[j2].getContainer();
        var children = container.get("children");
        for (var _i2 = 0, children_1 = children; _i2 < children_1.length; _i2++) {
          var child = children_1[_i2];
          var isKeyShape = child.get("isKeyShape");
          if (!isKeyShape) {
            child.set("ori-visibility", child.get("ori-visibility") || child.get("visible"));
            child.hide();
          }
        }
      }
    }
    if (typeof window !== "undefined") {
      var self_1 = this;
      this.handleDOMContextMenu = function(e9) {
        return self_1.onMouseUp(e9);
      };
      document.body.addEventListener("contextmenu", this.handleDOMContextMenu);
    }
  },
  onTouchMove: function onTouchMove(e8) {
    var self2 = this;
    var touches = e8.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (event1 && event2) {
      this.onMouseUp(e8);
      return;
    }
    e8.preventDefault();
    self2.onDrag(e8);
  },
  onDrag: function onDrag(e8) {
    if (!this.mousedown) return;
    var graph = this.graph;
    if (this.keydown) return;
    if (!this.allowDrag(e8)) return;
    e8 = cloneEvent4(e8);
    if (!this.origin) {
      return;
    }
    if (!this.dragging) {
      if (abs(this.origin.x - e8.clientX) + abs(this.origin.y - e8.clientY) < DRAG_OFFSET) {
        return;
      }
      if (this.shouldBegin(e8, this)) {
        e8.type = "dragstart";
        graph.emit("canvas:dragstart", e8);
        this.originPosition = {
          x: e8.clientX,
          y: e8.clientY
        };
        this.dragging = true;
      }
    } else {
      e8.type = "drag";
      graph.emit("canvas:drag", e8);
    }
    if (this.shouldUpdate(e8, this)) {
      this.updateViewport(e8);
    }
  },
  onMouseUp: function onMouseUp(e8) {
    var _a2, _b;
    this.mousedown = false;
    this.dragstart = false;
    var graph = this.graph;
    if (this.keydown) return;
    var currentZoom = graph.getZoom();
    var modeController = graph.get("modeController");
    var zoomCanvas = (_b = (_a2 = modeController === null || modeController === void 0 ? void 0 : modeController.modes[modeController.mode]) === null || _a2 === void 0 ? void 0 : _a2.filter(function(behavior) {
      return behavior.type === "zoom-canvas";
    })) === null || _b === void 0 ? void 0 : _b[0];
    var optimizeZoom = zoomCanvas ? zoomCanvas.optimizeZoom || 0.1 : 0;
    if (this.enableOptimize) {
      var edges = graph.getEdges();
      for (var i2 = 0, len6 = edges.length; i2 < len6; i2++) {
        var shapes = edges[i2].get("group").get("children");
        if (!shapes) continue;
        shapes.forEach(function(shape) {
          var oriVis2 = shape.get("ori-visibility");
          shape.set("ori-visibility", void 0);
          if (oriVis2) shape.show();
        });
      }
      if (currentZoom > optimizeZoom) {
        var nodes = graph.getNodes();
        for (var j2 = 0, nodeLen = nodes.length; j2 < nodeLen; j2++) {
          var container = nodes[j2].getContainer();
          var children = container.get("children");
          for (var _i2 = 0, children_2 = children; _i2 < children_2.length; _i2++) {
            var child = children_2[_i2];
            var isKeyShape = child.get("isKeyShape");
            if (!isKeyShape) {
              var oriVis = child.get("ori-visibility");
              child.set("ori-visibility", void 0);
              if (oriVis) child.show();
            }
          }
        }
      }
    }
    if (!this.dragging) {
      this.origin = null;
      return;
    }
    e8 = cloneEvent4(e8);
    if (this.shouldEnd(e8, this)) {
      this.updateViewport(e8);
    }
    e8.type = "dragend";
    e8.dx = e8.clientX - this.originPosition.x;
    e8.dy = e8.clientY - this.originPosition.y;
    graph.emit("canvas:dragend", e8);
    this.endDrag();
    if (typeof window !== "undefined") {
      document.body.removeEventListener("contextmenu", this.handleDOMContextMenu);
    }
  },
  endDrag: function endDrag() {
    this.origin = null;
    this.dragging = false;
    this.dragbegin = false;
    this.mousedown = false;
    this.dragstart = false;
  },
  onKeyDown: function onKeyDown(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (ALLOW_EVENTS2.indexOf(code.toLowerCase()) > -1) {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp() {
    this.keydown = false;
    this.origin = null;
    this.dragging = false;
    this.dragbegin = false;
  },
  allowDrag: function allowDrag(evt) {
    var _a2, _b;
    var target = evt.target;
    var targetIsCanvas = target && target.isCanvas && target.isCanvas();
    if (is_boolean_default(this.allowDragOnItem) && !this.allowDragOnItem && !targetIsCanvas) return false;
    if (is_object_default(this.allowDragOnItem)) {
      var _c = this.allowDragOnItem, node = _c.node, edge = _c.edge, combo = _c.combo;
      var itemType = (_b = (_a2 = evt.item) === null || _a2 === void 0 ? void 0 : _a2.getType) === null || _b === void 0 ? void 0 : _b.call(_a2);
      if (!node && itemType === "node") return false;
      if (!edge && itemType === "edge") return false;
      if (!combo && itemType === "combo") return false;
    }
    return true;
  }
};

// node_modules/@antv/g6-pc/es/behavior/drag-node.js
init_esm();
var drag_node_default = {
  getDefaultCfg: function getDefaultCfg3() {
    return {
      updateEdge: true,
      delegateStyle: {},
      // 是否开启delegate
      enableDelegate: false,
      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构
      onlyChangeComboSize: false,
      // 拖动过程中目标 combo 状态样式
      comboActiveState: "",
      selectedState: "selected",
      enableOptimize: false,
      enableDebounce: false,
      enableStack: true
    };
  },
  getEvents: function getEvents3() {
    return {
      "node:mousedown": "onMouseDown",
      drag: "onDragMove",
      dragend: "onDragEnd",
      "combo:dragenter": "onDragEnter",
      "combo:dragleave": "onDragLeave",
      "combo:drop": "onDropCombo",
      "node:drop": "onDropNode",
      "canvas:drop": "onDropCanvas",
      touchstart: "onTouchStart",
      touchmove: "onTouchMove",
      touchend: "onDragEnd",
      afterchangedata: "onDragEnd"
    };
  },
  validationCombo: function validationCombo(item) {
    if (!this.origin || !item || item.destroyed) {
      return false;
    }
    var type = item.getType();
    if (type !== "combo") {
      return false;
    }
    return true;
  },
  onTouchStart: function onTouchStart2(evt) {
    if (!evt.item) return;
    var self2 = this;
    try {
      var touches = evt.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      evt.preventDefault();
    } catch (e8) {
      console.warn("Touch original event not exist!");
    }
    this.mousedown = {
      item: evt.item,
      target: evt.target,
      origin: {
        x: evt.x,
        y: evt.y
      }
    };
    this.dragstart = true;
    self2.onDragStart(evt);
  },
  onTouchMove: function onTouchMove2(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        self2.onDragEnd(e8);
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.onDrag(e8);
  },
  /**
   * cache the manipulated item and target, since drag and dragend are global events but not node:*
   * @param evt event param
   */
  onMouseDown: function onMouseDown2(evt) {
    this.mousedown = {
      item: evt.item,
      target: evt.target,
      origin: {
        x: evt.x,
        y: evt.y
      }
    };
    if (typeof window !== "undefined" && !this.windowEventBinded) {
      this.windowEventBinded = true;
      document.body.addEventListener("contextmenu", this.onDragEnd.bind(this));
      document.body.addEventListener("mouseup", this.onDragEnd.bind(this));
    }
  },
  /**
   * trigger dragstart/drag by mousedown and drag events
   * @param evt event param
   */
  onDragMove: function onDragMove2(evt) {
    var _a2, _b;
    if (((_b = (_a2 = evt.item) === null || _a2 === void 0 ? void 0 : _a2.getType) === null || _b === void 0 ? void 0 : _b.call(_a2)) !== "node") {
      this.onDragEnd();
      return;
    }
    if (!this.mousedown) return;
    if (!this.dragstart) {
      this.dragstart = true;
      this.onDragStart(evt);
    } else {
      this.onDrag(__assign(__assign({}, evt), this.mousedown));
    }
  },
  /**
   * 开始拖动节点
   * @param evt
   */
  onDragStart: function onDragStart2(evt) {
    var _this = this;
    this.currentShouldEnd = true;
    if (!this.shouldBegin(__assign(__assign({}, evt), this.mousedown), this)) {
      return;
    }
    var _a2 = this.mousedown, item = _a2.item, target = _a2.target;
    if (!item || item.destroyed || item.hasLocked()) {
      return;
    }
    var group = item.getContainer();
    group.set("capture", false);
    if (!this.cachedCaptureItems) this.cachedCaptureItems = [];
    this.cachedCaptureItems.push(item);
    if (target) {
      var isAnchorPoint = target.get("isAnchorPoint");
      if (isAnchorPoint) {
        return;
      }
    }
    var graph = this.graph;
    this.targets = [];
    this.targetCombo = null;
    var nodes = graph.findAllByState("node", this.selectedState);
    var currentNodeId = item.get("id");
    var dragNodes = nodes.filter(function(node) {
      var nodeId = node.get("id");
      return currentNodeId === nodeId;
    });
    if (dragNodes.length === 0) {
      this.targets.push(item);
    } else if (nodes.length > 1) {
      nodes.forEach(function(node) {
        var locked = node.hasLocked();
        if (!locked) {
          _this.targets.push(node);
        }
      });
    } else {
      this.targets.push(item);
    }
    if (this.graph.get("enabledStack") && this.enableStack) {
      var beforeDragNodes_1 = [];
      this.targets.forEach(function(t4) {
        var _a3 = t4.getModel(), x4 = _a3.x, y4 = _a3.y, id = _a3.id;
        beforeDragNodes_1.push({
          x: x4,
          y: y4,
          id
        });
      });
      this.set("beforeDragNodes", beforeDragNodes_1);
    }
    this.hidenEdge = {};
    if (this.get("updateEdge") && this.enableOptimize && !this.enableDelegate) {
      this.targets.forEach(function(node) {
        var edges = node.getEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible()) return;
          _this.hidenEdge[edge.getID()] = true;
          edge.hide();
        });
      });
    }
    this.origin = this.mousedown.origin;
    this.point = {};
    this.originPoint = {};
  },
  /**
   * 持续拖动节点
   * @param evt
   */
  onDrag: function onDrag2(evt) {
    var _this = this;
    if (!this.mousedown || !this.origin) return;
    if (!this.shouldUpdate(evt, this)) return;
    if (this.get("enableDelegate")) {
      this.updateDelegate(evt);
    } else {
      if (this.enableDebounce) {
        this.debounceUpdate({
          targets: this.targets,
          graph: this.graph,
          point: this.point,
          origin: this.origin,
          evt,
          updateEdge: this.get("updateEdge"),
          onlyChangeComboSize: this.onlyChangeComboSize,
          updateParentCombos: this.updateParentCombos
        });
      } else {
        var parentComboMap_1 = {};
        this.targets.map(function(target) {
          _this.update(target, evt);
          var parentComboId = target.getModel().comboId;
          if (parentComboId) parentComboMap_1[parentComboId] = _this.graph.findById(parentComboId);
        });
        if (this.onlyChangeComboSize) {
          this.updateParentCombos();
        }
      }
    }
  },
  /**
   * 拖动结束，设置拖动元素capture为true，更新元素位置，如果是拖动涉及到 combo，则更新 combo 结构
   * @param evt
   */
  onDragEnd: function onDragEnd(evt) {
    var _this = this;
    var _a2;
    this.mousedown = false;
    this.dragstart = false;
    if (typeof window !== "undefined" && this.windowEventBinded) {
      this.windowEventBinded = false;
      document.body.removeEventListener("contextmenu", this.onDragEnd.bind(this));
      document.body.removeEventListener("mouseup", this.onDragEnd.bind(this));
    }
    if (!this.origin) {
      return;
    }
    (_a2 = this.cachedCaptureItems) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(item) {
      var group = item.getContainer();
      group.set("capture", true);
    });
    this.cachedCaptureItems = [];
    if (this.delegateRect) {
      this.delegateRect.remove();
      this.delegateRect = null;
    }
    if (this.get("updateEdge") && this.enableOptimize && !this.enableDelegate) {
      this.targets.forEach(function(node) {
        var edges = node.getEdges();
        edges.forEach(function(edge) {
          if (_this.hidenEdge[edge.getID()]) edge.show();
          edge.refresh();
        });
      });
    }
    this.hidenEdge = {};
    var graph = this.graph;
    if (graph.get("enabledStack") && this.enableStack) {
      var stackData_1 = {
        before: {
          nodes: [],
          edges: [],
          combos: []
        },
        after: {
          nodes: [],
          edges: [],
          combos: []
        }
      };
      this.get("beforeDragNodes").forEach(function(model) {
        stackData_1.before.nodes.push(model);
      });
      this.targets.forEach(function(target) {
        var _a3 = target.getModel(), x4 = _a3.x, y4 = _a3.y, id = _a3.id;
        stackData_1.after.nodes.push({
          x: x4,
          y: y4,
          id
        });
      });
      graph.pushStack("update", clone_default(stackData_1));
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: null
    });
    this.point = {};
    this.origin = null;
    this.originPoint = {};
    this.targets.length = 0;
    this.targetCombo = null;
  },
  /**
   * 拖动过程中将节点放置到 combo 上
   * @param evt
   */
  onDropCombo: function onDropCombo(evt) {
    var item = evt.item;
    this.currentShouldEnd = this.shouldEnd(evt, item, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd || !this.validationCombo(item)) return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, false);
    }
    this.targetCombo = item;
    if (this.onlyChangeComboSize) {
      graph.updateCombos();
    } else {
      var targetComboModel_1 = item.getModel();
      this.targets.map(function(node) {
        var nodeModel = node.getModel();
        if (nodeModel.comboId !== targetComboModel_1.id) {
          graph.updateComboTree(node, targetComboModel_1.id);
        }
      });
      graph.updateCombo(item);
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: this.targetCombo
    });
  },
  onDropCanvas: function onDropCanvas(evt) {
    var graph = this.graph;
    this.currentShouldEnd = this.shouldEnd(evt, void 0, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.targets || this.targets.length === 0 || !this.currentShouldEnd) return;
    if (this.onlyChangeComboSize) {
      this.updateParentCombos();
    } else {
      this.targets.map(function(node) {
        var model = node.getModel();
        if (model.comboId) {
          graph.updateComboTree(node);
        }
      });
    }
  },
  /**
   * 拖动放置到某个 combo 中的子 node 上
   * @param evt
   */
  onDropNode: function onDropNode(evt) {
    if (!this.targets || this.targets.length === 0) return;
    var self2 = this;
    var item = evt.item;
    var graph = self2.graph;
    var comboId = item.getModel().comboId;
    var newParentCombo = comboId ? graph.findById(comboId) : void 0;
    this.currentShouldEnd = this.shouldEnd(evt, newParentCombo, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd) return;
    if (this.onlyChangeComboSize) {
      this.updateParentCombos();
    } else if (comboId) {
      var combo = graph.findById(comboId);
      if (self2.comboActiveState) {
        graph.setItemState(combo, self2.comboActiveState, false);
      }
      this.targets.map(function(node) {
        var nodeModel = node.getModel();
        if (comboId !== nodeModel.comboId) {
          graph.updateComboTree(node, comboId);
        }
      });
      graph.updateCombo(combo);
    } else {
      this.targets.map(function(node) {
        var model = node.getModel();
        if (model.comboId) {
          graph.updateComboTree(node);
        }
      });
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: item
    });
  },
  /**
   * 将节点拖入到 Combo 中
   * @param evt
   */
  onDragEnter: function onDragEnter(evt) {
    var item = evt.item;
    if (!this.validationCombo(item)) return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, true);
    }
  },
  /**
   * 将节点从 Combo 中拖出
   * @param evt
   */
  onDragLeave: function onDragLeave(evt) {
    var item = evt.item;
    if (!this.validationCombo(item)) return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, false);
    }
  },
  updatePositions: function updatePositions(evt, restore) {
    var _this = this;
    if (!this.targets || this.targets.length === 0) return;
    if (this.get("enableDelegate")) {
      if (this.enableDebounce) this.debounceUpdate({
        targets: this.targets,
        graph: this.graph,
        point: this.point,
        origin: this.origin,
        evt,
        updateEdge: this.get("updateEdge"),
        onlyChangeComboSize: this.onlyChangeComboSize,
        updateParentCombos: this.updateParentCombos
      });
      else if (!restore) this.targets.map(function(node) {
        return _this.update(node, evt);
      });
    } else this.targets.map(function(node) {
      return _this.update(node, evt, restore);
    });
  },
  /**
   * 更新节点
   * @param item 拖动的节点实例
   * @param evt
   */
  update: function update14(item, evt, restore) {
    var origin = this.origin;
    var model = item.get("model");
    var nodeId = item.get("id");
    if (!this.point[nodeId]) {
      this.point[nodeId] = {
        x: model.x || 0,
        y: model.y || 0
      };
    }
    var x4 = evt.x - origin.x + this.point[nodeId].x;
    var y4 = evt.y - origin.y + this.point[nodeId].y;
    if (restore) {
      x4 += origin.x - evt.x;
      y4 += origin.y - evt.y;
    }
    var pos = {
      x: x4,
      y: y4
    };
    if (this.get("updateEdge")) {
      this.graph.updateItem(item, pos, false);
    } else {
      item.updatePosition(pos);
    }
  },
  /**
   * 限流更新节点
   * @param item 拖动的节点实例
   * @param evt
   */
  debounceUpdate: debounce_default(function(event) {
    var targets = event.targets, graph = event.graph, point = event.point, origin = event.origin, evt = event.evt, updateEdge = event.updateEdge, onlyChangeComboSize = event.onlyChangeComboSize, updateParentCombos3 = event.updateParentCombos;
    targets.map(function(item) {
      var model = item.get("model");
      var nodeId = item.get("id");
      if (!point[nodeId]) {
        point[nodeId] = {
          x: model.x || 0,
          y: model.y || 0
        };
      }
      var x4 = evt.x - origin.x + point[nodeId].x;
      var y4 = evt.y - origin.y + point[nodeId].y;
      var pos = {
        x: x4,
        y: y4
      };
      if (updateEdge) {
        graph.updateItem(item, pos, false);
      } else {
        item.updatePosition(pos);
      }
    });
    if (onlyChangeComboSize) {
      updateParentCombos3(graph, targets);
    }
  }, 50, true),
  /**
   * 更新拖动元素时的delegate
   * @param {Event} evt 事件句柄
   * @param {number} x 拖动单个元素时候的x坐标
   * @param {number} y 拖动单个元素时候的y坐标
   */
  updateDelegate: function updateDelegate(evt) {
    var graph = this.graph;
    if (!this.delegateRect) {
      var parent_1 = graph.get("group");
      var attrs = deep_mix_default({}, global_default2.delegateStyle, this.delegateStyle);
      var _a2 = this.calculationGroupPosition(evt), cx = _a2.x, cy = _a2.y, width = _a2.width, height = _a2.height, minX = _a2.minX, minY = _a2.minY;
      this.originPoint = {
        x: cx,
        y: cy,
        width,
        height,
        minX,
        minY
      };
      this.delegateRect = parent_1.addShape("rect", {
        attrs: __assign({
          width,
          height,
          x: cx,
          y: cy
        }, attrs),
        name: "rect-delegate-shape"
      });
      this.delegate = this.delegateRect;
      this.delegateRect.set("capture", false);
    } else {
      var clientX = evt.x - this.origin.x + this.originPoint.minX;
      var clientY = evt.y - this.origin.y + this.originPoint.minY;
      this.delegateRect.attr({
        x: clientX,
        y: clientY
      });
    }
  },
  /**
   * 计算delegate位置，包括左上角左边及宽度和高度
   * @memberof ItemGroup
   * @return {object} 计算出来的delegate坐标信息及宽高
   */
  calculationGroupPosition: function calculationGroupPosition(evt) {
    var nodes = this.targets;
    if (nodes.length === 0) {
      nodes.push(evt.item);
    }
    var minx = Infinity;
    var maxx = -Infinity;
    var miny = Infinity;
    var maxy = -Infinity;
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var element = nodes[i2];
      var bbox = element.getBBox();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (minX < minx) {
        minx = minX;
      }
      if (minY < miny) {
        miny = minY;
      }
      if (maxX > maxx) {
        maxx = maxX;
      }
      if (maxY > maxy) {
        maxy = maxY;
      }
    }
    var x4 = Math.floor(minx);
    var y4 = Math.floor(miny);
    var width = Math.ceil(maxx) - Math.floor(minx);
    var height = Math.ceil(maxy) - Math.floor(miny);
    return {
      x: x4,
      y: y4,
      width,
      height,
      minX: minx,
      minY: miny
    };
  },
  /**
   * updates the parent combos' size and position
   * @param paramGraph param for debounce function, where 'this' is not available
   * @param paramTargets param for debounce function, where 'this' is not available
   */
  updateParentCombos: function updateParentCombos(paramGraph, paramTargets) {
    var graph = paramGraph || this.graph;
    var targets = paramTargets || this.targets;
    var comboParentMap = {};
    targets === null || targets === void 0 ? void 0 : targets.forEach(function(target) {
      var comboId = target.getModel().comboId;
      if (comboId) comboParentMap[comboId] = graph.findById(comboId);
    });
    Object.values(comboParentMap).forEach(function(combo) {
      if (combo) graph.updateCombo(combo);
    });
  }
};

// node_modules/@antv/g6-pc/es/behavior/activate-relations.js
init_esm();
var clickNodeId = null;
var activate_relations_default = {
  getDefaultCfg: function getDefaultCfg4() {
    return {
      // 可选 mouseenter || click
      // 选择 click 会监听 touch，mouseenter 不会监听
      trigger: "mouseenter",
      activeState: "active",
      inactiveState: "inactive",
      resetSelected: false,
      shouldClearStatusOnSecond: false,
      shouldUpdate: function shouldUpdate3() {
        return true;
      }
    };
  },
  getEvents: function getEvents4() {
    if (this.get("trigger") === "mouseenter") {
      return {
        "node:mouseenter": "setAllItemStates",
        "combo:mouseenter": "setAllItemStates",
        "node:mouseleave": "clearActiveState",
        "combo:mouseleave": "clearActiveState"
      };
    }
    return {
      "node:click": "setAllItemStates",
      "combo:click": "setAllItemStates",
      "canvas:click": "clearActiveState",
      "node:touchstart": "setOnTouchStart",
      "combo:touchstart": "setOnTouchStart",
      "canvas:touchstart": "clearOnTouchStart"
    };
  },
  setOnTouchStart: function setOnTouchStart(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.setAllItemStates(e8);
  },
  clearOnTouchStart: function clearOnTouchStart(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.clearActiveState(e8);
  },
  setAllItemStates: function setAllItemStates(e8) {
    clearTimeout(this.timer);
    this.throttleSetAllItemStates(e8, this);
  },
  clearActiveState: function clearActiveState(e8) {
    var _this = this;
    var shouldClearStatusOnSecond = this.shouldClearStatusOnSecond;
    if (shouldClearStatusOnSecond) {
      clickNodeId = null;
    }
    this.timer = setTimeout(function() {
      _this.throttleClearActiveState(e8, _this);
    }, 50);
  },
  throttleSetAllItemStates: throttle_default(function(e8, self2) {
    var item = e8.item;
    var graph = self2.graph;
    if (!graph || graph.destroyed) return;
    self2.item = item;
    if (!self2.shouldUpdate(e8.item, {
      event: e8,
      action: "activate"
    }, self2)) {
      return;
    }
    var shouldClearStatusOnSecond = self2.shouldClearStatusOnSecond;
    var currentNodeId = item.getModel().id;
    if (clickNodeId === currentNodeId && shouldClearStatusOnSecond) {
      self2.throttleClearActiveState(e8, self2);
      clickNodeId = null;
      return;
    }
    var activeState = self2.activeState;
    var inactiveState = self2.inactiveState;
    var nodes = graph.getNodes();
    var combos = graph.getCombos();
    var edges = graph.getEdges();
    var vEdges = graph.get("vedges");
    var nodeLength = nodes.length;
    var comboLength = combos.length;
    var edgeLength = edges.length;
    var vEdgeLength = vEdges.length;
    var inactiveItems = self2.inactiveItems || {};
    var activeItems = self2.activeItems || {};
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var node = nodes[i2];
      var nodeId = node.getID();
      var hasSelected = node.hasState("selected");
      if (self2.resetSelected) {
        if (hasSelected) {
          graph.setItemState(node, "selected", false);
        }
      }
      if (activeItems[nodeId]) {
        graph.setItemState(node, activeState, false);
        delete activeItems[nodeId];
      }
      if (inactiveState && !inactiveItems[nodeId]) {
        graph.setItemState(node, inactiveState, true);
        inactiveItems[nodeId] = node;
      }
    }
    for (var i2 = 0; i2 < comboLength; i2++) {
      var combo = combos[i2];
      var comboId = combo.getID();
      var hasSelected = combo.hasState("selected");
      if (self2.resetSelected) {
        if (hasSelected) {
          graph.setItemState(combo, "selected", false);
        }
      }
      if (activeItems[comboId]) {
        graph.setItemState(combo, activeState, false);
        delete activeItems[comboId];
      }
      if (inactiveState && !inactiveItems[comboId]) {
        graph.setItemState(combo, inactiveState, true);
        inactiveItems[comboId] = combo;
      }
    }
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edge = edges[i2];
      var edgeId = edge.getID();
      if (activeItems[edgeId]) {
        graph.setItemState(edge, activeState, false);
        delete activeItems[edgeId];
      }
      if (inactiveState && !inactiveItems[edgeId]) {
        graph.setItemState(edge, inactiveState, true);
        inactiveItems[edgeId] = edge;
      }
    }
    for (var i2 = 0; i2 < vEdgeLength; i2++) {
      var vEdge = vEdges[i2];
      var vEdgeId = vEdge.getID();
      if (activeItems[vEdgeId]) {
        graph.setItemState(vEdge, activeState, false);
        delete activeItems[vEdgeId];
      }
      if (inactiveState && !inactiveItems[vEdgeId]) {
        graph.setItemState(vEdge, inactiveState, true);
        inactiveItems[vEdgeId] = vEdge;
      }
    }
    if (item && !item.destroyed) {
      if (inactiveState) {
        graph.setItemState(item, inactiveState, false);
        delete inactiveItems[item.getID()];
      }
      if (!activeItems[item.getID()]) {
        graph.setItemState(item, activeState, true);
        activeItems[item.getID()] = item;
      }
      var rEdges = item.getEdges();
      var rEdgeLegnth = rEdges.length;
      for (var i2 = 0; i2 < rEdgeLegnth; i2++) {
        var edge = rEdges[i2];
        var edgeId = edge.getID();
        var otherEnd = void 0;
        if (edge.getSource() === item) {
          otherEnd = edge.getTarget();
        } else {
          otherEnd = edge.getSource();
        }
        var otherEndId = otherEnd.getID();
        if (inactiveState && inactiveItems[otherEndId]) {
          graph.setItemState(otherEnd, inactiveState, false);
          delete inactiveItems[otherEndId];
        }
        if (!activeItems[otherEndId]) {
          graph.setItemState(otherEnd, activeState, true);
          activeItems[otherEndId] = otherEnd;
        }
        if (inactiveItems[edgeId]) {
          graph.setItemState(edge, inactiveState, false);
          delete inactiveItems[edgeId];
        }
        if (!activeItems[edgeId]) {
          graph.setItemState(edge, activeState, true);
          activeItems[edgeId] = edge;
        }
        edge.toFront();
      }
    }
    self2.activeItems = activeItems;
    self2.inactiveItems = inactiveItems;
    if (shouldClearStatusOnSecond) {
      clickNodeId = item.getModel().id;
    }
    graph.emit("afteractivaterelations", {
      item: e8.item,
      action: "activate"
    });
  }, 50, {
    trailing: true,
    leading: true
  }),
  throttleClearActiveState: throttle_default(function(e8, self2) {
    var graph = self2.get("graph");
    if (!graph || graph.destroyed) return;
    if (!self2.shouldUpdate(e8.item, {
      event: e8,
      action: "deactivate"
    }, self2)) return;
    var activeState = self2.activeState;
    var inactiveState = self2.inactiveState;
    var activeItems = self2.activeItems || {};
    var inactiveItems = self2.inactiveItems || {};
    Object.values(activeItems).filter(function(item) {
      return !item.destroyed;
    }).forEach(function(item) {
      graph.clearItemStates(item, activeState);
    });
    Object.values(inactiveItems).filter(function(item) {
      return !item.destroyed;
    }).forEach(function(item) {
      graph.clearItemStates(item, inactiveState);
    });
    self2.activeItems = {};
    self2.inactiveItems = {};
    graph.emit("afteractivaterelations", {
      item: e8.item || self2.get("item"),
      action: "deactivate"
    });
  }, 50, {
    trailing: true,
    leading: true
  })
};

// node_modules/@antv/g6-pc/es/behavior/brush-select.js
var min5 = Math.min;
var max7 = Math.max;
var abs2 = Math.abs;
var DEFAULT_TRIGGER = "shift";
var ALLOW_EVENTS3 = ["drag", "shift", "ctrl", "alt", "control"];
var brush_select_default = {
  getDefaultCfg: function getDefaultCfg5() {
    return {
      brushStyle: {
        fill: "#EEF6FF",
        fillOpacity: 0.4,
        stroke: "#DDEEFE",
        lineWidth: 1
      },
      onSelect: function onSelect() {
      },
      onDeselect: function onDeselect() {
      },
      selectedState: "selected",
      trigger: DEFAULT_TRIGGER,
      includeEdges: true,
      includeCombos: false,
      selectOnCombo: false,
      selectedEdges: [],
      selectedNodes: [],
      selectedCombos: []
    };
  },
  getEvents: function getEvents5() {
    if (!(ALLOW_EVENTS3.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER;
      console.warn("Behavior brush-select 的 trigger 参数不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'");
    }
    if (this.trigger === "drag") {
      return {
        dragstart: "onMouseDown",
        drag: "onMouseMove",
        dragend: "onMouseUp",
        "canvas:click": "clearStates"
      };
    }
    return {
      dragstart: "onMouseDown",
      drag: "onMouseMove",
      dragend: "onMouseUp",
      "canvas:click": "clearStates",
      keyup: "onKeyUp",
      keydown: "onKeyDown"
    };
  },
  onMouseDown: function onMouseDown3(e8) {
    var item = e8.item;
    var brush = this.brush;
    var selectOnCombo = this.selectOnCombo;
    var isCombo = (item === null || item === void 0 ? void 0 : item.getType()) === "combo";
    if (isCombo && !selectOnCombo) {
      return;
    }
    if (!isCombo && item) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    if (this.selectedNodes && this.selectedNodes.length !== 0) {
      this.clearStates();
    }
    if (!brush) {
      brush = this.createBrush();
    }
    this.originPoint = {
      x: e8.canvasX,
      y: e8.canvasY
    };
    brush.attr({
      width: 0,
      height: 0
    });
    brush.show();
    this.dragging = true;
  },
  onMouseMove: function onMouseMove(e8) {
    if (!this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.updateBrush(e8);
  },
  onMouseUp: function onMouseUp2(e8) {
    var graph = this.graph;
    if (!this.brush && !this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.brush.remove(true);
    this.brush = null;
    this.getSelectedNodes(e8);
    this.dragging = false;
  },
  clearStates: function clearStates() {
    var _a2 = this, graph = _a2.graph, selectedState = _a2.selectedState;
    var nodes = graph.findAllByState("node", selectedState);
    var edges = graph.findAllByState("edge", selectedState);
    var combos = graph.findAllByState("combo", selectedState);
    nodes.forEach(function(node) {
      return graph.setItemState(node, selectedState, false);
    });
    edges.forEach(function(edge) {
      return graph.setItemState(edge, selectedState, false);
    });
    combos.forEach(function(combo) {
      return graph.setItemState(combo, selectedState, false);
    });
    this.selectedNodes = [];
    this.selectedEdges = [];
    this.selectedCombos = [];
    if (this.onDeselect) {
      this.onDeselect(this.selectedNodes, this.selectedEdges, this.selectedCombos);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: [],
        combos: []
      },
      select: false
    });
  },
  isBBoxCenterInRect: function isBBoxCenterInRect(item, left, right, top, bottom) {
    var bbox = item.getBBox();
    return bbox.centerX >= left && bbox.centerX <= right && bbox.centerY >= top && bbox.centerY <= bottom;
  },
  getSelectedNodes: function getSelectedNodes(e8) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, originPoint = _a2.originPoint, shouldUpdate3 = _a2.shouldUpdate, isBBoxCenterInRect2 = _a2.isBBoxCenterInRect;
    var state = this.selectedState;
    var p1 = {
      x: e8.x,
      y: e8.y
    };
    var p2 = graph.getPointByCanvas(originPoint.x, originPoint.y);
    var left = min5(p1.x, p2.x);
    var right = max7(p1.x, p2.x);
    var top = min5(p1.y, p2.y);
    var bottom = max7(p1.y, p2.y);
    var selectedNodes = [];
    var selectedIds = [];
    graph.getNodes().forEach(function(node) {
      if (node.isVisible() && // 隐藏节点不能被选中
      isBBoxCenterInRect2(node, left, right, top, bottom) && shouldUpdate3(node, "select", _this)) {
        selectedNodes.push(node);
        var model = node.getModel();
        selectedIds.push(model.id);
        graph.setItemState(node, state, true);
      }
    });
    var selectedEdges = [];
    if (this.includeEdges) {
      selectedNodes.forEach(function(node) {
        var edges = node.getOutEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible()) return;
          var model = edge.getModel();
          var source = model.source, target = model.target;
          if (selectedIds.includes(source) && selectedIds.includes(target) && shouldUpdate3(edge, "select", _this)) {
            selectedEdges.push(edge);
            graph.setItemState(edge, _this.selectedState, true);
          }
        });
      });
    }
    var selectedCombos = [];
    if (this.includeCombos) {
      graph.getCombos().forEach(function(combo) {
        if (combo.isVisible() && // 隐藏节点不能被选中
        isBBoxCenterInRect2(combo, left, right, top, bottom) && shouldUpdate3(combo, "select", _this)) {
          selectedCombos.push(combo);
          var model = combo.getModel();
          selectedIds.push(model.id);
          graph.setItemState(combo, state, true);
        }
      });
    }
    this.selectedEdges = selectedEdges;
    this.selectedNodes = selectedNodes;
    this.selectedCombos = selectedCombos;
    if (this.onSelect) {
      this.onSelect(selectedNodes, selectedEdges, selectedCombos);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: selectedNodes,
        edges: selectedEdges,
        combos: selectedCombos
      },
      select: true
    });
  },
  createBrush: function createBrush() {
    var self2 = this;
    var brush = self2.graph.get("canvas").addShape("rect", {
      attrs: self2.brushStyle,
      capture: false,
      name: "brush-shape"
    });
    this.brush = brush;
    this.delegate = brush;
    return brush;
  },
  updateBrush: function updateBrush(e8) {
    var originPoint = this.originPoint;
    this.brush.attr({
      width: abs2(e8.canvasX - originPoint.x),
      height: abs2(e8.canvasY - originPoint.y),
      x: min5(e8.canvasX, originPoint.x),
      y: min5(e8.canvasY, originPoint.y)
    });
  },
  onKeyDown: function onKeyDown2(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    var triggerLowerCase = this.trigger.toLowerCase();
    var codeLowerCase = code.toLowerCase();
    if (codeLowerCase === triggerLowerCase || codeLowerCase === "control" && triggerLowerCase === "ctrl" || codeLowerCase === "ctrl" && triggerLowerCase === "control") {
      this.keydown = true;
    } else {
      this.keydown = false;
    }
  },
  onKeyUp: function onKeyUp2() {
    if (this.brush) {
      this.brush.remove(true);
      this.brush = null;
      this.dragging = false;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/click-select.js
init_esm();
var DEFAULT_TRIGGER2 = "shift";
var ALLOW_EVENTS4 = ["shift", "ctrl", "alt", "control"];
var click_select_default = {
  getDefaultCfg: function getDefaultCfg6() {
    return {
      multiple: true,
      trigger: DEFAULT_TRIGGER2,
      selectedState: "selected",
      selectNode: true,
      selectEdge: false,
      selectCombo: true
    };
  },
  getEvents: function getEvents6() {
    var self2 = this;
    if (!(ALLOW_EVENTS4.indexOf(self2.trigger.toLowerCase()) > -1)) {
      self2.trigger = DEFAULT_TRIGGER2;
      console.warn("Behavior click-select 的 trigger 参数不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'");
    }
    if (!self2.multiple) {
      return {
        "node:click": "onClick",
        "combo:click": "onClick",
        "edge:click": "onClick",
        "canvas:click": "onCanvasClick"
      };
    }
    return {
      "node:click": "onClick",
      "combo:click": "onClick",
      "edge:click": "onClick",
      "canvas:click": "onCanvasClick",
      keyup: "onKeyUp",
      keydown: "onKeyDown"
    };
  },
  onClick: function onClick(evt) {
    var self2 = this;
    var item = evt.item;
    if (!item || item.destroyed) {
      return;
    }
    var type = item.getType();
    var graph = self2.graph, keydown = self2.keydown, multiple = self2.multiple, shouldUpdate3 = self2.shouldUpdate, shouldBegin2 = self2.shouldBegin;
    if (!shouldBegin2(evt, self2)) {
      return;
    }
    if (!keydown || !multiple) {
      var selected = graph.findAllByState("node", self2.selectedState).concat(graph.findAllByState("edge", self2.selectedState)).concat(graph.findAllByState("combo", self2.selectedState));
      each_default(selected, function(selectedItem) {
        if (selectedItem !== item) {
          graph.setItemState(selectedItem, self2.selectedState, false);
        }
      });
    }
    var itemSelectable = function() {
      switch (type) {
        case "node":
          return self2.selectNode;
        case "edge":
          return self2.selectEdge;
        case "combo":
          return self2.selectCombo;
        default:
          return false;
      }
    }();
    if (!itemSelectable) {
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedEdges = graph.findAllByState("edge", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        selectedItems: {
          nodes: selectedNodes,
          edges: selectedEdges,
          combos: selectedCombos
        },
        select: false
      });
      return;
    }
    if (item.hasState(self2.selectedState)) {
      if (shouldUpdate3(evt, self2)) {
        graph.setItemState(item, self2.selectedState, false);
      }
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedEdges = graph.findAllByState("edge", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        target: item,
        selectedItems: {
          nodes: selectedNodes,
          edges: selectedEdges,
          combos: selectedCombos
        },
        select: false
      });
    } else {
      if (shouldUpdate3(evt, self2)) {
        graph.setItemState(item, self2.selectedState, true);
      }
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedEdges = graph.findAllByState("edge", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        target: item,
        selectedItems: {
          nodes: selectedNodes,
          edges: selectedEdges,
          combos: selectedCombos
        },
        select: true
      });
    }
  },
  onCanvasClick: function onCanvasClick(evt) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, shouldBegin2 = _a2.shouldBegin;
    if (!shouldBegin2(evt, this)) {
      return;
    }
    var selected = graph.findAllByState("node", this.selectedState);
    each_default(selected, function(node) {
      graph.setItemState(node, _this.selectedState, false);
    });
    var selectedEdges = graph.findAllByState("edge", this.selectedState);
    each_default(selectedEdges, function(edge) {
      graph.setItemState(edge, _this.selectedState, false);
    });
    var selectedCombos = graph.findAllByState("combo", this.selectedState);
    each_default(selectedCombos, function(combo) {
      graph.setItemState(combo, _this.selectedState, false);
    });
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: [],
        combos: []
      },
      select: false
    });
  },
  onKeyDown: function onKeyDown3(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === this.trigger.toLowerCase() || code.toLowerCase() === "control") {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp3() {
    var self2 = this;
    self2.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/zoom-canvas.js
init_esm();
var transform15 = ext_exports.transform;
var DELTA4 = 0.05;
var zoom_canvas_default = {
  getDefaultCfg: function getDefaultCfg7() {
    this.isFireFox = getBrowserName() === "firefox";
    return {
      sensitivity: 2,
      minZoom: void 0,
      maxZoom: void 0,
      enableOptimize: false,
      optimizeZoom: 0.1,
      fixSelectedItems: {
        fixAll: false,
        fixLineWidth: false,
        fixLabel: false,
        fixState: "selected"
      },
      animate: false,
      animateCfg: {
        duration: 500
      }
    };
  },
  getEvents: function getEvents7() {
    var fixSelectedItems = this.fixSelectedItems;
    if (!fixSelectedItems.fixState) fixSelectedItems.fixState = "selected";
    if (fixSelectedItems.fixAll) {
      fixSelectedItems.fixLineWidth = true;
      fixSelectedItems.fixLabel = true;
    }
    return {
      wheel: "onWheel",
      touchstart: "onTouchStart",
      touchmove: "onTouchMove",
      touchend: "onTouchEnd"
    };
  },
  onTouchStart: function onTouchStart3(evt) {
    var touches = evt.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    evt.preventDefault();
    if (!event2) {
      return;
    }
    if (this.shouldBegin && !this.shouldBegin(evt, this)) {
      return;
    }
    this.startPoint = {
      pageX: event1.pageX,
      pageY: event1.pageY
    };
    this.moveable = true;
    if (event2) {
      this.endPoint = {
        pageX: event2.pageX,
        pageY: event2.pageY
      };
    }
    this.originScale = this.graph.getZoom() || this.currentScale || 1;
  },
  onTouchMove: function onTouchMove3(evt) {
    if (!this.moveable) {
      return;
    }
    evt.preventDefault();
    var touches = evt.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (!event2) {
      return;
    }
    if (!this.endPoint) {
      this.endPoint = {
        pageX: event2.pageX,
        pageY: event2.pageY
      };
    }
    var getDistance3 = function getDistance4(start, end2) {
      return Math.hypot(end2.x - start.x, end2.y - start.y);
    };
    var scale12 = getDistance3({
      x: event1.pageX,
      y: event1.pageY
    }, {
      x: event2.pageX,
      y: event2.pageY
    }) / getDistance3({
      x: this.startPoint.pageX,
      y: this.startPoint.pageY
    }, {
      x: this.endPoint.pageX,
      y: this.endPoint.pageY
    });
    var zoom = this.originScale * scale12;
    this.currentScale = zoom;
    var minZoom = this.get("minZoom") || this.graph.get("minZoom");
    var maxZoom = this.get("maxZoom") || this.graph.get("maxZoom");
    if (zoom > maxZoom || zoom < minZoom) {
      return;
    }
    var animate = this.get("animate");
    var animateCfg = this.get("animateCfg");
    var canvas = this.graph.get("canvas");
    var point = canvas.getPointByClient(evt.clientX, evt.clientY);
    this.graph.zoomTo(zoom, {
      x: point.x,
      y: point.y
    }, animate, animateCfg);
    this.graph.emit("wheelzoom", evt);
  },
  onTouchEnd: function onTouchEnd() {
    this.moveable = false;
    this.endPoint = null;
  },
  onWheel: function onWheel(e8) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, fixSelectedItems = _a2.fixSelectedItems;
    if (this.shouldBegin && !this.shouldBegin(e8, this)) {
      return;
    }
    if (!this.shouldUpdate(e8, this)) {
      return;
    }
    e8.preventDefault();
    var canvas = graph.get("canvas");
    var point = canvas.getPointByClient(e8.clientX, e8.clientY);
    var sensitivity = this.get("sensitivity");
    var graphZoom = graph.getZoom();
    var ratio = graphZoom;
    var zoom = graphZoom;
    if (this.isFireFox) {
      if (e8.deltaY > 0 || e8.wheelDelta < 0) {
        ratio = 1 - DELTA4 * sensitivity;
      } else {
        ratio = 1 / (1 - DELTA4 * sensitivity);
      }
    } else {
      if (e8.wheelDelta < 0) {
        ratio = 1 - DELTA4 * sensitivity;
      } else {
        ratio = 1 / (1 - DELTA4 * sensitivity);
      }
    }
    zoom = graphZoom * ratio;
    var minZoom = this.get("minZoom") || graph.get("minZoom");
    var maxZoom = this.get("maxZoom") || graph.get("maxZoom");
    if (zoom > maxZoom) {
      zoom = maxZoom;
    } else if (zoom < minZoom) {
      zoom = minZoom;
    }
    var enableOptimize = this.get("enableOptimize");
    if (enableOptimize) {
      var optimizeZoom_1 = this.get("optimizeZoom");
      var optimized = this.get("optimized");
      var nodes_1 = graph.getNodes();
      var edges_1 = graph.getEdges();
      var nodesLength_1 = nodes_1.length;
      var edgesLength_1 = edges_1.length;
      if (!optimized) {
        for (var n2 = 0; n2 < nodesLength_1; n2++) {
          var node = nodes_1[n2];
          if (!node.destroyed) {
            var children = node.get("group").get("children");
            var childrenLength = children.length;
            for (var c3 = 0; c3 < childrenLength; c3++) {
              var shape = children[c3];
              if (!shape.destoryed && !shape.get("isKeyShape")) {
                shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
                shape.hide();
              }
            }
          }
        }
        for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {
          var edge = edges_1[edgeIndex];
          var children = edge.get("group").get("children");
          var childrenLength = children.length;
          for (var c3 = 0; c3 < childrenLength; c3++) {
            var shape = children[c3];
            shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
            shape.hide();
          }
        }
        this.set("optimized", true);
      }
      clearTimeout(this.get("timeout"));
      var timeout2 = setTimeout(function() {
        var currentZoom = graph.getZoom();
        var curOptimized = _this.get("optimized");
        if (curOptimized) {
          _this.set("optimized", false);
          for (var n3 = 0; n3 < nodesLength_1; n3++) {
            var node2 = nodes_1[n3];
            var children2 = node2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = node2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              keyShape.set("ori-visibility", void 0);
              if (oriVis) keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                var oriVis = shape2.get("ori-visibility");
                shape2.set("ori-visibility", void 0);
                if (!shape2.get("visible") && oriVis) {
                  if (oriVis) shape2.show();
                }
              }
            }
          }
          for (var edgeIndex2 = 0; edgeIndex2 < edgesLength_1; edgeIndex2++) {
            var edge2 = edges_1[edgeIndex2];
            var children2 = edge2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = edge2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              keyShape.set("ori-visibility", void 0);
              if (oriVis) keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                if (!shape2.get("visible")) {
                  var oriVis = shape2.get("ori-visibility");
                  shape2.set("ori-visibility", void 0);
                  if (oriVis) shape2.show();
                }
              }
            }
          }
        }
      }, 100);
      this.set("timeout", timeout2);
    }
    if (graphZoom <= 1) {
      var fixNodes = void 0, fixEdges = void 0;
      if (fixSelectedItems.fixAll || fixSelectedItems.fixLineWidth || fixSelectedItems.fixLabel) {
        fixNodes = graph.findAllByState("node", fixSelectedItems.fixState);
        fixEdges = graph.findAllByState("edge", fixSelectedItems.fixState);
        var scale12 = graphZoom / zoom;
        var fixNodesLength = fixNodes.length;
        for (var fn2 = 0; fn2 < fixNodesLength; fn2++) {
          var node = fixNodes[fn2];
          var group = node.getContainer();
          var nodeModel = node.getModel();
          var originStyle = node.getOriginStyle();
          var itemStateStyle = node.getStateStyle(fixSelectedItems.fixState);
          var shapeStateStyle = node.get("shapeFactory").getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, node)[fixSelectedItems.fixState];
          if (fixSelectedItems.fixAll) {
            if (zoom <= 1) {
              var groupMatrix = clone_default(group.getMatrix());
              if (!groupMatrix) groupMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
              var _b = node.getModel(), x4 = _b.x, y4 = _b.y;
              groupMatrix = transform15(groupMatrix, [["t", -x4, -y4], ["s", scale12, scale12], ["t", x4, y4]]);
              group.setMatrix(groupMatrix);
            }
          } else {
            var children = group.get("children");
            var childrenLength = children.length;
            for (var c3 = 0; c3 < childrenLength; c3++) {
              var shape = children[c3];
              var fontSize = void 0, lineWidth = void 0;
              if (fixSelectedItems.fixLabel) {
                var shapeType = shape.get("type");
                if (shapeType === "text") {
                  fontSize = shape.attr("fontSize") || 12;
                  var itemStyle = itemStateStyle[shape.get("name")];
                  var shapeStyle = shapeStateStyle[shape.get("name")];
                  var itemFontSize = itemStyle ? itemStyle.fontSize : 12;
                  var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;
                  var oriFontSize = itemFontSize || shapeFontSize || 12;
                  if (zoom <= 1) shape.attr("fontSize", oriFontSize / zoom);
                  if (lineWidth) break;
                }
              }
              if (fixSelectedItems.fixLineWidth) {
                if (shape.get("isKeyShape")) {
                  lineWidth = shape.attr("lineWidth") || 0;
                  var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || originStyle.lineWidth || 0;
                  if (zoom <= 1) shape.attr("lineWidth", oriLineWidth / zoom);
                  if (fontSize) break;
                }
              }
            }
          }
        }
        var fixEdgesLength = fixEdges.length;
        for (var fe2 = 0; fe2 < fixEdgesLength; fe2++) {
          var edge = fixEdges[fe2];
          var group = edge.getContainer();
          var children = group.get("children");
          var nodeModel = edge.getModel();
          var itemStateStyle = edge.getStateStyle(fixSelectedItems.fixState);
          var shapeStateStyle = edge.get("shapeFactory").getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, edge)[fixSelectedItems.fixState];
          var childrenLength = children.length;
          for (var c3 = 0; c3 < childrenLength; c3++) {
            var shape = children[c3];
            var fontSize = void 0, lineWidth = void 0;
            if (fixSelectedItems.fixLabel || fixSelectedItems.fixAll) {
              var shapeType = shape.get("type");
              if (shapeType === "text") {
                fontSize = shape.attr("fontSize") || 12;
                var itemStyle = itemStateStyle[shape.get("name")];
                var shapeStyle = shapeStateStyle[shape.get("name")];
                var itemFontSize = itemStyle ? itemStyle.fontSize : 12;
                var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;
                var oriFontSize = itemFontSize || shapeFontSize || 12;
                if (zoom <= 1) shape.attr("fontSize", oriFontSize / zoom);
                if (lineWidth) break;
              }
            }
            if (fixSelectedItems.fixLineWidth || fixSelectedItems.fixAll) {
              if (shape.get("isKeyShape")) {
                lineWidth = shape.attr("lineWidth") || 0;
                var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || 1;
                if (zoom <= 1) shape.attr("lineWidth", oriLineWidth / zoom);
                if (fontSize) break;
              }
            }
          }
        }
      }
    }
    var animate = this.get("animate");
    var animateCfg = this.get("animateCfg");
    graph.zoomTo(zoom, {
      x: point.x,
      y: point.y
    }, animate, animateCfg);
    graph.emit("wheelzoom", e8);
  }
};

// node_modules/@antv/g6-pc/es/behavior/tooltip-base.js
var tooltip_base_default = {
  onMouseEnter: function onMouseEnter(e8) {
    var item = e8.item;
    this.currentTarget = item;
    this.showTooltip(e8);
    this.graph.emit("tooltipchange", {
      item: e8.item,
      action: "show"
    });
  },
  onMouseMove: function onMouseMove2(e8) {
    if (!this.shouldUpdate(e8, this)) {
      this.hideTooltip();
      return;
    }
    if (!this.currentTarget || e8.item !== this.currentTarget) {
      return;
    }
    this.updatePosition(e8);
  },
  onMouseLeave: function onMouseLeave(e8) {
    if (!this.shouldEnd(e8, this)) {
      return;
    }
    this.hideTooltip();
    this.graph.emit("tooltipchange", {
      item: this.currentTarget,
      action: "hide"
    });
    this.currentTarget = null;
  },
  showTooltip: function showTooltip(e8) {
    var container = this.container;
    if (!e8.item || e8.item.destroyed) {
      return;
    }
    if (!container) {
      container = this.createTooltip(this.graph.get("canvas"));
      this.container = container;
    }
    var text = this.formatText(e8.item.get("model"), e8);
    container.innerHTML = text;
    modifyCSS(this.container, {
      visibility: "visible"
    });
    this.updatePosition(e8);
  },
  hideTooltip: function hideTooltip() {
    modifyCSS(this.container, {
      visibility: "hidden"
    });
  },
  updatePosition: function updatePosition(e8) {
    var shouldBegin2 = this.get("shouldBegin");
    var _a2 = this, width = _a2.width, height = _a2.height, container = _a2.container, graph = _a2.graph;
    if (!shouldBegin2(e8, this)) {
      modifyCSS(container, {
        visibility: "hidden"
      });
      return;
    }
    var point = graph.getPointByClient(e8.clientX, e8.clientY);
    var _b = graph.getCanvasByPoint(point.x, point.y), x4 = _b.x, y4 = _b.y;
    var bbox = container.getBoundingClientRect();
    if (x4 > width / 2) {
      x4 -= bbox.width;
    } else {
      x4 += this.offset;
    }
    if (y4 > height / 2) {
      y4 -= bbox.height;
    } else {
      y4 += this.offset;
    }
    var left = "".concat(x4, "px");
    var top = "".concat(y4, "px");
    modifyCSS(this.container, {
      left,
      top,
      visibility: "visible"
    });
  },
  createTooltip: function createTooltip(canvas) {
    var el = canvas.get("el");
    el.style.position = "relative";
    var container = createDom2('<div class="g6-tooltip g6-'.concat(this.item, '-tooltip"></div>'));
    el.parentNode.appendChild(container);
    modifyCSS(container, {
      position: "absolute",
      visibility: "visible"
    });
    this.width = canvas.get("width");
    this.height = canvas.get("height");
    this.container = container;
    this.graph.get("tooltips").push(container);
    return container;
  }
};

// node_modules/@antv/g6-pc/es/behavior/tooltip.js
var tooltip_default2 = __assign({
  getDefaultCfg: function getDefaultCfg8() {
    return {
      item: "node",
      offset: 12,
      formatText: function formatText(model) {
        return model.label;
      }
    };
  },
  getEvents: function getEvents8() {
    return {
      "node:mouseenter": "onMouseEnter",
      "node:mouseleave": "onMouseLeave",
      "node:mousemove": "onMouseMove",
      afterremoveitem: "onMouseLeave"
    };
  }
}, tooltip_base_default);

// node_modules/@antv/g6-pc/es/behavior/edge-tooltip.js
var edge_tooltip_default = __assign({
  getDefaultCfg: function getDefaultCfg9() {
    return {
      item: "edge",
      offset: 12,
      formatText: function formatText(model) {
        return "source: ".concat(model.source, " target: ").concat(model.target);
      }
    };
  },
  getEvents: function getEvents9() {
    return {
      "edge:mouseenter": "onMouseEnter",
      "edge:mouseleave": "onMouseLeave",
      "edge:mousemove": "onMouseMove",
      afterremoveitem: "onMouseLeave"
    };
  }
}, tooltip_base_default);

// node_modules/@antv/g6-pc/es/behavior/collapse-expand.js
var DEFAULT_TRIGGER3 = "click";
var ALLOW_EVENTS5 = ["click", "dblclick"];
var collapse_expand_default = {
  getDefaultCfg: function getDefaultCfg10() {
    return {
      /**
       * 发生收缩/扩展变化时的回调
       */
      trigger: DEFAULT_TRIGGER3,
      onChange: function onChange() {
      }
    };
  },
  getEvents: function getEvents10() {
    var _a2;
    var trigger;
    if (ALLOW_EVENTS5.includes(this.trigger)) {
      trigger = this.trigger;
    } else {
      trigger = DEFAULT_TRIGGER3;
      console.warn("Behavior collapse-expand 的 trigger 参数不合法，请输入 'click' 或 'dblclick'");
    }
    return _a2 = {}, _a2["node:".concat(trigger)] = "onNodeClick", // 支持移动端事件
    _a2.touchstart = "onNodeClick", _a2;
  },
  onNodeClick: function onNodeClick(e8) {
    var _this = this;
    if (this.trigger === "click") {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = 0;
        return;
      }
      this.timer = setTimeout(function() {
        _this.toggle(e8);
        clearTimeout(_this.timer);
        _this.timer = 0;
      }, 200);
    } else {
      this.toggle(e8);
    }
  },
  toggle: function toggle(e8) {
    var item = e8.item;
    if (!item) return;
    var sourceData = this.graph.findDataById(item.get("id"));
    if (!sourceData) {
      return;
    }
    var children = sourceData.children;
    if (!children || children.length === 0) {
      return;
    }
    var collapsed = !sourceData.collapsed;
    if (!this.shouldBegin(e8, collapsed, this)) {
      return;
    }
    sourceData.collapsed = collapsed;
    item.getModel().collapsed = collapsed;
    this.graph.emit("itemcollapsed", {
      item: e8.item,
      collapsed
    });
    if (!this.shouldUpdate(e8, collapsed, this)) {
      return;
    }
    this.onChange(item, collapsed, this);
    this.graph.layout();
  }
};

// node_modules/@antv/g6-pc/es/behavior/drag-combo.js
init_esm();
var calculationItemsBBox3 = util_default2.calculationItemsBBox;
var traverseCombo = function traverseCombo2(data, fn2) {
  if (fn2(data) === false) {
    return;
  }
  if (data) {
    var combos = data.get("combos");
    if (combos.length === 0) {
      return false;
    }
    each_default(combos, function(child) {
      traverseCombo2(child, fn2);
    });
  }
};
var drag_combo_default = {
  getDefaultCfg: function getDefaultCfg11() {
    return {
      enableDelegate: false,
      delegateStyle: {},
      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构
      onlyChangeComboSize: false,
      // 拖动过程中目标 combo 状态样式
      activeState: "",
      selectedState: "selected",
      enableStack: true
    };
  },
  getEvents: function getEvents11() {
    return {
      "combo:mousedown": "onMouseDown",
      "combo:dragstart": "onDragStart",
      "combo:drag": "onDrag",
      "combo:dragend": "onDragEnd",
      "combo:drop": "onDrop",
      "node:drop": "onNodeDrop",
      "combo:dragenter": "onDragEnter",
      "combo:dragleave": "onDragLeave"
    };
  },
  validationCombo: function validationCombo2(evt) {
    var item = evt.item;
    if (!item || item.destroyed) {
      return false;
    }
    if (!this.shouldUpdate(evt, this)) {
      return false;
    }
    var type = item.getType();
    if (type !== "combo") {
      return false;
    }
    return true;
  },
  onMouseDown: function onMouseDown4(evt) {
    this.origin = {
      x: evt.x,
      y: evt.y
    };
  },
  onDragStart: function onDragStart3(evt) {
    var _this = this;
    var graph = this.graph;
    var item = evt.item;
    this.currentShouldEnd = true;
    if (!this.validationCombo(evt)) return;
    this.targets = [];
    var combos = graph.findAllByState("combo", this.selectedState);
    var currentCombo = item.get("id");
    var dragCombos = combos.filter(function(combo) {
      var comboId = combo.get("id");
      return currentCombo === comboId;
    });
    if (dragCombos.length === 0) {
      this.targets.push(item);
    } else {
      this.targets = combos;
    }
    var beforeDragItems = [];
    this.targets.forEach(function(t4) {
      var _a2 = t4.getModel(), x4 = _a2.x, y4 = _a2.y, id = _a2.id;
      beforeDragItems.push({
        x: x4,
        y: y4,
        id
      });
    });
    this.set("beforeDragItems", beforeDragItems);
    if (this.activeState) {
      this.targets.map(function(combo) {
        var model = combo.getModel();
        if (model.parentId) {
          var parentCombo = graph.findById(model.parentId);
          if (parentCombo) {
            graph.setItemState(parentCombo, _this.activeState, true);
          }
        }
      });
    }
    this.point = {};
    this.originPoint = {};
    this.currentItemChildCombos = [];
    traverseCombo(item, function(param) {
      if (param.destroyed) {
        return false;
      }
      var model = param.getModel();
      _this.currentItemChildCombos.push(model.id);
      return true;
    });
  },
  onDrag: function onDrag3(evt) {
    var _this = this;
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt)) return;
    if (this.enableDelegate) {
      this.updateDelegate(evt);
    } else {
      if (this.activeState) {
        var graph_1 = this.graph;
        var item = evt.item;
        var model_1 = item.getModel();
        var combos = graph_1.getCombos();
        var sourceBBox = item.getBBox();
        var centerX_1 = sourceBBox.centerX, centerY_1 = sourceBBox.centerY, width_1 = sourceBBox.width;
        var calcCombos = combos.filter(function(combo) {
          var cmodel = combo.getModel();
          if (!model_1.parentId) {
            return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);
          }
          return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);
        });
        calcCombos.map(function(combo) {
          var _a2 = combo.getBBox(), cx = _a2.centerX, cy = _a2.centerY, w2 = _a2.width;
          var disX = centerX_1 - cx;
          var disY = centerY_1 - cy;
          var distance11 = 2 * Math.sqrt(disX * disX + disY * disY);
          if (width_1 + w2 - distance11 > 0.8 * width_1) {
            graph_1.setItemState(combo, _this.activeState, true);
          } else {
            graph_1.setItemState(combo, _this.activeState, false);
          }
        });
      }
      each_default(this.targets, function(item2) {
        _this.updateCombo(item2, evt);
      });
      if (this.onlyChangeComboSize) {
        this.updateParentCombos();
      }
    }
  },
  updatePositions: function updatePositions2(evt, restore) {
    var _this = this;
    if (this.enableDelegate || restore) {
      each_default(this.targets, function(item) {
        _this.updateCombo(item, evt, restore);
      });
    }
  },
  onDrop: function onDrop(evt) {
    var _this = this;
    var item = evt.item;
    this.currentShouldEnd = this.shouldEnd(evt, item, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd || !item || !this.targets || item.destroyed) return;
    var graph = this.graph;
    var targetModel = item.getModel();
    this.targets.map(function(combo) {
      var model = combo.getModel();
      if (model.parentId !== targetModel.id) {
        if (_this.activeState) {
          graph.setItemState(item, _this.activeState, false);
        }
        if (!_this.onlyChangeComboSize) {
          graph.updateComboTree(combo, targetModel.id, false);
        } else {
          graph.updateCombo(combo);
        }
      } else {
        graph.updateCombo(item);
      }
    });
    this.end(item, evt);
    this.endComparison = true;
  },
  onNodeDrop: function onNodeDrop(evt) {
    var _this = this;
    if (!this.targets || this.targets.length === 0) return;
    var graph = this.graph;
    var item = evt.item;
    var comboId = item.getModel().comboId;
    var newParentCombo = comboId ? graph.findById(comboId) : void 0;
    this.currentShouldEnd = this.shouldEnd(evt, newParentCombo, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd) return;
    var droppedCombo;
    if (comboId) {
      if (this.activeState) {
        var combo = graph.findById(comboId);
        graph.setItemState(combo, this.activeState, false);
      }
      this.targets.map(function(combo2) {
        if (!_this.onlyChangeComboSize) {
          if (comboId !== combo2.getID()) {
            droppedCombo = graph.findById(comboId);
            if (comboId !== combo2.getModel().parentId) graph.updateComboTree(combo2, comboId, false);
          }
        } else {
          graph.updateCombo(combo2);
        }
      });
    } else {
      this.targets.map(function(combo2) {
        if (!_this.onlyChangeComboSize) {
          var model = combo2.getModel();
          if (model.comboId) {
            graph.updateComboTree(combo2, void 0, false);
          }
        } else {
          graph.updateCombo(combo2);
        }
      });
    }
    this.endComparison = true;
    this.end(droppedCombo, evt);
  },
  onDragEnter: function onDragEnter2(evt) {
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt)) return;
    var item = evt.item;
    var graph = this.graph;
    if (this.activeState) {
      graph.setItemState(item, this.activeState, true);
    }
  },
  onDragLeave: function onDragLeave2(evt) {
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt)) return;
    var item = evt.item;
    var graph = this.graph;
    if (this.activeState) {
      graph.setItemState(item, this.activeState, false);
    }
  },
  onDragEnd: function onDragEnd2(evt) {
    if (!this.targets || this.targets.length === 0) return;
    var item = evt.item;
    if (this.currentShouldEnd) {
      this.updatePositions(evt);
    }
    var parentCombo = this.getParentCombo(item.getModel().parentId);
    var graph = this.graph;
    if (parentCombo && this.activeState) {
      graph.setItemState(parentCombo, this.activeState, false);
    }
    this.end(void 0, evt);
  },
  end: function end(comboDropedOn, evt) {
    var _this = this;
    if (!this.origin) return;
    var graph = this.graph;
    if (this.delegateShape) {
      var delegateGroup = graph.get("delegateGroup");
      delegateGroup.clear();
      this.delegateShape = null;
    }
    if (comboDropedOn && this.activeState) {
      graph.setItemState(comboDropedOn, this.activeState, false);
    }
    if (!comboDropedOn) {
      var stack_1 = graph.get("enabledStack") && this.enableStack;
      var stackData_1 = {
        before: {
          nodes: [],
          edges: [],
          combos: [].concat(this.get("beforeDragItems"))
        },
        after: {
          nodes: [],
          edges: [],
          combos: []
        }
      };
      this.targets.map(function(combo) {
        if (!_this.onlyChangeComboSize) {
          graph.updateComboTree(combo, void 0, stack_1);
        } else {
          graph.updateCombo(combo);
          var _a2 = combo.getModel(), x4 = _a2.x, y4 = _a2.y, id = _a2.id;
          stackData_1.after.combos.push({
            x: x4,
            y: y4,
            id
          });
          graph.pushStack("update", stackData_1);
        }
      });
    }
    this.point = [];
    this.origin = null;
    this.originPoint = null;
    this.targets.length = 0;
  },
  /**
   * 遍历 comboTree，分别更新 node 和 combo
   * @param data
   * @param fn
   */
  traverse: function traverse3(data, fn2, edgesToBeUpdate) {
    var _this = this;
    if (edgesToBeUpdate === void 0) {
      edgesToBeUpdate = {};
    }
    if (fn2(data, edgesToBeUpdate) === false) {
      return;
    }
    if (data) {
      var combos = data.get("combos");
      each_default(combos, function(child) {
        _this.traverse(child, fn2, edgesToBeUpdate);
      });
      var nodes = data.get("nodes");
      each_default(nodes, function(child) {
        _this.traverse(child, fn2, edgesToBeUpdate);
      });
    }
  },
  updateCombo: function updateCombo(item, evt, restore) {
    this.updateSingleItem(item, evt, restore);
    var edgesToBeUpdate = {};
    this.traverse(item, function(paramItem, paramEdgesMap) {
      if (paramItem.destroyed) {
        return false;
      }
      paramItem.getEdges().forEach(function(edge) {
        return paramEdgesMap[edge.getID()] = edge;
      });
      return true;
    }, edgesToBeUpdate);
    Object.values(edgesToBeUpdate).forEach(function(edge) {
      return edge.refresh();
    });
  },
  /**
   *
   * @param item 当前正在拖动的元素
   * @param evt
   */
  updateSingleItem: function updateSingleItem(item, evt, restore) {
    var origin = this.origin;
    var graph = this.graph;
    var model = item.getModel();
    var itemId = item.get("id");
    if (!this.point[itemId]) {
      this.point[itemId] = {
        x: model.x,
        y: model.y
      };
    }
    var x4 = evt.x - origin.x + this.point[itemId].x;
    var y4 = evt.y - origin.y + this.point[itemId].y;
    if (restore) {
      x4 += origin.x - evt.x;
      y4 += origin.y - evt.y;
    }
    graph.updateItem(item, {
      x: x4,
      y: y4
    }, false);
  },
  /**
   * 根据 ID 获取父 Combo
   * @param parentId 父 Combo ID
   */
  getParentCombo: function getParentCombo(parentId) {
    var graph = this.graph;
    if (!parentId) {
      return void 0;
    }
    var parentCombo = graph.findById(parentId);
    if (!parentCombo) {
      return void 0;
    }
    return parentCombo;
  },
  updateDelegate: function updateDelegate2(evt) {
    var graph = this.graph;
    if (!this.delegateShape) {
      var delegateGroup = graph.get("delegateGroup");
      var bbox = null;
      if (this.targets.length > 1) {
        bbox = calculationItemsBBox3(this.targets);
      } else {
        bbox = this.targets[0].getBBox();
      }
      var x4 = bbox.x, y4 = bbox.y, width = bbox.width, height = bbox.height, minX = bbox.minX, minY = bbox.minY;
      this.originPoint = {
        x: x4,
        y: y4,
        width,
        height,
        minX,
        minY
      };
      var attrs = __assign(__assign({}, global_default2.delegateStyle), this.delegateStyle);
      this.delegateShape = delegateGroup.addShape("rect", {
        attrs: __assign({
          width: bbox.width,
          height: bbox.height,
          x: bbox.x,
          y: bbox.y
        }, attrs),
        name: "combo-delegate-shape"
      });
      this.delegateShape.set("capture", false);
      this.delegate = this.delegateShape;
    } else {
      var clientX = evt.x - this.origin.x + this.originPoint.minX;
      var clientY = evt.y - this.origin.y + this.originPoint.minY;
      this.delegateShape.attr({
        x: clientX,
        y: clientY
      });
    }
  },
  /**
   * updates the parent combos' size and position
   */
  updateParentCombos: function updateParentCombos2() {
    var _a2 = this, graph = _a2.graph, targets = _a2.targets;
    var comboParentMap = {};
    targets === null || targets === void 0 ? void 0 : targets.forEach(function(target) {
      var comboId = target.getModel().parentId;
      if (comboId) comboParentMap[comboId] = graph.findById(comboId);
    });
    Object.values(comboParentMap).forEach(function(combo) {
      if (combo) graph.updateCombo(combo);
    });
  }
};

// node_modules/@antv/g6-pc/es/behavior/collapse-expand-combo.js
var DEFAULT_TRIGGER4 = "dblclick";
var ALLOW_EVENTS6 = ["click", "dblclick"];
var collapse_expand_combo_default = {
  getDefaultCfg: function getDefaultCfg12() {
    return {
      trigger: DEFAULT_TRIGGER4,
      relayout: true
    };
  },
  getEvents: function getEvents12() {
    var _a2;
    var trigger;
    if (ALLOW_EVENTS6.includes(this.trigger)) {
      trigger = this.trigger;
    } else {
      trigger = DEFAULT_TRIGGER4;
      console.warn("Behavior collapse-expand-group 的 trigger 参数不合法，请输入 'click' 或 'dblclick'");
    }
    return _a2 = {}, _a2["combo:".concat(trigger)] = "onComboClick", _a2;
  },
  onComboClick: function onComboClick(evt) {
    var item = evt.item;
    var _a2 = this, graph = _a2.graph, relayout = _a2.relayout;
    if (!item || item.destroyed || item.getType() !== "combo") return;
    var model = item.getModel();
    var comboId = model.id;
    if (!comboId) {
      return;
    }
    graph.collapseExpandCombo(comboId);
    if (relayout && graph.get("layout")) graph.layout();
    else graph.refreshPositions();
  }
};

// node_modules/@antv/g6-pc/es/behavior/lasso-select.js
var isPolygonsIntersect5 = util_default2.isPolygonsIntersect;
var pathToPoints3 = util_default2.pathToPoints;
var DEFAULT_TRIGGER5 = "shift";
var ALLOW_EVENTS7 = ["drag", "shift", "ctrl", "alt", "control"];
var isItemIntersecPolygon = function isItemIntersecPolygon2(item, polyPoints) {
  var shapePoints;
  var shape = item.getKeyShape();
  if (item.get("type") === "path") {
    shapePoints = pathToPoints3(shape.attr("path"));
  } else {
    var shapeBBox = shape.getCanvasBBox();
    shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];
  }
  return isPolygonsIntersect5(polyPoints, shapePoints);
};
var lasso_select_default = {
  getDefaultCfg: function getDefaultCfg13() {
    return {
      delegateStyle: {
        fill: "#EEF6FF",
        fillOpacity: 0.4,
        stroke: "#DDEEFE",
        lineWidth: 1
      },
      onSelect: function onSelect() {
      },
      onDeselect: function onDeselect() {
      },
      shouldDeselect: void 0,
      selectedState: "selected",
      trigger: DEFAULT_TRIGGER5,
      includeEdges: true,
      selectedEdges: [],
      selectedNodes: []
      // multiple: false,
    };
  },
  getEvents: function getEvents13() {
    if (!(ALLOW_EVENTS7.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER5;
      console.warn("Behavior lasso-select 的 trigger 参数不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'");
    }
    if (this.trigger === "drag") {
      return {
        dragstart: "onDragStart",
        drag: "onDragMove",
        dragend: "onDragEnd",
        "canvas:click": "clearStates"
      };
    }
    return {
      dragstart: "onDragStart",
      drag: "onDragMove",
      dragend: "onDragEnd",
      keyup: "onKeyUp",
      keydown: "onKeyDown",
      "canvas:click": "clearStates"
    };
  },
  onDragStart: function onDragStart4(e8) {
    var lasso = this.lasso;
    var item = e8.item;
    if (item) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    if (this.selectedNodes && this.selectedNodes.length !== 0) {
      this.clearStates("dragstart");
    }
    if (!lasso) {
      lasso = this.createLasso();
    }
    this.dragging = true;
    this.originPoint = {
      x: e8.x,
      y: e8.y
    };
    this.points.push(this.originPoint);
    lasso.show();
  },
  onDragMove: function onDragMove3(e8) {
    if (!this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.points.push({
      x: e8.x,
      y: e8.y
    });
    this.updateLasso(e8);
  },
  onDragEnd: function onDragEnd3(e8) {
    if (!this.lasso && !this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.points.push(this.originPoint);
    this.getSelectedItems();
    this.lasso.remove(true);
    this.lasso = null;
    this.points = [];
    this.dragging = false;
  },
  getLassoPath: function getLassoPath() {
    var points = this.points;
    var path = [];
    if (points.length) {
      points.forEach(function(point, index2) {
        if (index2 === 0) {
          path.push(["M", point.x, point.y]);
        } else {
          path.push(["L", point.x, point.y]);
        }
      });
      path.push(["L", points[0].x, points[0].y]);
    }
    return path;
  },
  clearStates: function clearStates2(action) {
    if (action === void 0) {
      action = "canvas:click";
    }
    var _a2 = this, graph = _a2.graph, selectedState = _a2.selectedState, shouldDeselect = _a2.shouldDeselect;
    var nodes = graph.findAllByState("node", selectedState);
    var edges = graph.findAllByState("edge", selectedState);
    if (!shouldDeselect || shouldDeselect({
      action,
      nodes,
      edges
    })) {
      nodes.forEach(function(node) {
        return graph.setItemState(node, selectedState, false);
      });
      edges.forEach(function(edge) {
        return graph.setItemState(edge, selectedState, false);
      });
    }
    if (this.onDeselect) {
      this.onDeselect(this.selectedNodes, this.selectedEdges);
    }
    this.selectedNodes = [];
    this.selectedEdges = [];
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: []
      },
      select: false
    });
  },
  getSelectedItems: function getSelectedItems() {
    var _this = this;
    var _a2 = this, graph = _a2.graph, shouldUpdate3 = _a2.shouldUpdate;
    var lassoContour = this.points.map(function(point) {
      return [graph.getCanvasByPoint(point.x, point.y).x, graph.getCanvasByPoint(point.x, point.y).y];
    });
    var state = this.selectedState;
    var selectedNodes = [];
    var selectedIds = [];
    graph.getNodes().forEach(function(node) {
      if (!node.isVisible()) return;
      if (isItemIntersecPolygon(node, lassoContour)) {
        if (shouldUpdate3(node, "select", _this)) {
          selectedNodes.push(node);
          var model = node.getModel();
          selectedIds.push(model.id);
          graph.setItemState(node, state, true);
        }
      }
    });
    var selectedEdges = [];
    if (this.includeEdges) {
      selectedNodes.forEach(function(node) {
        var edges = node.getOutEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible()) return;
          var model = edge.getModel();
          var source = model.source, target = model.target;
          if (selectedIds.includes(source) && selectedIds.includes(target) && shouldUpdate3(edge, "select", _this)) {
            selectedEdges.push(edge);
            graph.setItemState(edge, _this.selectedState, true);
          }
        });
      });
    }
    this.selectedEdges = selectedEdges;
    this.selectedNodes = selectedNodes;
    if (this.onSelect) {
      this.onSelect(selectedNodes, selectedEdges);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: selectedNodes,
        edges: selectedEdges
      },
      select: true
    });
  },
  createLasso: function createLasso() {
    var self2 = this;
    var lasso = self2.graph.get("delegateGroup").addShape("path", {
      attrs: __assign({
        path: []
      }, self2.delegateStyle),
      capture: false,
      name: "lasso-shape"
    });
    this.lasso = lasso;
    this.delegate = lasso;
    this.points = [];
    return lasso;
  },
  updateLasso: function updateLasso(e8) {
    var self2 = this;
    this.lasso.attr({
      path: self2.getLassoPath()
    });
  },
  onKeyDown: function onKeyDown4(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === this.trigger.toLowerCase()) {
      this.keydown = true;
    } else {
      this.keydown = false;
    }
  },
  onKeyUp: function onKeyUp4() {
    if (this.lasso) {
      this.lasso.remove(true);
      this.lasso = null;
      this.points = [];
      this.dragging = false;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/create-edge.js
init_esm();
var DEFAULT_TRIGGER6 = "click";
var ALLOW_EVENTS8 = ["click", "drag"];
var DEFAULT_KEY = void 0;
var ALLOW_KEYS = ["shift", "ctrl", "control", "alt", "meta", void 0];
var create_edge_default = {
  getDefaultCfg: function getDefaultCfg14() {
    return {
      trigger: DEFAULT_TRIGGER6,
      key: DEFAULT_KEY,
      edgeConfig: {},
      getEdgeConfig: void 0
    };
  },
  getEvents: function getEvents14() {
    var self2 = this;
    if (!(ALLOW_EVENTS8.indexOf(self2.trigger.toLowerCase()) > -1)) {
      self2.trigger = DEFAULT_TRIGGER6;
      console.warn("Behavior create-edge 的 trigger 参数不合法，请输入 'click'，'drag'");
    }
    if (self2.key && ALLOW_KEYS.indexOf(self2.key.toLowerCase()) === -1) {
      self2.trigger = DEFAULT_KEY;
      console.warn("Behavior create-edge 的 key 参数不合法，请输入 'shift'，'ctrl'，'alt'，'control'，或 undefined");
    }
    var events;
    if (self2.trigger === "drag") {
      events = {
        "node:dragstart": "onClick",
        "combo:dragstart": "onClick",
        drag: "updateEndPoint",
        "node:drop": "onClick",
        "combo:drop": "onClick",
        dragend: "onDragEnd"
      };
    } else if (self2.trigger === "click") {
      events = {
        "node:click": "onClick",
        mousemove: "updateEndPoint",
        "edge:click": "cancelCreating",
        "canvas:click": "cancelCreating",
        "combo:click": "onClick"
      };
    }
    if (self2.key) {
      events.keydown = "onKeyDown";
      events.keyup = "onKeyUp";
    }
    return events;
  },
  onDragEnd: function onDragEnd4(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown) return;
    var item = ev.item;
    if (!item || item.getID() === self2.source || item.getType() !== "node") self2.cancelCreating({
      item: self2.edge,
      x: ev.x,
      y: ev.y
    });
  },
  // 如果边的起点没有指定，则根据起点创建新边；如果起点已经指定而终点未指定，则指定终点
  onClick: function onClick2(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown) return;
    var node = ev.item;
    var graph = self2.graph;
    var model = node.getModel();
    var getEdgeConfig = self2.getEdgeConfig;
    if (self2.addingEdge && self2.edge) {
      if (!self2.shouldEnd(ev, self2)) return;
      var edgeConfig = void 0;
      if (getEdgeConfig && is_function_default(getEdgeConfig)) {
        edgeConfig = getEdgeConfig({
          source: self2.source,
          target: model.id
        }, self2);
      } else {
        edgeConfig = self2.edgeConfig;
      }
      var updateCfg2 = __assign({
        target: model.id
      }, edgeConfig);
      if (self2.source === model.id) {
        updateCfg2.type = "loop";
      }
      graph.emit("beforecreateedge", {});
      graph.updateItem(self2.edge, updateCfg2, false);
      if (graph.get("enabledStack")) {
        var addedModel = __assign(__assign({}, self2.edge.getModel()), {
          itemType: "edge"
        });
        var after = {};
        after.edges = [addedModel];
        graph.pushStack("add", {
          before: {},
          after
        });
      }
      graph.emit("aftercreateedge", {
        edge: self2.edge
      });
      self2.edge.getKeyShape().set("capture", true);
      self2.edge = null;
      self2.addingEdge = false;
    } else {
      if (!self2.shouldBegin(ev, self2)) return;
      var edgeConfig = void 0;
      if (getEdgeConfig && is_function_default(getEdgeConfig)) {
        edgeConfig = getEdgeConfig({
          source: model.id,
          target: model.id
        }, self2);
      } else {
        edgeConfig = self2.edgeConfig;
      }
      self2.edge = graph.addItem("edge", __assign({
        source: model.id,
        target: model.id
      }, edgeConfig), false);
      self2.source = model.id;
      self2.addingEdge = true;
      self2.edge.getKeyShape().set("capture", false);
    }
  },
  // 边的起点已经确定，边的末端跟随鼠标移动
  updateEndPoint: function updateEndPoint(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown) return;
    if (self2.edge && self2.edge.destroyed) self2.cancelCreating({
      item: self2.edge
    });
    var point = {
      x: ev.x,
      y: ev.y
    };
    if (!self2.graph.findById(self2.source)) {
      self2.addingEdge = false;
      return;
    }
    if (self2.addingEdge && self2.edge) {
      self2.graph.updateItem(self2.edge, {
        target: point
      }, false);
    }
  },
  // 取消增加边，删除该边；或指定终点
  cancelCreating: function cancelCreating(ev) {
    var _a2, _b;
    var self2 = this;
    if (self2.key && !self2.keydown) return;
    var graph = self2.graph;
    var currentEdge = ev.item;
    if (self2.addingEdge && (self2.edge === currentEdge || ((_b = (_a2 = ev.target) === null || _a2 === void 0 ? void 0 : _a2.isCanvas) === null || _b === void 0 ? void 0 : _b.call(_a2)))) {
      if (self2.edge && !self2.edge.destroyed) graph.removeItem(self2.edge, false);
      self2.edge = null;
      self2.addingEdge = false;
      return;
    }
  },
  onKeyDown: function onKeyDown5(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === self2.key.toLowerCase()) {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp5() {
    var self2 = this;
    if (self2.addingEdge && self2.edge) {
      self2.graph.removeItem(self2.edge, false);
      self2.addingEdge = false;
      self2.edge = null;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/shortcuts-call.js
var DEFAULT_TRIGGER7 = "ctrl";
var ALLOW_EVENTS9 = ["shift", "ctrl", "alt", "control"];
var DEFAULT_COMBINED_KEY = "1";
var shortcuts_call_default = {
  getDefaultCfg: function getDefaultCfg15() {
    return {
      trigger: DEFAULT_TRIGGER7,
      combinedKey: DEFAULT_COMBINED_KEY,
      functionName: "fitView",
      functionParams: []
    };
  },
  getEvents: function getEvents15() {
    if (!(ALLOW_EVENTS9.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER7;
      console.warn("Behavior shortcuts-fit-view 的 trigger 参数 '".concat(this.trigger, "' 不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'"));
    }
    if (this.combinedKey === this.trigger) {
      this.combinedKey = void 0;
    }
    return {
      keyup: "onKeyUp",
      keydown: "onKeyDown"
    };
  },
  onKeyDown: function onKeyDown6(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    var triggerLowerCase = this.trigger.toLowerCase();
    var codeLowerCase = code.toLowerCase();
    if (!this.triggerKeydown) {
      if (codeLowerCase === triggerLowerCase || codeLowerCase === "control" && triggerLowerCase === "ctrl" || codeLowerCase === "ctrl" && triggerLowerCase === "control") {
        this.triggerKeydown = true;
      } else {
        this.triggerKeydown = false;
      }
    }
    var graph = this.graph;
    if (!graph[this.functionName]) {
      console.warn("Behavior shortcuts-fit-view 的 functionName 参数 '".concat(this.functionName, "' 不合法，它不是 Graph 的一个函数名"));
      return {};
    }
    if (this.triggerKeydown && !this.combinedKey) {
      if (this.functionParams && this.functionParams.length) graph[this.functionName].apply(graph, this.functionParams);
      else graph[this.functionName]();
      return;
    }
    var combinedKeyLowerCase = this.combinedKey.toLowerCase();
    if (this.triggerKeydown) {
      if (codeLowerCase === combinedKeyLowerCase || codeLowerCase === "control" && combinedKeyLowerCase === "ctrl" || codeLowerCase === "ctrl" && combinedKeyLowerCase === "control") {
        if (this.functionParams && this.functionParams.length) graph[this.functionName].apply(graph, this.functionParams);
        else graph[this.functionName]();
      }
    }
  },
  onKeyUp: function onKeyUp6() {
    if (this.brush) {
      this.brush.remove(true);
      this.brush = null;
      this.dragging = false;
    }
    this.triggerKeydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/scroll-canvas.js
init_esm();
var ALLOW_EVENTS10 = ["shift", "ctrl", "alt", "control", "meta"];
var scroll_canvas_default = {
  getDefaultCfg: function getDefaultCfg16() {
    return {
      direction: "both",
      enableOptimize: false,
      zoomKey: "ctrl",
      // scroll-canvas 可滚动的扩展范围，默认为 0，即最多可以滚动一屏的位置
      // 当设置的值大于 0 时，即滚动可以超过一屏
      // 当设置的值小于 0 时，相当于缩小了可滚动范围
      // 具体实例可参考：https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*IFfoS67_HssAAAAAAAAAAAAAARQnAQ
      scalableRange: 0,
      allowDragOnItem: true
    };
  },
  getEvents: function getEvents16() {
    if (!this.zoomKey || ALLOW_EVENTS10.indexOf(this.zoomKey) === -1) this.zoomKey = "ctrl";
    return {
      wheel: "onWheel"
    };
  },
  onWheel: function onWheel2(ev) {
    var _this = this;
    if (!this.allowDrag(ev)) return;
    var graph = this.graph;
    var zoomKeys = Array.isArray(this.zoomKey) ? [].concat(this.zoomKey) : [this.zoomKey];
    if (zoomKeys.includes("control")) zoomKeys.push("ctrl");
    var keyDown = zoomKeys.some(function(ele) {
      return ev["".concat(ele, "Key")];
    });
    if (keyDown) {
      var canvas = graph.get("canvas");
      var point = canvas.getPointByClient(ev.clientX, ev.clientY);
      var ratio = graph.getZoom();
      if (ev.wheelDelta > 0) {
        ratio = ratio + ratio * 0.05;
      } else {
        ratio = ratio - ratio * 0.05;
      }
      graph.zoomTo(ratio, {
        x: point.x,
        y: point.y
      });
    } else {
      var dx = ev.deltaX || ev.movementX;
      var dy = ev.deltaY || ev.movementY;
      if (!dy && navigator.userAgent.indexOf("Firefox") > -1) dy = -ev.wheelDelta * 125 / 3;
      var width = this.graph.get("width");
      var height = this.graph.get("height");
      var graphCanvasBBox = this.graph.get("canvas").getCanvasBBox();
      var expandWidth = this.scalableRange;
      var expandHeight = this.scalableRange;
      if (expandWidth < 1 && expandWidth > -1) {
        expandWidth = width * expandWidth;
        expandHeight = height * expandHeight;
      }
      var minX = graphCanvasBBox.minX, maxX = graphCanvasBBox.maxX, minY = graphCanvasBBox.minY, maxY = graphCanvasBBox.maxY;
      if (dx > 0) {
        if (maxX < -expandWidth) {
          dx = 0;
        } else if (maxX - dx < -expandWidth) {
          dx = maxX + expandWidth;
        }
      } else if (dx < 0) {
        if (minX > width + expandWidth) {
          dx = 0;
        } else if (minX - dx > width + expandWidth) {
          dx = minX - (width + expandWidth);
        }
      }
      if (dy > 0) {
        if (maxY < -expandHeight) {
          dy = 0;
        } else if (maxY - dy < -expandHeight) {
          dy = maxY + expandHeight;
        }
      } else if (dy < 0) {
        if (minY > height + expandHeight) {
          dy = 0;
        } else if (minY - dy > height + expandHeight) {
          dy = minY - (height + expandHeight);
        }
      }
      if (this.get("direction") === "x") {
        dy = 0;
      } else if (this.get("direction") === "y") {
        dx = 0;
      }
      graph.translate(-dx, -dy);
    }
    ev.preventDefault();
    var enableOptimize = this.get("enableOptimize");
    if (enableOptimize) {
      var optimizeZoom_1 = this.get("optimizeZoom");
      var optimized = this.get("optimized");
      var nodes_1 = graph.getNodes();
      var edges_1 = graph.getEdges();
      var nodesLength_1 = nodes_1.length;
      var edgesLength_1 = edges_1.length;
      if (!optimized) {
        for (var n2 = 0; n2 < nodesLength_1; n2++) {
          var node = nodes_1[n2];
          if (!node.destroyed) {
            var children = node.get("group").get("children");
            var childrenLength = children.length;
            for (var c3 = 0; c3 < childrenLength; c3++) {
              var shape = children[c3];
              if (!shape.destoryed && !shape.get("isKeyShape")) {
                shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
                shape.hide();
              }
            }
          }
        }
        for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {
          var edge = edges_1[edgeIndex];
          var children = edge.get("group").get("children");
          var childrenLength = children.length;
          for (var c3 = 0; c3 < childrenLength; c3++) {
            var shape = children[c3];
            shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
            shape.hide();
          }
        }
        this.set("optimized", true);
      }
      clearTimeout(this.get("timeout"));
      var timeout2 = setTimeout(function() {
        var currentZoom = graph.getZoom();
        var curOptimized = _this.get("optimized");
        if (curOptimized) {
          _this.set("optimized", false);
          for (var n3 = 0; n3 < nodesLength_1; n3++) {
            var node2 = nodes_1[n3];
            var children2 = node2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = node2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis) keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                var oriVis = shape2.get("ori-visibility");
                if (!shape2.get("visible") && oriVis) {
                  if (oriVis) shape2.show();
                }
              }
            }
          }
          for (var edgeIndex2 = 0; edgeIndex2 < edgesLength_1; edgeIndex2++) {
            var edge2 = edges_1[edgeIndex2];
            var children2 = edge2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = edge2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis) keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                if (!shape2.get("visible")) {
                  var oriVis = shape2.get("ori-visibility");
                  if (oriVis) shape2.show();
                }
              }
            }
          }
        }
      }, 100);
      this.set("timeout", timeout2);
    }
  },
  allowDrag: function allowDrag2(evt) {
    var _a2, _b;
    var target = evt.target;
    var targetIsCanvas = target && target.isCanvas && target.isCanvas();
    if (is_boolean_default(this.allowDragOnItem) && !this.allowDragOnItem && !targetIsCanvas) return false;
    if (is_object_default(this.allowDragOnItem)) {
      var _c = this.allowDragOnItem, node = _c.node, edge = _c.edge, combo = _c.combo;
      var itemType = (_b = (_a2 = evt.item) === null || _a2 === void 0 ? void 0 : _a2.getType) === null || _b === void 0 ? void 0 : _b.call(_a2);
      if (!node && itemType === "node") return false;
      if (!edge && itemType === "edge") return false;
      if (!combo && itemType === "combo") return false;
    }
    return true;
  }
};

// node_modules/@antv/g6-pc/es/behavior/index.js
var behaviors = {
  "drag-canvas": drag_canvas_default,
  "zoom-canvas": zoom_canvas_default,
  "drag-node": drag_node_default,
  "activate-relations": activate_relations_default,
  "brush-select": brush_select_default,
  "click-select": click_select_default,
  "lasso-select": lasso_select_default,
  tooltip: tooltip_default2,
  "edge-tooltip": edge_tooltip_default,
  "collapse-expand": collapse_expand_default,
  "drag-combo": drag_combo_default,
  "collapse-expand-combo": collapse_expand_combo_default,
  "create-edge": create_edge_default,
  "shortcuts-call": shortcuts_call_default,
  "scroll-canvas": scroll_canvas_default
};
each_default(behaviors, function(behavior, type) {
  registerBehavior(type, behavior);
});

// node_modules/@antv/g6-pc/es/index.js
var Algorithm = __assign(__assign({}, es_exports), AlgorithmAsync);
var Grid2 = plugin_default.Grid;
var Minimap = plugin_default.Minimap;
var Bundling2 = plugin_default.Bundling;
var Menu2 = plugin_default.Menu;
var Fisheye2 = plugin_default.Fisheye;
var ToolBar2 = plugin_default.ToolBar;
var Tooltip2 = plugin_default.Tooltip;
var TimeBar2 = plugin_default.TimeBar;
var ImageMinimap = plugin_default.ImageMinimap;
var EdgeFilterLens2 = plugin_default.EdgeFilterLens;
var SnapLine2 = plugin_default.SnapLine;
var Legend2 = plugin_default.Legend;
var Annotation2 = plugin_default.Annotation;
var es_default4 = {
  version: global_default2.version,
  Graph: graph_default2,
  TreeGraph: tree_graph_default,
  Util: util_default2,
  Layout: import_lib.Layouts,
  TreeLayout: tree_layout_default,
  registerLayout,
  Global: global_default2,
  registerBehavior,
  registerCombo,
  registerEdge,
  registerNode,
  Minimap: plugin_default.Minimap,
  Grid: plugin_default.Grid,
  Bundling: plugin_default.Bundling,
  Menu: plugin_default.Menu,
  ToolBar: plugin_default.ToolBar,
  Tooltip: plugin_default.Tooltip,
  Legend: plugin_default.Legend,
  TimeBar: TimeBar2,
  SnapLine: SnapLine2,
  Fisheye: Fisheye2,
  ImageMinimap,
  EdgeFilterLens: EdgeFilterLens2,
  Annotation: Annotation2,
  Algorithm,
  Arrow: arrow_default,
  Marker: marker_default,
  Shape: element_default2
};

// node_modules/@antv/g6/es/index.js
es_default4.version = "4.8.23";
var es_default5 = es_default4;
var version = "4.8.23";
var export_Layout = import_lib.Layouts;
export {
  event_default as AbstractEvent,
  graph_default as AbstractGraph,
  layout_default as AbstractLayout,
  Algorithm,
  Annotation2 as Annotation,
  arrow_default as Arrow,
  BaseGlobal,
  Bundling2 as Bundling,
  combo_default as Combo,
  edge_default as Edge,
  EdgeFilterLens2 as EdgeFilterLens,
  Fisheye2 as Fisheye,
  G6GraphEvent,
  global_default2 as Global,
  graph_default2 as Graph,
  Grid2 as Grid,
  hull_default as Hull,
  ImageMinimap,
  export_Layout as Layout,
  Legend2 as Legend,
  marker_default as Marker,
  Menu2 as Menu,
  Minimap,
  node_default as Node,
  element_default2 as Shape,
  SnapLine2 as SnapLine,
  TimeBar2 as TimeBar,
  ToolBar2 as ToolBar,
  Tooltip2 as Tooltip,
  tree_graph_default as TreeGraph,
  tree_layout_default as TreeLayout,
  util_default2 as Util,
  es_default5 as default,
  registerBehavior,
  registerCombo,
  registerEdge,
  registerLayout,
  registerNode,
  version
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@babel/runtime/helpers/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
*/
//# sourceMappingURL=@antv_g6.js.map
